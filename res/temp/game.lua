GAME_REV_STR="$Rev: 3634 $"
GAME_VERSION=string.gsub(GAME_REV_STR, '[ ]*$[a-zA-Z:]*[ ]*', '');
print ("Is Game Lua Here")




-- version control
RELOAD_MODE        = false;
SIMPLE_FIGHT       = true;
DRAG_MODE          = false;
DEBUG_INFO         = true;
SHOP_PAGE          = false;
USE_FRAME          = false;
USE_FLASH          = true;

USE_ANIM           = true;
alog = function(...)
	--print(string.format(...));
	--print(...);
end

-- do cmd local, then send to server
--LOCAL_CMD = false;
LOCAL_CMD = true;
g_ui = true;

-- true : use testing card
-- false : use standard card
g_init_test = true;

require ("logic")
require ("lang_zh")
require ("lang_local")
-- /////////////////////// CONSTANT START ///////////////////////////
-- define at game_initialize
CPID               = 0;
CHANNEL_VER        = 0;
VER_APPSTORE       = 1;
VER_APAY_deprecated= 2;
VER_ANYSDK         = 3;
VER_APAY           = 4;
VER_ANYSDK_NO_LOGIN= 5;
VER_LJSDK          = 6;
VER_UCSDK          = 7;
VER_NINEYOU        = 8;

DEVICE_UNKNOWN     = 0;
DEVICE_IOS         = 1;
DEVICE_ANDROID     = 2;

PLATFORM_UNKNOWN   = 0;
PLATFORM_IPHONE    = 1;
PLATFORM_IPAD      = 2;
PLATFORM_MAC       = 3;
PLATFORM_ANDROID   = 4;
PLATFORM_WINDOWS   = 5;





STYPE_VER_1  = 1; -- normal size
STYPE_VER_2  = 2; -- use small size card frame

HAND_GAP = 50;


CARD_ARRAY_LIST    = 400;

-- tag start
TAG_BTN_NEXT_EFF_1   = 120;
TAG_BTN_NEXT_EFF_2   = 121;
TAG_BTN_NEXT_EFF_3   = 122;
TAG_SPRITE_SLEEP     = 450;
TAG_SPRITE_TIMER     = 460;
TAG_VIRTUAL_ACTION   = 600;
TAG_VIRTUAL_PARTICLE = 700;
TAG_STATUS_EFF       = 710;
TAG_STATUS_SPRITE    = 720;
TAG_NAME             = 798;
TAG_DESC             = 799;
TAG_HP               = 800;
TAG_COST             = 801;
TAG_POWER            = 802;
TAG_HIGHLIGHT        = 999;
TAG_MISSION_FINGER   = 310;
TAG_MSG_OTHER_LOGIN  = 499;
TAG_SHOW_CELL_MARK   = 1;
--TAG_LAYER_TUTOR      = 777;
-- tag end


GAME_SOLO         = 1;
GAME_QUICK        = 2;
GAME_ROOM         = 3;
GAME_CHALLENGE    = 4;
GAME_MATCH        = 5;
GAME_RANK         = 6;
GAME_GATE         = 7;
GAME_SOLO_GOLD    = 8;
GAME_VS_GOLD      = 9;
GAME_VS_CRYSTAL   = 10;
GAME_SOLO_FREE    = 11;
GAME_VS_FREE      = 12;
GAME_TOWER        = 13;
GAME_SOLO_PLUS    = 14;
GAME_CHAPTER      = 15;

-- ALERT TYPE
ALERT_HERO_MISS   = 1; -- how to get the hero
ALERT_GET_PIECE   = 2; -- how to get the card

-- side
SIDE_GUEST         = 99; -- CONSTANT
-- will be set at each time game starts..
-- set in data_handler.init_side
SIDE_UP            = 0;
SIDE_DOWN          = 0;
-- card is in which kind of table
-- will be set at each time game starts..
-- set in data_handler.init_side
DOWN_HERO     = 0;
DOWN_HAND     = 0;
DOWN_ALLY     = 0;
DOWN_SUPPORT  = 0;
DOWN_GRAVE    = 0;
DOWN_DECK     = 0;
DOWN_RES      = 0;
UP_HERO       = 0;
UP_HAND       = 0;
UP_ALLY       = 0;
UP_SUPPORT    = 0;
UP_GRAVE      = 0;
UP_DECK       = 0;
UP_RES        = 0;

-- attack_type
TYPE_NONE          = 1;
TYPE_ATTACK        = 2;
TYPE_ABILITY       = 3;
TYPE_BOTH          = 4;

-- card_highlight type
HL_ATTACK    = 1;
HL_ABILITY   = 2;
HL_BOTH      = 3;
HL_TBOTH     = 4;
HL_TARGET    = 11;
HL_SAC       = 12;

CARD_FRONT      = 1;
CARD_COVER      = 2;
CARD_GRAVE      = 3;
CARD_ALLY       = 4;
CARD_SUPPORT    = 5;
CARD_HERO       = 6;
CARD_ATTACH     = 7;
CARD_VIRTUAL    = 8;
CARD_HERO_ATTACH= 9;

-- action kind, @see in function check_kind(...)
AKIND_NONE         = 0;
AKIND_ATTACK       = 1;
AKIND_ABILITY      = 2;
AKIND_BOTH         = 3; -- both attack and ability
AKIND_SAC          = 4;
AKIND_TALLY        = 5; -- hand to ally
AKIND_TSUPPORT     = 6; -- hand to support
AKIND_TGRAVE       = 7; -- target is in grave

DURATION_NUM_EFF = 1.0;

-- step_constant
STEP_NONE          = 0
STEP_CHOOSE        = 1  -- choose a card to do action, such as attack or ability
STEP_TARGET        = 2  -- choose target card to attack or ability

-- should be same as server
ST_NULL            = 0;
ST_LOGIN           = 5;
ST_ROOM            = 10;
ST_GAME            = 15;

-- GUILD POS
GUILD_POS_NONE     = 0;
GUILD_POS_MASTER   = 1;
GUILD_POS_SENIOR   = 2;
GUILD_POS_MEMBER   = 3;
GUILD_POS_APPLY    = 9;

-- SEX
SEX_MALE      = 0;
SEX_FEMALE    = 1;

-- ladder
LADDER_RATING   = 0;
LADDER_LEVEL    = 1;
LADDER_GUILD    = 2;
LADDER_COLLECT  = 3;
LADDER_GOLD     = 4;
LADDER_CHAPTER  = 5;
LADDER_ARENA    = 99;

-- chat channel
C_ALL      = 1;   -- 全部
C_WORLD    = 2;   -- 世界
C_ROOM     = 3;   -- 房间
C_GUILD    = 4;   -- 公会
C_PRIVATE  = 5;   -- 私聊
C_LOG      = 6;  -- 日志

-- CHAPTER CONSTANT
CHAPTER_TARGET_MY_HERO_HP            = 1;
CHAPTER_TARGET_ROUND                 = 2;
CHAPTER_TARGET_WIN                   = 3;
CHAPTER_TARGET_MY_ALLY               = 4;
CHAPTER_TARGET_MY_SUPPORT            = 5;
CHAPTER_TARGET_MY_ABILITY            = 6;
CHAPTER_TARGET_MY_CARD               = 7;
CHAPTER_TARGET_OPPO_ALLY             = 8;
CHAPTER_TARGET_OPPO_SUPPORT          = 9;
CHAPTER_TARGET_OPPO_ABILITY          = 10;
CHAPTER_TARGET_OPPO_CARD             = 11;
CHAPTER_TARGET_MY_GRAVE              = 12;
CHAPTER_TARGET_OPPO_GRAVE            = 13;
CHAPTER_TARGET_MY_GRAVE_ALLY         = 14;
CHAPTER_TARGET_OPPO_GRAVE_ALLY       = 15;
CHAPTER_TARGET_MY_CARD_GRAVE         = 16;
CHAPTER_TARGET_OPPO_GRAVE_GRAVE      = 17;
CHAPTER_TARGET_MY_HERO               = 18;
CHAPTER_TARGET_OPPO_HERO             = 19;

CHAPTER_REWARD_GOLD                  = 1;
CHAPTER_REWARD_CRYSTAL               = 2;
CHAPTER_REWARD_PIECE                 = 3;
CHAPTER_REWARD_CARD                  = 4;
CHAPTER_REWARD_EXP                   = 5;
CHAPTER_REWARD_POWER                 = 6;

-- MATCH STATUS DEFINE
-- keep these same as sever --
MATCH_STATUS_READY          = 0;
MATCH_STATUS_ROUND_START    = 1;
MATCH_STATUS_ROUND_END      = 2;
MATCH_STATUS_FINISHED       = 3;
MATCH_STATUS_DELETE         = 9;

--mlist_type
MLIST_ALL               = 0;
MLIST_CHAPTER           = 1;
MLIST_WITHOUT_CHAPTER   = 2;
-- mission_type(mtype) define, use in layer_mission, net_mlist
MISSION_LEVEL           = 1;  -- lv up to p1
MISSION_AI              = 2;  -- win ai p1 time, p2=ai_id, p3=my_hero
MISSION_VS              = 3;  -- win VS game p1 time, p3=my_hero
MISSION_CHALLENGE       = 4;  -- win challenge p1 time
MISSION_BEI_CHALLENGE   = 5;  -- win passive challenge p1 time
MISSION_REPLAY          = 6;  -- press replay p1 time 
MISSION_CHAT            = 7;  -- chat p1 time (p2=1,2,3=world,room,guild)
MISSION_FRIEND          = 8;  -- add p1 friends (not total?)
MISSION_SHOP            = 9;  -- buy p1 cards p2=card_id
MISSION_CARD            = 10; -- own p1 card p2=card_id
MISSION_COLLECTION      = 11; -- own p1 unique cards
MISSION_PROMOTION       = 12; -- promote this game to p1 users
MISSION_VIEW            = 13; -- view other game p1 time p2=hero_id
MISSION_GUILD           = 14; -- p1 = times
MISSION_DECK            = 15; -- p1 = count, p2 = card_id
MISSION_GATE            = 16; -- p1 = times, p2 = gate_id, p2 = 0 means any
MISSION_FIGHT_AI        = 17; -- p1 = times
MISSION_FIGHT_VS        = 18; -- p1 = times
MISSION_FIGHT           = 19; -- p1 = times
MISSION_MONTHLY         = 20; -- daily mission, auto finish
MISSION_RANK_GAME_TIMES = 21; -- 
MISSION_CHAPTER_STAGE   = 22; -- p1 = star, p2 = chapter_id, p3=stage_id
MISSION_CHAPTER         = 23; -- p1 = stage_count, p2 = chapter_id, p3 = star
MISSION_QUICK           = 24; -- p1 = times
MISSION_QUICK_WIN       = 25; -- p1 = times
MISSION_HERO_HP         = 26; -- p1 = hp, p2 = hero_id
------------------------------

-- ui size start
CARD_SIZE = { width = 323, height = 494 };
CARD_SIZE_2 = { width = 125, height = 158 };
GRAVE_SIZE = { width = 44, height = 67 }; -- grave frame size
PIC_SIZE = { width = 297, height = 270 };
-- ui size end

-- /////////////////////// CONSTANT END ///////////////////////////

-- /////////////////////// VAR START ///////////////////////////
g_scale = nil;
-- @see in disable_touch, enable_touch
g_touchable     = 0;
g_constant = {};
g_list_shop = {};
g_list_piece = {};
g_mission_tip = 1;
-- about game --
-- @see step_constant
g_step = STEP_NONE;
g_ui_table = {};
g_all_card_list = {};
g_last_phase = 0; -- only be used for pop_phase
-- @see in init_net_play
g_net_play_cache = {};
g_stop_play_cmd = false;
-- revceive net_game cmd_size
g_net_cmdsize = 0;
-- only for net_game
g_game_info = nil;
-- only for net_play
g_game_play_list = nil;
-- @see in check_cmd_finish()
g_net_win_data = nil;
g_cache_cmd_list = {};
g_src_index = 0;
g_action_type = TYPE_NONE;
-- about game --
g_chat_list = {
	[C_ALL] = {},
	[C_WORLD] = {},
	[C_ROOM] = {},
	[C_GUILD] = {},
	[C_PRIVATE] = {},
	[C_LOG] = {},
};


g_euser = {
	-- info
	username = '', -- 账号名
	userid = 0, -- for anysdk
	password = '', -- for anysdk save pw
	eid = 0,
	level = 0,   -- 等级
	rating = 0,  -- 邪恶值
	gold = 0,    -- 金币
	crystal = 0, -- 水晶
	power = 0,   -- 体力
	game_count = 0, -- 比赛场数
	game_win = 0,   -- 胜利场数
	game_lose = 0,  -- 失败场数
	game_draw = 0,  -- 平局场数
	game_run = 0,   -- 逃跑场数
	icon = '',      -- 头像
	alias = '',     -- 昵称
	gid = 0,        -- 公会id
	gpos = GUILD_POS_NONE,  -- 公会职位
	gname = '',     -- 公会名称
	exp = 0,        -- 经验值
	exp_next = 0,   -- 下次升级所需经验
	exp_this = 0,   -- 当前等级起始exp -- not use anymore
	sex = SEX_MALE, -- 性别
	signature = '', -- 个性签名
	st = ST_NULL,   -- 游戏状态
	collection = 0,
	collection_rate = 0,

	-- TODO 
	----------------  check usage below
	last_login = 0,
	hero_id = 0,
	game_level = 1, -- 1 means newbie, 5-high
	all_str = nil;  -- all cards (lcard)
	deck_str = nil; -- deck cards (ldeck)
	slot_str = nil; -- slot cards (lcard - ldeck)
	merge_str = nil; -- piece required in merge (lmerge)

	-- reserve1, reserve2 for future use
	reserve1 = 0,
	reserve2 = 0,

	side = 0,
	room_data = nil,

	guild_data = nil,

	has_guild = function(self)
		if self.gid > 0 and self.gpos >= GUILD_POS_MASTER and 
							self.gpos <= GUILD_POS_MEMBER then
			return true;
		end
		return false;
	end,

	has_get_reward = nil,
	slot_id = nil,
	hero_id = nil,
};

list_icon_num = {
	-- hero icon
	1, 2, 5, 6, 8, 11, 15, 16,
	-- other icon
	21, 22, 23, 24, 25, 26, 27,
};
-- /////////////////////// VAR END ///////////////////////////

-- /////////////////////// UTIL START ///////////////////////////
util = {};


function util.space_(str)
	local flag = false;
	repeat 
		local spos, epos = string.find(str, ' ');
		if nil == spos or nil == epos then
			flag = true;
			break;
		end
		local str1 = string.sub(str, 1, spos-1);
		local str2 = string.sub(str, epos+1);
		str = str1 .. '_' .. str2;
	until true == flag;
	return str;
end

-- delim e.g " " or "[ ]" or "[%.]" or "[%. ]"
function csplit(str, delim, count)
	--print('DEBUG csplit str, delim: ', str, delim);
	local result = {};
	if nil == str then
		return result;
	end
	count = count or 500; -- max 500 token
	local token;

	repeat 
		local s_pos, e_pos = string.find(str, delim);
		if s_pos==nil or e_pos == nil then
			break;
		end
		-- print('s_pos = ', s_pos, ' e_pos = ', e_pos);
		token = string.sub(str, 1, s_pos-1);
		if string.len(token) > 0 then
			result[ #result + 1] = token;
		end
		str = string.sub(str, e_pos+1); -- missing len means up to full len
		-- print('Result i : ', result[#result], '  str=', str);
		count = count - 1;
	until count <= 0;

	if string.len(str) > 0 then
		result[ #result + 1] = str ;
	end
	
	return result;
end

function util.replace_str(str, rstr, istr)
	if nil == str or nil == rstr or 0 == string.len(rstr) then
		return str;
	end
	istr = istr or '';
	local spos, epos = string.find(str, rstr);
	if nil == spos or nil == epos then
		return str;
	end
	if 1 == spos and string.len(str) == epos then
		return istr;
	end
	local s1 = string.sub(str, 1, spos-1);
	local s2 = string.sub(str, epos+1, string.len(str));
	local nstr = s1 .. istr .. s2;
	return nstr;
end




-- should fisrt check download resoure, then check local resource.
-- if only use require, it will always check local resource first.
-- if only use dofile, android cannot load local lua file, because it must
--    unzip the apk first.
function util.include_lua(foldername, filename)
	-- 1. check the download folder
	local file_utils = cc.FileUtils:getInstance();
	local write_path = file_utils:getWritablePath();
	--[[
	local fname = foldername .. filename .. '.lua';
	local fullpath = write_path.. 'res/' .. fname;
	local is_exist = file_utils:isFileExist(fullpath);
	if true == is_exist then
		print('dofile ====>>> ', fullpath);
		dofile ( fullpath );
		return;
	end
	]]--
	-- do not need check , if file not exist , let it crash
	fullpath = foldername .. filename;
	print('require ====>>> ', fullpath);
	require (fullpath);
	return;
end








function util.set_scheduler(callback, time_interval, is_paused)
	kdebug("-- TODO util.set_scheduler");
	--[[
	if nil == callback then
		return;
	end
	local scheduler = CCDirector:sharedDirector():getScheduler();
	local ret = scheduler:scheduleScriptFunc(callback, time_interval, is_paused);
	return ret;
	]]--
end

function util.remove_scheduler(scheduler_id)
	kdebug("-- TODO util.remove_scheduler");
	--[[
	local scheduler = CCDirector:sharedDirector():getScheduler();
	scheduler:unscheduleScriptEntry(scheduler_id);
	]]--
end



function util.get_server_id(list, ip)
	list = list or {};
	for i = 1, #list do
		local info = list[i];
		local ipaddr = info.ip;
		if ipaddr == ip then
			return info.sid;
		end
	end
	return '0';
end





function util.add_sprite_frame(layer, filename, pos, anchorpoint, zorder)
	anchorpoint = anchorpoint or ANCHOR_CENTER_CENTER;
	local cache = cc.SpriteFrameCache:getInstance();
	local sprite_frame = cache:spriteFrameByName(filename);
	if nil == sprite_frame then
		return nil;
	end
	local sprite = cc.Sprite:createWithSpriteFrame(sprite_frame);
	sprite:setAnchorPoint(anchorpoint);
	sprite:setPosition(pos);
	if nil ~= zorder then
		layer:addChild(sprite, zorder);
	else
		layer:addChild(sprite);
	end
	return sprite;
end

function util.add_frames(path)
	local cache = cc.SpriteFrameCache:getInstance();
	cache:addSpriteFrames(path);
end


function util.add_mask_sprite(layer, fname1, fname2, pos, anchorpoint, zorder)
	local src = util.create_sprite(fname1);
	local mask = util.create_sprite(fname2);
	
	local sprite = util.add_mask_sprite_2(layer,src,mask,pos,anchorpoint,zorder);
	return sprite;
end

function util.add_mask_sprite_2(layer, src, mask, pos, anchorpoint, zorder)
	local src_size = src:getContentSize();
	local mask_size = mask:getContentSize();

	local rt = cc.RenderTexture:create(src_size.width, src_size.height, cc.TEXTURE2_D_PIXEL_FORMAT_RGB_A8888);

	local ratiow = src_size.width / mask_size.width;
	local ratioh = src_size.height / mask_size.height;
	mask:setScaleX(ratiow);
	mask:setScaleY(ratioh);
	mask:setPosition(cc.p(src_size.width / 2, src_size.height / 2));
	src:setPosition(cc.p(src_size.width / 2, src_size.height / 2));

	mask:setBlendFunc(gl.ONE, gl.ZERO);
	src:setBlendFunc(gl.DST_ALPHA, gl.ZERO);

	rt:begin();
	mask:visit();
	src:visit();
	rt:endToLua();

	local sprite = cc.Sprite:createWithTexture(rt:getSprite():getTexture());
	sprite:setFlipY(true);

	sprite:setAnchorPoint(anchorpoint or ANCHOR_CENTER_CENTER);
	if nil ~= pos then
		sprite:setPosition(pos);
	end
	if nil ~= zorder then
		layer:addChild(sprite, zorder);
	else
		layer:addChild(sprite);
	end
	return sprite;
end



function util.add_particle(layer, fullpath, pos, zorder)
	local emitter, batch;
	emitter = cc.ParticleSystemQuad:create(fullpath);
	emitter:setAutoRemoveOnFinish(true);
	batch = cc.ParticleBatchNode:createWithTexture(emitter:getTexture());
	batch:setPosition(pos.x, pos.y);
	batch:addChild(emitter);
	if nil ~= zorder then
		layer:addChild(batch, zorder);
	else
		layer:addChild(batch);
	end

	local info = { emitter = emitter, batch = batch };
	return info;
end





function util.change_item_image(item, path1, path2)
	local sprite, tc, texture;
	tc = cc.Director:getInstance():getTextureCache();
	sprite = item:getNormalImage();
	texture = tc:addImage(path1);
	if nil ~= texture then 
		sprite:setTexture(texture);
	end
	sprite = item:getSelectedImage();
	texture = tc:addImage(path2);
	if nil ~= texture then 
		sprite:setTexture(texture);
	end
end

function util.add_item_label_image(item, path1, path2)
	local unselectsprite = item:getNormalImage();
	local selectsprite = item:getSelectedImage();
	local s1, s2;

	local size = unselectsprite:getContentSize();
	local scale = unselectsprite:getScale();
	local pos = cc.p(scale * size.width / 2, scale * size.height / 2);
	s1 = util.add_sprite(unselectsprite, path1, pos, ANCHOR_CENTER_CENTER, 1);

	size = selectsprite:getContentSize();
	scale = selectsprite:getScale();
	pos = cc.p(scale * size.width / 2, scale * size.height / 2);
	s2 = util.add_sprite(selectsprite, path2, pos, ANCHOR_CENTER_CENTER, 1);
	return s1, s2;
end




function util.create_toggle_image(fname1, fname2, pos, anchorpoint, callback)
	local unselectsprite = util.create_sprite(fname1);
	local selectsprite = util.create_sprite(fname2);
	--selectsprite:setScale(1.1);

	return util.create_toggle_sprite(unselectsprite, selectsprite, pos, anchorpoint, callback);
end










function util.add_text_outline_to_sprite(parent, text, size, color, outline_color, outline_size, pos, anchorpoint, scale)
	local label = parent:getChildByTag(TAG_SPRITE_LABEL);
	if nil ~= label then
		label:removeFromParentAndCleanup(true);
		label = nil;
	end
	local psize = parent:getContentSize();
	local sx = parent:getScaleX();
	local sy = parent:getScaleY();
	--local pscale = sx<sy and sx or sy;
	--local width = psize.width * pscale;
	--local height = psize.height * pscale;
	local width = psize.width * sx;
	local height = psize.height * sy;
	pos = pos or cc.p(width / 2, height / 2);
	anchorpoint = anchorpoint or ANCHOR_CENTER_CENTER;
	local label = util.add_labeloutline(parent, text, nil, size, pos, color, outline_color, outline_size, anchorpoint, 1, cc.size(width, height), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
	label:setTag(TAG_SPRITE_LABEL);
	return label;
end

function util.add_stroke_to_sprite_by_data(parent, data, text, size, outline_size)
	local color = cc.c4b(data.r, data.g, data.b, 255);
	local outline_color = cc.c4b(data.sr, data.sg, data.sb, 255);
	return util.add_text_outline_to_sprite(parent, text, size, color, outline_color, outline_size);
end




function util.add_progress_radial(layer, sprite, pos, zorder, range, t_end, reverse)
	local progress = cc.ProgressTimer:create(sprite);
	progress:setPosition(pos);
	progress:setType(cc.PROGRESS_TIMER_TYPE_RADIAL);
	progress:setPercentage(range);
	layer:addChild(progress, zorder);
	
	if nil ~= reverse then
		progress:setReverseProgress(reverse);
	end
	local progress_to = cc.ProgressTo:create(t_end, 100);
	progress:runAction( cc.RepeatForever:create(progress_to) );
end

function util.add_progress_bar(layer, sprite, pos, bar_type, midpoint, rate, percentage, zorder)
	local progress = cc.ProgressTimer:create(sprite);
	progress:setPosition(pos);
	progress:setType(bar_type or cc.PROGRESS_TIMER_TYPE_BAR); -- 水平
	progress:setMidpoint(midpoint or ccp(0, 0));  -- 进度条开始的中间位置
	-- 设置进度条的长度和高度开始变化的大小
	progress:setBarChangeRate(rate or ccp(1, 0)); 
	progress:setPercentage(percentage or 0);
	if nil ~= zorder then
		layer:addChild(progress, zorder);
	else
		layer:addChild(progress);
	end

	return progress;
end

function util.open_url(url)
	local platform = cc.Application:getInstance():getTargetPlatform();
	if platform == cc.PLATFORM_OS_IPHONE or platform == cc.PLATFORM_OS_IPAD then
		g_scene:add_layer(ZORDER_LAYER_FORUM, layer_forum:create());
		local args = { 
			url = url, handler = layer_forum.callback,
		};
		local luaoc = require "luaoc";
		local class_name = "ForumView";
		local ok, ret = luaoc.callStaticMethod(class_name, "openURL", args);
		--[[
		if ok then
		end
		]]--
	elseif platform == cc.PLATFORM_OS_ANDROID then
		g_scene:add_layer(ZORDER_LAYER_FORUM, layer_forum:create());
		local args = { 
			url, layer_forum.callback,
		};
		local sigs = "(Ljava/lang/String;I)V";
		local luaj = require "luaj";
		local class_name;
		if true ~= is_ver(VER_ANYSDK)
		or 930 ~= tonumber(AgentManager:getInstance():getChannelId() or "0") then
			class_name = "org/cocos2dx/lua/AppActivity";
		else
			class_name = "com/evil/ec_anysdk/xmw/AppActivity";
		end
		local ok, ret = luaj.callStaticMethod(class_name, "openURL", args, sigs);
		--[[
		if ok then
		end
		]]--
	else
		return;
	end
end

function util.text_to_pasteboard(text)
	local platform = cc.Application:getInstance():getTargetPlatform();
	if platform == cc.PLATFORM_OS_IPHONE or platform == cc.PLATFORM_OS_IPAD then
		local args = { 
			text = text,
		};
		local luaoc = require "luaoc";
		local class_name = "SysTool";
		local ok = luaoc.callStaticMethod(class_name, "textToPasteboard", args);
		--[[
		if ok then
		end
		]]--
	elseif platform == cc.PLATFORM_OS_ANDROID then
		local args = { 
			text,
		};
		local sigs = "(Ljava/lang/String;)V";
		local luaj = require "luaj";
		local class_name;
		if true ~= is_ver(VER_ANYSDK)
		or 930 ~= tonumber(AgentManager:getInstance():getChannelId() or "0") then
			class_name = "org/cocos2dx/lua/AppActivity";
		else
			class_name = "com/evil/ec_anysdk/xmw/AppActivity";
		end
		local ok = luaj.callStaticMethod(class_name,"textToPasteboard",args,sigs);
	else
		return;
	end
end

function util.add_slider_image(layer, path1, path2, path3, max, min, pos, anchorpoint, callback, zorder)
	if nil == callback then
		return nil;
	end
	anchorpoint = anchorpoint or ANCHOR_CENTER_CENTER;
	local slider = cc.ControlSlider:create(path1, path2, path3);
	slider:setPosition(pos);
	slider:setAnchorPoint(anchorpoint);
	slider:setMinimumValue(min);
	slider:setMaximumValue(max);
	slider:registerControlEventHandler(callback, cc.CONTROL_EVENTTYPE_VALUE_CHANGED);

	if nil ~= zorder then
		layer:addChild(slider, zorder);
	else
		layer:addChild(slider);
	end
	return slider;
end

function util.show_horselamp(msg, count)
	msg = msg or '???';
	local lamp = layer_horselamp;
	lamp.list = lamp.list or {};
	table.insert(lamp.list, { msg = msg, count = count });
	if nil == lamp.layer then
		g_scene:add_layer(ZORDER_LAYER_HORSELAMP, lamp:create());
	end
end

-- return true: has done, false: not done yet
function util.check_tutor(tutor_step)
	if tutor_step > 100 then
		return false;
	end
	local index = util.bit_lshift(1, tutor_step);
	local mark = util.bit_and(g_tutor, index);
	if mark > 0 then
		return true;
	end
	return false;
end




function util.add_tutorial(pos, size, tutor_step, callback, not_set)
	--[[ no need to check again, already did in trigger_tutor
	if true == util.check_tutor(tutor_step) then
		return false;
	end
	]]--
	if true ~= not_set then
		util.set_tutor(tutor_step, true, false);
	end
	local tip = tutor_tip(tutor_step);
	--[[
	local director = cc.Director:getInstance();
	local scene = director:getRunningScene();
	local layer_tutor = scene:getChildByTag(TAG_LAYER_TUTOR);
	if nil == layer_tutor then
	]]--
	if nil == layer_tutorial.layer then
		local layer, name = layer_tutorial:create(pos, size, tip, callback);
		--layer:setTag(TAG_LAYER_TUTOR);
		g_scene:add_layer(ZORDER_LAYER_TUTORIAL, layer, name);
	else
		-- see in layer_tutorial to_close
		layer_tutorial:set_view(pos, size, tip, callback);
		return true, true;
		--return true, pos, size, tip, callback;
	end
	return true;
end

function util.trigger_tutor(ts, is_force) -- tutor_step
	--[[
	if false == OLD_TUTOR then
		return false;
	end
	]]--
	if nil == ts then return false; end
	if true ~= g_scene:is_online() then
		return false;	
	end
	if ts < 1000 and true ~= is_force and true == util.check_tutor(ts) then
		return false;
	end
	local flag = false;
	if ts == TUTOR_FIRST_INTRO then
		flag = tutor_first_intro(ts);
	elseif ts == TUTOR_CHAPTER_1_1 then
		flag =  tutor_chapter_1_1(ts);
	elseif ts == TUTOR_CHAPTER_1_1_R then
		flag =  tutor_chapter_1_1_r(ts);
	elseif ts == TUTOR_CHAPTER_1_2 then
		flag = tutor_chapter_1_2(ts);
	elseif ts == TUTOR_CHAPTER_1_2_R then
		flag = tutor_chapter_1_2_r(ts);
	elseif ts == TUTOR_CHAPTER_1_3 then
		flag = tutor_chapter_1_3(ts);
	elseif ts == TUTOR_CHAPTER_1_3_R then
		flag = tutor_chapter_1_3_r(ts);
	elseif ts == TUTOR_RETURN_1_1 then
		flag = tutor_return_1_1(ts);
	elseif ts == TUTOR_RETURN_1_7 then
		flag = tutor_return_1_7(ts);
	elseif ts == TUTOR_RETURN_1_8 then
		flag = tutor_return_1_8(ts);
	elseif ts == TUTOR_DECK_MOVE_CARD then
		flag = tutor_deck_move_card(ts);
	elseif ts == TUTOR_PIECE_MERGE then
		flag = tutor_piece_merge(ts);
	elseif ts == TUTOR_CHAPTER_1_9 then
		flag = tutor_chapter_1_9(ts);
	elseif ts == TUTOR_RETURN_1_9 then
		flag = tutor_return_1_9(ts);
	elseif ts == TUTOR_STAGE_1_9 then
		flag = tutor_stage_1_9(ts);
	elseif ts == TUTOR_SHOW_PIECE then
		flag = tutor_show_piece(ts);
	end
	--[[
	-- do when finish tutor
	if true == flag then
		util.set_tutor(ts, true, true);
	end
	]]--
	return flag;
	-- deprecated --
	--[[
	if ts == TUTOR_SOLO then
		return tutor_solo();
	elseif ts == TUTOR_RES then
		return tutor_res();
	elseif ts == TUTOR_TAP_SKIP then
		return tutor_tap_skip();
	elseif ts == TUTOR_HERO_POWER then
		return tutor_hero_power();
	elseif ts == TUTOR_ALLY_ATTACK then
		return tutor_ally_attack();
	elseif ts == TUTOR_WEAPON_ATK then
		return tutor_weapon_atk();
	elseif ts == TUTOR_ARMOR_DEF then
		return tutor_armor_def();
	elseif ts == TUTOR_COST then
		return tutor_cost();
	elseif ts == TUTOR_SAC then
		return tutor_sac();
	elseif ts == TUTOR_SAC_TAP then
		return tutor_sac_tap();
	elseif ts == TUTOR_PLAY then
		return tutor_play();
	elseif ts == TUTOR_HL then
		return tutor_hl();
	elseif ts == TUTOR_USE then
		return tutor_use();
	elseif ts == TUTOR_HL_ALLY then
		return tutor_hl_ally();
	elseif ts == TUTOR_TAP_ATTACK then
		return tutor_tap_attack();
	elseif ts == TUTOR_HL_ATTARGET then
		return tutor_hl_attarget();
	elseif ts == TUTOR_TAP_ATTARGET then
		return tutor_tap_attarget();
	elseif ts == TUTOR_HL_HERO then
		return tutor_hl_hero();
	elseif ts == TUTOR_TAP_ABHERO then
		return tutor_tap_abhero();
	elseif ts == TUTOR_NEXT then
		return tutor_next();
	elseif ts == TUTOR_STORY then
		return tutor_local();
	elseif ts == TUTOR_FIRST_SAC then
		return tutor_first_sac();
	elseif ts == TUTOR_WAIT_NEXT_SAC then
		return tutor_wait_next_sac();
	elseif ts == TUTOR_WAIT_NEXT then
		return tutor_wait_next();
	elseif ts == TUTOR_SECOND_SAC then
		return tutor_second_sac();
	elseif ts == TUTOR_HIGHLIGHT_CARD then
		return tutor_highlight_card();
	elseif ts == TUTOR_SOMMON_CARD then
		return tutor_summon_card();
	elseif ts == TUTOR_WYLD_SKILL then
		return tutor_wyld_skill();
	elseif ts == TUTOR_NO_TARGET_ATK then
		return tutor_no_target_atk();
	elseif ts == TUTOR_REST then
		return tutor_rest();
	elseif ts == TUTOR_ATTACK then
		return tutor_attack();
	elseif ts == TUTOR_INTRO then
		return tutor_intro();
	elseif ts == TUTOR_AREA then
		return tutor_area();
	elseif ts == TUTOR_AREA_RES then
		return tutor_area_res();
	elseif ts == TUTOR_AREA_HAND then
		return tutor_area_hand();
	elseif ts == TUTOR_AREA_HERO then
		return tutor_area_hero();
	elseif ts == TUTOR_AREA_DECK then
		return tutor_area_deck();
	elseif ts == TUTOR_AREA_SPACE then
		return tutor_area_space();
	elseif ts == TUTOR_TURN_SAC then
		return tutor_turn_sac();
	elseif ts == TUTOR_PVP_CAN_ATTACK then
		return tutor_pvp_can_attack();
	elseif ts == TUTOR_PVP_ATTACK then
		return tutor_pvp_attack();
	elseif ts == TUTOR_PAY_AD then
		return tutor_pay_ad();
	elseif ts == TUTOR_PAY then
		return tutor_pay();
	elseif ts == TUTOR_DECK then
		return tutor_deck();
	end
	return false;
	]]--
	-- deprecated --
end

function util.play_frame(layer, effname, pos, anchorpoint, frame_time, zorder, is_repeat)
	local filename, fullpath;
	local cache, sprite, animation, len;
	cache = cc.SpriteFrameCache:getInstance();
	filename = effname .. '.plist';
	fullpath = util.get_fullpath(F_ANIM, filename);
	cache:addSpriteFrames(fullpath);
	filename = effname .. '_1.png';
	sprite = cc.Sprite:createWithSpriteFrameName(filename);
	sprite:setPosition(pos);
	sprite:setAnchorPoint(anchorpoint or ANCHOR_LEFT_DOWN);
	layer:addChild(sprite, zorder or 0);
	animation = cc.Animation:create();
	len = 0;
	filename = effname .. '_' .. 1 .. '.png';
	local frame = cache:spriteFrameByName(filename);
	repeat
		len = len + 1;
		animation:addSpriteFrame(frame);
		filename = effname .. '_' .. len .. '.png';
		frame = cache:spriteFrameByName(filename);
	until nil == frame;
	animation:setDelayPerUnit(frame_time or 0.5);
	if true == is_repeat then
		sprite:runAction(cc.RepeatForever:create(cc.Animate:create(animation)));
	else
		sprite:runAction(cc.Animate:create(animation));
	end
	return sprite;
end

function util.string_cut_by_size(str, limit_size)
	local count = 0;
	local output = '';
	local byte_count = 0;
	for i = 1, string.len(str) do
		local cur_byte = string.byte(str, i);
		if byte_count == 0 then
			if cur_byte > 0 and cur_byte <= 127 then
				byte_count = 1;
			elseif cur_byte >= 192 and cur_byte < 223 then
				byte_count = 2;
			elseif cur_byte >= 224 and cur_byte < 239 then
				byte_count = 3;
			elseif cur_byte >= 240 and cur_byte < 247 then
				byte_count = 4;
			else
				byte_count = 1;
			end
			local char = string.sub(str, i, i+byte_count-1);
			output = output .. char;
			count = count + 1;
			if nil ~= limit_size then
				if count > limit_size then
					break;
				end
			end
		end
		byte_count = byte_count - 1;
	end
	return output, count;
end

function util.get_json_str(tbl)
	local str = "{";
	for k, v in pairs(tbl) do
		if #str > 1 then
			str = str .. ",";
		end
		str = str .. "\"" .. k .. "\"";
		str = str .. ":";
		str = str .. "\"" .. v .. "\"";
	end
	str = str .. "}";
	return str;
end


function util.set_gray(node)
	local glp = cc.GLProgram:createWithFilenames("shader_gray.vsh", "shader_gray.fsh");
	--glp:updateUniforms();
	--glp:link();
	node:setGLProgram(glp);
end

-- e.g
--local verts = {
--	cc.p(100, 700),
--	cc.p(500, 700),
--	cc.p(500, 800),
--	cc.p(100, 800),
--	cc.p(100, 700),
--};
--util.draw_line(layer, verts, cc.c4f(1, 0, 0, 1), 20, 10, 1);
function util.draw_line(layer, verts, color, dash, gap, speed, zorder, line_width)
	local pstencil = cc.DrawNode:create();
	line_width = line_width or 2;
	zorder = zorder or 100;
	dash = dash or 20;
	gap = gap or 10;
	speed = speed or 1;
	color = color or cc.c4f(1, 0, 0, 1);
	if #(verts or {}) < 2 then
		return;
	end
	for i = 1, #verts do
		verts[i].v_mark = 0;
	end
	local function cb_draw(delta)
		pstencil:clear();
		for i = 1, #verts-1 do
			local fpos = verts[i];
			local v = verts[i].v_mark; -- set new value in end of the loop
			local tpos = verts[i+1];
			local startx = fpos.x;
			local starty = fpos.y;
			local endx = tpos.x;
			local endy = tpos.y;
			local distance = cc.p(endx-startx, endy-starty);
			local r = math.atan2(distance.y, distance.x);
			local rx = math.cos(r);
			local ry = math.sin(r);
			v = math.abs(v);
			local ttt = 1;
			if rx < 0 or ry < 0 then
				ttt = -1;
			end
			if v == dash+gap then
				v = 0;
			end
			v = v * ttt;
			v = v + speed*ttt;
			local x = startx;
			local y = starty;
			local gapd = 0;
			local gapg = 0;
			local m = v;
			while v*ttt > 0 do
				local t = v;
				v = v - gap*ttt;
				if v*ttt <= 0 then
					gapg = t;
					break;
				end
				t = v;
				v = v - dash*ttt;
				if v*ttt <= 0 then
					gapd = t;
					break;
				end
			end
			v = m;
			while (endx > startx and x < endx) or 
				  (endx < startx and x > endx) or
				  (endy > starty and y < endy) or
				  (endy < starty and y > endy) do
				if gapg*ttt > 0 then
					x = x + gapg*rx*ttt;
					y = y + gapg*ry*ttt;
				end
				from = cc.p(x, y);
				if gapd*ttt > 0 then
					x = x + gapd*rx*ttt;
					y = y + gapd*ry*ttt;
				else
					x = x + dash*rx;
					y = y + dash*ry;
				end
				if (endx > startx and x > endx) or 
				   (endx < startx and x < endx) then
					x = endx;
				end
				if (endy > starty and y > endy) or 
				   (endy < starty and y < endy) then
					y = endy;
				end
				to = cc.p(x, y);
				pstencil:drawSegment(from, to, line_width, color);
				x = x + gap*rx;
				y = y + gap*ry;
				gapg = 0;
				gapd = 0;
			end
			verts[i].v_mark = v;
		end
		--pstencil:unscheduleUpdate();
	end
	--
	layer:addChild(pstencil, zorder);
	pstencil:scheduleUpdateWithPriorityLua(cb_draw, 1);
	return pstencil, verts;
end

-- time is sec
function util.set_local_push(time, message)
	if nil == time then return; end
	message = message or "决战王者";
	--print('time, os.time: ', time, os.time());
	local time_now = os.time();
	if time <= time_now then return; end
	local gap = time - time_now; -- sec
	local sec = gap%60;
	local min = math.floor(gap/60)%60;
	local hours = math.floor(gap/(60*60))%24;
	local days = math.floor(gap/(60*60*24));
	local startHour = 13;
	local endHour = 18;
	print('set_local_push days, hours, min, sec: ', days, hours, min, sec);
	local platform = cc.Application:getInstance():getTargetPlatform();
	if platform == cc.PLATFORM_OS_IPHONE or platform == cc.PLATFORM_OS_IPAD then
		local args = { 
			sec = sec,
			min = min,
			hours = hours,
			days = days,
			startHour = startHour,
			endHour = endHour,
			message = message,
		};
		local luaoc = require "luaoc";
		local class_name = "SysTool";
		local ok = luaoc.callStaticMethod(class_name, "setUpLocalPush", args);
	elseif platform == cc.PLATFORM_OS_ANDROID then
		local args = { 
			sec, min, hours, days, startHour, endHour, message
		};
		local sigs = "(IIIIIILjava/lang/String;)V";
		local luaj = require "luaj";
		local class_name = "org/cocos2dx/lua/AppActivity";
		local ok, ret = luaj.callStaticMethod(class_name, "setLocalPush", args, sigs);
	end
end
-- /////////////////////// UTIL END   ///////////////////////////

-- /////////////////////// RICH LABEL START   ///////////////////////////
rich_label = { chinese_size = 3 };
function rich_label.new(parent, pos, text, font, font_size, row_width, row_space, color, zorder)
	local node = cc.Node:create();
	node:setPosition(pos);
	node:setContentSize(cc.size(1, 1));
	parent:addChild(node, zorder or 0);
	local text_tab = rich_label.init_data(text, font, font_size, row_width);
	local ptab, copy_var = rich_label.tab_add_text(text_tab);

	local oc_width = 0;
	local oc_row = 1;
	local oc_height = 0;
	local btn = 0;
	local use_width = 0;
	local use_height = 0;
	for k, v in pairs(copy_var) do
		local params = {};
		rich_label.tab_add_data_to(params, v);
		--print('prow, orow: ', params.row, oc_row);
		if params.row == oc_row then
			oc_width = oc_width + use_width;
		else
			oc_row = params.row;
			oc_width = 0;
			oc_height = oc_height + use_height + row_space;
		end
		local max_size = params.size;
		local byte_size = math.floor((max_size+2)/rich_label.chinese_size);
		params.width = byte_size * params.breadth;
		params.height = max_size;
		params.x = oc_width;
		params.y = -(oc_height);
		params.node = node;
		params.default_color = color;
		btn, use_width, use_height = rich_label.tab_create_button(params);
	end
	return node, oc_width, oc_height + font_size;
end

function rich_label.init_data(text, font, font_size, row_width)
	local tab = rich_label.parse_string(text, {font = font, size = font_size});
	local var = { tab = tab, width = row_width };
	return var;
end

function rich_label.parse_string(text, param)
	local tab_head = {};
	-- get string attribute
	-- such as [color=FF0000]
	--for w in string.gfind(text, "%b[]") do
	for w in string.gmatch(text, "%b[]") do
		if "/" ~= string.sub(w, 2, 2) then
			table.insert(tab_head, w);
		end
	end
	local total_tab = {};
	for k, ns in pairs(tab_head) do
		local tab = {};
		local str = nil;
		-- get the attribute info
		-- such as tab["color"] = cc.c3b(255, 255, 255);
		string.gsub(ns, string.sub(ns, 2, #ns-1), 
			function(w)
				local n = string.find(w, "=");
				if n then
					local tem_tab = rich_label.str_split(w, " ");
					for k, pstr in pairs(tem_tab) do
						local tem_tab1 = rich_label.str_split(pstr, "=");
						local pname = tem_tab1[1];
						if 1 == k then str = pname; end
						local js = tem_tab1[2];
						local p = string.find(js, "[^%d.]");
						if not p then js = tonumber(js); end
						if "color" == pname then
							tab[pname] = rich_label.get_text_color(js);
						else
							tab[pname] = js;
						end
					end
				end
			end
		);
		-- cut the string to tab and then insert total_tab
		if str then
			local ns_2 = gsub_symbol(ns);
			local b_find1, e_find1 = string.find(text, ns_2);
			if nil ~= b_find1 and nil ~= e_find1 and b_find1-1 > 0 then
				local ttt = string.sub(text, 1, b_find1-1);
				local gap = string.len(ttt);
				local ttab = { ["text"]=ttt };
				if param then
					if not ttab.number then param.number = k; end
					rich_label.tab_add_data_to(ttab, param);
				end
				table.insert(total_tab, ttab);
				text = string.sub(text, b_find1, string.len(text));
				b_find1, e_find1 = string.find(text, ns_2);
			end
			local b_find, e_find = string.find(text, "%[%/" .. str .. "%]");
			if nil ~= b_find and nil ~= e_find and 
			   nil ~= b_find1 and nil ~= e_find1 then
				local s_number = e_find1 + 1;
				local e_number = b_find - 1;
				--local gs = string.sub(text, #ns+1, e_number);
				local gs = string.sub(text, s_number, e_number);
				if string.find(gs, "%[") then
					tab["text"] = gs;
				else
					gs = gsub_symbol(gs);
					string.gsub(text, gs, 
						function(w)
							tab["text"] = w;
						end
					);
				end
				text = string.sub(text, e_find+1, #text)
				if param then
					if not tab.number then param.number = k; end
					rich_label.tab_add_data_to(tab, param);
				end
				table.insert(total_tab, tab);
			end
		end
	end
	local tab_head_nums = 0;
	for k, v in pairs(tab_head) do
		tab_head_nums = tab_head_nums + 1;
	end
	if 0 == tab_head_nums then
		local ptab = {};
		ptab.text = text;
		if param then
			param.number = 1;
			rich_label.tab_add_data_to(ptab, param);
		end
		table.insert(total_tab, ptab);
	elseif string.len(text) > 0 then
		local tab = { ["text"]=text };
		if param then
			if not tab.number then param.number = k; end
			rich_label.tab_add_data_to(tab, param);
		end
		table.insert(total_tab, tab);
		text = nil;
	end
	return total_tab;
end

function rich_label.str_split(str, flag)
	local tab = {};
	while true do
		local n = string.find(str, flag);
		if n then
			local first = string.sub(str, 1, n-1);
			str = string.sub(str, n+1, #str); 
			table.insert(tab, first);
		else
			table.insert(tab, str);
			break;
		end
	end
	return tab;
end

function rich_label.get_text_color(text)
	if 6 == string.len(text) then
		local tmp = {};
		for i = 0,5 do
			local str = string.sub(text,i+1,i+1);
			if(str >= '0' and str <= '9') then
				tmp[6-i] = str - '0';
			elseif(str == 'A' or str == 'a') then
				tmp[6-i] = 10;
			elseif(str == 'B' or str == 'b') then
				tmp[6-i] = 11;
			elseif(str == 'C' or str == 'c') then
				tmp[6-i] = 12;
			elseif(str == 'D' or str == 'd') then
				tmp[6-i] = 13;
			elseif(str == 'E' or str == 'e') then
				tmp[6-i] = 14;
			elseif(str == 'F' or str == 'f') then
				tmp[6-i] = 15;
			else
				print("Wrong color value.");
				tmp[6-i] = 0;
			end
		end
		local r = tmp[6] * 16 + tmp[5];
		local g = tmp[4] * 16 + tmp[3];
		local b = tmp[2] * 16 + tmp[1];
		return cc.c3b(r,g,b);
	end
	return cc.c3b(0,0,0);
end

function rich_label.tab_add_data_to(tab, src)
	for k, v in pairs(src) do
		tab[k] = v;
	end
end

function rich_label.tab_add_text(var)
	local all_tab = {};
	local copy_var = {};
	local use_len = 0;
	local str = "";
	local current = 1;
	for ktb, tab in ipairs(var.tab) do
		local txt_tab, member = rich_label.tab_cut_text(tab.text);
		local num = math.floor((var.width)/math.ceil((tab.size+2)/rich_label.chinese_size));
		if 0 < use_len then
			local remain = num - use_len;
			local txt_len = rich_label.account_text_len(tab.text, tab.size);
			if txt_len <= remain then
				all_tab[current] = all_tab[current] .. tab.text;
				rich_label.add_data_to_render_tab(copy_var, tab, tab.text, (use_len + 1), current);
				use_len = use_len + txt_len;
				txt_tab = {};
			else
				local c_tag = 0;
				local mstr = "";
				local s_index = use_len + 1;
				for k, element in pairs(txt_tab) do
					local s_len = rich_label.account_text_len(element, tab.size);
					if (use_len + s_len) <= num then
						use_len = use_len + s_len;
						c_tag = k;
						mstr = mstr .. element;
					else
						if string.len(mstr) > 0 then
							all_tab[current] = all_tab[current] .. mstr;
							rich_label.add_data_to_render_tab(copy_var, tab, mstr, s_index, current);
						end
						current = current + 1;
						use_len = 0;
						str = "";
						break;
					end
				end
				for i = 1, c_tag do
					table.remove(txt_tab, 1);
				end
			end
		end
		local max_row = math.ceil(member/num);
		for k, element in pairs(txt_tab) do
			local s_len = rich_label.account_text_len(element, tab.size);
			if (use_len + s_len) <= num then
				use_len = use_len + s_len;
				str = str .. element;
			else
				all_tab[current] = str;
				rich_label.add_data_to_render_tab(copy_var, tab, str, 1, current);
				current = current + 1;
				use_len = s_len;
				str = element;
			end
			if k == #txt_tab then
				if use_len <= num then
					all_tab[current] = str;
					rich_label.add_data_to_render_tab(copy_var, tab, str,1,current);
				end
			end
		end
	end
	return all_tab, copy_var;
end

function rich_label.tab_cut_text(str)
	local list = {};
	local len = string.len(str or "");
	local i = 1;
	while i <= len do
		local c = string.byte(str, i);
		local shift = 1;
		if c > 0 and c <= 127 then
			shift = 1;
		elseif (c >= 192 and c <= 223) then
			shift = 2;
		elseif (c >= 224 and c <= 239) then
			shift = 3;
		elseif (c >= 240 and c <= 247) then
			shift = 4;
		end
		local char = string.sub(str, i, i+shift-1);
		i = i + shift;
		table.insert(list, char);
	end
	return list, len;
end

function rich_label.str_format_to_number(number, num)
	local s = "%." .. num .. "f"
	return tonumber(string.format(s, number))
end

function rich_label.account_text_len(str, tsize)
	local list = rich_label.tab_cut_text(str);
	local a_len = 0;
	for k, v in pairs(list) do
		local a = string.len(v);
		-- TODO need optimize
		local font = "Arial";
		local label = cc.Label:createWithSystemFont(v, font, tsize);
		a = tsize/label:getContentSize().width;
		local b = rich_label.str_format_to_number(rich_label.chinese_size / a, 4);
		a_len = a_len + b;
		-- now is let it auto relase
	end
	return a_len;
end

function rich_label.add_data_to_render_tab(copy_var, tab, text, index, current)
	local tag = #copy_var + 1;
	copy_var[tag] = {};
	rich_label.tab_add_data_to(copy_var[tag], tab);
	copy_var[tag].text = text;
	copy_var[tag].index = index;
	copy_var[tag].row = current;
	copy_var[tag].breadth = rich_label.account_text_len(text, tab.size);
	copy_var[tag].tag = tag;
end

function rich_label.tab_create_button(params)
	local node = params.node;
	local text = params.text;
	local size = params.size;
	local color = params.color or params.default_color;
	local font = params.font;
	local x = params.x;
	local y = params.y;
	--print('==== rich_label text: ', text, font, size, node, color);
	local label = util.add_labelsys(node, text, font, size, cc.p(x, y), color, ANCHOR_LEFT_DOWN);
	local lsize = label:getContentSize();
	if params.image then
		rich_label.image_manage(btn, params, use_Width)
	end
	return label, lsize.width, lsize.height;
end

function rich_label.image_manage(object, params, use_width)
	local node = params.node;
	local fname = params.image;
	local fullpath, is_exist = util.get_fullpath(F_IMAGE, fname);
	if true ~= is_exist then return; end
	local x = params.x;
	local y = params.y;
	util.add_sprite(node, fullpath, cc.p(x, y), ANCHOR_LEFT_DOWN);
end
-- /////////////////////// RICH LABEL END   ///////////////////////////

-- /////////////////////// COMMON START   ///////////////////////////

function is_anysdk_show_pay()
	if true ~= (is_ver(VER_ANYSDK) or is_ver(VER_ANYSDK_NO_LOGIN)) then
		return false;
	end
	local agent = AgentManager:getInstance();
	local cid = tonumber(agent:getChannelId() or "0");

	return true;
	--show_msg("cid: " .. cid);
	-- 000008 木蚂蚁
	-- 000003 当乐
	-- 000004 N多
	-- 000066 小米 木蚂蚁
	-- 000020 可可
	-- 000286 金立
	-- 000002 机锋
	-- 000054 华为
	-- 000078 酷派
	-- 000108 4399
	-- 110000 百度游戏
	-- 000116 豌豆荚
	-- 000014 魅族
	-- 000550 腾讯
--	if cid == 8 or cid == 3 or cid == 4 or cid == 66 or cid == 20 or cid == 286 or cid == 2 or cid == 54 or cid == 78 or cid == 108 or cid == 110000 or cid == 116 or cid == 14 or cid == 550 then
--		return true;
--	end
--	return false;
end

function is_anysdk_oppo()
	if true ~= (is_ver(VER_ANYSDK) or is_ver(VER_ANYSDK_NO_LOGIN)) then
		return false;
	end
	local agent = AgentManager:getInstance();
	local cid = tonumber(agent:getChannelId() or "0");
	if cid == 20 then
		return true;
	end
	return false;
end

function callback_remove_sprite(...)
	local args = { ... };
	local sprite = args[1];
	sprite:removeFromParentAndCleanup(false);
end


function get_time()
	local str = os.date("%X");
	return str;
end

function get_icon_path(index)
	index = index or '0';
	local filename = 'picon_1_' .. index .. '.png';
	--local fullpath = util.get_fullpath(F_IMAGE, filename, 'picon_1_0.png');
	local path = util.get_path(filename, 'picon_1_0.png');
	return path;
end

function c_get_slot_str(deck_str, all_str)
	local deck_len = string.len(deck_str or '');
	local all_len = string.len(all_str or '');
	local str = '';
	if deck_len ~= all_len then
		kerror("c_get_slot_str len[%d],deck[%d]", deck_len, all_len);
		return str;
	end
	for i = 1, deck_len do
		local ds = string.sub(deck_str, i, i); -- 
		local dn = tonumber(ds) or 0;

		local as = string.sub(all_str, i, i); 
		local an = tonumber(as) or 0;

		local n = an - dn;
		if n < 0 then
			n = 0;
		end
		str = str .. n;
	end
	return str;
end

function c_str_array(str)
	local list = {};
	local len = string.len(str or '');
	for i = 1, len do
		local s = string.sub(str, i, i); -- get one character
		local n = tonumber(s) or 0;
		if n > 0 then
			local rc = g_card_list[i];
			if nil == rc then
				rc = hero_list[i];
			end
			if nil ~= rc then
				-- in layer_deck 
				-- when using g_euser.deck_array
				-- will clone the cards again in order to avoid mixup the card
				local card = clone(rc);	
				table.insert(list, { card = card, count = n });
				--list[#list+1] = { card = card, count = n };
			end
		end
	end
	return list;
end

function c_str_array_2(str)
	local list = {};
	local len = string.len(str or '');
	for i = 1, len do
		local s = string.sub(str, i, i); -- get one character
		local n = tonumber(s) or 0;
		if n > 0 then
			local rc = g_card_list[i];
			if nil == rc then
				rc = hero_list[i];
			end
			if nil ~= rc then
				table.insert(list, { cid = i, count = n });
			end
		end
	end
	return list;
end

function c2_str_array(str)
	local list = {};
	local len = string.len(str or '');
	local index = 1;
	for i = 1, len, 2 do
		local s = string.sub(str, i, i+1); -- get two character
		local n = tonumber(s) or 0;
		if n > 0 then
			local rc = g_card_list[index];
			if nil == rc then
				rc = hero_list[index];
			end
			if nil ~= rc then
				-- in g_layer_deck 
				-- when using g_euser.deck_array
				-- will clone the cards again in order to avoid mixup the card
				--local card = clone(rc); -- just get the id is enough	
				table.insert(list, { cid = index, count = n });
				--list[#list+1] = { card = card, count = n };
			end
		end
		index = index + 1;
	end
	return list;
end

function get_guild_name(gname)
	if nil == gname or "_no_guild" == gname then
		return t_lang("NO_GUILD");
	end
	return gname;
end

function get_power()
	return math.floor(g_euser.power or 0);
end

function enable_btn(btn, is_enable)
	if nil == btn then return; end
    if true == is_enable then
		btn:setEnabled(true);
		btn:setColor(cc.c3b(255, 255, 255));
	else  
		btn:setEnabled(false);
		btn:setColor(cc.c3b(100, 100, 100));
	end   
end

-- calculate the horizontal gap width between 2 cards, 
-- given a table of table_width,  card_width can be init globally
-- ltype is ui_table.ltype
function calculate_gap(total_card, card_width, table_width, ltype)
	if g_euser.side == SIDE_DOWN and ltype == DOWN_HAND then
		table_width = table_width+HAND_GAP*2;
	end
	local gap;
	local base;
	-- ?? why not table_width / total_card ?
	base = total_card - 1;
	if (base <= 0) then
		base = 1;  -- magic, never division-by-zero
	end

	-- beware: gap may be negative!
	gap = (table_width - card_width) / base;
	if gap > card_width then
		gap = card_width;
	end
	return math.abs(gap); -- note: this is not pixel, so decimal is OK
end

-- just used for init_ui_table and refresh_table_list
function get_card_pos_rotation(ui_table, gap, index, total_card)
	local pos;
	local rotation = 0;
	if ui_table.ltype == DOWN_HAND then
		local half_height = ui_table.height / 4;
		local m_index = total_card / 2 + 1;
		local offsety = half_height / (m_index - 1);
		local tx = ui_table.x;
		local half_width = ui_table.width / 2;
		local y;
		if g_euser.side == SIDE_DOWN then
			tx = tx - HAND_GAP;
			half_width = half_width + HAND_GAP; -- HAND_GAP*2/2
			y = ui_table.y;
			rotation = 0;
		else
			y = ui_table.y;
			rotation = 0;
			--[[
			y = ui_table.y - math.abs(m_index - index) * offsety * 0.5;
			local r_gap = 40 / m_index;
			rotation = (index - m_index) * r_gap;
			]]--
		end
		pos = cc.p( tx + half_width + gap * ( index - m_index ), y);
	elseif ui_table.ltype == UP_HAND then
		local half_height = ui_table.height / 4;
		local m_index = total_card / 2 + 1;
		local offsety = half_height / (m_index - 1);
		local tx = ui_table.x;
		local half_width = ui_table.width / 2;
		y = ui_table.y;
		rotation = 0;
		pos = cc.p( tx + half_width + gap * ( index - m_index ), y);
		--[[
		local half_height = ui_table.height / 4;
		local m_index = total_card / 2 + 1;
		local offsety = half_height / (m_index - 1);
		local tx = ui_table.x;
		local half_width = ui_table.width / 2;
		pos = ccp( tx + half_width + gap * ( index - m_index ), 
			       ui_table.y + math.abs(m_index - index) * offsety * 0.5 
				 );
		local r_gap = 40 / m_index;
		rotation = 180 - (index - m_index) * r_gap;
		]]--
	elseif ui_table.ltype == UP_DECK then
		--rotation = 30;
		pos = ccp( ui_table.x + gap * ( index - 1 ), ui_table.y );
	elseif ui_table.ltype == DOWN_DECK then
		--rotation = -30;
		pos = ccp( ui_table.x + gap * ( index - 1 ), ui_table.y );
	else
		pos = ccp( ui_table.x + gap * ( index - 1 ), ui_table.y );
	end
	return pos, rotation;
end

function add_ui_card(layer, card_list, pos, rotation, card, sprite, alist, index, keep_sprite)
	if card==nil then
		kerror("add_ui_card card(info)=nil");
	end

	local t = card_list.ltype;
	local ctype = CARD_FRONT;
	if card.id > 1000 then
		ctype = CARD_VIRTUAL;
	elseif t==UP_DECK or t==DOWN_DECK then
		if (g_euser.side == SIDE_DOWN and t==DOWN_DECK) and is_view_top() then
--			print('card index:', cindex(card));
			ctype = CARD_FRONT;
		else
			ctype = CARD_COVER;
		end
	elseif t==DOWN_HAND or t==UP_HAND then
		if (g_euser.side == SIDE_UP and t==UP_HAND) or true == SHOW_ALL or is_view_oppo() then
			ctype = CARD_FRONT;
		elseif g_euser.side == SIDE_DOWN and t==DOWN_HAND then
			ctype = CARD_FRONT;
		elseif true == data_handler.show_all_card then
			ctype = CARD_FRONT;
		else
			ctype = CARD_COVER;
		end
	elseif t==DOWN_SUPPORT or t==UP_SUPPORT then
		if TRAP==card.ctype then
			ctype = CARD_COVER;
		else
			ctype = CARD_FRONT;
		end
	elseif t==UP_GRAVE or t==DOWN_GRAVE then
		ctype = CARD_GRAVE;
	elseif t==UP_HERO or t==DOWN_HERO then
		ctype = CARD_HERO;
	elseif card.ctype == ATTACH then
		local ppp = cindex(card);
		local ttt = index_table_num(ppp);
		if ttt == T_HERO then
			ctype = CARD_HERO_ATTACH;
		else
			ctype = CARD_ATTACH;
		end
	end

	local scale = card_list.cscale;
	local stype = STYPE_VER_2;
	local info;
	info = object_card:new(layer, card, sprite, alist, pos, rotation,scale,stype);
	if nil == index or index > #card_list + 1 then
		index = #card_list + 1;
	elseif index < 1 then
		index = 1;
	end
	table.insert(card_list, index, info);

	local t = card_list.ltype;
	local list_offset = index_offset(index);
	if t == UP_DECK or t == DOWN_DECK then
		--local list_length = #g_logic_table[SIDE_UP][T_DECK];
		--info.status = CARD_COVER;
		--if t == DOWN_DECK then
		--print('card.name: ', card.name, info.status, CARD_FRONT, CARD_COVER);
		--end
		if true ~= keep_sprite and list_offset > 4 then
			if nil ~= sprite then
				info:remove_sprite();
			end
			return info;	
		end
	end
	if t == UP_GRAVE then
		return info;
		--[[
		local list_length = #g_logic_table[SIDE_UP][T_GRAVE];
		if list_offset < list_length then
			return info;	
		end
		]]--
	end
	if t == DOWN_GRAVE then
		return info;
		--[[
		local list_length = #g_logic_table[SIDE_DOWN][T_GRAVE];
		if list_offset < list_length then
			return info;	
		end
		]]--
	end
	if nil ~= sprite then
		--[[
		local tt = index_table_num(cindex(info.card));
		if tt == T_DECK and info.status ~= CARD_COVER then
				info:remove_sprite();
		else
			return info, sprite;
		end
		]]--
		return info, sprite;
	end
	local new_sprite = info:set_sprite(ctype);

	return info, new_sprite;
end

-- this is for cc.CallFunc
function refresh_layer_card()
	layer_card:refresh_layer();
end


function remove_from_cmd_list()
	g_cache_cmd_list = g_cache_cmd_list or {};
	if 0 == #g_cache_cmd_list then
		return;
	end
	table.remove(g_cache_cmd_list, 1);
end

function pop_cmd_list()
	g_cache_cmd_list = g_cache_cmd_list or {};
	if 1 > #g_cache_cmd_list then
		return nil;
	end
	local list = g_cache_cmd_list[1];
	return list;
end

function push_cmd_list(cmd, list_callback, index)
	g_cache_cmd_list = g_cache_cmd_list or {};
	local before = #g_cache_cmd_list;
	g_cache_cmd_list[#g_cache_cmd_list + 1] = {
		cmd = cmd,
		list_callback = list_callback,
		index = index,
	};

	if 1 == #g_cache_cmd_list then
		local list = pop_cmd_list();
		if nil ~= list then
			cmd_to_eff(list);
		end
	end
end

function cmd_to_eff(list)
	local cmd = list.cmd;
	local list_callback = list.list_callback;
	local index = list.index;
	local eff_list, err;
	eff_list, err = cmd_game_to_logic(cmd, true);
	local input_list = split_string(cmd);
	layer_card:visible_btn_by_cmd(input_list[1], false);
	if 'n' == input_list[1] then
		local timeout = nil;
		layer_card:handle_next_timeout(input_list[2]);
		layer_table:change_side(g_current_side);
	end
	play_to_anim(eff_list, list_callback, index, err);
end

function check_cmd_finish()
	g_cache_cmd_list = g_cache_cmd_list or {};
	if 0 < #g_cache_cmd_list then
		return false;
	end
	if nil == g_net_win_data then
		return false;
	end
	callback_net_win();
	return true;
end

function callback_anim()
	--layer_action:remove();
	--enable_touch();
	---------
	-- assume that all net_play cmd will save to g_cache_cmd_list first
	remove_from_cmd_list();
	local is_finish = check_cmd_finish();
	if true == is_finish then
		return;
	end
	local list = pop_cmd_list();
	if nil ~= list then
		cmd_to_eff(list);
		return;
	end
	--------

	if false == g_scene:is_online() and true ~= LOCAL_TEST and g_euser.side ~= g_current_side then
		do_ai();
	end

	if true == g_is_in_tutor then
		if nil ~= story_next then
			local cb = story_next;
			story_next = nil;
			cb();
		end
	end
end

-- get eff_list from logic.lua , pass to anim.lua
function play_to_anim(eff_list, callback_list, index, err)
	kdebug("==play_to_anim==");
	if nil == eff_list then
		kerror("play_to_anim eff_list is nil");
		layer_card:refresh_card_list();
		refresh_layer_card();
		if nil ~= err then
			g_scene:add_layer(ZORDER_LAYER_MSG, layer_msg:create(err));
		end
		return false;
	end
	layer_card:hide_all_btn();
	remove_hl();

	print('---------------------------------');
	print_eff_list(eff_list);
	print('---------------------------------');
	
	layer_card:clean_for_touch_end();
	layer_action:remove();

	callback_list = callback_list or {};
	table.insert(callback_list, callback_anim);
	if true == USE_ANIM then
		--anim.main(g_current_side, g_euser.side, g_ui_table, layer_card.layer, eff_list, callback_list, index);
		anim.main(eff_list, callback_list, index);
	else
		for i = 1, #callback_list do
			local cb = callback_list[i];
			cb();
		end
	end
	return true;
end

function cmd_game_to_logic(str, is_save)
	--[[ TODO
	if true == is_save then
		push_playcmd_list(str);
	end
	]]--
	local eff_list = nil; 
	local err = nil;
	print('DEBUG cmd_game_to_logic play_cmd: ', str);
	eff_list, g_current_side, g_phase, err = play_cmd(str, g_logic_table, g_current_side, g_phase);
	if nil == eff_list then
		local bc = g_net_play_cache[#g_net_play_cache];
		local input_list = csplit(bc, ' ');
		bc = str_cut_num(input_list[1], bc);
		if str == bc then
			table.remove(g_net_play_cache, #g_net_play_cache);
		else
			do_greconn();
		end
	end
	return eff_list, err;
end

function play_game_cmd(cmd, index)
	local is_online = g_scene:is_online();
	local is_save = false;
	if true ~= LOCAL_TEST and false == is_online then
		is_save = true;
	end
	layer_card:hide_all_btn();
	layer_card:remove_tip_help();
	-- PVP
	if true ~= g_is_in_tutor and true == is_online then
		if true == LOCAL_CMD then
			local lcmd = cmd;
			if 'f' == cmd then
				lcmd = 'n';
			end
			local_play(lcmd);
			net_send(cmd, true);
		else
			net_send(cmd);
		end
		return false;
	end

	-- PVE
	local eff_list = nil;
	local err = nil;
	local input_list = csplit(cmd, ' ');
	local cmdtype = input_list[1];
	if 'local_ai' == cmdtype then
		eff_list, g_current_side, g_phase = ai(g_logic_table, g_current_side, g_phase);
	else
		push_cmd_list(cmd, { refresh_layer_card }, nil);
		return;
	end
	return play_to_anim(eff_list, { refresh_layer_card }, index, err);
end

function is_target_grave(index, logic_table, current_side)
	local ab_indexs = list_ability_target(index, logic_table, current_side, {},1);
	for i = 1, #ab_indexs do
		local ci = ab_indexs[i];
		local itable = index_table_num(ci);
		local iside = index_side(ci);
		if itable == T_GRAVE then
			return true, iside;
		end
	end
end

-- RET 0 == do nothing  1 == can attack   2 == can ability
--     3 == both        4 == sac          5 == table ally   6 == table support
--     7 == grave
function check_kind(card, logic_table, current_side, phase)
	if nil == card then
		return AKIND_NONE;
	end
	local side_num = index_side(cindex(card));
	if side_num ~= current_side then
		return AKIND_NONE;
	end
	local index = cindex(card);
	local tb = index_table_num(index);
	-- return -1: can be sacrifice
	-- return 0:  no action available
	-- return 1:  attack
	-- return 2:  ability
	-- return 3:  both  : attack + ability
	local kind = check_action(card, logic_table, current_side);
	local index = cindex(card);
	if -1 == kind then
		return AKIND_SAC;
	elseif 1 == kind then
		return AKIND_ATTACK;
	elseif 2 == kind then
		local num;
		local err;
		num, err = total_target(index, logic_table, current_side);
		if nil ~= err then
			err = 'check_kind ' .. err;
			g_scene:add_layer(ZORDER_LAYER_MSG, layer_msg:create(err));
			return AKIND_NONE;
		end
		if 0 == num then
			if T_HAND == tb then
				if card.ctype == ALLY then
					return AKIND_TALLY;
				elseif card.ctype >= 50 and card.ctype <= 59 then
					return AKIND_TSUPPORT;
				else
					-- e.g. card 142 支援牌
					-- in hand, to use, no target, so point to support
					return AKIND_TSUPPORT;
				end
			end
			return AKIND_ABILITY;
		end
		if 0 < num then
			if 0 == target_num(index, logic_table, current_side) then
				return AKIND_NONE;
			end
			return AKIND_ABILITY;
		end
	elseif 3 == kind then
		local num, err = total_target(index, logic_table, current_side);
		if 0 == target_num(index, logic_table, current_side) and num > 0 then
			return AKIND_ATTACK;
		end
		return AKIND_BOTH;
	end
	return AKIND_NONE;
end

-- given an integer : DOWN_HERO, DOWN_HAND,  UP_HAND etc.
-- get the sub-g_ui_table
-- global: g_ui_table
function get_card_list(ltype) -- start {
	if nil == ltype then
		return {};
	end
	local s = math.floor(ltype / 1000);
	local t = math.floor(ltype % 10);
	local table_side = g_ui_table[s];
	if table_side == nil then
		--print('ERROR get_card_list table side is nil, ltype = ', ltype);
		return {};
	end
	local table_list = table_side[t];
	if table_list == nil then
		kerror("get_card_list table type is nil, ltype[%d]", ltype);
		return {};
	end
	return table_list;
end -- get_card_list }

-- get the ui data of a card  
-- counterpart:  index_card(index, g_logic_table)
-- e.g. g_ui_table[SIDE_UP][T_HAND][3]
function get_ui_card(index) -- {
	--print('DEBUG get_ui_card index: ', index);
	if index <= 0 then
		return nil;
	end
	local side_num = index_side(index);
	local table_side = g_ui_table[side_num];
	if table_side == nil then
		kerror("table_side is nil, side[%d]", side_num);
		return nil;
	end
	
	local table_num = index_table_num(index);
	local target_list = table_side[table_num];
	if target_list == nil then
		kerror("target_list is nil, table[%d]", table_num);
		return nil;
	end
	
	local table_index = index_offset(index);
	local card_info = target_list[table_index];
	if index > 10000 then
		local alist = card_info.attach_list or {};
		local aindex = index - math.floor(index/10)*10;
		card_info = alist[aindex];
	end
	if card_info == nil then
		kdebug("get_card_info is nil, index[%d]table_index[%d]", index, table_index);
		return nil;
	end
	return card_info;
end -- get_card_info }

function target_num(index, logic_table, current_side)
	local num = 0;
	if nil == index then
		return num;
	end
	local ab_list = {};
	local tindexs = list_ability_target(index, logic_table, current_side, ab_list, #ab_list + 1);
	if nil ~= tindexs then
		num = #tindexs;
	end
	return num;
end

-- obj is card_list e.g. g_ui_table[UP_SIDE][T_HAND]
function check_in_card(obj, x, y)
	local card = obj.card;
	local sprite = obj.sprite;
	local frame = obj.frame;
	local posx = frame.x;
	local posy = frame.y;
	local scale = frame.scale;
	local width = sprite:getContentSize().width;
	local height = sprite:getContentSize().height;
	local h_width = width * scale / 2;
	local h_height = height * scale / 2;

	range = range or 0;

	local sprite_l = posx - h_width;
	local sprite_r = posx + h_width;
	local sprite_u = posy + h_height;
	local sprite_d = posy - h_height;

	--print(' x, y, l, r, u, d ', x, y, sprite_l, sprite_r, sprite_u, sprite_d);

	if x > sprite_l and x < sprite_r and y < sprite_u and y > sprite_d then
		return true;
	end

	return false;
end

-- highlight card sprite
function hl_card(index, htype) -- {
	local card = index_card(index, g_logic_table);
	local card_sprite = g_sprite_cache[card];
	if nil == card_sprite or nil == htype then
		return;
	end
	local hl = card_sprite:getChildByTag(TAG_HIGHLIGHT);
	if hl ~= nil then
		card_sprite:removeChildByTag(TAG_HIGHLIGHT, true);
	end

	local path;
	local size = card_sprite:getContentSize();
	local pos = cc.p(size.width/2, size.height/2);
	if card.ctype == HERO then
		--path = util.get_path('highlight_h.png');
		path = util.get_path('bg_136.png');
	else
		--path = util.get_path('highlight.png');
		pos.x = pos.x + 6;
		path = util.get_path('bg_98.png');
	end
	hl = util.add_sprite(card_sprite, path, pos, ANCHOR_CENTER_CENTER, -1);
	hl:setTag(TAG_HIGHLIGHT);
	if card.ctype == HERO then
		local c = hl:getColor();
		local action, array;
		array = {};
		action = cc.TintTo:create(0.5, 200, 200, 200);
		table.insert(array, action);
		action = cc.TintTo:create(0.5, c.r, c.g, c.b);
		table.insert(array, action);
		action = cc.Sequence:create(array);
		action = cc.RepeatForever:create(action);
		hl:runAction(action);
	end
end -- hl_card }

-- kind = 4(resource) 5(ally) 6(support)
function hl_table(layer, kind, ui_table, current_side)
	local hl_list = {};
	if kind == AKIND_TALLY or kind == AKIND_SAC or kind == AKIND_TSUPPORT then
		local list = ui_table[current_side][T_ALLY];
		local data = gui_get_data('ally_down', GUI_MATCH); -- ally
		local size = cc.size(data.width, data.height);
		local pos = cc.p(data.x+data.width/2, data.y+data.height/2);
		--local size = cc.size(data.width, data.height/2);
		--local pos = cc.p(data.x+data.width/2, data.y+data.height/4*3);
		table.insert(hl_list, { pos = pos, size = size });

		--[[
		list = ui_table[current_side][T_SUPPORT];
		data = gui_get_data('sup_down', GUI_MATCH); -- support
		pos = cc.p(data.x+data.width/2, data.y+data.height/2);
		size = cc.size(data.width, data.height);
		table.insert(hl_list, { pos = pos, size = size });
		]]--
		--[[
	elseif kind == AKIND_TSUPPORT then
		list = ui_table[current_side][T_SUPPORT];
		data = gui_get_data('sup_down', GUI_MATCH); -- support
		pos = cc.p(data.x+data.width/2, data.y+data.height/2);
		size = cc.size(data.width, data.height);
	elseif kind == AKIND_SAC then
		list = ui_table[current_side][T_RES];
		pos = cc.p(list.x, list.y);
		size = cc.size(list.width, list.height);
		]]--
	elseif kind == AKIND_TGRAVE then
		local list = ui_table[current_side][T_GRAVE];
		local pos = cc.p(list.x, list.y-list.height/2);
		local size = cc.size(list.width, list.height);
		table.insert(hl_list, { pos = pos, size = size });
	else
		return;
	end

	remove_hl();

	--local fullrect = cc.rect(0, 0, 64, 64);
	--local insetrect = cc.rect(4, 3, 56, 58);
	--local path = util.get_path('white.png');
	for i = 1, #hl_list do
		local info = hl_list[i];
		local pos = info.pos;
		local size = info.size;
		--[[
		local sprite = util.add_scale9sprite(layer, path, pos, ANCHOR_CENTER_CENTER, fullrect, insetrect, size, ZORDER_CARD - 10); 
		local sprite = util.
		sprite:setTag(TAG_HIGHLIGHT);

		local rect = { x1 = pos.x - size.width/2, x2 = pos.x + size.width/2,
					   y1 = pos.y - size.height/2, y2 = pos.y + size.height/2 };
		]]--
		local x1 = pos.x - size.width/2;
		local x2 = pos.x + size.width/2;
		local y1 = pos.y - size.height/2;
		local y2 = pos.y + size.height/2;
		local verts = {
			cc.p(x1, y1),
			cc.p(x2, y1),
			cc.p(x2, y2),
			cc.p(x1, y2),
			cc.p(x1, y1),
		};
		local sprite = util.draw_line(layer, verts, cc.c4f(1, 0, 0, 1), 20, 10, 1, ZORDER_CARD-10);
		sprite:setTag(TAG_HIGHLIGHT);

	end
end

-- e.g index = 1101
function hl_at_target(index, flag) -- {
	g_src_index = index;

	local self = layer_card;
	
	local attack_target_indexs = list_attack_target(g_src_index, g_logic_table, g_current_side);

	-- order is important!  change_step must before layer_action:close(...)
	-- this two should do before remove action 
	-- because whether to reset g_src_index to 0 is base on the step
	change_step(STEP_TARGET);
	g_action_type = TYPE_ATTACK;

	remove_hl();
	if 'action' == flag then
		layer_action:close( { create_btn_cancel } );  
	end

	-- highlight the selectable targets
	for i = 1, #attack_target_indexs do
		local card_index = attack_target_indexs[i];
		hl_card(card_index, HL_TARGET);
	end
end -- hl_at_target end }

function hl_ab_target(index, flag) -- { start
	g_src_index = index;

	local self = layer_card;
	
	-- check for cast, execute ability directly
	local num;
	local err;
	num, err = total_target(g_src_index, g_logic_table, g_current_side)
	if nil ~= err then
		g_scene:add_layer(ZORDER_LAYER_MSG, layer_msg:create(err));
		return;
	end
	--print('DEBUG hl_ab_target num: ', num);
	if nil == num then
		kerror("callback_ability[%s]", err);
		return;
	end
	local is_special = false;
	local cid = (index_card(g_src_index, g_logic_table)).id;
	if 53 == cid then
		local list = list_ability_target(g_src_index, g_logic_table, g_current_side, {}, 1);
		if #(list or {}) > 0 then
			if nil == layer_action.layer then
				create_btn_cancel();
			end
			is_special = true;
		end
	end
	if true == is_special then
	elseif 'action' == flag then
		--print('--------------id, num: ', g_src_index, num);
		if 0 == num then
			local cmd = 'b ' .. g_src_index;
			play_game_cmd(cmd, index);
			return true;
		end
		local just_myself = is_target_just_myself(g_src_index, g_logic_table, g_current_side);
		if true == just_myself then
			local cmd = string.format("b %d %d", g_src_index, g_src_index);
			play_game_cmd(cmd, index);
			return true;
		end
		local attach_hero = is_target_attach_hero(g_src_index, g_logic_table, g_current_side);
		if nil ~= attach_hero then
			local cmd = string.format("b %d %d", g_src_index, attach_hero);
			play_game_cmd(cmd, index);
			return true;
		end
	end
	
	-- this is global
	self.ability_target_list = {};
	local ability_target_indexs = list_ability_target(g_src_index, g_logic_table, g_current_side, self.ability_target_list, #self.ability_target_list + 1);
	--print('DEBUG hl_ab_target #ab_list: ', #ability_target_indexs);
	
	-- this two should do before remove action 
	-- because whether to reset g_src_index to 0 is base on the step
	change_step(STEP_TARGET);
	g_action_type = TYPE_ABILITY;
	-- new
	remove_hl();

	-- TODO consider 'move' case
	if 'action' == flag then
		local callback_list = { };
		if 1 > #(self.ability_target_list or {}) then
			table.insert(callback_list, create_btn_cancel);
		else
			table.insert(callback_list, create_btn_confirm);
		end
		local is_grave = false;
		for i = 1, #ability_target_indexs do
			local card_index = ability_target_indexs[i];
			local card_table_index = index_table_num(card_index);
			if card_table_index == T_GRAVE then
				is_grave = true;
				break;
			end
		end
		if true == is_grave then
			table.insert(callback_list, callback_open_grave);
			layer_action:close( callback_list );  
			return;
		end
		layer_action:close( callback_list );  
		--[[
		-- special case for Master Smith(158)
		-- Target weapon or armor in your graveyard is retruned to your hand.
		local card = index_card(g_src_index, g_logic_table);
		local src_side = index_side(g_src_index);
		-- TODO src_side == src_side ??
		if nil ~= card and 158 == card.id and src_side == src_side then
			table.insert(callback_list) = show_select_grave;
			--callback_list[#callback_list + 1] = show_select_grave;
		end
		--
		layer_action:close( callback_list );  
		]]--
	end

	for i = 1, #ability_target_indexs do
		--print(string.format("DEBUG ab selectable target [%d][%s]", i, ability_target_indexs[i]));
		local card_index = ability_target_indexs[i];
		hl_card(card_index,  HL_TARGET);
	end

	if true == is_special then
		if 53 == cid then
			local tt = index_table_num(g_src_index);
			if tt == T_HAND then
				self:reset_touch_data();
				show_msg("请选择上场技能的目标");
			end
		end
	end

end -- hl_ab_target end }

function get_both_target_list(self, src_index, is_just_t_b)
	local attack_target_indexs = list_attack_target(src_index, g_logic_table, g_current_side);

	self.ability_target_list = {};
	local ability_target_indexs = {};
	local num;
	local err;
	num, err = total_target(g_src_index, g_logic_table, g_current_side)
	if nil ~= num and num > 0 then
		ability_target_indexs = list_ability_target(g_src_index, g_logic_table, g_current_side, self.ability_target_list, #self.ability_target_list + 1);
	end
	if true == is_just_t_b then
		return attack_target_indexs, ability_target_indexs;
	end

	local lboth = {};
	local lat = {};
	local lab = {};
	for i = 1, #ability_target_indexs do
		local is_both = false;
		local index_ab = ability_target_indexs[i];
		for j = 1, #attack_target_indexs do
			local index_at = attack_target_indexs[j];
			if index_ab == index_at then
				table.insert(lboth, index_ab);
				table.remove(attack_target_indexs, j);
				is_both = true;
				break;
			end
		end
		if false == is_both then
			table.insert(lab, index_ab);
		end
	end
	lat = attack_target_indexs;

	return lat, lab, lboth;
end

function hl_both_target(index) -- {
	g_src_index = index;
	local self = layer_card;

	local lat, lab, lboth;
	lat, lab, lboth = get_both_target_list(self, g_src_index);

	change_step(STEP_TARGET)
	g_action_type = TYPE_BOTH;
	remove_hl()
	create_btn_cancel();

	for i = 1, #lat do
		local index = lat[i];
		hl_card(index, HL_TARGET);
	end
	for i = 1, #lab do
		local index = lab[i];
		hl_card(index,  HL_TARGET);
	end
	for i = 1, #lboth do
		local index = lboth[i];
		hl_card(index,  HL_TBOTH);
	end
end -- hl_both_target end }

function callback_attack(...) -- {
	play_tap_1();
	local arg = {...};
	-- second arg is the CCMenuItem (pressed button)
	local index = arg[2]:getTag(); 

	hl_at_target(index, 'action');

	util.trigger_tutor(TUTOR_HL_ATTARGET);
end -- callback_attack }

function callback_ability(...)  -- start {
	play_tap_1();
	local arg = {...};
	-- second arg is the CCMenuItem (pressed button)
	local index = arg[2]:getTag();   
	---print('DEBUG callback_ability');
	hl_ab_target(index, 'action');
end -- callback_ability end }

--function show_select_grave(select_side)
function open_grave(select_side)
	select_side = select_side or 0;
	if nil == g_src_index then
		--print('ERROR show_select_grave g_src_index is nil');
		if 0 ~= select_side then
			local list = g_ui_table[select_side][T_GRAVE];
			if 0 == #list then
				return;
			end
			g_scene:add_layer(ZORDER_LAYER_GRAVE, layer_grave:create(list));
		end
		return;
	end
	local src_side = index_side(g_src_index);
	if 0 ~= select_side and src_side ~= select_side then
		local list = g_ui_table[select_side][T_GRAVE];
		if 0 == #list then
			return;
		end
		g_scene:add_layer(ZORDER_LAYER_GRAVE, layer_grave:create(list));
		return;
	end
	local num;
	local err;
	num, err = total_target(g_src_index, g_logic_table, g_current_side)
	local ability_target_indexs = list_ability_target(g_src_index, g_logic_table, g_current_side, layer_card.ability_target_list, #layer_card.ability_target_list + 1);
	local is_grave = false;
	local grave_side = 0;
	for i = 1, #ability_target_indexs do
		local card_index = ability_target_indexs[i];
		local card_table_index = index_table_num(card_index);
		if card_table_index == T_GRAVE then
			grave_side = index_side(card_index);
			is_grave = true;
			break;
		end
	end
	if true == is_grave then
		local list = g_ui_table[grave_side][T_GRAVE];
		if 0 == #list then
			return;
		end
		g_scene:add_layer(ZORDER_LAYER_GRAVE, layer_grave:create(list));
		return;
	end
	if 0 ~= select_side then
		local list = g_ui_table[select_side][T_GRAVE];
		if 0 == #list then
			return;
		end
		g_scene:add_layer(ZORDER_LAYER_GRAVE, layer_grave:create(list));
		return;
	end
end

function callback_open_grave()
	open_grave();
end

function do_action_t(self, src_index, target_index)
	local cmd = 't ' .. src_index .. ' ' .. target_index;
	play_game_cmd(cmd, target_index);
	return;
end

function do_action_b(self, src_index, target_index)
	if target_index <= 0 then
		kerror("action_target target_index[%d]", target_index);
		refresh_layer_card();
		return;
	end
	
	self.ability_target_list[#self.ability_target_list + 1] = target_index;
	
	local ability_target_indexs = list_ability_target(src_index, g_logic_table, g_current_side, self.ability_target_list, #self.ability_target_list + 1);

	if 0 == #(ability_target_indexs or {}) then
		self:clean_menu();

		local cmd = 'b ' .. src_index ;
		for i=1, #self.ability_target_list do
			cmd = cmd .. ' ' .. self.ability_target_list[i];
		end
		play_game_cmd(cmd, target_index);

		-- for tutor check has more target
		-- see in cft_5_tap_hl_target()
		g_src_index = 0;
		--
		return;

	end

	-- implicit:  the ability is not yet played, 
	--            let user select more target(s)
	-- if optional target is there, create a done button, 
	--             together with cancel button

	-- is for drag move e.g card 74
	create_btn_cancel();
	
	-- show button done, check optional
	local src_card = index_card(src_index, g_logic_table);
	if src_card ~= nil and src_card.target_list ~= nil 
		and #(src_card.target_list) > #self.ability_target_list then

		local target = src_card.target_list[#self.ability_target_list + 1];
		
		if true == target.optional then
			create_btn_confirm();
		end
	end
	

	-- note: do not use eff_list ~= nil to check whether a play() is done
	layer_action:close( {  } );  
	remove_hl();
	for i = 1, #ability_target_indexs do
		local card_index = ability_target_indexs[i];
		hl_card(card_index, HL_TARGET);
	end
	local num, err = total_target(src_index, g_logic_table, g_current_side);
	if num > 1 then
		local choose_num = #(self.ability_target_list or {});
		show_msg(string.format("还可以选择%d个目标", num-choose_num));
	end
end

function do_action_pick(self, src_index, target_index)
	local cinfo = get_ui_card(target_index);
	if nil == cinfo then
		return false;
	end
	local layer = layer_action:create(cinfo);
	g_scene:add_layer(ZORDER_LAYER_ACTION, layer);
	return true;
end

-- is_action == true means to do realy t or b action but not show the choice
function handle_action_both_target(self, src_index, target_index, is_action)
	local lat, lab, lboth;
	if true == is_action then
		lat, lab = get_both_target_list(self, src_index, true);
		lboth = {};
	else
		lat, lab, lboth = get_both_target_list(self, src_index);
	end

	for i = 1, #lat do
		local index = lat[i];
		if index == target_index then
			do_action_t(self, src_index, target_index);
			return true;
		end
	end
	for i = 1, #lab do
		local index = lab[i];
		if index == target_index then
			do_action_b(self, src_index, target_index);
			return true;
		end
	end
	for i = 1, #lboth do
		local index = lboth[i];
		if index == target_index then
			return do_action_pick(self, src_index, target_index);
		end
	end
	return false;
end

-- drag -> touch_end -> action_target ->
-- if is TYPE_BOTH -> handle_action_both_target ->
-- lat -> do_action_t / lab -> do_action_b / lboth -> do_action_pick
-- do_action_pick -> show 'attack target' and 'ability target'
-- set these two's callback method to callback_target_both
-- and set is_action = true for action_target to avoid 
-- dead loop that go into action_target again
function action_target(self, action_type, src_index, target_index, is_action)
	if action_type == TYPE_BOTH then
		return handle_action_both_target(self, src_index, target_index,is_action);
	
	elseif action_type == TYPE_ATTACK then
		do_action_t(self, src_index, target_index);
		return true;
		
	elseif action_type == TYPE_ABILITY then
		do_action_b(self, src_index, target_index);

		-- here return true , is for drag card action
		-- tell caller that should scale back the src_card and target card
		return true;
	end
	
	kerror("action_target is not legal action_type[%d]", action_type);
	return false;
end

function callback_target(...) -- {
	play_tap_1();
	local self = layer_card;
	local arg = {...};
	local target_card_index = arg[2]:getTag();
	action_target(self, g_action_type, g_src_index, target_card_index);
end -- callback_target }

function callback_target_b(...)
	local self = layer_card;
	local arg = {...};
	local target_card_index = arg[2]:getTag();
	action_target(self, TYPE_ABILITY,g_src_index,target_card_index,true);
end

-- use callback_target_t, callback_target_t directly
function callback_target_both(...) -- {
	local self = layer_card;
	local arg = {...};
	local target_card_index = arg[2]:getTag();
	action_target(self, g_action_type,g_src_index,target_card_index,true);
end -- callback_target }

function callback_target_t(...)
	local self = layer_card;
	local arg = {...};
	local target_card_index = arg[2]:getTag();
	action_target(self, TYPE_ATTACK,g_src_index,target_card_index,true);
end

function action_sac(index)
	local cmd = 's ' .. index;
	play_game_cmd(cmd, index);
end

function callback_sac(...) -- {
	play_tap_1();
	local index = nil;
	local arg = {...};
	index = arg[2]:getTag();   -- second arg is the CCMenuItem (pressed button)
	-- layer : CCMenu : CCMenuItem
	local self = arg[2]:getParent(); -- cc.Layer or CCMenu?  not layer_action
	action_sac(index);
	return;
end -- callback_sac }

function remove_child_by_tag(layer, tag)
	if nil == layer then
		return;
	end
	local sprite = layer:getChildByTag(tag);
	while nil ~= sprite do
		layer:removeChildByTag(tag, true);
		sprite = layer:getChildByTag(tag);
	end
end

function remove_hl()
	for i = 1, #g_all_card_list do
		local card_lists = g_all_card_list[i];
		for j = 1, #card_lists do
			local card_info = card_lists[j];
			if nil ~= g_sprite_cache[card_info.card] then
				local card_sprite = card_info.sprite;
				remove_child_by_tag(card_sprite, TAG_HIGHLIGHT);
			end
		end
	end
	remove_child_by_tag(layer_card.layer, TAG_HIGHLIGHT);
end

function ctype_to_str(ctype, is_bow)
	if ABILITY == ctype then
		return '技能';
	elseif SUPPORT == ctype then
		return '支援';
	elseif WEAPON == ctype then
		if is_bow == true then
			return '武器/弓';
		end
		return '武器';
	elseif ARMOR == ctype then
		return '防具';
	elseif ATTACH == ctype then
		return '附加';
	elseif ALLY == ctype then
		return '盟军';
	elseif HERO == ctype then
		return '英雄';
	elseif ARTIFACT == ctype then
		return '神器';
	elseif TRAP == ctype then
		return '陷阱';
	else
		return '未知';
	end
end

function job_name(job_id)
	job_id = tonumber(job_id) or 0;
	local name = '';
	if 0 == job_id then
		return name;
	end
	local max = 512;
	name = name .. '[';

	local first = true;
	for i=1, 10 do
		if job_id >= max then
			local job_str = job_map[max] or ('_' .. max .. '_');
			if first then
				name = name .. job_str;
				first = false;
			else
				name = name .. ' ' .. job_str;
			end
			job_id = job_id - max;
		end
		max = max / 2;
	end
	name = name .. ']';
	return name;
end

function disable_touch()
	--layer_loading:add_anim_loading();
	g_touchable = g_touchable + 1;
	--print('g_touchable + 1 : ', g_touchable);
end

function force_enable_touch()
	g_touchable = 0;
end

function enable_touch()
	--layer_loading:remove_anim_loading();
	if 0 == g_touchable then
		return;
	end
	g_touchable = g_touchable - 1;
	--print('g_touchable - 1 : ', g_touchable);
end

function is_touchable()
	if 0 == g_touchable then
		return true;
	end
	return false;
end

function reset_touchable()
	g_touchable = 0;
end

function get_card_scale(width, height, size)
	local cwidth = size.width;
	local cheight = size.height;
	local swidth = width / cwidth;
	local sheight = height / cheight;
	local scale;
	if swidth < sheight then
		scale = swidth;
	else
		scale = sheight;
	end
	return scale;
end

-- change game step
function change_step(step)
	g_step = step;
end

-- judge current step is this or not
function is_step(step)
	if g_step == step then
		return true;
	else
		return false;
	end
end

function is_target_just_myself(index, logic_table, current_side)
	if nil == index then
		return false;
	end
	local ab_list = {};
	local tindexs = list_ability_target(index, logic_table, current_side, ab_list, #ab_list + 1);
	if 1 == #(tindexs or {}) then
		local t = tindexs[1];
		if t == index then
			return true;
		end
	end
	return false;
end

function is_target_attach_hero(index, logic_table, current_side)
	if nil == index then
		return nil;
	end
	local src_card = index_card(index, logic_table);	
	if ATTACH ~= src_card.ctype then
		return nil;
	end
	local ab_list = {};
	local tindexs = list_ability_target(index, logic_table, current_side, ab_list, #ab_list + 1);
	if 1 ~= #(tindexs or {}) then
		return nil;
	end
	local tindex = tindexs[1];
	local tar_card = index_card(tindex, logic_table);	
	if HERO ~= tar_card.ctype then
		return nil;
	end
	return tindex;
end

function create_btn_confirm()
	local self = layer_card;
	if nil == self.layer then
		return;
	end
	self:change_btn(self.btn_confirm);
end

function create_btn_cancel()
	local self = layer_card;
	if nil == self.layer then
		return;
	end
	self:change_btn(self.btn_cancel);
end

function pop_turn(myside, current_side)
	local layer = layer_touch.layer;
	local path = util.get_path('pop_up.png');
	local frect = cc.rect(0, 0, 64, 64); -- fullrect
	local irect = cc.rect(30, 30, 4, 4); -- insetrect
	local size = cc.size(wfix(305), hfix(116));--realsize
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local sprite = util.add_scale9sprite(layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, size, 10); 
	local str;
	if myside == current_side then
		str = '我方回合';
	else
		str = '敌方回合';
	end
	util.add_labeloutline(sprite, str, nil, 30, cc.p(size.width/2, size.height/2), util.c4b_black, util.c4b_white, 2, ANCHOR_CENTER_CENTER, 10, cc.size(size.width-40, size.height-30), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);

	local animation = {};
	local action;
	action = cc.FadeTo:create(1, 200);
	table.insert(animation, action);
	action = cc.CallFunc:create(callback_remove_sprite);
	table.insert(animation, action);

	action = cc.Sequence:create(animation);

	sprite:runAction(action);
end

function pop_gate_count(tip)
	local layer = layer_touch.layer;
	local path = util.get_path('pop_up.png');
	local frect = cc.rect(0, 0, 64, 64); -- fullrect
	local irect = cc.rect(30, 30, 4, 4); -- insetrect
	local size = cc.size(wfix(350), hfix(116));--realsize
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT/2*3);
	local sprite = util.add_scale9sprite(layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, size, 10); 
	--util.add_labeloutline(sprite, tip, nil, 22, cc.p(size.width/2, size.height/2), util.c4b_black, util.c4b_white, 2, ANCHOR_CENTER_CENTER, 10, cc.size(size.width-40, size.height-30), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
	util.add_labelttf(sprite, tip, nil, 22, cc.p(size.width/2, size.height/2), util.c4b_white, ANCHOR_CENTER_CENTER, 10, cc.size(size.width-40, size.height-30), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);

	local animation = {};
	local action;
	action = cc.FadeTo:create(1.5, 200);
	table.insert(animation, action);
	action = cc.CallFunc:create(callback_remove_sprite);
	table.insert(animation, action);

	action = cc.Sequence:create(animation);

	sprite:runAction(action);
end

function pop_phase(phase)
	if true == g_is_in_tutor then
		return;
	end
	local layer = layer_touch.layer;
	local path = util.get_path('pop_up.png');
	local frect = cc.rect(0, 0, 64, 64); -- fullrect
	local irect = cc.rect(30, 30, 4, 4); -- insetrect
	local size = cc.size(wfix(305), hfix(116));--realsize
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT-hfix(140));
	local sprite = util.add_scale9sprite(layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, size, 10); 
	local str;
	if phase == PHASE_SACRIFICE then
		str = '弃牌阶段';
	else
		str = '出牌阶段';
	end
	util.add_labeloutline(sprite, str, nil, 30, cc.p(size.width/2, size.height/2), util.c4b_black, util.c4b_white, 2, ANCHOR_CENTER_CENTER, 10, cc.size(size.width-40, size.height-30), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);

	local animation = {};
	local action;
	action = cc.FadeTo:create(2, 200);
	table.insert(animation, action);
	action = cc.CallFunc:create(callback_remove_sprite);
	table.insert(animation, action);

	action = cc.Sequence:create(animation);

	sprite:runAction(action);
end

function clone_card_by_id(card_id)
	local card = nil;
	if 1 > card_id then
		return card;
	end
	local rc = g_card_list[card_id];
	if nil == rc then
		rc = hero_list[card_id];
	end
	if nil ~= rc then
		-- in layer_deck 
		-- when using g_euser.deck_array
		-- will clone the cards again in order to avoid mixup the card
		card = clone(rc);	
	end
	return card;
end

-- drop down
function eff_layer_1(layer, callback)
	-- TODO need disable and enable touch 
	local x, y, opos, npos;
	local action, array;
	x = layer:getPositionX();
	y = layer:getPositionY();
	opos = cc.p(x, y);
	npos = cc.p(x, y + HALF_HEIGHT/3);
	layer:setPosition(npos);

	array = {};
	npos = cc.p(x, y - hfix(10));
	action = cc.MoveTo:create(0.3, npos);
	action = cc.EaseOut:create(action, 0.3);
	table.insert(array, action);
	action = cc.JumpTo:create(0.3, opos, hfix(10), 1);
	table.insert(array, action);
	if nil ~= callback then
		action = cc.CallFunc:create(callback);
		table.insert(array, action);
	end
	action = cc.Sequence:create(array);
	layer:runAction(action);
end

-- pull up
function eff_layer_2(layer, callback)
	-- TODO need disable and enable touch 
	local x, y, opos, npos;
	local action, array;
	x = layer:getPositionX();
	y = layer:getPositionY();
	opos = cc.p(x, y);
	npos = cc.p(x, y + HALF_HEIGHT/3);

	array = {};
	action = cc.JumpTo:create(0.3, opos, hfix(-10), 1);
	table.insert(array, action);
	action = cc.MoveTo:create(0.3, npos);
	action = cc.EaseOut:create(action, 0.3);
	table.insert(array, action);
	if nil ~= callback then
		action = cc.CallFunc:create(callback);
		table.insert(array, action);
	end
	action = cc.Sequence:create(array);
	layer:runAction(action);
end

function suit_scale_big_frame(layer, ltype, callback_return)
	local sprite, fullpath, pos, data, table_view_gapy;
	local data = gui_get_data('bg', ltype, ANCHOR_CENTER);
	pos = cc.p(0, 0);
	fullpath = util.get_fullpath(F_IMAGE, data.fname1);
	local fullrect = cc.rect(0, 0, 617, 873);
	local insetrect = cc.rect(300, 600, 17, 20);
	size = cc.size(FULL_WIDTH, data.y + data.height);
	sprite = util.add_scale9sprite(layer, fullpath, pos, ANCHOR_LEFT_DOWN, fullrect, insetrect, size, data.zorder); 
	table_view_gapy = size.height - data.height;

	local data2;
	sprite, data2 = gui_add_sprite(layer, 'right_up', ltype,ANCHOR_CENTER);
	local gapx, gapy;
	gapx = data.x + data.width - data2.x;
	gapy = data.y + data.height - data2.y;
	sprite:setPosition(cc.p(pos.x+size.width-gapx, pos.y+size.height-gapy));

	local items = {};
	local item;

	item, data2 = gui_add_item(items, 'return', ltype, callback_return, ANCHOR_CENTER);
	gapx = data.x + data.width - data2.x;
	gapy = data.y + data.height - data2.y;
	item:setPosition(ccp(pos.x+size.width-gapx, pos.y+size.height-gapy));

	util.add_menu(layer, items, data2.zorder);

	return table_view_gapy;
end

function add_big_frame_title(layer, title, ltype, anchorpoint)
	local data = gui_get_data('title', ltype, anchorpoint);
	local pos = cc.p(data.x, data.y);
	local size = cc.size(data.width, data.height);
	util.add_labeloutline(layer, title, nil, 30, pos, util.c4b_white, util.c4b_black, 2, ANCHOR_LEFT_DOWN, data.zorder, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_TOP);
end

function move_tvh(sprite, tvh)
	if nil == sprite then return; end
	local y = sprite:getPositionY();
	sprite:setPositionY(y + tvh);
end

function get_signature(signature)
	if nil == signature or '_no_signature' == signature then
		return '';
	end
	return signature;
end

function use_frames(filename, folder)
	if true == USE_FRAME then
		folder = folder or F_IMAGE;
		local fullpath = util.get_fullpath(folder, filename);
		util.add_frames(fullpath);
	end
end

function exit_game()
	--[[
	if is_ver(VER_UCSDK) then
		UCSdkHandler:destroyFloatButton();
		UCSdkHandler:exitSDK();
		return;
	end
	]]--
	if true ~= v_anysdk_init_flag and (is_ver(VER_ANYSDK) or is_ver(VER_ANYSDK_NO_LOGIN)) then
		local agent = AgentManager:getInstance();
		-- both below is ok
		if nil ~= agent.unloadAllPlugins then
			agent:unloadAllPlugins();
		elseif nil ~= agent.unloadALLPlugin then
			agent:unloadALLPlugin();
		else
			AgentManager:endManager();
		end
	end
	local platform = cc.Application:getInstance():getTargetPlatform();
	if platform == cc.PLATFORM_OS_ANDROID then
		local luaj = require "luaj";
		local class_name;
		if true ~= is_ver(VER_ANYSDK)
		or 930 ~= tonumber(AgentManager:getInstance():getChannelId() or "0") then
			class_name = "org/cocos2dx/lua/AppActivity";
		else
			class_name = "com/evil/ec_anysdk/xmw/AppActivity";
		end
		local ok, ret = luaj.callStaticMethod(class_name, "exitGame", {}, "()V");
		--[[
		if ok then
		end
		]]--
	end
end

function logout()
	-- reset private setting
	layer_chapter.last_chapter_id = nil;
	g_euser.all_str = nil;
	g_list_piece = {};

	g_scene:close_connect();
	g_scene:login();
	if is_ver(VER_ANYSDK) then
		local agent = AgentManager:getInstance();
		local user_plugin = agent:getUserPlugin();
		if user_plugin ~= nil then
			if user_plugin:isFunctionSupported("logout") then
				user_plugin:callFuncWithParam("logout");
			end
		end
	end
	if is_ver(VER_UCSDK) then
		UCSdkHandler:logout();
	end
	if is_ver(VER_LJSDK) then
		if nil ~= layer_net.layer then
--			LJSdkImpl:setUserListener(layer_net.layer);
			LJSdkImpl:logout("logout");
		end
	end
end

function get_hour_offset(t1, t2)
	local t_offset = math.floor(math.abs(t2 - t1) / 60 / 60);
	return t_offset;
end

function get_guild_title(gpos)
	if gpos == GUILD_POS_MASTER then
		-- '会长';
		return '会长';
	elseif gpos == GUILD_POS_SENIOR then
		-- '副会长';
		return '副会长';
	elseif gpos == GUILD_POS_MEMBER then
		-- '会员';
		return '会员';
	elseif gpos == GUILD_POS_APPLY then
		-- '申请者';
		return '申请者';
	end
	return '';
end

function get_guild_title_path(gpos)
	local fname = nil;
	if gpos == GUILD_POS_MASTER then
		-- '会长';
		fname = 'text_3.png';
	elseif gpos == GUILD_POS_SENIOR then
		-- '副会长';
		fname = 'text_33.png';
	elseif gpos == GUILD_POS_MEMBER then
		-- '会员';
		fname = 'text_4.png';
	elseif gpos == GUILD_POS_APPLY then
		-- '申请者';
		fname = 'text_32.png';
	end
	if nil == fname then
		return nil;
	end
	local path = util.get_fullpath(F_IMAGE, fname);
	return path;
end

function get_match_status(status)
	if 0 == status then
		return '接受申请';
	elseif 1 == status then
		return '回合开始';
	elseif 2 == status then
		return '回合结束';
	elseif 3 == status then
		return '比赛结束';
	elseif 9 == status then
		return '比赛不存在';
	end
	local s = '未知比赛状态 ' .. status;
	return s;
end

function update_attachment_timer(sprite, card)
	if nil == sprite or nil == card.vtype or 0 == card.vtype then
		return;
	end
	local timer = card.timer or 0;
	local label = sprite:getChildByTag(TAG_SPRITE_TIMER);
	if nil ~= label and 0 == timer then
		label:removeFromParentAndCleanup(true);
		return;
	end
	if nil == label then
		if timer < 2 then
			return;
		end
		local path = util.get_path(FNT_CARD);
		--[[
		local size = sprite:getContentSize();
		--local pos = cc.p(size.width/2, size.height/2);
		--local ap = ANCHOR_CENTER_CENTER;
		local csize = CARD_SIZE_2;
		local ap = ANCHOR_RIGHT_UP;
		local pos = cc.p((size.width+csize.width)/2,(size.height+csize.height)/2);
		]]--
		local pos = cc.p(0, 0);
		local ap = ANCHOR_CENTER_CENTER;
		label = util.add_labelbmf(sprite, timer, path, pos, ap, 5);
		label:setTag(TAG_SPRITE_TIMER);
	else
		local otimer = label:getString();
		if tonumber(otimer) ~= timer then
			label:setString(timer);
			--print('------------------- set timer');
		end
	end
	return label;
end

function create_virtual_particle(parent, vtype)
	vtype = vtype or 0;
	local pname = nil;
	if 1 == vtype then
		pname = 'v_ablaze_1';
	elseif 4 == vtype then
		pname = 'v_poison_1';
	else
		return;
	end
	local filename = pname .. '.plist';
	local fullpath = util.get_fullpath(F_PARTICLE, filename);   
	local size = parent:getContentSize();
	local pos = cc.p(size.width/2, 20);
	local info  = util.add_particle(parent, fullpath, pos);
	info.batch:setTag(TAG_VIRTUAL_PARTICLE);
	local emitter = info.emitter;
	local p1 = emitter:getPosVar();
	local p2 = cc.p(size.width/4, p1.y);
	emitter:setPosVar(p2);
end

function refresh_card_status(sprite, card, width, height)
	local ci = cindex(card);
	if index_table_num(ci) == T_ALLY then
		--print(' card status ready: ', card.name, card.ready);
		-- read 0 not ready, 
		local ready = card.ready;
		local s = sprite:getChildByTag(TAG_SPRITE_SLEEP);
		if 0 == ready then
			if nil == s then
				s = util.play_frame(sprite, 's_sleep', cc.p(width, height), ANCHOR_RIGHT_UP, 0.3, 30, true);
				s:setTag(TAG_SPRITE_SLEEP);
			end
		else
			if nil ~= s then
				s:removeFromParentAndCleanup(true);
			end
		end
	end
end

function check_hl_in_list(list)
	local info = nil;
	for i = 1, #list do
		local ccc = list[i];
		local s = ccc:get_sprite();
		local h = s:getChildByTag(TAG_HIGHLIGHT);
		if nil ~= h then
			info = ccc;
			break;
		end
	end
	return info;
end

function is_show_tip_btn()
	--[[
	if g_euser.level <= 5 then
		return true;
	end
	return false;
	]]--
	return true;
end

function set_value_for_g_tutor(value)
	g_tutor = tonumber(value) or 0;
	if true == USE_TIP_TUTOR and 0 == g_tutor then
		g_tutor = util.bit_not(0);
	end
end

function pop_invite_fight(eid)
	local cmd = string.format("challenge 0 %d", eid);
	net_send(cmd);
	local s = '等待对方回应';
	g_scene:add_layer(ZORDER_LAYER_FIGHT,layer_fight:create(s, layer_fight.TIP_TYPE_INVITE_FIGHT, {eid=eid}));
end

function pop_answer_fight(eid, alias)
	local s = alias .. '向你挑战';
	g_scene:add_layer(ZORDER_LAYER_FIGHT,layer_fight:create(s, layer_fight.TIP_TYPE_ANSWER_FIGHT, {eid=eid, alias=alias}));
end

function is_wait_for_battle()
	if nil ~= layer_quick.layer then
		return 1;
	end
	if nil ~= layer_room.layer then
		return 2;
	end
	return 0;
end

function show_quick()
	local layer, name = layer_quick:create();
	g_scene:add_layer(ZORDER_LAYER_QUICK, layer, name, true);
	local cmd = "quick";
	net_send(cmd);
end

function show_mission_list()
	--[[
	local btn_mission = layer_chat.btn_mission;
	if nil ~= btn_mission
	and nil ~= btn_mission:getChildByTag(TAG_MISSION_FINGER) then
		btn_mission:removeChildByTag(TAG_MISSION_FINGER, true);
		--print("remove btn_mission_finger");
	end
	]]--
	--print("show mission list");
	local function callback()
		--net_send('mlist 0', true);
		local cmd = string.format("mlist %d %d", MLIST_WITHOUT_CHAPTER, 0);
		net_send(cmd, true);
	end
	local layer, name = layer_mission:create();
	g_scene:add_layer(ZORDER_LAYER_MISSION, layer, name, true, callback);
end

function show_daily_list()
	local function callback()
		net_send('daily_log', true);
	end
	local layer, name = layer_daily:create();
	g_scene:add_layer(ZORDER_LAYER_DAILY, layer, name, true, callback);
end

function show_notice()
	local function callback()
		net_send('notice 0', true);
	end
	local layer, name = layer_notice:create();
	g_scene:add_layer(ZORDER_LAYER_NOTICE, layer, name, true, callback);
end

function show_mail()
	local function callback()
		local cmd = string.format("list_message 0 %d", layer_mail.PAGE_SIZE);
		net_send(cmd, true);
	end
	local layer, name = layer_mail:create();
	g_scene:add_layer(ZORDER_LAYER_MAIL, layer, name, true, callback);
end

function show_match()
	local layer, name = layer_lmatch:create();
	g_scene:add_layer(ZORDER_LAYER_LMATCH, layer, name, true);
	net_send('lmatch', true);
end

function show_pclg()
	--g_scene:go(GUI_PCLG, "pclg");
	g_scene:pclg();
end

function add_toggle_1(items, callback, anchorpoint, pos, size)
	local path1 = util.get_path('btn_131.png');
	local path2 = util.get_path('btn_131_s.png');
	local unsprite = util.create_sprite(path1);
	local sprite = util.create_sprite(path2);
	local item = util.create_toggle_sprite(unsprite,sprite,pos,anchorpoint,callback);
	table.insert(items, item);
	return item;
end


function add_title_1(layer, data, title)
	local fsize = 30;
	local color = cc.c4b(data.r, data.g, data.b, 255);
	local scolor = cc.c4b(data.sr, data.sg, data.sb, 255);
	local pos = cc.p(data.width/2, data.height/3*2);
	local label = util.add_labeloutline(layer, title, nil, fsize, pos, color, scolor, 2, ANCHOR_CENTER_CENTER, 10);
	return label;
end

function add_item_back_1(layer, ltype, callback)
	if nil == layer then return; end
	gui_add_sprite(layer, 'bg_back', ltype, ANCHOR_UP);
	local items = {};
	local item, data = gui_add_item(items, 'btn_back', ltype, callback,ANCHOR_UP);
	util.add_menu(layer, items, data.zorder);
	return item;
end

function add_editbox_1(layer, pos, size, tip, zorder, handler, fsize)
	local fullrect = cc.rect(0, 0, 49, 49);
	local insetrect = cc.rect(22, 22, 5, 5);
	local s = cc.size(size.width, size.height);
	local p = cc.p(pos.x, pos.y);
	local path = util.get_path('bg_213.png');
	local sprite = util.add_scale9sprite(layer, path, p, ANCHOR_LEFT_DOWN, fullrect, insetrect, s, zorder); 

	s = cc.size(s.width-20, size.height);
	p = cc.p(p.x+10, pos.y);
	local editbox = util.add_editbox_blank(layer, s, ANCHOR_LEFT_DOWN, 
		p, util.f_default, (fsize or 22), cc.c3b(255, 255, 255), 
		cc.EDITBOX_INPUT_MODE_SINGLELINE, cc.KEYBOARD_RETURNTYPE_DONE, 
		nil, handler, 10, tip, cc.c3b(255, 255, 255), zorder+2); 
	return editbox;
end

function add_editbox_2(layer, pos, size, tip, zorder, handler, fsize)
	local fullrect = cc.rect(0, 0, 63, 63);
	local insetrect = cc.rect(30, 30, 3, 3);
	local s = cc.size(size.width, size.height);
	local p = cc.p(pos.x, pos.y);
	local path = util.get_path('bg_197.png');
	local sprite = util.add_scale9sprite(layer, path, p, ANCHOR_LEFT_DOWN, fullrect, insetrect, s, zorder); 

	s = cc.size(s.width-20, size.height);
	p = cc.p(p.x+10, pos.y);
	local editbox = util.add_editbox_blank(layer, s, ANCHOR_LEFT_DOWN, 
		p, util.f_default, (fsize or 22), cc.c3b(231, 247, 253), 
		cc.EDITBOX_INPUT_MODE_SINGLELINE, cc.KEYBOARD_RETURNTYPE_DONE, 
		nil, handler, 10, tip, cc.c3b(231, 247, 253), zorder+2); 
	return editbox;
end

function init_bar_info_for_full_view(layer, cb_back, ltype)
	gui_add_sprite(layer, 'bg_infobar', ltype, ANCHOR_UP);
	gui_add_sprite(layer, 'frame_gold', ltype, ANCHOR_UP);
	gui_add_sprite(layer, 'frame_crystal', ltype, ANCHOR_UP);
	gui_add_sprite(layer, 'icon_gold', ltype, ANCHOR_UP);
	gui_add_sprite(layer, 'icon_crystal', ltype, ANCHOR_UP);

	local str = g_euser.gold;
	gui_add_label(layer,str,18,'num_gold',ltype,ANCHOR_UP);

	str = g_euser.crystal;
	gui_add_label(layer,str,18,'num_crystal',ltype,ANCHOR_UP);

	gui_add_sprite(layer, 'bg_back', ltype, ANCHOR_UP);
	local items = {};
	local item, data = gui_add_item(items,'btn_back',ltype,cb_back,ANCHOR_UP);
	util.add_menu(layer, items, data.zorder);
end

function init_bg_for_full_view(layer, ltype, title)
	gui_add_sprite(layer, 'board', ltype);
	local sprite,data = gui_add_sprite(layer, 'bg', ltype);
	if data.width/data.rwidth > data.height/data.rheight then
		sprite:setScale(data.width/data.rwidth);
	else
		sprite:setScale(data.height/data.rheight);
	end
	gui_add_sprite(layer, 'bg_2', ltype);
	gui_add_sprite(layer, 'f_left_up', ltype, ANCHOR_UP);
	gui_add_sprite(layer, 'f_right_up', ltype, ANCHOR_UP);
	gui_add_sprite(layer, 'bg_title', ltype, ANCHOR_UP);
	gui_add_label_ali(layer, title, 28, 'title', ltype, ANCHOR_UP, cc.TEXT_ALIGNMENT_CENTER);
end

function init_bg_pop_no_scale(layer, ltype, title, cb_back, is_stroke_title)
	local sprite, data;
	sprite, data = gui_add_sprite(layer,'bg',ltype,ANCHOR_DOWN);
	sprite:setPositionY(HALF_HEIGHT);
	sprite:setAnchorPoint(ANCHOR_LEFT_CENTER);
	local rect = {
		x1 = data.x, x2 = data.x + data.width,
		y1 = data.y, y2 = data.y + data.height,
	};
	gui_add_sprite_on_cell(sprite, data, 'bg_title', ltype, ANCHOR_DOWN);
	if nil == title then
		gui_add_sprite_on_cell(sprite, data, 'title', ltype, ANCHOR_DOWN);
	elseif true == is_stroke_title then
		local l = gui_add_stroke_on_cell(sprite, data, title, 30, 'title', ltype, ANCHOR_DOWN);
		l:setAlignment(cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);
	else
		gui_add_label_ali_on_cell(sprite, data, title, 28, 'title', ltype, ANCHOR_DOWN, cc.TEXT_ALIGNMENT_CENTER);
	end
	local items = {};
	local item, item_data;
	item, item_data = gui_add_item_on_cell(items, data, 'btn_back', ltype, cb_back, ANCHOR_DOWN);
	util.add_menu(sprite, items, item_data.zorder);
	return sprite, data, rect;
end

function init_bg_pop(layer, ltype, title, cb_back, no_scale, is_stroke_title)
	if true == no_scale then
		return init_bg_pop_no_scale(layer, ltype, title, cb_back, is_stroke_title)
	end
	local d1 = gui_get_data('bg', ltype, ANCHOR_DOWN);
	local d2 = gui_get_data('bg', ltype, ANCHOR_UP);
	local offsetheight = d2.y-d1.y;
	local sprite, data;
	sprite, data = gui_add_sprite(layer,'bg',ltype,ANCHOR_DOWN,nil,offsetheight);
	local rect = {
		x1 = data.x, x2 = data.x + data.width,
		y1 = data.y, y2 = data.y + data.height,
	};
	gui_add_sprite(layer, 'bg_title', ltype, ANCHOR_UP);
	if nil == title then
		gui_add_sprite(layer, 'title', ltype, ANCHOR_UP);
	elseif true == is_stroke_title then
		local l = gui_add_stroke(layer, title, 30, 'title', ltype, ANCHOR_UP);
		l:setAlignment(cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);
	else
		gui_add_label_ali(layer, title, 28, 'title', ltype, ANCHOR_UP, cc.TEXT_ALIGNMENT_CENTER);
	end
	local items = {};
	local item;
	item, data = gui_add_item(items, 'btn_back', ltype, cb_back, ANCHOR_UP);
	util.add_menu(layer, items, data.zorder);
	return offsetheight, sprite, rect;
end

function init_bg_full(layer, ltype, cb_back, title)
	local sprite, data, d2, size, item;
	sprite, data = gui_add_sprite(layer, 'bg_wall', ltype, ANCHOR_DOWN);
	d2 = gui_get_data('bg_wall', ltype, ANCHOR_UP);
	sprite:setContentSize(cc.size(data.width, d2.y+d2.height-data.y));
	sprite, data = gui_add_sprite(layer, 'bg', ltype);
	if data.width/data.rwidth > data.height/data.rheight then
		sprite:setScale(data.width/data.rwidth);
	else
		sprite:setScale(data.height/data.rheight);
	end
	sprite, data = gui_add_sprite(layer, 'bg_frame', ltype, ANCHOR_DOWN);
	d2 = gui_get_data('bg_frame', ltype, ANCHOR_UP);
	local offsetheight = d2.y-data.y;
	size = sprite:getContentSize();
	size.height = d2.y+d2.height-data.y;
	sprite:setContentSize(size);
	gui_add_sprite(layer, 'bg_title', ltype, ANCHOR_UP);
	if nil == title then
		gui_add_sprite(layer, 'title', ltype, ANCHOR_UP);
	else
		gui_add_label_ali(layer, title, 28, 'title', ltype, ANCHOR_UP, cc.TEXT_ALIGNMENT_CENTER);
	end

	if nil == cb_back then return; end
	local items = {};
	item, data = gui_add_item(items, 'btn_back', ltype, cb_back, ANCHOR_UP);
	util.add_menu(layer, items, data.zorder);
	return offsetheight;
end

function init_prank_bg_full(layer, ltype, cb_back, title)
	local sprite, data, d2, size, item;
	sprite, data = gui_add_sprite(layer, 'bg_wall', ltype, ANCHOR_DOWN);
	d2 = gui_get_data('bg_wall', ltype, ANCHOR_UP);
	sprite:setContentSize(cc.size(data.width, d2.y+d2.height-data.y));
	sprite, data = gui_add_sprite(layer, 'bg', ltype);
	if data.width/data.rwidth > data.height/data.rheight then
		sprite:setScale(data.width/data.rwidth);
	else
		sprite:setScale(data.height/data.rheight);
	end
	gui_add_sprite(layer, 'leaf_left_up', ltype, ANCHOR_UP);
	gui_add_sprite(layer, 'leaf_right_down', ltype, ANCHOR_DOWN);
	sprite, data = gui_add_sprite(layer, 'bg_map', ltype, ANCHOR_DOWN);
	d2 = gui_get_data('bg_map', ltype, ANCHOR_UP);
	sprite:setScaleX((d2.x+d2.width-data.x)/data.rwidth);
	sprite:setScaleY((d2.y+d2.height-data.y)/data.rheight);

	local offsetheight = d2.y-data.y;
	size = sprite:getContentSize();
	size.height = d2.y+d2.height-data.y;
	sprite:setContentSize(size);
	gui_add_sprite(layer, 'bg_title', ltype, ANCHOR_UP);
	if nil == title then
		gui_add_sprite(layer, 'title', ltype, ANCHOR_UP);
	else
		gui_add_label_ali(layer, title, 28, 'title', ltype, ANCHOR_UP, cc.TEXT_ALIGNMENT_CENTER);
	end

	if nil == cb_back then return; end
	local items = {};
	item, data = gui_add_item(items, 'btn_back', ltype, cb_back, ANCHOR_UP);
	util.add_menu(layer, items, data.zorder);
	return offsetheight;
end


function init_bg_for_view(layer, ltype, title, cb_back)
	local d1 = gui_get_data('bg', ltype, ANCHOR_DOWN);
	local d2 = gui_get_data('bg', ltype, ANCHOR_UP);
	local offsetheight = d2.y-d1.y;
	local sprite, data;
	sprite, data = gui_add_sprite(layer,'bg',ltype,ANCHOR_DOWN,nil,offsetheight);
	local rect = {
		x1 = data.x, x2 = data.x + data.width,
		y1 = data.y, y2 = data.y + data.height,
	};
	gui_add_sprite(layer, 'bg_title', ltype, ANCHOR_UP);
	gui_add_label_ali(layer,title,30,'title',ltype, ANCHOR_UP, cc.TEXT_ALIGNMENT_CENTER);
	local items = {};
	local item;
	item, data = gui_add_item(items, 'btn_back', ltype, cb_back, ANCHOR_UP);
	util.add_menu(layer, items, data.zorder);
	return offsetheight, sprite, rect;
end

function init_bg_for_popview(layer, title, bgsize, cb_close, no_scale)
	if true ~= no_scale then
		bgsize.width = wfix(bgsize.width);
		bgsize.height = hfix(bgsize.height);
	end
	local path = util.get_path('bg_121.png');
	local frect = cc.rect(0, 0, 404, 260); -- fullrect
	local irect = cc.rect(200, 123, 4, 4); -- insetrect
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local bg = util.add_scale9sprite(layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, bgsize, 10); 
	local bg_rect = { x1 = pos.x - bgsize.width/2, x2 = pos.x + bgsize.width/2,
					  y1 = pos.y - bgsize.height/2, y2 = pos.y + bgsize.height/2};

	path = util.get_path('bg_196.png');
	pos = cc.p(bgsize.width/2, bgsize.height-15);
	local bar = util.add_sprite(bg, path, pos, ANCHOR_CENTER_CENTER, 50);
	local barsize = bar:getContentSize();
	pos = cc.p(barsize.width/2, barsize.height/2);
	util.add_labeloutline(bar, title, nil, 30, pos, cc.c4b(251, 252, 244, 255), cc.c4b(57, 29, 74, 255), 2, ANCHOR_CENTER_CENTER, 1);

	local items = {};
	local item;

	pos = cc.p(bgsize.width-20, bgsize.height-20);
	add_item_close(items, pos, ANCHOR_CENTER_CENTER, cb_close);

	util.add_menu(bg, items, 60);
	
	return bg, bg_rect;
end

function add_icon_gold(layer, pos, anchorpoint, zorder, scale)
	local path = util.get_path('icon_69.png');
	local sprite = util.add_sprite(layer, path, pos, anchorpoint, zorder);
	sprite:setScale(scale or 1);
	return sprite;
end

function add_font_1(layer, text, pos, anchorpoint, zorder, scale)
	local path = util.get_path(FT_1);
	local label = util.add_labelbmf(layer, text, path, pos, anchorpoint, zorder);
	label:setScale(scale or 1);
	return label;
end

function add_font_5(layer, text, pos, anchorpoint, zorder, scale)
	local path = util.get_path(FT_5);
	local label = util.add_labelbmf(layer, text, path, pos, anchorpoint, zorder);
	label:setScale(scale or 1);
	return label;
end

function add_line_1(layer, pos, anchorpoint, zorder, width)
	local path = util.get_path('line_1.png');
	local sprite = util.add_sprite(layer, path, pos, anchorpoint, zorder);
	sprite:setScaleX(width/sprite:getContentSize().width);
	return sprite;
end

function add_line_2(layer, pos, anchorpoint, zorder, width)
	local path = util.get_path('line_2.png');
	local sprite = util.add_sprite(layer, path, pos, anchorpoint, zorder);
	sprite:setScaleX(width/sprite:getContentSize().width);
	return sprite;
end

function add_status_eff_sprite(layer, eff_id, pos, anchorpoint, scale, zorder)
	local filename = string.format("e_%d.plist", eff_id);
	if true ~= util.check_file(filename) then
		return nil;
	end
	local path = util.get_path(filename);	
	local cache = cc.SpriteFrameCache:getInstance();
	cache:addSpriteFrames(path);
	filename = string.format("e_%d_1.png", eff_id);
	local sprite = cc.Sprite:createWithSpriteFrameName(filename);
	sprite:setPosition(pos);
	sprite:setScale(scale);
	sprite:setAnchorPoint(anchorpoint);
	layer:addChild(sprite, zorder);
	local animation = cc.Animation:create();
	local len = 0;
	filename = string.format("e_%d_%d.png", eff_id, 1);
	local frame = cache:spriteFrameByName(filename);
	repeat
		len = len + 1;
		animation:addSpriteFrame(frame);
		local filename = string.format("e_%d_%d.png", eff_id, len);
		frame = cache:spriteFrameByName(filename);
	until nil == frame;
	local pt = 0.1;
	if len > 5 then
		pt = 0.07;
	end
	animation:setDelayPerUnit(pt);
	local action = cc.RepeatForever:create(cc.Animate:create(animation));
	action:setTag(TAG_STATUS_EFF);
	sprite:runAction(action);
	return sprite;
end


function clean_for_replay()
	cc.Director:getInstance():getScheduler():setTimeScale(1);
	layer_anim:remove();
	layer_card:remove();
	data_handler:cleanup();
	g_euser.side = nil;
	g_euser.room_data = nil;
	g_scene:map();
	g_scene:add_layer(ZORDER_LAYER_INFO, layer_info:create(g_euser));
	local eid = layer_video.eid or '';
	local cmd = 'lreplay ' .. eid;
	net_send(cmd);
end

function get_friend_list()
	local function callback()
		local cmd = string.format("flist 0 %d", layer_friend.PAGE_SIZE);
		net_send(cmd, true);
	end
	local layer, name = layer_friend:create();
	g_scene:add_layer(ZORDER_LAYER_FRIEND, layer, name, true, callback);
end

function uc_submit_data(key)
	local eid = (g_euser.eid or 'eid_null') .. '';
	local alias = g_euser.alias or 'alias_null';
	local level = (g_euser.level or 'level_null') .. '';
--	local data = string.format("{\"eid\":\"%s\",\"alias\":\"%s\",\"level\":\"%s\"}", eid, alias, level);
	local data = string.format("{\"roleId\":\"%s\",\"roleName\":\"%s\",\"roleLevel\":\"%s\",\"zoneId\":\"%s\",\"zoneName\":\"%s\"}", eid, alias, level, 1, 's1正式服务器');
	UCSdkHandler:submitExtendData(key, data);
end

function ljsdk_submit_data(key)
	local data = {};
	data._id		= key;
	data.roleId		= (g_euser.eid or g_euser.lj_userid or 0) .. '';
	data.roleName	= g_euser.alias or ('决战王者' .. (g_euser.lj_userid or 0));
	data.roleLevel	= (g_euser.level or 1) .. '';
	data.zoneId		= '1';
	data.zoneName	= 's1正式服务器';
	data.balance	= (g_euser.crystal or 0) .. '';
	data.vip		= 1;
	data.partyName	= g_euser.gname or '无帮派';
	LJSdkImpl:setExtRoleData(util.get_json_str(data));
end

function show_lai()
	local layer, name = layer_solo:create();
	g_scene:add_layer(ZORDER_LAYER_SOLO, layer, name, true);
	net_send('lai', true);
end


function show_gate()
	local layer, name = layer_gate:create();
	g_scene:add_layer(ZORDER_LAYER_GATE, layer, name, true);
	local cmd = string.format("lgate 0 %d", layer_gate.PAGE_SIZE);
	net_send(cmd, true);
end
			
function show_service()
	local layer, name = layer_service:create();
	g_scene:add_layer(ZORDER_LAYER_SERVICE, layer, name, true);
	net_send('fdata', true);
end

function get_res_number_area(side)
	local info = g_ui_table.label_res[side]
	if nil == info then
		return false;
	end
	local rdata = layer_dragtutorial.get_sprite_data(info, false);
	info = g_ui_table.label_res_max[g_euser.side];
	if nil == info then
		return false;
	end
	local rmdata = layer_dragtutorial.get_sprite_data(info, false);

	local pos = cc.p(rdata.x, rdata.y + rdata.height / 2);
	local size = cc.size(rmdata.x + rmdata.width * 4 - rdata.x, rmdata.height * 2);
	return pos, size;
end

function get_res_area(side)

	local info = g_ui_table[side][T_RES];
	local pos = cc.p(info.x, info.y);
	local size = cc.size(info.width, info.height);

	local rpos, rsize = get_res_number_area(side);
	local gap_y = 0;

	local s = g_ui_table.label_res[side];
	local y = s:getPositionY();
	local h = s:getContentSize().height * s:getScale();
	if side == SIDE_DOWN then
		gap_y = pos.y-size.height/2 - y;
		size.height = pos.y + size.height/2 - y;
		pos.y = y;
	else
		gap_y = y + h - (pos.y + size.height/2);
		size.height = size.height + gap_y;
	end
	return pos, size;
end

function get_hand_area(side)
	local info = g_ui_table[side][T_HAND];

	local c = CARD_SIZE_2;
	local pos = cc.p(info.x + info.width / 2 - c.width / 2, info.y);
	local size = cc.size(info.width, info.height);
	if (side == SIDE_DOWN) then
		size.width = size.width + HAND_GAP * 2;
	end
	return pos, size;
end

function get_ally_area(side)
	local info = g_ui_table[side][T_ALLY];

	local c = CARD_SIZE_2;
	local pos = cc.p(info.x + info.width / 2 - c.width / 2, info.y);
	local size = cc.size(info.width, info.height);
	return pos, size;
end

function get_support_area(side)
	local info = g_ui_table[side][T_SUPPORT];

	local c = CARD_SIZE_2;
	local pos = cc.p(info.x + info.width / 2 - c.width / 2, info.y);
	local size = cc.size(info.width, info.height);
	return pos, size;
end

function get_space_area(side)
	local apos, asize = get_ally_area(side)
	local spos, ssize = get_support_area(side)
	local c = CARD_SIZE_2;

	local size = cc.size(asize.width, (asize.height + ssize.height) / 2 + math.abs(spos.y - apos.y));
	local pos = cc.p(apos.x, (apos.y + spos.y) / 2);
	return pos, size;
end

function get_deck_area(side)
	local info = g_ui_table[side][T_DECK];

	local pos = cc.p(info.x, info.y);
	local size = cc.size(info.width, info.height);
	return pos, size;
end

function get_hero_area(side)
	local info = g_ui_table[side][T_HERO];

	local pos = cc.p(info.x, info.y);
	local size = cc.size(info.width, info.height);
	return pos, size;
end

function show_tutor_gate()
	if g_euser.level > 1 then return false; end
	local btn = layer_map.btn_pve;
	if nil == btn then return false; end

	local function callback()
		g_tutor_wait_net = show_tutor_do_gate;
		show_gate();
		--show_tutor_do_gate();
	end
	local fdata = layer_dragstory.get_sprite_data(btn, false);
	fdata.x = fdata.x + fdata.width/2;
	fdata.y = fdata.y + fdata.height/2;
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	return true;
end

function show_tutor_do_gate()
	g_tutor_wait_net = nil;
	local function callback()
		local info = layer_gate.list[1];
		if nil ~= info then
			local cmd = 'gate ' .. info.gate_id;
			net_send(cmd);
		end
		return;
	end
	if nil == layer_gate.layer then return; end
	if 0 == #(layer_gate.list or {}) then return; end
	local width = layer_gate.cwidth;
	local height = layer_gate.cheight;
	local th = layer_gate.theight;
	local x, y = layer_gate.tableview:getPosition();
	local fdata = { x=x+width/2, y=y+th-height+height/2, width=width, height=height, use_circle=false };
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	local f = layer_dragstory.finger;
	if nil ~= f then
		local fxx, fyy = f:getPosition();
		f:setPosition(cc.p(fxx+width/4, fyy-height/2));
	end
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function show_tutor_mission()
	if g_euser.level > 10 then return false; end
	--if nil == g_mission_tip or g_mission_tip < 1 or g_mission_tip > 3 then return; end
	local btn = layer_chat.btn_mission;
	if nil == btn then return false; end
	local fdata = layer_dragstory.get_sprite_data(btn, false);

	if g_euser.level > 4 then
		local finger = btn:getChildByTag(TAG_MISSION_FINGER);
		if nil == finger then
			local tpos = cc.p(fdata.width / 2, fdata.height / 2);
			local finger = util.play_frame(btn, 'tutor_finger', tpos, ANCHOR_LEFT_UP, 0.1, 70, true);
			finger:setTag(TAG_MISSION_FINGER);
		end
		return false;
	end

	local function callback()
		g_tutor_wait_net = show_tutor_do_mission;
		show_mission_list();
	end
	fdata.x = fdata.x + fdata.width/2;
	fdata.y = fdata.y + fdata.height/2;
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	return true;
end

function show_tutor_do_mission()
	g_tutor_wait_net = nil;
	-- also limit under 5 in net_mlist
	if g_euser.level > 4 then return; end
	if nil == layer_mission.layer then return; end
	if 0 == #(layer_mission.list or {}) then return; end
	local function callback()
		local info = layer_mission.list[1];
		if nil == info then return; end
		if 16 ~= tonumber(info.mtype) then return; end
		if 2 == tonumber(info.status) then
			local mid = info.mid;
			net_send('mreward ' .. mid);
			return;
		end
		layer_mission:do_gate(info.p2);
	end
	local width = layer_mission.cwidth;
	local height = layer_mission.cheight;
	local th = layer_mission.theight;
	local x, y = layer_mission.tableview:getPosition();
	local fdata = { x=x+width/2, y=y+th-height+height/2, width=width, height=height, use_circle=false };
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	local f = layer_dragstory.finger;
	if nil ~= f then
		local fxx, fyy = f:getPosition();
		f:setPosition(cc.p(fxx+width/4, fyy-height/2));
	end
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function go_pay()
	local layer, name = layer_pay:create();
	g_scene:add_layer(ZORDER_LAYER_PAY, layer, name, true);
	if is_ver(VER_ANYSDK) or is_ver(VER_ANYSDK_NO_LOGIN) then
		if nil == g_anysdk_plugin or false == g_anysdk_init_play then
			local iap_plugin_maps = AgentManager:getInstance():getIAPPlugin();
			for key, value in pairs(iap_plugin_maps) do
				print('key: ' .. key);
				value:setResultListener(anysdk_pay_result);
				g_anysdk_plugin = value;
				break;
			end
		end
		net_send('lpay 6');
		--[[
				local list = {};
				local l = {};
				l.pay_code = 123;
				l.pay_price = 10;
				l.money_type = 1;
				l.money = 20;
				l.title = 'test anysdk';
				l.description = 'test anysdk';
				l.a = a;
				table.insert(list, l);
				layer_pay:add_list(5, list);
		]]--
	elseif is_ver(VER_APAY) then
		net_send('lpay 4');
	elseif is_ver(VER_APPSTORE) then
		net_send('lpay 3');
	elseif is_ver(VER_UCSDK) then
		net_send('lpay 7');
	elseif is_ver(VER_LJSDK) then
		net_send('lpay 8');
	elseif is_ver(VER_NINEYOU) then
		net_send('lpay 9');
	else
		--net_send('lpay 4');
	end
end

function show_money_tip(tip)
	tip = tip or "资金不足";
	tip = tip .. "，点击确定进行充值";
	g_scene:add_layer(ZORDER_LAYER_TIP, layer_tip:create(tip, go_pay));
end

function show_crystal_tip()
	if true == is_vip_member(g_euser) then
		local tip = t_lang("TIP_NOT_ENOUGH_CRYSTAL");
		show_money_tip(tip);
		return;
	end
	tip = "您的水晶不足,点击确定进行充值。\n成为月卡vip会员更可获得每日赠送100水晶";
	g_scene:add_layer(ZORDER_LAYER_TIP, layer_tip:create(tip, go_pay));
end

function add_scroll_icons(layer, pos, is_up)
	local anchor = (true == is_up) and ANCHOR_RIGHT_UP or ANCHOR_RIGHT_DOWN;
	local fname;
	if true == is_up then
		fname = 'btn_112.png';
	else
		fname = 'btn_111.png';
	end
	local path = util.get_path(fname);
	local s = util.add_sprite(layer, path, pos, anchor, 100);
	local size = s:getContentSize();
	local gap = 0;
	if true == is_up then
		gap = 30;
	else
		gap = -30;
	end

	local x = pos.x;
	local y = pos.y;
	local t = 0.8;
	local array = {};
	table.insert(array, cc.EaseIn:create(cc.MoveTo:create(t, cc.p(x, y+gap)), t));
	table.insert(array, cc.EaseIn:create(cc.MoveTo:create(t, cc.p(x, y)), t));
	s:runAction(cc.RepeatForever:create(cc.Sequence:create(array)));
	return s;
end

function update_scroll_icon(icon_up, icon_down, view, table_height)
	local offset_y = view:getContentOffset().y;
	local content_height = view:getContentSize().height;
	icon_down:setVisible(false);
	icon_up:setVisible(false);
	if offset_y < 0 then
		icon_down:setVisible(true);
	end
	if table_height - content_height < offset_y then
		icon_up:setVisible(true);
	end
end

function is_vip_member(user)
	if nil == user then	return false;	end
	local cur_time = os.time();
	local end_time = user.monthly_end_date or 0;
--	print('=============================================');
--	print('cur_time:', cur_time, ' end_time:', end_time);
--	print('=============================================');
	return (end_time - cur_time > 0);
end

function show_lottery()
	local layer, name = layer_lottery:create();
	g_scene:add_layer(ZORDER_LAYER_LOTTERY, layer, name, true);
	net_send('lottery 0', true);
end

function is_view_top()
	local support_table = g_logic_table[SIDE_DOWN][T_SUPPORT];
	for i = 1, #support_table do
		local card = support_table[i];
		if card.view_top == true then
			return true;
		end
	end
	return false;
end

function is_view_oppo()
	local support_table = g_logic_table[SIDE_DOWN][T_SUPPORT];
	for i = 1, #support_table do
		local card = support_table[i];
		if card.view_oppo == true then
			return true;
		end
	end
	return false;
end

function ask_exit()
	local s = '是否要退出游戏';
	g_scene:add_layer(ZORDER_LAYER_TIP,layer_tip:create(s,exit_game));

	if is_ver(VER_ANYSDK)
	and 930 == tonumber(AgentManager:getInstance():getChannelId() or "0") then
		layer_tip:add_button_bbs('http://bbs.youxiqun.com');
	end
end

function gsub_symbol(text)
	-- eg.
	-- "完成5次关卡10(0/5)" -> "完成5次关卡10%(0/5%)"
	-- if not do this step
	-- when use string.gsub(string, text, function(w)..end);
	-- cannot match up the text
	return string.gsub(text, 
			"[%(%)%.%%%+%-%*%?%[%^%$%]]", 
			function(w) 
				w = "%" .. w;
				return w;     
			end);
end



function add_detail_for_show_frame(sprite, card)
	local s = sprite:getContentSize();
	local str, pos, path;
	local l = nil;
	local scale = 0.6;
	local fontpath = util.get_path(FNT_CARD);
	local x, y;
	if card.ctype ~= HERO then
		path = util.get_path('icon_54.png'); -- 75x84
		x = 13;
		y = s.height-13;
		pos = cc.p(x, y);
		l = util.add_sprite(sprite, path, pos, ANCHOR_CENTER_CENTER);
		l:setScale(scale);
		pos = cc.p(x, y);
		str = card.cost;
		l=util.add_labelbmf(sprite,str,fontpath,pos,ANCHOR_CENTER_CENTER);
		l:setScale(scale);
	end
	if ABILITY == card.ctype or ATTACH == card.ctype 
			or SUPPORT == card.ctype or ARTIFACT == card.ctype
			or TRAP == card.ctype then
		return cell;
	end
	if ARMOR == card.ctype then
		fname = 'icon_59.png'; -- 75x84
	elseif HERO == card.ctype then
		fname = 'icon_57.png'; -- 75x90
	else
		fname = 'icon_55.png'; -- 146x104
	end
	x = 13;
	y = 20;
	pos = cc.p(x, y);
	path = util.get_path(fname);
	l = util.add_sprite(sprite, path, pos, ANCHOR_CENTER_CENTER);
	l:setScale(scale);
	if card.ctype == HERO then
		str = card.energy;
	else
		str = card.power;
	end
	--[[
	if ARMOR == card.ctype then
		pos = ccp(26, 32);
	elseif HERO == card.ctype then
		pos = ccp(26, 32);
	else
		pos = ccp(46, 32);
	end
	]]--
	pos = cc.p(x, y);
	l=util.add_labelbmf(sprite,str,fontpath,pos,ANCHOR_CENTER_CENTER);
	l:setScale(scale);
	if ARMOR == card.ctype or WEAPON == card.ctype then
		fname = 'icon_58.png'; -- 75x86
	else
		fname = 'icon_56.png'; -- 75x89
	end
	path = util.get_path(fname);
	x = s.width-13;
	y = 20;
	pos = cc.p(x, y);
	l = util.add_sprite(sprite, path, pos, ANCHOR_CENTER_CENTER);
	l:setScale(scale);

	--[[
	if ARMOR == card.ctype or WEAPON == card.ctype then
		pos = ccp(s.width-26, 32);
	else
		pos = ccp(s.width-26, 32);
	end
	]]--
	pos = cc.p(x, y);
	str = card.hp;
	l=util.add_labelbmf(sprite,str,fontpath,pos,ANCHOR_CENTER_CENTER);
	l:setScale(scale);
end
-- /////////////////////// COMMON END   ///////////////////////////

-- /////////////////////// ANYSDK START ///////////////////////////
g_anysdk_init = false;

function show_anysdk_tip(tip)
	local layer = layer_touch.layer;
	if nil == layer then return; end
	local function cb_tip()
		layer:unscheduleUpdate();
		show_msg(tip);
	end
	layer:scheduleUpdateWithPriorityLua(cb_tip, 1);
end

g_anysdk_init_action = false;
function anysdk_action_result(plugin, code, msg)
	hide_netloading();
	print('anysdk action_result code: ' .. code .. ' msg: ' .. msg);
	if code == UserActionResultCode.kInitSuccess then
		g_anysdk_init_action = true;
	elseif code == UserActionResultCode.kInitFail then
		g_anysdk_init_action = false;
		show_anysdk_tip("登录系统初始化失败");
	elseif code == UserActionResultCode.kLoginNetworkError then
		show_anysdk_tip("网络错误，登录失败");
	elseif code == UserActionResultCode.kLoginNoNeed then
	elseif code == UserActionResultCode.kLoginCancel then
	elseif code == UserActionResultCode.kLogoutFail then
		show_anysdk_tip("登出失败");
	elseif code == UserActionResultCode.kLoginFail then
		if g_scene:is_stage(STAGE_LOGIN) then
--			if 5 == code then
--			else
--				show_anysdk_tip("登录失败!\n"..msg);
--			end
			local agent = AgentManager:getInstance();
			local cid = tonumber(agent:getChannelId() or "0");
			-- 550 腾讯
			if cid == 550 and "Weixin NOT Installed" == msg then
				show_anysdk_tip('该设备尚未安装微信\n请到腾讯网下载微信最新版本');
--				show_msg('该设备尚未安装微信, 请到腾讯网下载微信最新版本');
--				return;
			else
				show_anysdk_tip("登录失败!\n"..msg);
			end
		else
			local layer = layer_touch.layer;
			if nil == layer then return; end
			local function cb()
				layer:unscheduleUpdate();
				logout();
			end
			layer:scheduleUpdateWithPriorityLua(cb, 1);
		end
	elseif code == UserActionResultCode.kAccountSwitchSuccess then
		--table.insert(g_chat_list[C_ALL], "hihihihi 999999");
		--show_anysdk_tip("切换账户:" .. msg);
		local layer = layer_touch.layer;
		if nil == layer then return; end
		local function cb()
			layer:unscheduleUpdate();
			local function parse_json_str(jstr, key)
				local p1, p2 = string.find(jstr, key);
				if nil == p1 then
					return nil;
				end
				local pstart = p2 + 4;
				local pend = pstart;
				for i = pstart, string.len(jstr) do
					local c = string.sub(jstr, i, i);
					if '"' == c then
						pend = i;
						break;
					end
				end
				if pend <= pstart then
					return nil;
				end
				local ret = string.sub(jstr, pstart, pend-1);
				return ret;
			end
			local user = AgentManager:getInstance():getUserPlugin();
			g_euser.userid = user:getUserID();
			local password = parse_json_str(msg, "password");
			local username = parse_json_str(msg, "username");
			g_euser.username = username;
			g_euser.password = password;
			net_cmd_log(username, password);
		end
		layer:scheduleUpdateWithPriorityLua(cb, 1);

	elseif code == UserActionResultCode.kLoginSuccess then
		local layer = layer_touch.layer;
		if nil == layer then return; end
		local function cb()
			local function parse_json_str(jstr, key)
				local p1, p2 = string.find(jstr, key);
				if nil == p1 then
					return nil;
				end
				local pstart = p2 + 4;
				local pend = pstart;
				for i = pstart, string.len(jstr) do
					local c = string.sub(jstr, i, i);
					if '"' == c then
						pend = i;
						break;
					end
				end
				if pend <= pstart then
					return nil;
				end
				local ret = string.sub(jstr, pstart, pend-1);
				return ret;
			end
			local password = parse_json_str(msg, "password");
			local username = parse_json_str(msg, "username");
			layer:unscheduleUpdate();
			local user = AgentManager:getInstance():getUserPlugin();
			g_euser.userid = user:getUserID();
			layer_login:cb_login_for_anysdk(username, password);
		end
		layer:scheduleUpdateWithPriorityLua(cb, 1);
	elseif code == UserActionResultCode.kAccountSwitchFail then
		show_anysdk_tip("切换账号失败");
	end
end

g_anysdk_plugin = nil;
g_anysdk_init_pay = false;
function anysdk_pay_result(code, msg, product_info)
	print('anysdk pay_result code: ' .. code .. ' msg: ' .. msg);
	if code == PayResultCode.kPayInitSuccess then
		g_anysdk_init_pay = true;	
	elseif code == PayResultCode.kPayInitFail then
		g_anysdk_init_pay = false;	
	elseif code == PayResultCode.kPayCancel then
	elseif code == PayResultCode.kPayNetworkError then
		show_anysdk_tip("网络错误，支付失败");
	elseif code == PayResultCode.kPayProductionInforIncomplete then
		show_anysdk_tip("产品信息有误，支付失败");
	elseif code == PayResultCode.kPayNowPaying then
		ProtocolIAP:resetPayState();
	elseif code == PayResultCode.kPayRechareSuccess then
		show_anysdk_tip("充值成功");
	elseif code == PayResultCode.kPaySuccess then
		show_anysdk_tip("购买成功");
	elseif code == PayResultCode.kPayFail then
		show_anysdk_tip("购买失败\n"..msg);
	end
end
-- /////////////////////// ANYSDK END   ///////////////////////////

-- /////////////////////// TUTOR START   ///////////////////////////

g_tutor_wait_net = nil;
g_is_in_tutor = nil;
story_data = nil;
story_next = nil;

function check_do_tutor_wait_net()
	if nil ~= g_tutor_wait_net then
		local cb = g_tutor_wait_net;
		g_tutor_wait_net = nil;
		cb();
		return true;
	end
	return false;
end



function story_1()
	local actor = { name = story_data.actor, icon = story_data.icon };
	local list_tip = {
		string.format("%s,欢迎你来到战场...", g_euser.alias or "朋友"),
		string.format("你选择了[%s]作为你的英雄,正在与[%s]进行作战...", story_data.m_hero or "", story_data.t_hero or ""),
		"来看看我们如何痛击对手吧!",
	};
	local function callback()
		play_game_cmd("s 0");
		play_game_cmd("t 2302 1301");
		play_game_cmd("t 2304 1301");
		play_game_cmd("t 2303 1301");
		play_game_cmd("t 2301 1101");
		story_next = story_2;
	end
	local layer, name = layer_story:create(actor, list_tip, callback);
	g_scene:add_layer(ZORDER_LAYER_STORY, layer, name);
end

function story_2()
	local actor = { name = story_data.actor, icon = story_data.icon };
	local list_tip = {
		"敌方军力已尽,只需再一回合就能取得胜利,英雄们继续向前!",
	};
	local function callback()
		play_game_cmd("n");
		play_game_cmd("s 1203");
		story_next = story_3;
	end
	local layer, name = layer_story:create(actor, list_tip, callback);
	g_scene:add_layer(ZORDER_LAYER_STORY, layer, name);
end

function story_3()
	local actor = { name = story_data.t_hero, icon = story_data.t_icon };
	local list_tip = {
		"太天真了，没那么容易让你胜利的。",
	};
	local function callback()
		play_game_cmd("b 1201 2101 2302 2303 2304");
		story_next = story_4;
	end
	local layer, name = layer_story:create(actor, list_tip, callback);
	g_scene:add_layer(ZORDER_LAYER_STORY, layer, name);
end

function story_4()
	local actor = { name = story_data.actor, icon = story_data.icon };
	local list_tip = {
		"我方英雄受到2点伤害,审判天使、九尾妖狐、扭曲树精被击杀。",
	};
	local function callback()
		play_game_cmd("b 1201");
		play_game_cmd("t 1301 2101");
		play_game_cmd("n");
		story_next = story_5;
	end
	local layer, name = layer_story:create(actor, list_tip, callback);
	g_scene:add_layer(ZORDER_LAYER_STORY, layer, name);
end

function story_5()
	local actor = { name = story_data.actor, icon = story_data.icon };
	local list_tip = {
		"敌人果然强大,但大家不要放弃。",
		"我方新兵听命,要战胜敌人,充足的资源必不可少,所以我们懂得放弃手上多余的卡牌转化为资源。",
	};
	local function callback()
		story_6();
	end
	local layer, name = layer_story:create(actor, list_tip, callback);
	g_scene:add_layer(ZORDER_LAYER_STORY, layer, name);
end

function story_6()
	local function callback()
		play_game_cmd("s 2202");
		story_next = story_7;
	end
	local info = g_ui_table[2][T_HAND][2];
	if nil == info then callback(); return; end
	local fdata = layer_dragstory.get_sprite_data(info:get_sprite(), true);
	info = g_ui_table[2][T_RES];
	if nil == info then callback(); return; end
	local tdata = { x = info.x, y = info.y, width = info.width, height = info.height, use_circle = false };
	local layer, name = layer_dragstory:create(fdata, tdata, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function story_7()
	local actor = { name = story_data.actor, icon = story_data.icon };
	local list_tip = {
		"终于有足够资源召唤高级盟军,赶紧召唤潘森上场吧！",
	};
	local function callback()
		story_8();
	end
	local layer, name = layer_story:create(actor, list_tip, callback);
	g_scene:add_layer(ZORDER_LAYER_STORY, layer, name);
end

function story_8()
	local function callback()
		play_game_cmd("b 2201");
		story_next = story_9;
	end
	local info = g_ui_table[2][T_HAND][1];
	if nil == info then callback(); return; end
	local fdata = layer_dragstory.get_sprite_data(info:get_sprite(), true);
	info = g_ui_table[2][T_ALLY];
	if nil == info then callback(); return; end
	local tdata = { x = info.x+info.width/2-fdata.width/2, y = info.y, width = info.width, height = info.height, use_circle = false };
	local layer, name = layer_dragstory:create(fdata, tdata, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function story_9()
	local actor = { name = story_data.actor, icon = story_data.icon };
	local list_tip = {
		"潘森具有[守护者]效果,只要他在场,我方其他非守护者盟军就不会成为敌方行动目标。",
		"但刚上场盟军会处于疲倦状态无法行动,还好我方还有恶魔小丑,赶紧进行攻击吧。",
	};
	local function callback()
		story_10();
	end
	local layer, name = layer_story:create(actor, list_tip, callback);
	g_scene:add_layer(ZORDER_LAYER_STORY, layer, name);
end

function story_10()
	local function callback()
		play_game_cmd("t 2301 1101");
		story_next = story_11;
	end
	local info = g_ui_table[2][T_ALLY][1];
	if nil == info then callback(); return; end
	local fdata = layer_dragstory.get_sprite_data(info:get_sprite(), true);
	info = g_ui_table[1][T_HERO][1];
	if nil == info then callback(); return; end
	local tdata = layer_dragstory.get_sprite_data(info:get_sprite(), true);
	local layer, name = layer_dragstory:create(fdata, tdata, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function story_11()
	local function callback()
		play_game_cmd("n");
		play_game_cmd("s 0");
		story_next = story_12;
	end
	local item = layer_card.btn_next;
	if nil == item then callback(); return; end
	local fdata = layer_dragstory.get_sprite_data(item, false);
	fdata.x = fdata.x + fdata.width/2;
	fdata.y = fdata.y + fdata.height/2;
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function story_12()
	local actor = { name = story_data.t_hero, icon = story_data.t_icon };
	local list_tip = {
		"你以为这样就能胜利了?看我的厉害。",
	};
	local function callback()
		story_13();
	end
	local layer, name = layer_story:create(actor, list_tip, callback);
	g_scene:add_layer(ZORDER_LAYER_STORY, layer, name);
end

function story_13()
	local actor = { name = story_data.actor, icon = story_data.icon };
	local list_tip = {
		"对方[跳过]弃牌阶段,一定是抽到关键卡牌,大家小心!",
	};
	local function callback()
		play_game_cmd("b 1201");
		story_next = story_14;
	end
	local layer, name = layer_story:create(actor, list_tip, callback);
	g_scene:add_layer(ZORDER_LAYER_STORY, layer, name);
end

function story_14()
	local actor = { name = story_data.actor, icon = story_data.icon };
	local list_tip = {
		"虽我军受创,但不要放弃,相信哪天我们一定能把敌人战胜。",
	};
	local function callback()
		story_next = nil;
		g_scene:map();
		story_15();
	end
	local layer, name = layer_story:create(actor, list_tip, callback);
	g_scene:add_layer(ZORDER_LAYER_STORY, layer, name);
end

function story_15()
	local actor = { name = story_data.actor, icon = story_data.icon };
	local list_tip = {
		"失败乃成功之母,多练习才能增加获胜的机会,加油啊。",
	};
	local function callback()
		story_16();
	end
	local layer, name = layer_story:create(actor, list_tip, callback);
	g_scene:add_layer(ZORDER_LAYER_STORY, layer, name);
end

function story_16()
	local function callback()
		--show_lai();
		show_gate();
		story_17();
	end
	local item = layer_map.btn_pve;
	if nil == item then callback(); return; end
	local fdata = layer_dragstory.get_sprite_data(item, false);
	fdata.x = fdata.x + fdata.width/2;
	fdata.y = fdata.y + fdata.height/2;
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function story_17()
	local function callback()
		g_is_in_tutor = nil;
		story_data = nil;
		util.set_tutor(TUTOR_STORY, true, true);
		--[[
		local info = layer_solo.list[1];
		local eid = info.eid;
		local cmd = 'solo ' .. eid;
		net_send(cmd);
		]]--
		local info = layer_gate.list[1];
		if nil ~= info then
			local cmd = 'gate ' .. info.gate_id;
			net_send(cmd);
		end
		return;
	end
	if nil == layer_gate.layer then callback(); return; end
	if 0 == #(layer_gate.list or {}) then callback(); return; end
	local width = layer_gate.cwidth;
	local height = layer_gate.cheight;
	local th = layer_gate.theight;
	local x, y = layer_gate.tableview:getPosition();
	local fdata = { x=x+width/2, y=y+th-height+height/2, width=width, height=height, use_circle=false };
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function tutor_tip(step)
	if step == TUTOR_SOLO then
		return "请先与电脑进行练习，熟悉基本玩法。";
	elseif step == TUTOR_RES then
		return "这是弃牌阶段，丢弃一张手牌可增加1点资源，出牌需要消耗资源。";
	elseif step == TUTOR_TAP_SKIP then
		return "手牌所剩无几啦，别再扔啦~试试点击跳过，可以跳过弃牌阶段";
	elseif step == TUTOR_TAP_CARD then
		return "点击查看牌的详细信息。";
	elseif step == TUTOR_COST then
		return "左上方数字表示出这张牌需要消耗的资源。";
	elseif step == TUTOR_DESC then
		return "描述部分会说明它的特殊技能和作用。";
	elseif step == TUTOR_HERO_POWER then
		return "英雄的法力值，每回合+1，用来施放英雄技能。";
	elseif step == TUTOR_HERO_HP then
		return "英雄的血量，降至0时战斗失败。";
	elseif step == TUTOR_ALLY_ATTACK then
		return "盟军的攻击力，每次攻击会使目标减少对应的血量。";
	elseif step == TUTOR_ALLY_HP then
		return "盟军的血量，降至0时盟军死亡。";
	elseif step == TUTOR_WEAPON_ATK then
		return "武器的攻击力，装备后使英雄获得对应的攻击力。";
	elseif step == TUTOR_WEAPON_DUR then
		return "武器的耐久度，每次使用武器后耐久度-1。";
	elseif step == TUTOR_ARMOR_DEF then
		return "防具的防御力，装备后使英雄获得对应的防御力。";
	elseif step == TUTOR_ARMOR_DUR then
		return "防具的耐久度，每次使用防具后耐久度-1。";
	elseif step == TUTOR_SAC then
		return "拖动你需要弃置的卡牌到资源区后就可以增加1点资源。";
	elseif step == TUTOR_SAC_TAP then
		return "你需要弃置的卡牌到资源区后就可以增加1点资源。";
	elseif step == TUTOR_PLAY then
		return "这是出牌阶段，消耗资源把手牌放出以及使用已上场卡牌的技能。";
	elseif step == TUTOR_HL then
		return "可操作的卡牌边框会高亮提示。";
	elseif step == TUTOR_NEED_RES then
		return "当前回合资源不足，不能出牌。";
	elseif step == TUTOR_NEXT then
		return "操作完成后点击【结束】按钮结束本回合，轮到对方操作。";
	elseif step == TUTOR_USE then
		return "使用你手上的牌。";
	elseif step == TUTOR_HL_ALLY then
		return "可操作的盟军牌边框会高亮提示。";
	elseif step == TUTOR_TAP_ATTACK then
		return "点击攻击进行目标选择。";
	elseif step == TUTOR_HL_ATTARGET then
		return "选择攻击的目标。";
	elseif step == TUTOR_TAP_ATTARGET then
		return "进行攻击吧。";
	elseif step == TUTOR_HL_HERO then
		return "英雄拥有足够技能点就可以发动技能。";
	elseif step == TUTOR_TAP_ABHERO then
		return "使用英雄技能吧。";
	elseif step == TUTOR_FIRST_SAC then
		return "弃除手牌可提升1点可用资源。";
	elseif step == TUTOR_WAIT_NEXT_SAC then
		return "可用资源不足支付手牌所需资源，无法进行出牌。";
	elseif step == TUTOR_WAIT_NEXT then
		return "结束回合，等待积累更多资源。";
	elseif step == TUTOR_SECOND_SAC then
		return "继续移除手牌，获取更多可用资源。";
	elseif step == TUTOR_HIGHLIGHT_CARD then
		return "可用资源足够支付出牌时，可用卡牌会被高亮与上移。";
	elseif step == TUTOR_SOMMON_CARD then
		return "拖动卡牌至盟军区域。";
	elseif step == TUTOR_WYLD_SKILL then
		return "恶魔小丑有迅捷技能，在出场回合即可立即攻击。";
	elseif step == TUTOR_NO_TARGET_ATK then
		return "但对方场上没有攻击目标，闯关模式下无法攻击对方英雄。";
	elseif step == TUTOR_REST then
		return "新上场的盟军会处于休息状态无法行动。";
	elseif step == TUTOR_ATTACK then
		return "拖动至攻击目标进行攻击。";
	elseif step == TUTOR_INTRO then
		return "欢迎来到决战王者，我们将以一系列的教程来引导各路新人在对战中战胜对手。";
	elseif step == TUTOR_AREA then
		return "首先，决战王者的战场主要划分为几个区域。";
	elseif step == TUTOR_AREA_RES then
		return "资源区：显示玩家或敌方当时所剩资源与回合可用的总资源。";
	elseif step == TUTOR_AREA_HAND then
		return "手牌区：显示玩家或敌方目前拥有的手牌，手牌可以通过消耗资源召唤至场上。";
	elseif step == TUTOR_AREA_HERO then
		return "英雄区：显示玩家或敌方目前英雄种类，所剩生命值(右边数字)，所剩技能点(左边数字)。";
	elseif step == TUTOR_AREA_DECK then
		return "牌堆：显示玩家或敌方目前剩余可抽牌数，当牌堆为0时，每抽取一次牌则扣除1点生命。";
	elseif step == TUTOR_AREA_SPACE then
		return "场地：通过消耗资源被召唤至场上的卡牌都会出现在场地上。卡牌被召唤后才能被使用或发挥效果。";
	elseif step == TUTOR_TURN_SAC then
		return "目前处于我方弃牌阶段，弃除手牌可提升1点可用资源。";
	elseif step == TUTOR_PVP_CAN_ATTACK then
		return "对战模式下，对方英雄生命点被扣至0时会宣布我方胜利，反之则我方失败。";
	elseif step == TUTOR_PVP_ATTACK then
		return "拖动至对方英雄位置进行攻击。";
	elseif step == TUTOR_TEST then
		return "sdafldfjlajdlajldfjaljd  aksdfjlajdfjk，啊啊发动机拉卡机阿事实上是,ajalfdsllkafkl\n999\n101010";
	end
	return nil;
end

function tutor_solo()
	local self = layer_solo;
	if nil == self.layer then
		return false;
	end
	if 0 == #(self.list or {}) then
		return false;
	end
	local size = cc.size(self.cwidth, self.cheight);
	local x, y = self.tableview:getPosition();
	local pos = cc.p(x, y + self.theight - size.height);
	return util.add_tutorial(pos, size, TUTOR_SOLO);
end

function tutor_res()
	local self = layer_table;
	if nil == self.layer then
		return false;
	end
	local info = g_ui_table[g_euser.side][T_RES];
	if nil == info then
		return false;
	end
	local size = cc.size(info.width, info.height);
	local pos = cc.p(info.x-size.width/2, info.y-size.height/2);
	return util.add_tutorial(pos, size, TUTOR_RES, tutor_tap_card);
end

function tutor_tap_skip()
	local self = layer_table;
	if nil == self.layer then
		return false;
	end
	local list = g_ui_table[g_euser.side][T_HAND] or {};
	if #list > 3 then
		return false;
	end
	local btn = layer_card.btn_skip;
	if nil == btn then return false; end
	if false == btn:isVisible() then return false; end
	local x, y = btn:getPosition();
	local pos = cc.p(x, y);
	local size = btn:getContentSize();
	return util.add_tutorial(pos, size, TUTOR_TAP_SKIP);
end

function tutor_tap_card()
	local self = layer_card;
	if nil == self.layer then
		return false;
	end
	local list = g_ui_table[g_euser.side][T_HAND];
	local info = list[1];
	if nil == info then
		return false;
	end
	local s = info:get_sprite();
	local x1, y1 = s:getPosition();
	local size1 = s:getContentSize();
	local size = cc.size(list.width, list.height);
	local pos = cc.p(x1-size1.width/2, y1-size1.height/2);
	return util.add_tutorial(pos, size, TUTOR_TAP_CARD);
end

function tutor_card_detail_area(sprite, tag)
	local ss = sprite:getChildByTag(tag);
	if nil == ss then 
		return false; 
	end
	local x, y = sprite:getPosition();
	local size = sprite:getContentSize();
	local scale = sprite:getScale();
	local x2 = x - size.width/2*scale;
	local y2 = y - size.height/2*scale;
	x, y = ss:getPosition();
	size = ss:getContentSize();
	size.width = size.width * scale;
	size.height = size.height * scale;
	local pos = cc.p(x*scale+x2-size.width/2, y*scale+y2-size.height/2);
	return true, pos, size;
end

function tutor_cost()
	local self = layer_action;
	if nil == self.layer then
		return false;
	end
	local list = layer_action.list or {};
	if 0 == #list then
		return false;
	end
	local sprite = list[1].sprite;
	if nil == sprite then return false; end

	local flag, pos, size = tutor_card_detail_area(sprite, TAG_COST);
	if true ~= flag then return false; end

	local cb = nil;
	if false == util.check_tutor(TUTOR_DESC) then
		cb = tutor_desc;
	end
	return util.add_tutorial(pos, size, TUTOR_COST, cb);
end

function tutor_desc()
	local self = layer_action;
	if nil == self.layer then
		return false;
	end
	local list = layer_action.list or {};
	if 0 == #list then
		return false;
	end
	local sprite = list[1].sprite;
	if nil == sprite then return false; end

	local flag, pos, size = tutor_card_detail_area(sprite, TAG_DESC);
	if true ~= flag then return false; end

	return util.add_tutorial(pos, size, TUTOR_DESC, tutor_sac_tap);
end

function tutor_left_down()
	local self = layer_action;
	if nil == self.layer then
		return false;
	end
	local list = layer_action.list or {};
	if 0 == #list then
		return false;
	end
	local sprite = list[1].sprite;
	if nil == sprite then return false; end

	local flag, pos, size = tutor_card_detail_area(sprite, TAG_POWER);
	if true ~= flag then return false; end

	return true, pos, size;
end

function tutor_right_down()
	local self = layer_action;
	if nil == self.layer then
		return false;
	end
	local list = layer_action.list or {};
	if 0 == #list then
		return false;
	end
	local sprite = list[1].sprite;
	if nil == sprite then return false; end

	local flag, pos, size = tutor_card_detail_area(sprite, TAG_HP);
	if true ~= flag then return false; end

	return true, pos, size;
end

function tutor_hero_power()
	local flag, pos, size = tutor_left_down();
	if false == flag then
		return false;
	end

	return util.add_tutorial(pos, size, TUTOR_HERO_POWER, tutor_hero_hp);
end

function tutor_hero_hp()
	local flag, pos, size = tutor_right_down();
	if false == flag then
		return false;
	end

	local cb = nil;
	if false == util.check_tutor(TUTOR_DESC) then
		cb = tutor_desc;
	end
	return util.add_tutorial(pos, size, TUTOR_HERO_HP, cb);
end

function tutor_ally_attack()
	local flag, pos, size = tutor_left_down();
	if false == flag then
		return false;
	end

	return util.add_tutorial(pos, size, TUTOR_ALLY_ATTACK, tutor_ally_hp);
end

function tutor_ally_hp()
	local flag, pos, size = tutor_right_down();
	if false == flag then
		return false;
	end

	local cb = nil;
	if false == util.check_tutor(TUTOR_COST) then
		cb = tutor_cost;
	end
	return util.add_tutorial(pos, size, TUTOR_ALLY_HP, cb);
end

function tutor_weapon_atk()
	local flag, pos, size = tutor_left_down();
	if false == flag then
		return false;
	end

	return util.add_tutorial(pos, size, TUTOR_WEAPON_ATK, tutor_weapon_dur);
end

function tutor_weapon_dur()
	local flag, pos, size = tutor_right_down();
	if false == flag then
		return false;
	end

	local cb = nil;
	if false == util.check_tutor(TUTOR_COST) then
		cb = tutor_cost;
	end
	return util.add_tutorial(pos, size, TUTOR_WEAPON_DUR, cb);
end

function tutor_armor_def()
	local flag, pos, size = tutor_left_down();
	if false == flag then
		return false;
	end

	return util.add_tutorial(pos, size, TUTOR_ARMOR_DEF, tutor_armor_dur);
end

function tutor_armor_dur()
	local flag, pos, size = tutor_right_down();
	if false == flag then
		return false;
	end

	local cb = nil;
	if false == util.check_tutor(TUTOR_COST) then
		cb = tutor_cost;
	end
	return util.add_tutorial(pos, size, TUTOR_ARMOR_DUR, cb);
end

function tutor_sac()
	local self = layer_card;
	if nil == self.layer then
		return false;
	end
	local list = g_ui_table[g_euser.side][T_HAND];
	local info = list[1];
	if nil == info then
		return false;
	end
	local s = info:get_sprite();
	local x, y = s:getPosition();
	local size = s:getContentSize();
	local pos = cc.p(x - size.width/2, y - size.height/2);
	local flag = util.add_tutorial(pos, size, TUTOR_SAC);
	if false == flag then
		return false;
	end
	local finger = layer_tutorial:get_finger();
	if nil == finger then	
		return false;
	end
	finger:stopAllActions();
	info = g_ui_table[g_euser.side][T_RES];
	if nil == info then
		return false;
	end
	size = cc.size(info.width, info.height);
	local pos2 = cc.p(info.x, info.y);
	local array = {};
	local action = cc.MoveTo:create(2, pos2);
	table.insert(array, action);
	action = cc.MoveTo:create(0.05, pos);
	table.insert(array, action);
	action = cc.Sequence:create(array);
	action = cc.RepeatForever:create(action);
	finger:runAction(action);
	return true;
end

function tutor_sac_tap()
	local self = layer_action;
	if nil == self.layer then
		return false;
	end
	if PHASE_SACRIFICE ~= g_phase then
		return false;
	end
	local menu = self.menu;
	if nil == menu then return false; end
	local item = menu:getChildren()[1];
	if nil == item then return false; end

	local x, y = item:getPosition();
	local size = item:getContentSize();
	local scale = item:getScale();
	local pos = cc.p(x-size.width/2, y);
	return util.add_tutorial(pos, size, TUTOR_SAC_TAP);
end

function tutor_play()
	local self = layer_card;
	if nil == self.layer then
		return false;
	end
	local label = g_ui_table.label_res[SIDE_DOWN];
	if nil == label then return false; end
	local x, y = label:getPosition();
	local size = label:getContentSize();
	local pos = cc.p(x-size.width, y-size.height);
	local cb = nil;
	if false == util.check_tutor(TUTOR_HL) then
		cb = tutor_hl;
	end
	return util.add_tutorial(pos, size, TUTOR_PLAY, cb);
end

function tutor_hl()
	local self = layer_card;
	if nil == self.layer then
		return false;
	end
	local list = g_ui_table[g_euser.side][T_HAND];
	local info = check_hl_in_list(list);
	if nil == info then
		--[[
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local size = cc.size(0, 0);
		return util.add_tutorial(pos, size, TUTOR_NEED_RES, tutor_next, true);
		]]--
		return util.trigger_tutor(TUTOR_NEXT);
	end
	local s = info:get_sprite();
	local size = s:getContentSize();
	local x, y = s:getPosition();
	local pos = cc.p(x - size.width/2, y - size.height/2);
	return util.add_tutorial(pos, size, TUTOR_HL);
end

function tutor_use()
	local self = layer_action;
	if nil == self.layer then
		return false;
	end
	if PHASE_PLAY ~= g_phase then
		return false;
	end
	local menu = self.menu;
	if nil == menu then return false; end
	local item = menu:getChildren()[1];
	if nil == item then return false; end

	local x, y = item:getPosition();
	local size = item:getContentSize();
	local scale = item:getScale();
	local pos = cc.p(x-size.width/2, y);
	return util.add_tutorial(pos, size, TUTOR_USE);
end

function tutor_hl_ally()
	local self = layer_card;
	if nil == self.layer then
		return false;
	end
	local list = g_ui_table[g_euser.side][T_ALLY];
	local info = check_hl_in_list(list);
	if nil == info then
		return false;
	end
	local s = info:get_sprite();
	local size = s:getContentSize();
	local x, y = s:getPosition();
	local pos = cc.p(x - size.width/2, y - size.height/2);
	return util.add_tutorial(pos, size, TUTOR_HL_ALLY);
end

function tutor_tap_attack()
	local self = layer_action;
	if nil == self.layer then
		return false;
	end
	if PHASE_PLAY ~= g_phase then
		return false;
	end
	local menu = self.menu;
	if nil == menu then return false; end
	local item = menu:getChildren()[1];
	if nil == item then return false; end

	local x, y = item:getPosition();
	local size = item:getContentSize();
	local scale = item:getScale();
	local pos = cc.p(x-size.width/2, y);
	return util.add_tutorial(pos, size, TUTOR_TAP_ATTACK);
end

function tutor_hl_attarget()
	local self = layer_card;
	if nil == self.layer then
		return false;
	end
	local list = list_attack_target(g_src_index, g_logic_table, g_current_side);
	local index = list[1];
	if nil == index then return false; end
	local info = get_ui_card(index);
	if nil == info then return false; end
	local s = info:get_sprite();
	local size = s:getContentSize();
	local x, y = s:getPosition();
	local pos = cc.p(x - size.width/2, y - size.height/2);
	return util.add_tutorial(pos, size, TUTOR_HL_ATTARGET);
end

function tutor_tap_attarget()
	local self = layer_action;
	if nil == self.layer then
		return false;
	end
	if PHASE_PLAY ~= g_phase then
		return false;
	end
	local menu = self.menu;
	if nil == menu then return false; end
	local item = menu:getChildren()[1];
	if nil == item then return false; end

	local x, y = item:getPosition();
	local size = item:getContentSize();
	local scale = item:getScale();
	local pos = cc.p(x-size.width/2, y);
	return util.add_tutorial(pos, size, TUTOR_TAP_ATTARGET);
end

function tutor_hl_hero()
	local self = layer_card;
	if nil == self.layer then
		return false;
	end
	local info = g_ui_table[g_euser.side][T_HERO][1];
	if nil == info then return false; end
	local kind = check_kind(info.card, g_logic_table, g_current_side, g_phase);
	if kind ~= AKIND_ABILITY and kind ~= AKIND_BOTH then
		return false;
	end
	local s = info:get_sprite();
	--[[
	local h = s:getChildByTag(TAG_HIGHLIGHT);
	if nil == h then return false; end
	local index = cindex(info.card);
	if nil == index then return false; end
	local indexs = list_ability_target(index, g_logic_table, g_current_side, {}, 1);
	if #indexs == 0 then return false; end
	]]--
	local size = s:getContentSize();
	local x, y = s:getPosition();
	local pos = cc.p(x - size.width/2, y - size.height/2);
	return util.add_tutorial(pos, size, TUTOR_HL_HERO);
end

function tutor_tap_abhero()
	local self = layer_action;
	if nil == self.layer then
		return false;
	end
	if PHASE_PLAY ~= g_phase then
		return false;
	end
	local menu = self.menu;
	if nil == menu then return false; end
	local items = menu:getChildren();
	if 0 == #items then return false; end
	local item = items[#items];
	if nil == item then return false; end

	local x, y = item:getPosition();
	local size = item:getContentSize();
	local scale = item:getScale();
	local pos = cc.p(x-size.width/2, y);
	return util.add_tutorial(pos, size, TUTOR_TAP_ABHERO);
end

function tutor_next()
	local self = layer_card;
	if nil == self.layer then
		return false;
	end
	local item = self.btn_next;
	if nil == item then
		return false;
	end
	local x, y = item:getPosition();
	local pos = cc.p(x, y);
	local size = item:getContentSize();
	return util.add_tutorial(pos, size, TUTOR_NEXT);
end

function tutor_first_sac()
	local slist = g_logic_table[g_euser.side][T_ALLY];
	local cur_res = g_logic_table[g_euser.side].resource;
	if false == g_scene:is_stage(STAGE_PVG)
	or PHASE_SACRIFICE ~= g_phase
	or cur_res > 0
	or #slist > 0 then
		return false;
	end

	local self = layer_card;
	if nil == self.layer then
		return false;
	end
	local list = g_ui_table[g_euser.side][T_HAND];
	local info = list[1];
	local card_pos = 1;
	for i=1,#list do
		local card = list[i].card;
		if card.cost > info.card.cost then
			info = list[i];
			card_pos = i;
		end
	end
	if nil == info then
		return false;
	end

	local s = info:get_sprite();
	local size = s:getContentSize();
	local fdata = layer_dragtutorial.get_sprite_data(info:get_sprite(), true);
	info = g_ui_table[g_euser.side][T_RES];
	if nil == info then
		return false;
	end
	local tdata = { x = info.x, y = info.y, width = info.width, height = info.height, use_circle = false };
	local cliplist = { fdata, tdata };
	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT * 3 / 4);
	local tip = tutor_tip(TUTOR_FIRST_SAC);
	local function callback()
		play_game_cmd("s " .. g_euser.side .. "20" .. card_pos);
	end
	local layer, name = layer_dragtutorial:create(cliplist, fdata, tdata, pos, tip, callback);
--	create = function(self, cliplist, fdata, tdata, pos, size, tip, callback)
	
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);

	-- TODO
	util.set_tutor(TUTOR_FIRST_SAC, true, true)
	return true;
end

function tutor_wait_next_sac()
	if false == g_scene:is_stage(STAGE_PVG)
	or #g_logic_table[g_euser.side][T_ALLY] > 0 then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local list = g_ui_table[g_euser.side][T_HAND];
	local min_cost = 10;
	for i = 1, #list do
		if min_cost > list[i].card.cost then
			min_cost = list[i].card.cost;
		end
	end
	local cur_res = g_logic_table[g_euser.side].resource;
	if min_cost <= cur_res then
		return false;
	end

	local info = list[1];

	local s = info:get_sprite();
	local size = s:getContentSize();
	local s_data = layer_dragtutorial.get_sprite_data(info:get_sprite(), false);
	fdata = {
		x = s_data.x + s_data.width * #list / 2 - s_data.width / 4,
		y = s_data.y + s_data.height / 3,
		width = s_data.width * #list + s_data.width / 2,
		height = s_data.height / 3,
		use_circle = false
	};

	local rpos, rsize = get_res_number_area(g_euser.side);

	local resdata = {
		x = rpos.x,
		y = rpos.y,
		width = rsize.width,
		height = rsize.height,
		use_circle = false
	};

	local function callback()
		util.trigger_tutor(TUTOR_WAIT_NEXT)
	end
	local cliplist = { fdata, resdata };
	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT * 3 / 4);
	local tip = tutor_tip(TUTOR_WAIT_NEXT_SAC);
	local layer, name = layer_dragtutorial:create(cliplist, nil, nil, pos, tip, callback);
	
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);

	return true;
end

function tutor_wait_next()
	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local function callback()
		play_game_cmd("n");
		util.set_tutor(TUTOR_WAIT_NEXT_SAC, true, true)
	end
	local item = layer_card.btn_next;
	if nil == item then callback(); return; end
	local fdata = layer_dragtutorial.get_sprite_data(item, false);
	fdata.x = fdata.x + fdata.width/2;
	fdata.y = fdata.y + fdata.height/2;
	local cliplist = { fdata };
	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT * 3 / 4);
	local size = g_ui_table[g_euser.side][T_HAND][1]:get_sprite():getContentSize();
	local tip = tutor_tip(TUTOR_WAIT_NEXT);
	local layer, name = layer_dragtutorial:create(cliplist, fdata, nil, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);
	return true;
end

function tutor_second_sac()
	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end
	local list = g_ui_table[g_euser.side][T_HAND];
	local info = list[1];
	local card_pos = 1;
	for i=1,#list do
		local card = list[i].card;
		if card.cost > info.card.cost then
			info = list[i];
			card_pos = i;
		end
	end
	if nil == info then
		return false;
	end

	local s = info:get_sprite();
	local size = s:getContentSize();
	local fdata = layer_dragtutorial.get_sprite_data(info:get_sprite(), true);
	info = g_ui_table[g_euser.side][T_RES];
	if nil == info then
		return false;
	end
	local tdata = { x = info.x, y = info.y, width = info.width, height = info.height, use_circle = false };
	local cliplist = { fdata, tdata };
	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT * 3 / 4);
	local tip = tutor_tip(TUTOR_SECOND_SAC);
	local function callback()
		play_game_cmd("s " .. g_euser.side .. "20" .. card_pos);
	end
	local layer, name = layer_dragtutorial:create(cliplist, fdata, tdata, pos, tip, callback);
	
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);

	-- TODO
	util.set_tutor(TUTOR_SECOND_SAC, true, true)
	return true;
end

function tutor_highlight_card()
	if false == g_scene:is_stage(STAGE_PVG)
	or #g_ui_table[g_euser.side][T_ALLY] > 0 then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local list = g_ui_table[g_euser.side][T_HAND];
	local slist = {};
	local info = nil;
	local cdata = nil;
	local ally_count = 0;
	for i=1,#list do
		info = list[i];
		local cs = info.sprite;
		local hl = cs:getChildByTag(TAG_HIGHLIGHT);
		if nil ~= hl then
			cdata = layer_dragtutorial.get_sprite_data(info:get_sprite(), true);
			table.insert(slist, cdata);
			ally_count = ally_count + 1;
		end
	end

	if ally_count == 0 then
		return false;
	end

	local s = list[1]:get_sprite();
	local size = s:getContentSize();

	local rpos, rsize = get_res_number_area(g_euser.side);
	local resdata = {
		x = rpos.x,
		y = rpos.y,
		width = rsize.width,
		height = rsize.height,
		use_circle = false
	};
	table.insert(slist, resdata);

	local function callback()
		util.trigger_tutor(TUTOR_SOMMON_CARD)
	end
	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT * 3 / 4);
	local tip = tutor_tip(TUTOR_HIGHLIGHT_CARD);
	local layer, name = layer_dragtutorial:create(slist, nil, nil, pos, tip, callback);
	
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);

	return true;
end


function tutor_summon_card()
	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local cur_res = g_logic_table[g_euser.side].resource;

	local list = g_ui_table[g_euser.side][T_HAND];
	local info = nil;
	local card_pos = -1;
	for i=1,#list do
		local card = list[i].card;
		if card.cost <= cur_res and card.ctype == ALLY then
			info = list[i];
			card_pos = i;
			break;
		end
	end

	if nil == info then
		return false;
	end

	local s = info:get_sprite();
	local size = s:getContentSize();
	local fdata = layer_dragtutorial.get_sprite_data(s, true);

	info = g_ui_table[g_euser.side][T_ALLY];
	if nil == info then
		print("ERROR: ally info nil");
		return false;
	end
	local tdata = {
		x = info.x + info.width / 2 - fdata.width / 2,
		y = info.y,
		width = info.width,
		height = info.height,
		use_circle = false
	};

	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT * 3 / 4);
	local tip = tutor_tip(TUTOR_SOMMON_CARD);
	local cliplist = { fdata, tdata };
	local function callback()
		play_game_cmd("b " .. g_euser.side .. "20" .. card_pos);
		util.set_tutor(TUTOR_HIGHLIGHT_CARD, true, true)
	end
	local layer, name = layer_dragtutorial:create(cliplist, fdata, tdata, pos, tip, callback);
	
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);

	return true;
end

function tutor_wyld_skill()
	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local list = g_ui_table[g_euser.side][T_ALLY];
	local info = nil;
	for i=1, #list do
		local card = list[i].card;
		if card.id == 25 then
			info = list[i];
			break;
		end
	end
	if nil == info then
		return false;
	end

	local s = info:get_sprite();
	local size = s:getContentSize();
	local f_data = layer_dragtutorial.get_sprite_data(info:get_sprite(), true);

	local function callback()
		local flag = false;
		list = g_ui_table[3-g_euser.side][T_ALLY];
		if #list == 0 then
			flag = util.trigger_tutor(TUTOR_NO_TARGET_ATK);
		else
			flag = util.trigger_tutor(TUTOR_ATTACK);
		end
		util.set_tutor(TUTOR_WYLD_SKILL, true, true)

		if false == flag then
			flag = show_svg_help();
		end
	end
	local cliplist = { f_data };
	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT * 3 / 4);
	local tip = tutor_tip(TUTOR_WYLD_SKILL);
	local layer, name = layer_dragtutorial:create(cliplist, nil, nil, pos, tip, callback);
	
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);

	return true;
end

function tutor_no_target_atk()
	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	if #(g_logic_table[3-g_euser.side][T_ALLY] or {}) > 0 then
		return false;
	end

	local apos, asize = get_ally_area(3-g_euser.side);
	local fdata = {
		x = apos.x,
		y = apos.y,
		width = asize.width,
		height = asize.height,
		use_circle = false
	};

	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT * 3 / 4);
	local tip = tutor_tip(TUTOR_NO_TARGET_ATK);
	local cliplist = { fdata };
	function callback()
		local flag = false;
		if false == flag then
			flag = util.trigger_tutor(TUTOR_WAIT_NEXT);
		end
		if false == flag then
			flag = show_svg_help();
		end
	end
	local layer, name = layer_dragtutorial:create(cliplist, nil, nil, pos, tip, callback);
	
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);

	return true;
end

function tutor_rest()

	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local alist = g_ui_table[g_euser.side][T_ALLY];
	local info = nil;
	for i = 1, #alist do
		if alist[i].card.ready == 0 and alist[i].card.id ~= 25 then
			info = alist[i];
			break;
		end
	end

	if nil == info then
		return false;
	end

	local s = info:get_sprite();
	local size = s:getContentSize();
	local s_data = layer_dragtutorial.get_sprite_data(info:get_sprite(), false);
	local fdata = {
		x = s_data.x + s_data.width / 3,
		y = s_data.y + s_data.height / 3,
		width = s_data.width * 3 / 4,
		height = s_data.height / 2,
		use_circle = false
	};

	local cliplist = { fdata };
	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT * 3 / 4);
	local tip = tutor_tip(TUTOR_REST);
	function callback()
		util.trigger_tutor(TUTOR_WAIT_NEXT)
	end
	local layer, name = layer_dragtutorial:create(cliplist, nil, nil, pos, tip, callback);
	
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);

	-- TODO
	util.set_tutor(TUTOR_REST, true, true);
	return true;
end

function tutor_attack()
	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local tlist = g_ui_table[3-g_euser.side][T_ALLY];
	if #tlist == 0 then
		return false;
	end

	local list = g_ui_table[g_euser.side][T_ALLY];
	local info = nil;
	local card_pos = -1;
	for i=1,#list do
		local card = list[i].card;
		if check_ready_attack(card) then
			info = list[i];
			card_pos = i;
			break;
		end
	end

	if nil == info then
		return false;
	end

	local s = info:get_sprite();
	local size = s:getContentSize();
	local fdata = layer_dragtutorial.get_sprite_data(s, true);

	info = tlist[1];
	if nil == info then
		return false;
	end
	local tdata = layer_dragtutorial.get_sprite_data(info:get_sprite(), true);

	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT * 3 / 4);
	local tip = tutor_tip(TUTOR_ATTACK);
	local cliplist = { fdata, tdata };
	local function callback()
		play_game_cmd("t " .. g_euser.side .. "30" .. card_pos .. " " .. (3-g_euser.side) .. "301");
		util.set_tutor(TUTOR_ATTACK, true, true)
	end
	local layer, name = layer_dragtutorial:create(cliplist, fdata, tdata, pos, tip, callback);
	
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);

	return true;

end

function tutor_intro()
	if false == g_scene:is_stage(STAGE_PVG)
	or g_round > 2 or g_euser.level > 1 then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local function callback()
		util.trigger_tutor(TUTOR_AREA);
	end
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local tip = tutor_tip(TUTOR_INTRO);
	local layer, name = layer_dragtutorial:create(nil, nil, nil, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);
	return true;
end

function tutor_area()
	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local function callback()
		util.trigger_tutor(TUTOR_AREA_RES);
	end
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local tip = tutor_tip(TUTOR_AREA);
	local layer, name = layer_dragtutorial:create(nil, nil, nil, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);
	return true;
end

function tutor_area_res()
	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local dpos, dsize = get_res_area(SIDE_DOWN);
	local ddata = {
		x = dpos.x,
		y = dpos.y + dsize.height/2,
		width = dsize.width,
		height = dsize.height,
		use_circle = false
	};
	local upos, usize = get_res_area(SIDE_UP);
	local udata = {
		x = upos.x,
		y = upos.y,
		width = usize.width,
		height = usize.height,
		use_circle = false
	};

	local cliplist = { ddata, udata };

	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local tip = tutor_tip(TUTOR_AREA_RES);
	function callback()
		util.trigger_tutor(TUTOR_AREA_HAND);
	end
	local layer, name = layer_dragtutorial:create(cliplist, nil, nil, nil, tip, callback);
	
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);

	return true;
end

function tutor_area_hand()
	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local dpos, dsize = get_hand_area(SIDE_DOWN);
	local ddata = {
		x = dpos.x,
		y = dpos.y,
		width = dsize.width,
		height = dsize.height,
		use_circle = false
	};
	local upos, usize = get_hand_area(SIDE_UP);
	local udata = {
		x = upos.x,
		y = upos.y,
		width = usize.width,
		height = usize.height,
		use_circle = false
	};

	local cliplist = { ddata, udata };

	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local tip = tutor_tip(TUTOR_AREA_HAND);
	function callback()
		util.trigger_tutor(TUTOR_AREA_HERO);
	end
	local layer, name = layer_dragtutorial:create(cliplist, nil, nil, pos, tip, callback);
	
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);

	return true;
end

function tutor_area_hero()
	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local dpos, dsize = get_hero_area(SIDE_DOWN);
	local ddata = {
		x = dpos.x,
		y = dpos.y,
		width = dsize.width,
		height = dsize.height,
		use_circle = true
	};
	local upos, usize = get_hero_area(SIDE_UP);
	local udata = {
		x = upos.x,
		y = upos.y,
		width = usize.width,
		height = usize.height,
		use_circle = true
	};

	local cliplist = { ddata, udata };

	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local tip = tutor_tip(TUTOR_AREA_HERO);
	function callback()
		util.trigger_tutor(TUTOR_AREA_DECK);
	end
	local layer, name = layer_dragtutorial:create(cliplist, nil, nil, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);
	return true;
end

function tutor_area_deck()
	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local dpos, dsize = get_deck_area(SIDE_DOWN);
	local ddata = {
		x = dpos.x,
		y = dpos.y,
		width = dsize.width,
		height = dsize.height,
		use_circle = true
	};

	local cliplist = { ddata };

	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local tip = tutor_tip(TUTOR_AREA_DECK);
	function callback()
		util.trigger_tutor(TUTOR_AREA_SPACE);
	end
	local layer, name = layer_dragtutorial:create(cliplist, nil, nil, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);
	return true;
end

function tutor_area_space()
	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end

	local dpos, dsize = get_space_area(SIDE_DOWN);
	local ddata = {
		x = dpos.x,
		y = dpos.y,
		width = dsize.width,
		height = dsize.height,
		use_circle = false
	};
	local upos, usize = get_space_area(SIDE_UP);
	local udata = {
		x = upos.x,
		y = upos.y,
		width = usize.width,
		height = usize.height,
		use_circle = false
	};

	local cliplist = { ddata, udata };

	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT * 7 / 8);
	local tip = tutor_tip(TUTOR_AREA_SPACE);
	function callback()
		util.trigger_tutor(TUTOR_TURN_SAC);
	end
	local layer, name = layer_dragtutorial:create(cliplist, nil, nil, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);
	return true;
end

function tutor_turn_sac()

	if false == g_scene:is_stage(STAGE_PVG) then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end
	local info = layer_table.phase
	if nil == info then
		return false;
	end
	local f_data = layer_dragtutorial.get_sprite_data(info, false);

	local cliplist = { f_data }
	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT * 3 / 4);
	local tip = tutor_tip(TUTOR_TURN_SAC);
	function callback()
		util.set_tutor(TUTOR_INTRO, true, true)
		util.trigger_tutor(TUTOR_FIRST_SAC);
	end
	local layer, name = layer_dragtutorial:create(cliplist, nil, nil, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);
	return true;
end

function show_svg_help()
	if false == g_scene:is_stage(STAGE_PVG) or nil ~= g_net_win_data then
		return false;
	end
	local self = layer_card;
	if nil == self.layer then
		return false;
	end
	if g_euser.level >= 5 then
		return false;
	end

	local tips = '';

	local cur_res = g_logic_table[g_euser.side].resource;
	local list = g_ui_table[g_euser.side][T_HAND];
	local info = nil;
	for i=1,#list do
		local card = list[i].card;
		if card.cost <= cur_res and card.ctype == ALLY then
			info = list[i];
			break;
		end
	end
	if nil ~= info then
		tips = tips .. "\n召唤新卡牌上场";
	end

	local tlist = g_ui_table[3-g_euser.side][T_ALLY];
	local list = g_ui_table[g_euser.side][T_ALLY];
	info = nil;
	if #tlist > 0 then
		for i=1,#list do
			local card = list[i].card;
			if check_ready_attack(card) then
				info = list[i];
				break;
			end
		end
	end
	if nil ~= info then
		tips = tips .. "\n盟军进行攻击";
	end

	if 0 == string.len(tips) then
		tip_tap_next();
		tips = "无可选择行为，结束回合";
	else
		tips = "可选择行为：" .. tips;
	end
	layer_card:show_tip_help(tips);
	return true;
end

function tutor_pvp_can_attack()
	print("tutor_pvp_can_attack");
	if false == g_scene:is_stage(STAGE_PVP) then
		return false;
	end
	if nil == g_euser.room_data then
		return false;
	end
	local guest_list = g_euser.room_data.guest_list or {};
	local info = guest_list[3-g_euser.side];
	if nil == info then return false; end
	if info.eid >= 500 then return false; end

	print("pvp check atk:" ..  info.eid);
	local list = g_ui_table[g_euser.side][T_ALLY];
	info = nil;
	local thero = nil;
	local findex = nil;
	local tindex = nil;
	for i=1,#list do
		local card = list[i].card;
		findex = cindex(card);
		print("findex: " , findex);
		local tlist = list_attack_target(findex, g_logic_table, g_current_side);
		for j = 1, #tlist do
			tindex = tlist[j];
			print("tindex:" , tindex);
			local tb = index_table_num(tindex);
			if tb == T_HERO then
				info = list[i];
				thero = g_ui_table[3-g_euser.side][T_HERO][1];
				break;
			end
		end
	end
	print("findex: ", findex, " tindex:", tindex);

	if nil == info or nil == thero then
		return false;
	end

	local tdata = layer_dragtutorial.get_sprite_data(thero:get_sprite(), true);

	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT / 4);
	local tip = tutor_tip(TUTOR_PVP_CAN_ATTACK);
	local cliplist = { tdata };
	local function callback()
		util.trigger_tutor(TUTOR_PVP_ATTACK);
		util.set_tutor(TUTOR_PVP_CAN_ATTACK, true, true)
	end
	local layer, name = layer_dragtutorial:create(cliplist, nil, nil, pos, tip, callback);
	
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);

	return true;

end

function tutor_pvp_attack()
	if false == g_scene:is_stage(STAGE_PVP) then
		return false;
	end
	if nil == g_euser.room_data then
		return false;
	end
	local guest_list = g_euser.room_data.guest_list or {};
	local info = guest_list[3-g_euser.side];
	if nil == info then return false; end
	if info.eid >= 500 then return false; end

	local list = g_ui_table[g_euser.side][T_ALLY];
	info = nil;
	local thero = nil;
	local findex = nil;
	local tindex = nil;
	for i=1,#list do
		local card = list[i].card;
		findex = cindex(card);
		local tlist = list_attack_target(findex, g_logic_table, g_euser.side);
		for j = 1, #tlist do
			tindex = tlist[j];
			local tb = index_table_num(tindex);
			if tb == T_HERO then
				info = list[i];
				thero = g_ui_table[3-g_euser.side][T_HERO][1];
				break;
			end
		end
	end

	if nil == info or nil == thero then
		return false;
	end

	local s = info:get_sprite();
	local size = s:getContentSize();
	local fdata = layer_dragtutorial.get_sprite_data(s, true);
	local tdata = layer_dragtutorial.get_sprite_data(thero:get_sprite(), true);

	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT / 8);
	local tip = tutor_tip(TUTOR_PVP_ATTACK);
	local cliplist = { fdata, tdata };
	local function callback()
		play_game_cmd("t " .. findex .. " " .. tindex);
		util.set_tutor(TUTOR_PVP_ATTACK, true, true)
	end
	local layer, name = layer_dragtutorial:create(cliplist, fdata, tdata, pos, tip, callback);
	
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);

	return true;
end


function tutor_pay_ad()
	if false == g_scene:is_stage(STAGE_MAP) then
		return false;
	end
	--if g_euser.level > 5 then return false; end

	local btn = layer_map.btn_lottery;
	if nil == btn then return false; end
	local fdata = layer_dragstory.get_sprite_data(btn, false);
	local function callback()
		g_tutor_wait_net = tutor_pay_ad_2;
		show_lottery();
		--tutor_pay_ad_2();
	end
	fdata.x = fdata.x + fdata.width/2;
	fdata.y = fdata.y + fdata.height/2;
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);

	return true;
end

function tutor_pay_ad_2()
	g_tutor_wait_net = nil;
	local function callback()
		local info = layer_lottery.list[1];
		if nil ~= info then
			--g_scene:add_layer(ZORDER_LAYER_POPCLIST, layer_popclist:create({},true));
			--tutor_pay_ad_3();
			g_tutor_wait_net = tutor_pay_ad_3;
			--layer_popclist.after_eff();
			layer_lottery:do_it(1);
		end
		return;
	end
	if nil == layer_lottery.layer then callback(); return; end
	if 0 == #(layer_lottery.list or {}) then callback(); return; end
	local width = layer_lottery.cwidth;
	local height = layer_lottery.cheight;
	local th = layer_lottery.theight;
	local x, y = layer_lottery.tableview:getPosition();
	local fdata = { x=x+width/2, y=y+th-height+height/2, width=width, height=height, use_circle=false };
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function tutor_pay_ad_3()
	g_tutor_wait_net = nil;
	local btn = layer_popclist.btn_back;
	if nil == btn then return false; end
	local fdata = layer_dragstory.get_sprite_data(btn, false);
	local function callback()
		layer_popclist.back();
		tutor_pay_ad_4();
	end
	fdata.x = fdata.x;
	fdata.y = fdata.y + fdata.height/2;
	local cliplist = { fdata };
	local info = layer_popclist.list[1];
	print('1 : ', info);
	if nil ~= info then
		local cinfo = info.info;
	print('2 : ', cinfo);
		if nil ~= cinfo then
			local scale = info.scale;
			local dd = layer_dragstory.get_sprite_data(cinfo.sprite, false);
			table.insert(cliplist, dd);
		end
	end
	--local layer, name = layer_dragstory:create(fdata, nil, callback);
	local layer, name = layer_dragtutorial:create(cliplist, fdata, nil, nil, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function tutor_pay_ad_4()
	local function callback()
		show_pay_ad();
		return;
	end
	if nil == layer_lottery.layer then callback(); return; end
	if 1 >= #(layer_lottery.list or {}) then callback(); return; end
	local width = layer_lottery.cwidth;
	local height = layer_lottery.cheight;
	local th = layer_lottery.theight;
	local x, y = layer_lottery.tableview:getPosition();
	local fdata = { x=x+width/2, y=y+th-2*height+height/2, width=width, height=height, use_circle=false };
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function tutor_pay()
	local function callback()
		util.set_tutor(TUTOR_PAY, true, true);
	end
	if nil == layer_pay.layer then return false; end
	if 0 == #(layer_pay.list or {}) then return false; end
	local width = layer_pay.cwidth;
	local height = layer_pay.cheight;
	local th = layer_pay.theight;
	local x, y = layer_pay.tableview:getPosition();
	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT/8*7);
	local fdata = { x=x+width/2, y=y+th-height+height/2, width=width, height=height, use_circle=false };
	local cliplist = { fdata };
	local tip = "购买后获得100水晶并成为月卡会员资格,月卡会员可每日获得100水晶(价值10元)赠送";
	local layer, name = layer_dragtutorial:create(cliplist, fdata, nil, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	return true;
end

function tutor_deck()
	local btn = layer_map.btn_deck;
	if nil == btn then return false; end
	local fdata = layer_dragstory.get_sprite_data(btn, false);
	local function callback()
		g_tutor_wait_net = tutor_deck_2;
		--g_scene:go(GUI_DECK, "deck");
		g_scene:deck();
		--tutor_deck_2();
	end
	fdata.x = fdata.x + fdata.width/2;
	fdata.y = fdata.y + fdata.height/2;
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);

	return true;
end

function tutor_deck_2()
	g_tutor_wait_net = nil;
	local function callback()
		local self = layer_deck;
		local info = self.list_slot[1];
		if nil == info then return; end
		self:move_card('slot', 'deck', info.card, 1);
		tutor_deck_3();
	end
	if nil == layer_deck.layer then return; end
	if 0 == #(layer_deck.list_deck or {}) then return; end
	if 0 == #(layer_deck.list_slot or {}) then return; end
	local width = layer_deck.cwidth_slot;
	local height = layer_deck.cheight_slot;
	local x, y = layer_deck.tableview_slot:getPosition();
	local twidth = layer_deck.twidth_slot;
	local fdata = { x=x+width/2, y=y+height/2, width=width, height=height, use_circle=false };
	width = layer_deck.cwidth_deck;
	height = layer_deck.cheight_deck;
	x, y = layer_deck.tableview_deck:getPosition();
	twidth = layer_deck.twidth_deck;
	local tdata = { x=x+twidth/2, y=y+height/2, width=twidth, height=height, use_circle=false };
	local layer, name = layer_dragstory:create(fdata, tdata, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function tutor_deck_3()
	local btn = layer_deck.btn_back;
	if nil == btn then return false; end
	local fdata = layer_dragstory.get_sprite_data(btn, false);
	local function callback()
		layer_deck.callback_ask_return();
		tutor_deck_4();
	end
	fdata.x = fdata.x + fdata.width/2;
	fdata.y = fdata.y + fdata.height/2;
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);

	return true;
end

function tutor_deck_4()
	local btn = layer_tip.btn_confirm;
	if nil == btn then return false; end
	local fdata = layer_dragstory.get_sprite_data(btn, false);
	local function callback()
		layer_tip.confirm();
	end
	local bg = layer_tip.bg;
	local bx, by = bg:getPosition();
	local bsize = bg:getContentSize();
	fdata.x = fdata.x + bx - bsize.width/2;
	fdata.y = fdata.y + fdata.height/2 + by - bsize.height/2;
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);

	return true;
end

function cft_1()
	local thand = g_ui_table[g_euser.side][T_HAND];
	local info = thand[1];
	if nil == info then return false; end
	local function callback()
		play_game_cmd("s 1201");
	end
	local fdata = layer_dragstory.get_sprite_data(info:get_sprite(), true);
	local cwidth = CARD_SIZE_2.width;
	local tally = g_ui_table[g_euser.side][T_ALLY];
	local tdata = { x = tally.x-cwidth/2+tally.width/2, y = tally.y, width = tally.width, height = tally.height, use_circle = false };
	local tsupp = g_ui_table[g_euser.side][T_SUPPORT];
	local t1 = { x = tsupp.x-cwidth/2+tsupp.width/2, y = tsupp.y, width = tsupp.width, height = tsupp.height, use_circle = false };
	local tres = g_ui_table[g_euser.side][T_RES];
	local t2 = { x = tres.x, y = tres.y, width = tres.width, height = tres.height, use_circle = false };
	local cliplist = { fdata, tdata, t1, t2 };
	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT/4*3);
	local tip = "弃牌，增加资源！";
	local layer, name = layer_dragtutorial:create(cliplist, fdata, tdata, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);
	return true;
end

function cft_2()
	local thand = g_ui_table[g_euser.side][T_HAND];
	local info = nil;
	for i = 1, #thand do
		local d = thand[i];
		local s = d:get_sprite();
		local h = s:getChildByTag(TAG_HIGHLIGHT);
		if nil ~= h then
			info = d;
			break;
		end
	end
	if nil == info then return false; end
	local index = cindex(info.card);
	local function callback()
		play_game_cmd(string.format("b %d", index));
	end
	local kind = check_kind(info.card, g_logic_table, g_current_side, g_phase);
	local frame = nil;
	if kind == AKIND_TALLY then
		frame = g_ui_table[g_euser.side][T_ALLY];
	elseif kind == AKIND_TSUPPORT then
		--frame = g_ui_table[g_euser.side][T_SUPPORT];
		frame = g_ui_table[g_euser.side][T_ALLY];
	else
		return false;
	end
	local cwidth = CARD_SIZE_2.width;
	local tdata = { x = frame.x-cwidth/2+frame.width/2, y = frame.y, width = frame.width, height = frame.height, use_circle = false };
	local fdata = layer_dragstory.get_sprite_data(info:get_sprite(), true);
	local tres = g_ui_table[g_euser.side][T_RES];
	local t1 = { x = tres.x, y = tres.y, width = tres.width, height = tres.height, use_circle = false };
	local cliplist = { fdata, tdata, t1 };
	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT/4*3);
	local tip = "出牌，消耗资源使用卡牌！";
	local layer, name = layer_dragtutorial:create(cliplist, fdata, tdata, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);
	return true;
end

function cft_3()
	local tally = g_ui_table[g_euser.side][T_ALLY];
	local info = nil;
	for i = 1, #tally do
		local d = tally[i];
		local s = d:get_sprite();
		local h = s:getChildByTag(TAG_HIGHLIGHT);
		if nil ~= h then
			info = d;
			break;
		end
	end
	if nil == info then return false; end
	local index = cindex(info.card);
	local callback = nil;
	local tinfo = nil;
	local kind = check_kind(info.card, g_logic_table, g_current_side, g_phase);
	if kind == AKIND_ABILITY then
		callback = function()
			play_game_cmd(string.format("b %d", index));
		end
		local num;
		local err;
		num, err = total_target(index, g_logic_table, g_current_side)
		local tlist=list_ability_target(index,g_logic_table,g_current_side,{},1);
		if 0 == #tlist and num == 0 then 
			callback = function()
				if 0 == #tlist then
					local layer = layer_action:create(info);
					g_scene:add_layer(ZORDER_LAYER_ACTION, layer, name);
					cft_5_tap_hl_action();
					return;
				end
			end
		else
			local tindex = tlist[1];
			if #tlist > 1 and T_HERO == index_table_num(tindex) then
				tindex = tlist[2];
			end
			tinfo = get_ui_card(tindex);
			callback = function()
				if num > 1 then
					hl_ab_target(index, "action");
					action_target(layer_card,TYPE_ABILITY,g_src_index,tindex,true);
					cft_5_tap_hl_card();
					return;
				end
				play_game_cmd(string.format("b %d %d", index, tindex));
			end
		end
	elseif kind == AKIND_ATTACK then
		local tlist = list_attack_target(index, g_logic_table, g_current_side);
		if 0 == #tlist then return false; end
		local tindex = tlist[1];
		if #tlist > 1 and T_HERO == index_table_num(tindex) then
			tindex = tlist[2];
		end
		tinfo = get_ui_card(tindex);
		callback = function()
			play_game_cmd(string.format("t %d %d", index, tindex));
		end
	else
		return false;
	end
	local fdata = layer_dragstory.get_sprite_data(info:get_sprite(), true);
	local tdata = nil;
	if nil ~= tinfo then
		tdata = layer_dragstory.get_sprite_data(tinfo:get_sprite(), true);
	end
	local cliplist = { fdata, tdata };
	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT/4*3);
	local tip = "攻击，消灭敌人！";
	local layer, name = layer_dragtutorial:create(cliplist, fdata, tdata, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);
	return true;
end

function cft_4()
	local info = g_ui_table[g_euser.side][T_HERO][1];
	if nil == info then return false; end
	local index = cindex(info.card);
	local callback = nil;
	local tinfo = nil;
	local kind = check_kind(info.card, g_logic_table, g_current_side, g_phase);
	if kind == AKIND_ABILITY then
		callback = function()
			play_game_cmd(string.format("b %d", index));
		end
		local num;
		local err;
		num, err = total_target(index, g_logic_table, g_current_side)
		local tlist=list_ability_target(index,g_logic_table,g_current_side,{},1);
		if 0 == #tlist and num == 0 then 
			callback = function()
				if 0 == #tlist then
					local layer = layer_action:create(info);
					g_scene:add_layer(ZORDER_LAYER_ACTION, layer, name);
					cft_5_tap_hl_action();
					return;
				end
			end
		else
			local tindex = tlist[1];
			if #tlist > 1 and T_HERO == index_table_num(tindex) then
				tindex = tlist[2];
			end
			tinfo = get_ui_card(tindex);
			callback = function()
				if num > 1 then
					hl_ab_target(index, "action");
					action_target(layer_card,TYPE_ABILITY,g_src_index,tindex,true);
					cft_5_tap_hl_card();
					return;
				end
				play_game_cmd(string.format("b %d %d", index, tindex));
			end
		end
	elseif kind == AKIND_ATTACK then
		local tlist = list_attack_target(index, g_logic_table, g_current_side);
		if 0 == #tlist then return false; end
		local tindex = tlist[1];
		if #tlist > 1 and T_HERO == index_table_num(tindex) then
			tindex = tlist[2];
		end
		tinfo = get_ui_card(tindex);
		callback = function()
			play_game_cmd(string.format("t %d %d", index, tindex));
		end
	else
		return false;
	end
	local fdata = layer_dragstory.get_sprite_data(info:get_sprite(), true);
	local tdata = nil;
	if nil ~= tinfo then
		tdata = layer_dragstory.get_sprite_data(tinfo:get_sprite(), true);
	end
	local cliplist = { fdata, tdata };
	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT/4*3);
	local tip = "使用英雄技能，秒杀敌人！";
	local layer, name = layer_dragtutorial:create(cliplist, fdata, tdata, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);
	return true;
end

function cft_5_tap_hl_action()
	local info = layer_action.obj;
	if nil == info then
		return false;
	end
	local function callback()
		local index = cindex(info.card);
		play_game_cmd(string.format("b %d", index));
	end
	local x = FULL_WIDTH/2-15;
	local y = hfix(120)-15;
	local s = cc.size(150, 53);
	local w = s.width+30;
	local h = s.height+30;
	local fdata = { x=x, y=y+h/2, width=w, height=h, use_circle=false };
	local cliplist = { fdata };
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local tip = "发动技能吧";
	local layer, name = layer_dragtutorial:create(cliplist, fdata, nil, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);
	return true;
end

function cft_5_tap_hl_target()
	local info = layer_action.obj;
	if nil == info then
		return false;
	end
	local function callback()
		local tindex = cindex(info.card);
		action_target(layer_card,TYPE_ABILITY,g_src_index,tindex,true);
		if nil ~= g_src_index then
			cft_5_tap_hl_card();
			return;
		end
	end
	local x = FULL_WIDTH/2-15;
	local y = hfix(120)-15;
	local s = cc.size(150, 53);
	local w = s.width+30;
	local h = s.height+30;
	local fdata = { x=x, y=y+h/2, width=w, height=h, use_circle=false };
	local cliplist = { fdata };
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local tip = "选择更多目标";
	local layer, name = layer_dragtutorial:create(cliplist, fdata, nil, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);
	return true;
end

function cft_5_tap_hl_card()
	local info = nil;
	local d = g_ui_table[3-g_euser.side][T_HERO][1];
	local s = d:get_sprite();
	local h = s:getChildByTag(TAG_HIGHLIGHT);
	if nil ~= h then
		info = d;
	end
	if nil == info then
		local t = g_ui_table[3-g_euser.side][T_ALLY];
		for i = 1, #t do
			d = t[i];
			s = d:get_sprite();
			h = s:getChildByTag(TAG_HIGHLIGHT);
			if nil ~= h then
				info = d;
				break;
			end
		end
	end
	if nil == info then return false; end
	local index = cindex(info.card);
	local function callback()
		local layer = layer_action:create(info);
		g_scene:add_layer(ZORDER_LAYER_ACTION, layer, name);
		cft_5_tap_hl_target();
	end
	local fdata = layer_dragstory.get_sprite_data(info:get_sprite(), true);
	local cliplist = { fdata };
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local tip = "选择更多目标";
	local layer, name = layer_dragtutorial:create(cliplist, fdata, nil, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);
	return true;
end

function cft_5()
	local thand = g_ui_table[g_euser.side][T_HAND];
	local info = nil;
	for i = 1, #thand do
		local d = thand[i];
		local s = d:get_sprite();
		local h = s:getChildByTag(TAG_HIGHLIGHT);
		if nil ~= h then
			info = d;
			break;
		end
	end
	if nil == info then return false; end
	local index = cindex(info.card);
	local callback = nil;
	local tinfo = nil;
	local kind = check_kind(info.card, g_logic_table, g_current_side, g_phase);
	if kind == AKIND_ABILITY then
		callback = function()
			play_game_cmd(string.format("b %d", index));
		end
		local num;
		local err;
		num, err = total_target(index, g_logic_table, g_current_side)
		local tlist=list_ability_target(index,g_logic_table,g_current_side,{},1);
		if 0 == #tlist and num == 0 then 
			callback = function()
				if 0 == #tlist then
					local layer = layer_action:create(info);
					g_scene:add_layer(ZORDER_LAYER_ACTION, layer, name);
					cft_5_tap_hl_action();
					return;
				end
			end
		else
			local tindex = tlist[1];
			if #tlist > 1 and T_HERO == index_table_num(tindex) and info.card.id ~= 71 then
				tindex = tlist[2];
			end
			tinfo = get_ui_card(tindex);
			callback = function()
				if num > 1 then
					hl_ab_target(index, "action");
					action_target(layer_card,TYPE_ABILITY,g_src_index,tindex,true);
					cft_5_tap_hl_card();
					return;
				end
				play_game_cmd(string.format("b %d %d", index, tindex));
			end
		end
	else
		return false;
	end
	local fdata = layer_dragstory.get_sprite_data(info:get_sprite(), true);
	local tdata = nil;
	if nil ~= tinfo then
		tdata = layer_dragstory.get_sprite_data(tinfo:get_sprite(), true);
	end
	local cliplist = { fdata, tdata };
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local tip;
	if info.card.id == 67 then
		tip = "虚弱敌人!";
	elseif info.card.id == 64 then
		tip = "破坏敌人装备!";
	else
		tip = "拖动选择目标";
	end
	local layer, name = layer_dragtutorial:create(cliplist, fdata, tdata, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);
	return true;
end

function cft_6()
	local tsupp = g_ui_table[g_euser.side][T_SUPPORT];
	local info = nil;
	for i = 1, #tsupp do
		local d = tsupp[i];
		local s = d:get_sprite();
		local h = s:getChildByTag(TAG_HIGHLIGHT);
		if nil ~= h then
			info = d;
			break;
		end
	end
	if nil == info then return false; end
	local index = cindex(info.card);
	local callback = nil;
	local tinfo = nil;
	local kind = check_kind(info.card, g_logic_table, g_current_side, g_phase);
	if kind == AKIND_ABILITY then
		callback = function()
			play_game_cmd(string.format("b %d", index));
		end
		local num;
		local err;
		num, err = total_target(index, g_logic_table, g_current_side)
		local tlist=list_ability_target(index,g_logic_table,g_current_side,{},1);
		if 0 == #tlist and num == 0 then 
			callback = function()
				if 0 == #tlist then
					local layer = layer_action:create(info);
					g_scene:add_layer(ZORDER_LAYER_ACTION, layer, name);
					cft_5_tap_hl_action();
					return;
				end
			end
		else
			local tindex = tlist[1];
			if #tlist > 1 and T_HERO == index_table_num(tindex) then
				tindex = tlist[2];
			end
			tinfo = get_ui_card(tindex);
			callback = function()
				if num > 1 then
					hl_ab_target(index, "action");
					action_target(layer_card,TYPE_ABILITY,g_src_index,tindex,true);
					cft_5_tap_hl_card();
					return;
				end
				play_game_cmd(string.format("b %d %d", index, tindex));
			end
		end
	else
		return false;
	end
	local fdata = layer_dragstory.get_sprite_data(info:get_sprite(), true);
	local tdata = nil;
	if nil ~= tinfo then
		tdata = layer_dragstory.get_sprite_data(tinfo:get_sprite(), true);
	end
	local cliplist = { fdata, tdata };
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local tip = "使用技能牌吧";
	local layer, name = layer_dragtutorial:create(cliplist, fdata, tdata, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);
	return true;
end

function cft_tip_tap(btn, is_force)
	if nil == btn then return false; end
	local scale = btn:getScale();
	local size = btn:getContentSize();
	local x1 = 0;
	local x2 = size.width * scale;
	local y1 = 0;
	local y2 = size.height * scale;
	local speed = 250;
	local tx = (x2 - x1) / speed;
	local ty = (y2 - y1) / speed;
	local path, pos, array;

	local sprite = btn:getChildByTag(TAG_BTN_NEXT_EFF_1);
	if nil == sprite then
		path = util.get_path('tutor_star.png');
		pos = cc.p(x1, y1);
		sprite = util.add_sprite(btn, path, pos, ANCHOR_CENTER_CENTER, 40);
		sprite:setTag(TAG_BTN_NEXT_EFF_1);

		array = {};
		table.insert(array, cc.MoveTo:create(ty, cc.p(x1, y2)));
		table.insert(array, cc.MoveTo:create(tx, cc.p(x2, y2)));
		table.insert(array, cc.MoveTo:create(ty, cc.p(x2, y1)));
		table.insert(array, cc.MoveTo:create(tx, cc.p(x1, y1)));
		sprite:runAction(cc.RepeatForever:create(cc.Sequence:create(array)));
		sprite:runAction(cc.RepeatForever:create(cc.RotateBy:create(1, 360)));
	end

	sprite = btn:getChildByTag(TAG_BTN_NEXT_EFF_2);
	if nil == sprite then
		path = util.get_path('tutor_tail.plist');
		pos = cc.p(x1, y1);
		local p = util.add_particle(btn, path, pos, 20);
		sprite = p.batch;
		sprite:setTag(TAG_BTN_NEXT_EFF_2);

		array = {};
		table.insert(array, cc.MoveTo:create(ty, cc.p(x1, y2)));
		table.insert(array, cc.MoveTo:create(tx, cc.p(x2, y2)));
		table.insert(array, cc.MoveTo:create(ty, cc.p(x2, y1)));
		table.insert(array, cc.MoveTo:create(tx, cc.p(x1, y1)));
		sprite:runAction(cc.RepeatForever:create(cc.Sequence:create(array)));
	end

	if true == is_force then return; end
	sprite = btn:getChildByTag(TAG_BTN_NEXT_EFF_3);
	if nil == sprite then
		pos = cc.p(x2/2, y2/2);
		sprite = util.play_frame(btn, 'tutor_finger', pos, ANCHOR_LEFT_CENTER, 0.2, 70, true);
		sprite:setTag(TAG_BTN_NEXT_EFF_3);
	end
	return true;
end

function cft_force_tap(btn, tip, callback)
	tip = tip or "点击";
	if nil == btn then return false; end
	local fdata = layer_dragstory.get_sprite_data(btn, false);
	fdata.x = fdata.x + fdata.width/2;
	fdata.y = fdata.y + fdata.height/2;
	local cliplist = { fdata };
	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT/4*3);
	local layer, name = layer_dragtutorial:create(cliplist, fdata, nil, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGTUTOR, layer, name);
	return true;
end

function tip_tap_next(is_force)
	local btn = layer_card.btn_next;
	if true == is_force then
		local tip = "结束本回合操作。";
		cft_force_tap(btn, tip, function()
			layer_card.callback_next_side(nil, btn);
		end);
	end
	return cft_tip_tap(btn, is_force);
end

function tip_tap_skip(is_force)
	local btn = layer_card.btn_skip;
	if true == is_force then
		local thand = g_ui_table[g_euser.side][T_HAND];
		local tip;
		if #thand == 0 then
			tip = "没手牌了，跳过弃牌吧。";
		else
			tip = "手牌不多了，跳过弃牌吧。";
		end
		cft_force_tap(btn, tip, function()
			layer_card.callback_skip_sac(nil, btn);
		end);
	end
	return cft_tip_tap(btn, is_force);
end

-- return true means has do any action
function check_for_teach()
	local ret;
	---------- for battle --------
	if g_euser.side ~= g_current_side then return false; end
	-- in sacrifice
	if PHASE_SACRIFICE == g_phase then
		local thand = g_ui_table[g_euser.side][T_HAND];
		if #thand <= 1 then
			return tip_tap_skip(true);
		end
		return cft_1();
	end
	-- in play
	-- hero ability or attack
	ret = cft_4();
	if true == ret then return true; end
	-- check hand available card type
	local thand = g_ui_table[g_euser.side][T_HAND];
	local info = nil;
	for i = 1, #thand do
		local d = thand[i];
		local s = d:get_sprite();
		local h = s:getChildByTag(TAG_HIGHLIGHT);
		if nil ~= h then
			info = d;
			break;
		end
	end
	if nil ~= info then
		local ctype = info.card.ctype;
		-- hand to ally or support
		ret = cft_2();
		if true == ret then return true; end
		--[[
		if ctype == ALLY or ctype == SUPPORT or ctype == WEAPON or ctype == ARMOR or ctype == ARTIFACT or ctype == TRAP or kind == AKIND_TSUPPORT or kind == AKIND_TALLY then
			-- hand to ally or support
			ret = cft_2();
			if true == ret then return true; end
		end
		]]--
		-- hand ability
		ret = cft_5();
		if true == ret then return true; end
	end
	-- ally ability or attack
	ret = cft_3();
	if true == ret then return true; end
	-- use card in support
	ret = cft_6();
	if true == ret then return true; end
	if g_round > 2 then
		return tip_tap_next();
	else
		return tip_tap_next(true);
	end
end

function tutor_show_dialog(dialog_list, callback)
	if 0 == #(dialog_list or {}) then
		if nil ~= callback then
			callback();
		end
		return;
	end
	local layer, name = layer_dialog:create(dialog_list, callback);
	g_scene:add_layer(ZORDER_LAYER_DIALOG, layer, name);
	return true;
end

function tutor_first_intro(ts)
	local actor = { name = "安娜导师", icon = 8 };
	local list_tip = {
		"欢迎来到《梦想召唤师》，在开始冒险前，首先要学习成为一个召唤师。",
	};
	local function callback()
		util.set_tutor(ts, true, true);
		tutor_tap_chapter();
	end
	local layer, name = layer_story:create(actor, list_tip, callback);
	g_scene:add_layer(ZORDER_LAYER_STORY, layer, name);
	return true;
end

function tutor_tap_chapter()
	local function callback()
		show_list_solo();
	end
	local btn = layer_map.btn_chapter;
	if nil == btn then return; end
	-- btn->menup
	local p = btn:getParent();
	local px, py = p:getPosition();
	local pscale = p:getScale();
	local x, y = btn:getPosition();
	local size = btn:getContentSize();
	local x, y, w, h = x*pscale, y*pscale, size.width*pscale, size.height*pscale;
	local fdata = {x=px+x+w/2, y=py+y+h/2,width=w, height=h,use_circle = true};
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function tutor_chapter_1_1(ts)
	local list = layer_chapter.list or {};
	if 0 == #list then return false; end
	local index = 1;
	local function callback()
		util.set_tutor(ts, true, true);
		g_tutor_wait_net = tutor_stage_go;
		layer_chapter:choose_tower(index);
	end
	local info = list[index];
	local tower = info.tower;
	if nil == tower then return false; end
	if nil == info.data then return false; end
	local flag = info.data.flag;
	if 8 ~= flag then return false; end
	-- btn->menu->map
	local p = tower:getParent():getParent();
	local px, py = p:getPosition();
	local pscale = p:getScale();
	local x, y = tower:getPosition();
	local size = tower:getContentSize();
	local x, y, w, h = x*pscale, y*pscale, size.width*pscale, size.height*pscale;
	local fdata = {x=px+x+w/2, y=py+y+h/2,width=w, height=h,use_circle = true};
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	return true;
end

function tutor_chapter_1_1_r(ts)
	local list = layer_chapter.list or {};
	if 0 == #list then return false; end
	local index = 1;
	local function callback()
		util.set_tutor(ts, true, true);
		layer_chapter:choose_box(index);
		tutor_chapter_reward();
	end
	local info = list[index];
	local box = info.box;
	if nil == box then return false; end
	if nil == info.mdata then return false; end
	if 2 ~= info.mdata.status then return false; end
	-- btn->menu->map
	local p = box:getParent():getParent();
	local px, py = p:getPosition();
	local pscale = p:getScale();
	local x, y = box:getPosition();
	local size = box:getContentSize();
	local x, y, w, h = x*pscale, y*pscale, size.width*pscale, size.height*pscale;
	local fdata = {x=px+x+w/2, y=py+y+h/2,width=w, height=h,use_circle = true};
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	return true;
end

function tutor_chapter_1_2(ts)
	local list = layer_chapter.list or {};
	if 0 == #list then return false; end
	local index = 2;
	local function callback()
		util.set_tutor(ts, true, true);
		g_tutor_wait_net = tutor_stage_go;
		layer_chapter:choose_tower(index);
	end
	local info = list[index];
	local tower = info.tower;
	if nil == tower then return false; end
	if nil == info.data then return false; end
	local flag = info.data.flag;
	if 8 ~= flag then return false; end
	-- btn->menu->map
	local p = tower:getParent():getParent();
	local px, py = p:getPosition();
	local pscale = p:getScale();
	local x, y = tower:getPosition();
	local size = tower:getContentSize();
	local x, y, w, h = x*pscale, y*pscale, size.width*pscale, size.height*pscale;
	local fdata = {x=px+x+w/2, y=py+y+h/2,width=w, height=h,use_circle = true};
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	return true;
end

function tutor_chapter_1_2_r(ts)
	local list = layer_chapter.list or {};
	if 0 == #list then return false; end
	local index = 2;
	local function callback()
		util.set_tutor(ts, true, true);
		layer_chapter:choose_box(index);
		tutor_chapter_reward();
	end
	local info = list[index];
	local box = info.box;
	if nil == box then return false; end
	if nil == info.mdata then return false; end
	if 2 ~= info.mdata.status then return false; end
	-- btn->menu->map
	local p = box:getParent():getParent();
	local px, py = p:getPosition();
	local pscale = p:getScale();
	local x, y = box:getPosition();
	local size = box:getContentSize();
	local x, y, w, h = x*pscale, y*pscale, size.width*pscale, size.height*pscale;
	local fdata = {x=px+x+w/2, y=py+y+h/2,width=w, height=h,use_circle = true};
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	return true;
end

function tutor_chapter_1_3(ts)
	local list = layer_chapter.list or {};
	if 0 == #list then return false; end
	local index = 3;
	local function callback()
		util.set_tutor(ts, true, true);
		g_tutor_wait_net = tutor_stage_go;
		layer_chapter:choose_tower(index);
	end
	local info = list[index];
	local tower = info.tower;
	if nil == tower then return false; end
	if nil == info.data then return false; end
	local flag = info.data.flag;
	if 8 ~= flag then return false; end
	-- btn->menu->map
	local p = tower:getParent():getParent();
	local px, py = p:getPosition();
	local pscale = p:getScale();
	local x, y = tower:getPosition();
	local size = tower:getContentSize();
	local x, y, w, h = x*pscale, y*pscale, size.width*pscale, size.height*pscale;
	local fdata = {x=px+x+w/2, y=py+y+h/2,width=w, height=h,use_circle = true};
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	return true;
end

function tutor_chapter_1_3_r(ts)
	local list = layer_chapter.list or {};
	if 0 == #list then return false; end
	local index = 3;
	local function callback()
		util.set_tutor(ts, true, true);
		layer_chapter:choose_box(index);
		tutor_chapter_reward();
	end
	local info = list[index];
	local box = info.box;
	if nil == box then return false; end
	if nil == info.mdata then return false; end
	if 2 ~= info.mdata.status then return false; end
	-- btn->menu->map
	local p = box:getParent():getParent();
	local px, py = p:getPosition();
	local pscale = p:getScale();
	local x, y = box:getPosition();
	local size = box:getContentSize();
	local x, y, w, h = x*pscale, y*pscale, size.width*pscale, size.height*pscale;
	local fdata = {x=px+x+w/2, y=py+y+h/2,width=w, height=h,use_circle = true};
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	return true;
end

function tutor_stage_go()
	local function callback()
		layer_stage.go();
	end
	local btn = layer_stage.btn_go;
	if nil == btn then return; end
	-- btn->menu->map
	local p = btn:getParent():getParent();
	local px, py = p:getPosition();
	local pscale = p:getScale();
	local x, y = btn:getPosition();
	local size = btn:getContentSize();
	local x, y, w, h = x*pscale, y*pscale, size.width*pscale, size.height*pscale;
	local fdata = {x=px+x+w/2, y=py+y+h/2,width=w, height=h,use_circle = true};
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function tutor_chapter_reward()
	local btn = layer_cbox.btn_get;
	if nil == btn then return; end
	local function callback()
		layer_cbox:get(btn);
	end
	-- btn->menu->map
	local p = btn:getParent():getParent();
	local px, py = p:getPosition();
	local psize = p:getContentSize();
	px = px - psize.width/2;
	py = py - psize.height/2;
	local pscale = p:getScale();
	local x, y = btn:getPosition();
	local size = btn:getContentSize();
	local x, y, w, h = x*pscale, y*pscale, size.width*pscale, size.height*pscale;
	local fdata = {x=px+x, y=py+y+h/2,width=w, height=h,use_circle = true};
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function tutor_return_1_1(ts)
	local list = layer_chapter.list or {};
	if 0 == #list then return false; end
	local index = 3;
	local info = list[index];
	local tower = info.tower;
	if nil == tower then return false; end
	if nil == info.data then return false; end
	local flag = info.data.flag;
	if flag > 3 then return false; end
	local function callback()
		util.set_tutor(ts, true, true);
		--g_tutor_wait_net = tutor_tap_mission;
		g_tutor_wait_net = tutor_tap_mydeck;
		layer_chapter.back();
	end
	local data = gui_get_data("btn_back", GUI_CHAPTER, ANCHOR_UP);
	local fdata = {x=data.x+data.width/2, y=data.y+data.height/2,width=data.width, height=data.height,use_circle=false};
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	return true;
end

function tutor_tap_mission()
	local function callback()
		g_tutor_wait_net = tutor_get_reward;
		show_mission_list();
	end
	local btn = layer_map.btn_mission;
	if nil == btn then return; end
	-- btn->menu->map
	local x, y = btn:getPosition();
	local size = btn:getContentSize();
	local w = size.width;
	local h = size.height;
	local fdata = {x=x+w/2, y=y+h/2,width=w, height=h,use_circle = true};
	local cliplist = { fdata };
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local tip = "前往领取任务奖励!";
	local layer, name = layer_dragtutorial:create(cliplist, fdata, nil, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function tutor_get_reward()
	if nil == layer_mission.layer then return; end
	if 0 == #(layer_mission.list or {}) then return; end
	local function callback()
		local info = layer_mission.list[1];
		if nil == info then return; end
		print('tutor_get_reward info.status: ', info.status);
		if 2 ~= tonumber(info.status) then
			return;
		end
		g_tutor_wait_net = tutor_close_mission;
		local mid = info.mid;
		net_send('mreward ' .. mid);
	end
	local info = layer_mission.list[1];
	local data = info.data_cell or self.data_cell2;
	local width = data.width;
	local height = data.height;
	local th = layer_mission.theight;
	local x, y = layer_mission.tableview:getPosition();
	local fdata = { x=x+width/2, y=y+th-height+height/2, width=width, height=height, use_circle=false };
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	local f = layer_dragstory.finger;
	if nil ~= f then
		local fxx, fyy = f:getPosition();
		f:setPosition(cc.p(fxx+width/4, fyy-height/2));
	end
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function tutor_close_mission()
	local function callback()
		layer_mission.back();
		tutor_tap_mydeck();
	end
	local data = gui_get_data('btn_back', GUI_MISSION, ANCHOR_UP);
	local fdata = {x=data.x+data.width/2, y=data.y+data.height/2,width=data.width, height=data.height,use_circle=false};
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	return true;
end

function tutor_tap_mydeck()
	local function callback()
		g_scene:mydeck();
		tutor_tap_deck();
	end
	local btn = layer_map.btn_deck;
	if nil == btn then return; end
	-- btn->menu->map
	local x, y = btn:getPosition();
	local size = btn:getContentSize();
	local w = size.width;
	local h = size.height;
	local fdata = {x=x, y=y,width=w, height=h,use_circle = true};
	local cliplist = { fdata };
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local tip = "获得新卡牌,马上去牌堆上阵新卡吧！";
	local layer, name = layer_dragtutorial:create(cliplist, fdata, nil, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	return true;
end

function tutor_tap_deck()
	local function callback()
		g_tutor_wait_net = tutor_edit_deck;
		layer_mydeck.cb_deck();
	end
	local btn = layer_mydeck.btn_pick_deck;
	if nil == btn then return; end
	-- btn->menu->map
	local x, y = btn:getPosition();
	local size = btn:getContentSize();
	local w = size.width;
	local h = size.height;
	local fdata = {x=x+w/2, y=y+h/2,width=w, height=h,use_circle = false};
	local cliplist = { fdata };
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local tip = nil;
	local layer, name = layer_dragtutorial:create(cliplist, fdata, nil, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	return true;
end

function tutor_edit_deck()
	if nil == layer_pickdeck.layer then return; end
	if 2 > #(layer_pickdeck.list or {}) then return; end
	local function callback()
		local info = layer_pickdeck.list[2];
		if nil == info then return; end
		local sid = info.slot_id;
		if nil == sid then return; end
		g_tutor_wait_net = tutor_deck_move_card;
		g_scene:deck();
		local cmd = string.format("get_hero_slot %d %d", layer_pickdeck.hero_id, sid);
		net_send(cmd, true);
	end
	local data = layer_pickdeck.data_cell;
	local width = data.width;
	local height = data.height;
	local th = layer_pickdeck.theight;
	local x, y = layer_pickdeck.tableview:getPosition();
	y = y-layer_pickdeck.data_cell_first.height;
	local fdata = { x=x+width/2, y=y+th-height+height/2, width=width, height=height, use_circle=false };
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	local f = layer_dragstory.finger;
	if nil ~= f then
		local fxx, fyy = f:getPosition();
		f:setPosition(cc.p(fxx+width/4, fyy-height/2));
	end
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function tutor_deck_move_card(ts)
	local function callback()
		if nil ~= ts then
			util.set_tutor(ts, true, true);
		end
		local self = layer_deck;
		local info = self.list_slot[1];
		if nil ~= info then 
			self:move_card('slot', 'deck', info.card, 1);
		end
		if #self.list_slot > 0 then
			tutor_deck_move_card(ts);
			return;
		end
		tutor_close_deck();
	end
	local tv_deck = layer_deck.tableview_deck;
	local tv_slot = layer_deck.tableview_slot;
	local x, y, width, height, w, h;
	x, y = tv_deck:getPosition();
	width = layer_deck.twidth_slot;
	height = layer_deck.data_cell_deck.height;
	w = width/2;
	h = height/2;
	local tdata = {x=x+w, y=y+h,width=width, height=height,use_circle =false};
	x, y = tv_slot:getPosition();
	width = layer_deck.data_cell_rest.width;
	height = layer_deck.data_cell_rest.height;
	w = width/2;
	h = height/2;
	local fdata = {x=x+w, y=y+h,width=width,height=height,use_circle = false};
	if 0 == #(layer_deck.list_slot or {}) then 
		local function callback()
			if nil ~= ts then
				util.set_tutor(ts, true, true);
			end
			tutor_close_deck();
		end
		local cliplist = { fdata };
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local tip = "当有闲置卡牌时，可拖动其至上阵牌堆";
		local layer, name = layer_dragtutorial:create(cliplist, fdata, nil, pos, tip, callback);
		g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
		return true;
	end
	local cliplist = { fdata, tdata };
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local tip = "拖动卡牌到上阵牌堆";
	local layer, name = layer_dragtutorial:create(cliplist, fdata, tdata, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	return true;
end

function tutor_close_deck()
	local function callback()
		g_tutor_wait_net = tutor_close_pickdeck;
		layer_deck.callback_return(1);
	end
	local data = gui_get_data("btn_back", GUI_DECK, ANCHOR_UP);
	local fdata = {x=data.x+data.width/2, y=data.y+data.height/2,width=data.width, height=data.height,use_circle=false};
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	return true;
end

function tutor_close_pickdeck()
	local function callback()
		layer_pickdeck.back();
		tutor_close_mydeck();
	end
	local data = gui_get_data("btn_back", GUI_PICKDECK, ANCHOR_UP);
	local fdata = {x=data.x+data.width/2, y=data.y+data.height/2,width=data.width, height=data.height,use_circle=false};
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	return true;
end

function tutor_close_mydeck()
	local function callback()
		g_tutor_wait_net = tutor_tap_chapter;
		layer_mydeck.back();
	end
	local data = gui_get_data("btn_back", GUI_MYDECK, ANCHOR_UP);
	local fdata = {x=data.x+data.width/2, y=data.y+data.height/2,width=data.width, height=data.height,use_circle=false};
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	return true;
end

function tutor_chapter_1_4()
	local list = layer_chapter.list or {};
	if 0 == #list then return false; end
	local index = 4;
	local info = list[index];
	local tower = info.tower;
	if nil == tower then return false; end
	if nil == info.data then return false; end
	local flag = info.data.flag;
	if 8 ~= flag then return false; end
	-- btn->menu->map
	local p = tower:getParent():getParent();
	local px, py = p:getPosition();
	local pscale = p:getScale();
	local x, y = tower:getPosition();
	local size = tower:getContentSize();
	local x, y, w, h = x*pscale, y*pscale, size.width*pscale, size.height*pscale;
	local fdata = {x=px+x+w/2, y=py+y+h/2,width=w, height=h,use_circle = true};
	local layer, name = layer_dragstory:create(fdata, nil, nil);
	local zorder = ZORDER_LAYER_CHAPTER + 5;
	g_scene:add_layer(zorder, layer, name);
	return true;
end

function tutor_chapter_1_4_r()
	local list = layer_chapter.list or {};
	if 0 == #list then return false; end
	local index = 4;
	local info = list[index];
	local box = info.box;
	if nil == box then return false; end
	if nil == info.mdata then return false; end
	if 2 ~= info.mdata.status then return false; end
	-- btn->menu->map
	local p = box:getParent():getParent();
	local px, py = p:getPosition();
	local pscale = p:getScale();
	local x, y = box:getPosition();
	local size = box:getContentSize();
	local x, y, w, h = x*pscale, y*pscale, size.width*pscale, size.height*pscale;
	local fdata = {x=px+x+w/2, y=py+y+h/2,width=w, height=h,use_circle = true};
	local layer, name = layer_dragstory:create(fdata, nil, nil);
	local zorder = ZORDER_LAYER_CHAPTER + 5;
	g_scene:add_layer(zorder, layer, name);
	return true;
end

function tutor_chapter_1_5()
	local list = layer_chapter.list or {};
	if 0 == #list then return false; end
	local index = 5;
	local info = list[index];
	local tower = info.tower;
	if nil == tower then return false; end
	if nil == info.data then return false; end
	local flag = info.data.flag;
	if 8 ~= flag then return false; end
	-- btn->menu->map
	local p = tower:getParent():getParent();
	local px, py = p:getPosition();
	local pscale = p:getScale();
	local x, y = tower:getPosition();
	local size = tower:getContentSize();
	local x, y, w, h = x*pscale, y*pscale, size.width*pscale, size.height*pscale;
	local fdata = {x=px+x+w/2, y=py+y+h/2,width=w, height=h,use_circle = true};
	local layer, name = layer_dragstory:create(fdata, nil, nil);
	local zorder = ZORDER_LAYER_CHAPTER + 5;
	g_scene:add_layer(zorder, layer, name);
	return true;
end

function tutor_chapter_1_5_r()
	local list = layer_chapter.list or {};
	if 0 == #list then return false; end
	local index = 5;
	local info = list[index];
	local box = info.box;
	if nil == box then return false; end
	if nil == info.mdata then return false; end
	if 2 ~= info.mdata.status then return false; end
	-- btn->menu->map
	local p = box:getParent():getParent();
	local px, py = p:getPosition();
	local pscale = p:getScale();
	local x, y = box:getPosition();
	local size = box:getContentSize();
	local x, y, w, h = x*pscale, y*pscale, size.width*pscale, size.height*pscale;
	local fdata = {x=px+x+w/2, y=py+y+h/2,width=w, height=h,use_circle = true};
	local layer, name = layer_dragstory:create(fdata, nil, nil);
	local zorder = ZORDER_LAYER_CHAPTER + 5;
	g_scene:add_layer(zorder, layer, name);
	return true;
end

function tutor_chapter_1_6()
	local list = layer_chapter.list or {};
	if 0 == #list then return false; end
	local index = 6;
	local info = list[index];
	local tower = info.tower;
	if nil == tower then return false; end
	if nil == info.data then return false; end
	local flag = info.data.flag;
	if 8 ~= flag then return false; end
	-- btn->menu->map
	local p = tower:getParent():getParent();
	local px, py = p:getPosition();
	local pscale = p:getScale();
	local x, y = tower:getPosition();
	local size = tower:getContentSize();
	local x, y, w, h = x*pscale, y*pscale, size.width*pscale, size.height*pscale;
	local fdata = {x=px+x+w/2, y=py+y+h/2,width=w, height=h,use_circle = true};
	local layer, name = layer_dragstory:create(fdata, nil, nil);
	local zorder = ZORDER_LAYER_CHAPTER + 5;
	g_scene:add_layer(zorder, layer, name);
	return true;
end

function tutor_chapter_1_6_r()
	local list = layer_chapter.list or {};
	if 0 == #list then return false; end
	local index = 6;
	local info = list[index];
	local box = info.box;
	if nil == box then return false; end
	if nil == info.mdata then return false; end
	if 2 ~= info.mdata.status then return false; end
	-- btn->menu->map
	local p = box:getParent():getParent();
	local px, py = p:getPosition();
	local pscale = p:getScale();
	local x, y = box:getPosition();
	local size = box:getContentSize();
	local x, y, w, h = x*pscale, y*pscale, size.width*pscale, size.height*pscale;
	local fdata = {x=px+x+w/2, y=py+y+h/2,width=w, height=h,use_circle = true};
	local layer, name = layer_dragstory:create(fdata, nil, nil);
	local zorder = ZORDER_LAYER_CHAPTER + 5;
	g_scene:add_layer(zorder, layer, name);
	return true;
end

function tutor_chapter_1_7()
	local list = layer_chapter.list or {};
	if 0 == #list then return false; end
	local index = 7;
	local info = list[index];
	local tower = info.tower;
	if nil == tower then return false; end
	if nil == info.data then return false; end
	local flag = info.data.flag;
	if 8 ~= flag then return false; end
	-- btn->menu->map
	local p = tower:getParent():getParent();
	local px, py = p:getPosition();
	local pscale = p:getScale();
	local x, y = tower:getPosition();
	local size = tower:getContentSize();
	local x, y, w, h = x*pscale, y*pscale, size.width*pscale, size.height*pscale;
	local fdata = {x=px+x+w/2, y=py+y+h/2,width=w, height=h,use_circle = true};
	local layer, name = layer_dragstory:create(fdata, nil, nil);
	local zorder = ZORDER_LAYER_CHAPTER + 5;
	g_scene:add_layer(zorder, layer, name);
	return true;
end

function tutor_chapter_1_7_r()
	local list = layer_chapter.list or {};
	if 0 == #list then return false; end
	local index = 7;
	local info = list[index];
	local box = info.box;
	if nil == box then return false; end
	if nil == info.mdata then return false; end
	if 2 ~= info.mdata.status then return false; end
	-- btn->menu->map
	local p = box:getParent():getParent();
	local px, py = p:getPosition();
	local pscale = p:getScale();
	local x, y = box:getPosition();
	local size = box:getContentSize();
	local x, y, w, h = x*pscale, y*pscale, size.width*pscale, size.height*pscale;
	local fdata = {x=px+x+w/2, y=py+y+h/2,width=w, height=h,use_circle = true};
	local layer, name = layer_dragstory:create(fdata, nil, nil);
	local zorder = ZORDER_LAYER_CHAPTER + 5;
	g_scene:add_layer(zorder, layer, name);
	return true;
end

function tutor_chapter_1_8()
	local list = layer_chapter.list or {};
	if 0 == #list then return false; end
	local index = 8;
	local info = list[index];
	local tower = info.tower;
	if nil == tower then return false; end
	if nil == info.data then return false; end
	local flag = info.data.flag;
	if 8 ~= flag then return false; end
	-- btn->menu->map
	local p = tower:getParent():getParent();
	local px, py = p:getPosition();
	local pscale = p:getScale();
	local x, y = tower:getPosition();
	local size = tower:getContentSize();
	local x, y, w, h = x*pscale, y*pscale, size.width*pscale, size.height*pscale;
	local fdata = {x=px+x+w/2, y=py+y+h/2,width=w, height=h,use_circle = true};
	local layer, name = layer_dragstory:create(fdata, nil, nil);
	local zorder = ZORDER_LAYER_CHAPTER + 5;
	g_scene:add_layer(zorder, layer, name);
	return true;
end

function tutor_chapter_1_8_r()
	local list = layer_chapter.list or {};
	if 0 == #list then return false; end
	local index = 8;
	local info = list[index];
	local box = info.box;
	if nil == box then return false; end
	if nil == info.mdata then return false; end
	if 2 ~= info.mdata.status then return false; end
	-- btn->menu->map
	local p = box:getParent():getParent();
	local px, py = p:getPosition();
	local pscale = p:getScale();
	local x, y = box:getPosition();
	local size = box:getContentSize();
	local x, y, w, h = x*pscale, y*pscale, size.width*pscale, size.height*pscale;
	local fdata = {x=px+x+w/2, y=py+y+h/2,width=w, height=h,use_circle = true};
	local layer, name = layer_dragstory:create(fdata, nil, nil);
	local zorder = ZORDER_LAYER_CHAPTER + 5;
	g_scene:add_layer(zorder, layer, name);
	return true;
end

function tutor_chapter_1_9(ts)
	local list = layer_chapter.list or {};
	if 0 == #list then return false; end
	local index = 9;
	local function callback()
		util.set_tutor(ts, true, true);
		g_tutor_wait_net = tutor_first_pay;
		layer_chapter:choose_tower(index);
	end
	local info = list[index];
	local tower = info.tower;
	if nil == tower then return false; end
	if nil == info.data then return false; end
	local flag = info.data.flag;
	if 8 ~= flag then return false; end
	-- btn->menu->map
	local p = tower:getParent():getParent();
	local px, py = p:getPosition();
	local pscale = p:getScale();
	local x, y = tower:getPosition();
	local size = tower:getContentSize();
	local x, y, w, h = x*pscale, y*pscale, size.width*pscale, size.height*pscale;
	local fdata = {x=px+x+w/2, y=py+y+h/2,width=w, height=h,use_circle = true};
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	return true;
end

function tutor_first_pay()
	local function callback()
		layer_stage.first_charge();
	end
	local btn = layer_stage.btn_pay;
	if nil == btn then return; end
	-- btn->menu->map
	local p = btn:getParent():getParent();
	local px, py = p:getPosition();
	local pscale = p:getScale();
	local x, y = btn:getPosition();
	local size = btn:getContentSize();
	local x, y, w, h = x*pscale, y*pscale, size.width*pscale, size.height*pscale;
	local fdata = {x=px+x+w/2, y=py+y+h/2,width=w, height=h,use_circle = true};
	local cliplist = { fdata };
	--local layer, name = layer_dragstory:create(fdata, nil, callback);
	--g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local tip = "首次充值助你3星过关获取5星卡牌!";
	local layer, name = layer_dragtutorial:create(cliplist, fdata, nil, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function tutor_stage_1_9(ts)
	local function callback()
		util.set_tutor(ts, true, true);
		layer_stage.go();
	end
	local btn = layer_stage.btn_go;
	if nil == btn then return; end
	-- btn->menu->map
	local p = btn:getParent():getParent();
	local px, py = p:getPosition();
	local pscale = p:getScale();
	local x, y = btn:getPosition();
	local size = btn:getContentSize();
	local x, y, w, h = x*pscale, y*pscale, size.width*pscale, size.height*pscale;
	local fdata = {x=px+x+w/2, y=py+y+h/2,width=w, height=h,use_circle = true};
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
end

function tutor_return_1_7(ts)
	local list = layer_chapter.list or {};
	if 0 == #list then return false; end
	local index = 7;
	local info = list[index];
	local tower = info.tower;
	if nil == tower then return false; end
	if nil == info.data then return false; end
	local flag = info.data.flag;
	if flag > 3 then return false; end
	local function callback()
		util.set_tutor(ts, true, true);
		--g_tutor_wait_net = tutor_tap_piece;
		layer_chapter.back();
		if true == util.trigger_tutor(TUTOR_SHOW_PIECE) then
			return;
		end
	end
	local data = gui_get_data("btn_back", GUI_CHAPTER, ANCHOR_UP);
	local fdata = {x=data.x+data.width/2, y=data.y+data.height/2,width=data.width, height=data.height,use_circle=false};
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	return true;
end

function tutor_return_1_8(ts)
	local list = layer_chapter.list or {};
	if 0 == #list then return false; end
	local index = 8;
	local info = list[index];
	local tower = info.tower;
	if nil == tower then return false; end
	if nil == info.data then return false; end
	local flag = info.data.flag;
	if flag > 3 then return false; end
	local function callback()
		util.set_tutor(ts, true, true);
		g_tutor_wait_net = tutor_tap_mydeck;
		layer_chapter.back();
	end
	local data = gui_get_data("btn_back", GUI_CHAPTER, ANCHOR_UP);
	local fdata = {x=data.x+data.width/2, y=data.y+data.height/2,width=data.width, height=data.height,use_circle=false};
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	return true;
end

function tutor_return_1_9(ts)
	if layer_chapter.chapter_id == 1 then
		local list = layer_chapter.list or {};
		if 0 == #list then return false; end
		local index = 9;
		local info = list[index];
		local tower = info.tower;
		if nil == tower then return false; end
		if nil == info.data then return false; end
		local flag = info.data.flag;
		if flag > 3 then return false; end
	else
		local list = layer_chapter.list or {};
		if 0 == #list then return false; end
		local index = 1;
		local info = list[index];
		local tower = info.tower;
		if nil == tower then return false; end
		if nil == info.data then return false; end
		local flag = info.data.flag;
		if flag ~= 8 then return false; end
	end
	local function callback()
		util.set_tutor(ts, true, true);
		g_tutor_wait_net = tutor_end_intro;
		layer_chapter.back();
	end
	local data = gui_get_data("btn_back", GUI_CHAPTER, ANCHOR_UP);
	local fdata = {x=data.x+data.width/2, y=data.y+data.height/2,width=data.width, height=data.height,use_circle=false};
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	return true;
end

function tutor_show_piece()
	local btn = layer_map.btn_more;
	if nil == btn then return false; end
	local function callback()
	end
	local layer, name = layer_dragstory:create(nil, nil, callback);
	layer_dragstory.can_touch = false;
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);

	if 0 == btn:getSelectedIndex() then
		btn:setSelectedIndex(1);
		layer_map.show_more(1, btn, true);
	end

	local path = util.get_path('bg_121.png');
	local frect = cc.rect(0, 0, 404, 260); -- fullrect
	local irect = cc.rect(200, 128, 4, 4); -- insetrect
	local size = cc.size(404, 300);
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local bg = util.add_scale9sprite(layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, size, 10); 
	pos = cc.p(size.width/2, 50);
	local lsize = cc.size(size.width-40, size.height - 80 - 100);
	local msg = "碎片功能开放";
	util.add_labeloutline(bg, msg, nil, 25, pos, util.c4b_white, util.c4b_black, 1, ANCHOR_CENTER_DOWN, 50, lsize, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

	local items = {};
	pos = cc.p(HALF_WIDTH, HALF_HEIGHT+20);
	local item = add_item_2(items, 'icon_68.png', 'icon_68_s.png', nil, ANCHOR_CENTER_CENTER, pos);
	util.add_menu(layer, items, 60);

	bg:setScale(0.5);
	local list, action;
	list = {};
	table.insert(list, cc.EaseIn:create(cc.ScaleTo:create(0.3, 1.2), 0.3));
	table.insert(list, cc.EaseIn:create(cc.ScaleTo:create(0.2, 1), 0.2));
	table.insert(list, cc.DelayTime:create(2));
	table.insert(list, cc.EaseIn:create(cc.FadeOut:create(1), 1));
	action = cc.Sequence:create(list);
	bg:runAction(action);

	local function refresh_more()
		layer_map.show_more(0, btn, true);
		table.insert(layer_map.list_more, 3, layer_map.btn_piece);
		layer_map.show_more(1, btn, true);
		layer_dragstory:remove();
		util.set_tutor(TUTOR_SHOW_PIECE, true, true);
		tutor_tap_piece();
	end
	item:setOpacity(0);
	item:setScale(1.5);
	list = {};
	table.insert(list, cc.DelayTime:create(0.4));
	table.insert(list, cc.EaseIn:create(cc.FadeIn:create(0.2), 0.2));
	table.insert(list, cc.EaseIn:create(cc.ScaleTo:create(0.3, 1), 0.3));
	table.insert(list, cc.DelayTime:create(2));
	local x = 0;
	local y = 0;
	local b3 = layer_map.list_more[3];
	if nil ~= b3 then
		x, y = b3:getPosition();
	end
	pos = cc.p(x, y);
	table.insert(list, cc.EaseIn:create(cc.MoveTo:create(0.3, pos), 0.3));
	table.insert(list, cc.CallFunc:create(refresh_more));
	action = cc.Sequence:create(list);
	item:runAction(action);
end

function tutor_end_intro()
	local actor = { name = "安娜导师", icon = 8 };
	local list_tip = {
		"恭喜你通过第1章的考验成为及格的召唤师！",
		"继续完成任务，将开放更多有趣的内容！",
	};
	local function callback()
	end
	local layer, name = layer_story:create(actor, list_tip, callback);
	g_scene:add_layer(ZORDER_LAYER_STORY, layer, name);
	return true;
end

function tutor_tap_piece()
	local function callback()
		g_tutor_wait_net = tutor_piece_merge;
		g_scene:piece();
	end
	local btn = layer_map.btn_piece;
	if nil == btn then return; end
	-- btn->menu->map
	local x, y = btn:getPosition();
	local size = btn:getContentSize();
	local w = size.width;
	local h = size.height;
	local fdata = {x=x, y=y,width=w, height=h,use_circle = true};
	local cliplist = { fdata };
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT/2);
	local tip = "进入把卡牌碎片合成卡牌";
	local layer, name = layer_dragtutorial:create(cliplist, fdata, nil, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	return true;
end

function tutor_piece_merge(ts)
	local list = layer_piece.list or {};
	if #list == 0 then
		tutor_close_piece();
		return true;
	end
	local x, y = layer_piece.tableview:getPosition();
	local width = layer_piece.cwidth;
	local height = layer_piece.cheight;
	local fdata = {x=x+width/2, y=y+height/4*3,width=width, height=height/2,use_circle=false};
	local cliplist = { fdata };
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT/2);
	local index = 1;
	local info = list[index];
	local c_count = info.current_piece_count;
	local m_count = info.merge_count;
	if c_count < m_count then
		local function callback()
			util.set_tutor(ts, true, true);
			tutor_close_piece();
		end
		local tip = "集齐碎片后可合成卡牌";
		local layer, name = layer_dragtutorial:create(cliplist, fdata, nil, pos, tip, callback);
		g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
		return true;
	end
	local function callback()
		util.set_tutor(ts, true, true);
		layer_piece:merge_action(index);
		g_tutor_wait_net = tutor_close_piece;
	end
	local tip = "点击进行合成卡牌";
	local layer, name = layer_dragtutorial:create(cliplist, fdata, nil, pos, tip, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	return true;
end

function tutor_close_piece()
	local function callback()
		g_tutor_wait_net = tutor_tap_chapter;
		layer_piece.back();
	end
	local data = gui_get_data("btn_back", GUI_PIECE, ANCHOR_UP);
	local fdata = {x=data.x+data.width/2, y=data.y+data.height/2,width=data.width, height=data.height,use_circle=false};
	local layer, name = layer_dragstory:create(fdata, nil, callback);
	g_scene:add_layer(ZORDER_LAYER_DRAGSTORY, layer, name);
	return true;
end
-- /////////////////////// TUTOR END   ///////////////////////////

-- /////////////////////// GUI START ///////////////////////////









function gui_get_test_list()
	return gui_info;
end

function gui_load_frame(ltype)
	local list = gui_get_list(ltype);
	if nil == list then
		return nil;
	end
	local rname = list.rname;
	if nil == rname then
		return nil;
	end
	rname = rname .. '.plist';
	return rname;
end






function gui_add_labelbmf_on_cell(cell, cdata, str, path, key, ltype, sfactor, halignment)
	local label, data = gui_add_labelbmf(cell, str, path, key, ltype, sfactor, halignment);
	local x, y = label:getPosition();
	local pos = cc.p(x - cdata.x, y - cdata.y);
	label:setPosition(pos);
	data.x = pos.x;
	data.y = pos.y;
	return label, data;
end





function gui_add_rlabel_on_cell(cell, cdata, str, fsize, key, ltype, sfactor, color, row_width, row_space)
	local label, data = gui_add_rlabel(cell, str, fsize, key, ltype, sfactor, color, row_width, row_space);
	local x, y = label:getPosition();
	local pos = cc.p(x - cdata.x, y - cdata.y);
	label:setPosition(pos);
	data.x = pos.x;
	data.y = pos.y;
	return label, data;
end



function gui_add_mask_image(layer, path, mask_path, key, ltype, sfactor)
	local data, scale = gui_get_data(key, ltype, sfactor);
	local pos = ccp(data.x, data.y);
	local sprite = util.add_mask_sprite(layer, path, mask_path, pos, ANCHOR_LEFT_DOWN, data.zorder);
	sprite:setAnchorPoint(ANCHOR_LEFT_DOWN);
	--local x, y = sprite:getPosition();
	sprite:setScale(scale);
	return sprite;
end

function gui_add_sprite_tip(layer, key, ltype, sfactor)
	local data, scale = gui_get_data(key, ltype, sfactor);
	local fname = data.fname1;
	local pos = ccp(data.x + data.width/2, data.y + data.height/2);
	local anchor = ANCHOR_CENTER_CENTER;
	local width = data.width;
	local height = data.height;
	local fullpath = util.get_fullpath(F_IMAGE, fname);
	local sprite = util.add_sprite(layer, fullpath, pos, anchor, data.zorder);
	if nil ~= scale then
		sprite:setScale(scale);
	else
		local size = sprite:getContentSize();
		local s1 = width / size.width;
		local s2 = height / size.height;
		if s1 < s2 then
			sprite:setScale(s1);
		else
			sprite:setScale(s2);
		end
	end
	return sprite, data;
end




function gui_add_rlabel(layer, str, fsize, key, ltype, sfactor, color, row_width, row_space)
	local data, scale = gui_get_data(key, ltype, sfactor);
	local pos, width, height;
	local pos = ccp(data.x, data.y);
	local width = data.width;
	local height = data.height;
	local r = data.r;
	local g = data.g;
	local b = data.b;
	color = color or cc.c4b(r, g, b, 255);
	row_width = row_width or data.width;
	row_space = row_space or 2;
	local label = rich_label.new(layer, pos, str, "Arial", fsize, row_width, row_space, color, data.zorder);
	label:setColor(color);
	label:setScale(scale);
	data.y = pos.y;
	data.height = height;
	return label, data;
end

function gui_add_labelbmf(layer, str, path, key, ltype, sfactor, halignment)
	local data, scale = gui_get_data(key, ltype, sfactor);
	local pos = cc.p(data.x, data.y-6);
	local size = cc.size(data.width, data.height);
	local label = util.add_labelbmf(layer, str, path, pos, ANCHOR_LEFT_DOWN, data.zorder, halignment, size);
	label:setScale(scale or 1);
	return label, data;
end
-- /////////////////////// GUI END   ///////////////////////////

-- /////////////////////// ALIAS START ///////////////////////////
-- deprecated
function load_alias_data()
	local str = open_file(F_DOCX, "evil_alias.csv");
	--alias_list = alias_read_data(str);
	local list_line = csplit(str, "[\r\n]");
	for i = 1, 6 do
		table.remove(list_line, 1);
	end
	local l_prefix = {};
	local l_boy = {};
	local l_girl = {};
	for i = 1, #list_line do
		local line = list_line[i];
		line = string.gsub(line, "\n", "")
		--print('line: ', line);
		local colomn = csplit(line, ",");
		if #colomn == 4 then
			local rid = colomn[1];
			local prefix = colomn[2];
			local boy = colomn[3];
			local girl = colomn[4];
			if '0' ~= prefix then table.insert(l_prefix, prefix); end
			if '0' ~= boy then table.insert(l_boy, boy); end
			if '0' ~= girl then table.insert(l_girl, girl); end
		end
	end
	return l_prefix, l_boy, l_girl;
end
-- /////////////////////// ALIAS END   ///////////////////////////

-- /////////////////////// ANIM START ///////////////////////////
anim = {};
anim.queue = {};
anim.cache = {};
anim.eff_list = {};
anim.anim_list = {};
anim.multi_target_list = { src_index = 0, tcount = 0 };
anim.eff_hp_count = 0;
anim.eff_power_count = 0;
anim.last_rm_attach_index = 0;
anim.anim_list_length = 0;
anim.anim_list_counter = 0;

function anim.reset_data()
	anim.queue = {};
	anim.cache = {};
end

-- almost same as layer_action.obj_to_new_layer
-- because sprite remove from parent will remove all the running action 
--   in sprite or it's child
-- so must run these action again
function switch_layer(sprite, new_layer)
	local tlist = {};
	local children = sprite:getChildren();
	local count = sprite:getChildrenCount();
	for i = 1, count do
		local s = children[i];
		local es = s:getChildByTag(TAG_STATUS_SPRITE);
		if nil ~= es then
			local action = es:getActionByTag(TAG_STATUS_EFF);
			if nil ~= action then
				action:retain();
				tlist[#tlist + 1] = { sprite = es, action = action }; 
			end
		end
		--[[
		--local s = children:objectAtIndex(i);
		--s = tolua.cast(s, "cc.Node");
		local action = s:getActionByTag(TAG_VIRTUAL_ACTION);
		if nil ~= action then
			action:retain();
			tlist[#tlist + 1] = { sprite = s, action = action }; 
		end
		]]--
	end
	sprite:retain();
	sprite:removeFromParentAndCleanup(true);
	new_layer:addChild(sprite, ZORDER_CARD);
	for i = 1, #tlist do
		local s = tlist[i].sprite;
		local action = tlist[i].action;
		s:runAction(action);
		action:release();
	end
	sprite:release();
	return sprite;
end

-- use in anim_action_anim, anim_action_map_damage
-- for the case that attack multi targets, show the eff at the same time
-- then show the hurt eff one after one
function anim_set_tlist_src(src_index)
	anim.multi_target_list.src_index = src_index;
	anim.multi_target_list.tcount = 0;
end
function anim_insert_tlist(index)
	if nil == index then
		return;
	end
	anim.multi_target_list.tcount = anim.multi_target_list.tcount + 1;
end
function anim_remove_tlist(src_index, is_remove_all)
	if true == is_remove_all then
		anim.multi_target_list = { src_index = 0, tlist = {} };
		return false;
	end
	--print('src_index, src: ', src_index, anim.multi_target_list.src_index);
	if src_index ~= anim.multi_target_list.src_index then
		return false;
	end
	anim.multi_target_list.tcount = anim.multi_target_list.tcount - 1;
	if 0 == anim.multi_target_list.tcount then
		anim.multi_target_list.src_index = 0;
	end
	return true;
end

function anim_preprocess_efflist(list, front_index)
	list = list or {};

	if 0 == #list then
		--anim_return('preprocess_efflist 0==#list'); -- do it outside
		return list;
	end

	-- usually, 'card' is the first eff
	-- but, in sacrifice, next, no eff 'card' come
	--[[
	[LUA] effect list: #eff_list=2
	[LUA]     EFF card, id=47, index=1301, |
	[LUA]     EFF damage, target_index=2101, dtype=1, src_index=1301, power=1, |
	-----------
	[LUA] effect list: #eff_list=3
	[LUA]     EFF move, src_index=2202, target_index=2701, |
	[LUA]     EFF resource_max, side=1, offset=1, |
	[LUA]     EFF phase, |
	]]--
	local use_index = nil;
	local fisrt_src_index = nil;
	if 'card' == list[1][1] then
		list[1].front_index = nil;--front_index;
		use_index = list[1].index;
		list[2].front_index = use_index;
		first_src_index = use_index;
	else
		list[1].front_index = nil;--front_index;
		first_src_index = list[1].src_index;
	end
	if nil ~= front_index and first_src_index ~= front_index then
		alog('DEBUG preprocess add scale_back: ', front_index);
		local eff = {'scale_back', index = front_index};
		table.insert(list, 1, eff);
	end

	-- TODO LOG
	for i = 1, #list do
		local eff = list[i];
		alog('eff ', eff[1]);
	end

	return list;
end

function efflist_to_anim(list) -- {
	local anim_info = { has_anim = false, anim_group = {} };

	if nil == list then
		-- the first eff_list is nil, so eff_group is empty
		alog('DEBUG eff_list == nil');
		return anim_info;
	end

	if 0 == #list then
		alog('DEBUG #eff_list <= 0');
		return anim_info;
	end

	-- make anim group
	if 0 < #list then
		alog('DEBUG efflist_to_anim before make_anim,#list: ', list[1][1], #list);
	end
	anim_group = make_anim(list[1]);
	table.remove(list, 1);
	if 0 < #list then
		alog('DEBUG efflist_to_anim after make_anim, #list: ', list[1][1], #list);
	end

	if nil ~= anim_group then
		--anim_info[1] = true;
		anim_info.has_anim = true;
	end
	anim_info.anim_group = anim_group;

	return anim_info;
end -- efflist_to_anim }

function run_anim(animation, anim_list)
	--alog('DEBUG do run_anim #animation, #anim_list: ', #animation, #anim_list);
	anim.anim_list_length = #animation;
	anim.anim_list_counter = 0;

	for i = 1, #animation do
		run_sprite_actions(animation[i]);	
	end
	table.remove(anim_list, 1);
	--alog('DEBUG end run_anim #anim_list: ', #anim_list);
end

-- @see in logic.lua index_side(index)
function anim_index_side(index)
	return index_side(index);
	--[[
	local s;
	-- avoid attach
	if index >= 10000 then
		index = math.floor(index / 10);
	end

	s = math.floor(index / 1000);
	if s < 1 or s > 2 then
		print('BUG anim_index_side out of range: ', index);
	end
	return s;
	]]--
end

-- @see in logic.lua index_table_num(index)
function anim_index_table_num(index)
	return index_table_num(index);
	--[[
	local tbindex;
	index = tonumber(index) or 9999;
	-- avoid attach
	if index >= 10000 then
		index = math.floor(index / 10);
	end
	tbindex = math.floor((index % 1000) / 100);
	return tbindex;
	]]--
end

-- @see in logic.lua index_offset(index)
function anim_index_offset(index)
	return index_offset(index);
	--[[
	-- avoid attach
	if index >= 10000 then
		index = math.floor(index / 10);
	end
	return index % 100;
	]]--
end

--[[
local src_table_index, src_list_index, src_card_list, src_card;
src_table_index, src_list_index, src_card_list, src_card 
	= anim_get_info(src_index);
local tar_table_index, tar_list_index, tar_card_list, tar_card;
tar_table_index, tar_list_index, tar_card_list, tar_card 
	= anim_get_info(tar_index);
local front_table_index, front_list_index, front_card_list, front_card;
front_table_index, front_list_index, front_card_list, front_card 
	= anim_get_info(front_index);
]]--
function anim_get_info(index)
	if nil == index then
		return;
	end
	local side_index = anim_index_side(index);
	local table_index = anim_index_table_num(index);
	local list_index = anim_index_offset(index);
	local table_side = g_ui_table[side_index];
	if nil ==  table_side then
		return table_index, list_index, nil, nil;
	end
	local table_list = table_side[table_index];
	if nil ==  table_list then
		return table_index, list_index, table_list, nil;
	end
	local card = table_list[list_index];

	--alog('DEBUG anim_get_info index, table_index, list_index, #table_list: ', index, table_index, list_index, #table_list);
	return table_index, list_index, table_list, card;
end

function anim_get_card_info(index)
	return get_ui_card(index);
end

function anim_get_npos(index)
	local table_index, list_index, list, info = anim_get_info(index);
	local pos = cc.p(list.x, list.y);
	local cwidth = list.cwidth;
	local limit = list.width / cwidth;

	if table_index ~= T_GRAVE and table_index ~= T_HERO and
	   table_index ~= T_DECK and table_index ~= T_RES then
	   
	   	local offset = list_index - 1;
		if list_index > limit then
			offset = limit - 1;
		end
		pos.x = pos.x + offset * cwidth;
	end
	return pos;
end

-- action is 'insert' or 'remove'
function anim_arrange_list(index, anim_list, action)
	local table_index, list_index, list, info = anim_get_info(index);
	local cscale = list.cscale;
	if table_index == T_GRAVE or table_index == T_DECK or table_index==T_RES then
		return;
	end

	for i = 1, #list do
		local info = list[i];
		local sprite = anim_get_sprite(info);
		local pos;
		local rotation = 0;
		pos, rotation = anim_get_card_pos_rotation(list, i);

		info.frame.x = pos.x;
		info.frame.y = pos.y;
		info.frame.rotation = rotation;
		info.frame.zorder = ZORDER_CARD;
		info.t_index = table_index;
		if 'remove' == action or i ~= list_index then
			anim_list[#anim_list + 1] = {
				sprite = sprite,
				anims = {
					{ anim_name = 'spawn', 
					  anim_parts = {
						  { anim_part = 'move', pos = pos },
						  { anim_part = 'rotate', rotation = rotation },
						  { anim_part = 'scale', scale = cscale },
					  },
					},
				},
			};
		end
	end
end

function anim_arrange_grave(tar_index, anim_list, action)
	local side = anim_index_side(tar_index);
	local lindex = anim_index_offset(tar_index);
	local ui_table = g_ui_table[side][T_GRAVE];
	local len = ui_table.pic_len or 1;
	if #ui_table < len then
		len = #ui_table;
	end
	local scale = ui_table.pic_scale;
	local index = 1;
	for i = #ui_table, 1, -1 do
		local info = ui_table[i];
		local pos = info:get_grave_pos(ui_table, index);
		if nil ~= pos then
			local sprite = anim_get_sprite(info);
			--local sprite = info:change_grave(pos, ui_table.pic_scale);
			if i == lindex then
				if 'remove' == action then
					-- no need to remove the sprite
					--info:remove_sprite();
				else
					--sprite:setScale(0);
					anim_list[#anim_list + 1] = {
						sprite = sprite,
						anims = {
							{ anim_name = 'spawn', 
							  anim_parts = {
								  { anim_part = 'scale', scale = scale },
							  },
							},
					        { anim_name='to_grave', ui_table = ui_table, index = index, info = info },
						},
					};
				end
			elseif index == len + 1 then
				anim_list[#anim_list + 1] = {
					sprite = sprite,
					anims = {
						{ anim_name = 'hide' },
					},
				};
			else
				anim_list[#anim_list + 1] = {
					sprite = sprite,
					anims = {
						{ anim_name = 'spawn', 
						  anim_parts = {
							  { anim_part = 'move', pos = pos },
							  { anim_part = 'rotate', rotation = 1 },
						  },
						},
					},
				};
			end
			index = index + 1;
			if index > len + 1 then
				break;
			end
		end
	end
end

function callback_front(...)
	local arg = {...}
	local sprite = arg[1];
	if nil == sprite then
		alog('BUG nil == sprite');
		return nil;
	end
	local layer = sprite:getParent();
	layer:reorderChild(sprite, ZORDER_SHOWING);
end

function anim_callback_remove(...)
	local args = { ... };
	local sprite = args[1];
	sprite:removeFromParentAndCleanup(true);
	alog('DEBUG do anim_callback_remove');
end

function callback_table(...)
	local arg = {...};
	local sprite = arg[1];
	if nil == sprite then
		alog('BUG nil == sprite');
		return nil;
	end
	local layer = sprite:getParent();
	layer:reorderChild(sprite, ZORDER_CARD);
end

function callback_play_eff(...)
	local args = { ... };
	local sprite = args[1];
	sprite:removeFromParentAndCleanup(true);

	local cache = cc.SpriteFrameCache:getInstance();
	cache:removeUnusedSpriteFrames();
end

function anim_csprite_info(sprite)
	if nil == sprite then
		return nil, nil, nil;
	end
	local size = sprite:getContentSize();
	local scale = sprite:getScaleY();
	local rscale = sprite:getScale() * 2;
	rscale = 1;
	local rsize = cc.size(size.width*scale, size.height*scale);
	local rpos = cc.p(sprite:getPositionX(), sprite:getPositionY());
	return rsize, rscale, rpos;
end

function a_play_eff_show(sprite, delay, is_show)
	if nil == sprite then
		return;
	end
	local array, action;
	array = {};
	action = cc.DelayTime:create(delay);
	table.insert(array, action);
	if true == is_show then
		action = cc.CallFunc:create(a_particle_sac);
		table.insert(array, action);
		action = cc.DelayTime:create(0.4);
		table.insert(array, action);
		action = cc.Show:create();
		table.insert(array, action);
	else
		action = cc.Hide:create();
		table.insert(array, action);
		action = cc.CallFunc:create(a_particle_sac);
		table.insert(array, action);
	end
	action = cc.Sequence:create(array);
	sprite:runAction(action);
end

-- eff image size is ref from half size of the card(365x512), see in gui.lua
-- so the scale factor should be card_sprite:getScale() * 2
function play_eff(layer, ekind, fsprite, tsprite, step, eff, callback)
	step = step or 0;
	eff = eff or false;
	
	local fsize, fscale, fpos = anim_csprite_info(fsprite);
	local tsize, tscale, tpos = anim_csprite_info(tsprite);
	local time = 0;
	local ename = string.format("s_%d", ekind);
	local list = {};
	if 0 == step or 1 == step then
		local l = { 
			pos = fpos, step = 1, size = fsize,
			csprite = fsprite, 
			radius = 4, ap = ANCHOR_CENTER_CENTER, scale = fscale 
		};
		table.insert(list, l);
		--[[
		l = { 
			pos = fpos, tpos = tpos, size = fsize, tsize = tsize,
			step = 0, ap = ANCHOR_CENTER_CENTER, scale = (fscale+tscale)/2
		};
		table.insert(list, l);
		]]--
	end
	if 0 == step or 2 == step then
		local l = { -- the number of fly effect should match the hurt effect  
			pos = fpos, tpos = tpos, size = fsize, tsize = tsize,
			step = 0, ap = ANCHOR_CENTER_CENTER, scale = (fscale+tscale)/2
		};
		table.insert(list, l);
		l = { 
			pos = tpos, step = 2, size = tsize,
			csprite = tsprite, 
			radius = 8, ap = ANCHOR_CENTER_CENTER, scale = tscale 
		};
		table.insert(list, l);
	end
	if 0 == step or 3 == step then
		local l = { 
			pos = ccp(HALF_WIDTH, HALF_HEIGHT), step = 3,
			ap = ANCHOR_CENTER_CENTER, scale = 1 
		};
		table.insert(list, l);
	end

	local cache = cc.SpriteFrameCache:getInstance();
	for i = 1, #list do
		local info = list[i];
		local step = info.step;
		local pos = info.pos;
		local ap = info.ap;
		local size = info.size;
		local scale = info.scale;
		local filename = string.format("%s_%d.plist", ename, step);
		if true == util.check_file(filename) then
			info.is_attacker_atnormal = false;
			local fullpath = util.get_fullpath(F_ANIM, filename);	
			cache:addSpriteFrames(fullpath);

			filename = string.format("%s_%d_1.png", ename, step);
			local sprite = cc.Sprite:createWithSpriteFrameName(filename);
			sprite:setPosition(pos);
			sprite:setAnchorPoint(ap);
			--sprite:setScale(scale);
			layer:addChild(sprite, ZORDER_EFFECT);
			local animation = cc.Animation:create();
			local len = 0;
			filename = string.format("%s_%d_%d.png", ename, step, 1);
			local frame = cache:spriteFrameByName(filename);
			repeat
				len = len + 1;
				animation:addSpriteFrame(frame);
				local filename = string.format("%s_%d_%d.png", ename, step, len);
				frame = cache:spriteFrameByName(filename);
			until nil == frame;
			local pt = 0.1;
			if len > 5 then
				pt = 0.07;
			end
			animation:setDelayPerUnit(pt);
			local t = pt * len;
			time = time + t;

			info.animation = animation;
			info.sprite = sprite;
			info.time = t;
		elseif 1 == step then
			info.is_attacker_atnormal = true;
			info.sprite = fsprite;
		end
	end

	local delay = 0;
	if 'e_hide' == eff and (0 == step or 1 == step) then
		a_play_eff_show(fsprite, delay, false);
	end
	for i = 1, #list do
		local info = list[i];
		local animation = info.animation;
		local csprite = info.csprite;
		local radius = info.radius;
		local sprite = info.sprite;
		local step = info.step;
		if 1 == step and true == info.is_attacker_atnormal and nil ~= sprite then
			local action, array, sarray, scale;
			local x = sprite:getPositionX();
			local y = sprite:getPositionY();
			scale = sprite:getScale();
			local svv = 1;
			if y > HALF_HEIGHT then
				svv = -1;
			end
			array = {};
			table.insert(array, cc.DelayTime:create(delay));
			sarray = {};
			action = cc.ScaleTo:create(0.2, scale + 0.05);
			table.insert(array, action);
			action = cc.ScaleTo:create(0.1, scale + 0.03);
			table.insert(array, action);

			sarray = {};
			action = cc.ScaleTo:create(0.2, scale + 0.01);
			table.insert(sarray, action);
			action = cc.MoveTo:create(0.2, cc.p(x, y + svv*15));
			table.insert(sarray, action);
			action = cc.Spawn:create(sarray);
			action = cc.EaseIn:create(action, 0.1);
			table.insert(array, action);
			action = cc.Sequence:create(array);
			sprite:runAction(action);
			delay = delay + 0.4;

			array = {};
			table.insert(array, cc.DelayTime:create(delay + 0.1));
			sarray = {};
			action = cc.RotateTo:create(0.2, 0);
			table.insert(sarray, action);
			action = cc.ScaleTo:create(0.1, scale);
			table.insert(sarray, action);
			action = cc.MoveTo:create(0.1, cc.p(x, y));
			table.insert(sarray, action);
			action = cc.Spawn:create(sarray);
			table.insert(array, action);
			action = cc.Sequence:create(array);
			sprite:runAction(action);

		elseif nil ~= animation and nil ~= info.sprite then
			local t = info.time;
			local tpos = info.tpos;
			local pos = info.pos;
			local tsize = info.tsize;
			local scale = info.scale;

			local array = {};
			table.insert(array, cc.Hide:create());
			table.insert(array, cc.DelayTime:create(delay));
			table.insert(array, cc.Show:create());
			if nil ~= tpos then
				local spawns = {};
				local action = cc.MoveTo:create(t, tpos);
				table.insert(spawns, action);
				table.insert(spawns, cc.Animate:create(animation));
				table.insert(array, cc.Spawn:create(spawns));

				local pp = cc.p(tpos.x-pos.x, tpos.y-pos.y);
				local r = math.atan2(pp.y, pp.x);
				local r1 = r * 360 / ( 2 * 3.14 );
				local r2 = 90 - r1;
				sprite:setRotation(r2);
				
				if nil ~= tsize then
					local s = sprite:getContentSize();
					sprite:setScale(scale);
				end
			else
				table.insert(array, cc.Animate:create(animation));
			end
			table.insert(array, cc.CallFunc:create(callback_play_eff));
			if i == #list and nil ~= callback then
				table.insert(array, cc.CallFunc:create(callback));
			end
			sprite:runAction(cc.Sequence:create(array));

			if nil ~= csprite then
				csprite:shake(0.2, radius, delay+0.1);
			end

			delay = delay + t;
		end
	end
	local flag = fsprite:isVisible();
	if false == flag and (0 == step or 2 == step or 3 == step) then
		a_play_eff_show(fsprite, delay, true);
	end

	return delay;
end

-- eff image size is ref from half size of the card(365x512), see in gui.lua
-- so the scale factor should be card_sprite:getScale() * 2
function play_animation(layer, ekind, fsprite, tsprite, step, eff, callback)
	step = step or 0;
	eff = eff or false;
	
	local fsize, fscale, fpos = anim_csprite_info(fsprite);
	local tsize, tscale, tpos = anim_csprite_info(tsprite);
	local time = 0;
	local ename = string.format("s_%d", ekind);
	local list = {};
	if 0 == step or 1 == step then
		local l = { 
			pos = fpos, step = 1, size = fsize,
			csprite = fsprite, 
			radius = 4, ap = ANCHOR_CENTER_CENTER, scale = fscale 
		};
		table.insert(list, l);
		--[[
		l = { 
			pos = fpos, tpos = tpos, size = fsize, tsize = tsize,
			step = 0, ap = ANCHOR_CENTER_CENTER, scale = (fscale+tscale)/2
		};
		table.insert(list, l);
		]]--
	end
	if 0 == step or 2 == step then
		local l = { -- the number of fly effect should match the hurt effect  
			pos = fpos, tpos = tpos, size = fsize, tsize = tsize,
			step = 0, ap = ANCHOR_CENTER_CENTER, scale = (fscale+tscale)/2
		};
		table.insert(list, l);
		l = { 
			pos = tpos, step = 2, size = tsize,
			csprite = tsprite, 
			radius = 8, ap = ANCHOR_CENTER_CENTER, scale = tscale 
		};
		table.insert(list, l);
	end
	if 0 == step or 3 == step then
		local l = { 
			pos = ccp(HALF_WIDTH, HALF_HEIGHT), step = 3,
			ap = ANCHOR_CENTER_CENTER, scale = 1 
		};
		table.insert(list, l);
	end

	local function handler(armatureBack, movementType, movementID)
		-- armatureBack is ccs.Armature
		--ccs.MovementEventType = {
	--		start = 0,
	--		complete = 1,
	--		loopComplete = 2, 
	--	}
		if movementType == ccs.MovementEventType.complete then
			armatureBack:removeFromParentAndCleanup(true);
			cc.SpriteFrameCache:getInstance():removeUnusedSpriteFrames();
		end
	end

	local function play_it(...)
		local args = {...};
		local armature = args[1];
		local animation = armature:getAnimation();
		animation:setMovementEventCallFunc(handler);
		--animation:playWithIndex(0, -1, 0);
		--animation:playWithName('play');
		animation:playWithIndex(0);
	end

	for i = 1, #list do
		local info = list[i];
		local step = info.step;
		local pos = info.pos;
		local ap = info.ap;
		local size = info.size;
		local scale = info.scale;
		local fname = string.format("%s_%d", ename, step);
		local filename = string.format("%s.csb", fname);
		if true == util.check_file(filename) then
			local path = util.get_fullpath(F_ANIM, filename);	
			print('path: ', path);
			ccs.ArmatureDataManager:getInstance():removeArmatureFileInfo(path);
			ccs.ArmatureDataManager:getInstance():addArmatureFileInfo(path);

			local armature = ccs.Armature:create(fname);
			local animation = armature:getAnimation();
			--animation:setMovementEventCallFunc(handler);
			--animation:playWithIndex(0, -1, 0);
			--animation:playWithName('play');
			armature:setPosition(pos);
			--armature:setAnchorPoint(ap);
			layer:addChild(armature, ZORDER_EFFECT);

			local animation_data = animation:getAnimationData();
			local movement_data = animation_data:getMovement('play');
			print('md: ', movement_data, movement_data.duration);
			--local t = pt * len;
			local t = 0.5;
			time = time + t;

			info.animation = animation;
			info.sprite = armature;
			info.time = t;
		end
	end

	local delay = 0;
	if 'e_hide' == eff and (0 == step or 1 == step) then
		a_play_eff_show(fsprite, delay, false);
	end
	for i = 1, #list do
		local info = list[i];
		local csprite = info.csprite;
		local radius = info.radius;
		local sprite = info.sprite;
		local step = info.step;
		if nil ~= sprite then
			local t = info.time;
			local tpos = info.tpos;
			local pos = info.pos;
			local tsize = info.tsize;
			local scale = info.scale;

			local array = {};
			table.insert(array, cc.Hide:create());
			table.insert(array, cc.DelayTime:create(delay));
			table.insert(array, cc.Show:create());
			if nil ~= tpos then
				local spawns = {};
				local action = cc.MoveTo:create(t, tpos);
				table.insert(spawns, action);
				table.insert(spawns, cc.Animate:create(animation));
				table.insert(array, cc.Spawn:create(spawns));

				local pp = cc.p(tpos.x-pos.x, tpos.y-pos.y);
				local r = math.atan2(pp.y, pp.x);
				local r1 = r * 360 / ( 2 * 3.14 );
				local r2 = 90 - r1;
				sprite:setRotation(r2);
				
				if nil ~= tsize then
					local s = sprite:getContentSize();
					sprite:setScale(scale);
				end
			else
				local sa = {};
				table.insert(sa, cc.DelayTime:create(t));
				table.insert(sa, cc.CallFunc:create(play_it));
				table.insert(array, cc.Spawn:create(sa));
			end
			if i == #list and nil ~= callback then
				table.insert(array, cc.CallFunc:create(callback));
			end
			sprite:runAction(cc.Sequence:create(array));

			if nil ~= csprite then
				csprite:shake(0.2, radius, delay+0.1);
			end

			delay = delay + t;
		end
	end
	local flag = fsprite:isVisible();
	if false == flag and (0 == step or 2 == step or 3 == step) then
		a_play_eff_show(fsprite, delay, true);
	end

	return delay;
end

-- eff image size is ref from half size of the card(365x512), see in gui.lua
-- so the scale factor should be card_sprite:getScale() * 2
function play_flash(layer, ekind, fsprite, tsprite, step, eff, callback)
	step = step or 0;
	eff = eff or false;
	
	local fsize, fscale, fpos = anim_csprite_info(fsprite);
	local tsize, tscale, tpos = anim_csprite_info(tsprite);
	local time = 0;
	local ename = string.format("s_%d", ekind);
	local list = {};
	if 0 == step or 1 == step then
		local l = { 
			pos = fpos, step = 1, size = fsize,
			csprite = fsprite, 
			radius = 4, ap = ANCHOR_CENTER_CENTER, scale = fscale 
		};
		table.insert(list, l);
		--[[
		l = { 
			pos = fpos, tpos = tpos, size = fsize, tsize = tsize,
			step = 0, ap = ANCHOR_CENTER_CENTER, scale = (fscale+tscale)/2
		};
		table.insert(list, l);
		]]--
	end
	if 0 == step or 2 == step then
		local l = { -- the number of fly effect should match the hurt effect  
			pos = fpos, tpos = tpos, size = fsize, tsize = tsize,
			step = 0, ap = ANCHOR_CENTER_CENTER, scale = (fscale+tscale)/2
		};
		table.insert(list, l);
		l = { 
			pos = tpos, step = 2, size = tsize,
			csprite = tsprite, 
			radius = 8, ap = ANCHOR_CENTER_CENTER, scale = tscale 
		};
		table.insert(list, l);
	end
	if 0 == step or 3 == step then
		local l = { 
			pos = ccp(HALF_WIDTH, HALF_HEIGHT), step = 3,
			ap = ANCHOR_CENTER_CENTER, scale = 1 
		};
		table.insert(list, l);
	end

	local last_action_index = 1;
	local factory = DBCCFactory:getInstance();
	--local cache = cc.SpriteFrameCache:getInstance();
	local is_has_anim = false;
	for i = 1, #list do
		local info = list[i];
		local step = info.step;
		local pos = info.pos;
		local ap = info.ap;
		local size = info.size;
		local scale = info.scale;
		local aname = string.format("%s_%d", ename, step);
		local slt_name = string.format("%s_skeleton.xml", aname);
		local tx_name = string.format("%s_texture.xml", aname);
		if true == util.check_file(slt_name) then
			factory:loadDragonBonesData(slt_name, aname);
			factory:loadTextureAtlas(tx_name, aname);
			local armature_node = factory:buildArmatureNode(aname);

			armature_node:setPosition(pos);
			armature_node:setAnchorPoint(ap);
			--sprite:setScale(scale);
			layer:addChild(armature_node, ZORDER_EFFECT);
			last_action_index = last_action_index + 1;
			local t = 0.5;
			if 0 == step then
			--pos = fpos, tpos = tpos, size = fsize, tsize = tsize,
				local pp = cc.p(info.tpos.x-pos.x, info.tpos.y-pos.y);
				local offset = math.sqrt(math.pow(pp.x, 2) + math.pow(pp.y, 2));
				t = offset / 1000;
				if t > 0.5 then t = 0.5 end
			end
			time = time + t;

			info.sprite = armature_node;
			info.time = t;
			is_has_anim = true;
		elseif 1 == step then
			info.is_attacker_atnormal = true;
			info.sprite = fsprite;
			info.time = 0;
		end
	end
	if false == is_has_anim then
		for i = 1, #list do
			local info = list[i];
			if true == info.is_attacker_atnormal then
				info.is_attacker_atnormal = nil;
				info.sprite = nil;
			end
		end
	end

	local delay = 0;
	if 'e_hide' == eff and (0 == step or 1 == step) then
		a_play_eff_show(fsprite, delay, false);
	end
	for i = 1, #list do
		local info = list[i];
		local csprite = info.csprite;
		local radius = info.radius;
		local sprite = info.sprite;
		local step = info.step;
		if 1 == step and true == info.is_attacker_atnormal and nil ~= sprite then
			local action, array, sarray, scale;
			local x = sprite:getPositionX();
			local y = sprite:getPositionY();
			scale = sprite:getScale();
			local svv = 1;
			if y > HALF_HEIGHT then
				svv = -1;
			end
			array = {};
			table.insert(array, cc.DelayTime:create(delay));
			sarray = {};
			action = cc.ScaleTo:create(0.2, scale + 0.05);
			table.insert(array, action);
			action = cc.ScaleTo:create(0.1, scale + 0.03);
			table.insert(array, action);

			sarray = {};
			action = cc.ScaleTo:create(0.2, scale + 0.01);
			table.insert(sarray, action);
			action = cc.MoveTo:create(0.2, cc.p(x, y + svv*15));
			table.insert(sarray, action);
			action = cc.Spawn:create(sarray);
			action = cc.EaseIn:create(action, 0.1);
			table.insert(array, action);
			action = cc.Sequence:create(array);
			sprite:runAction(action);
			delay = delay + 0.4;

			array = {};
			table.insert(array, cc.DelayTime:create(delay + 0.1));
			sarray = {};
			action = cc.RotateTo:create(0.2, 0);
			table.insert(sarray, action);
			action = cc.ScaleTo:create(0.1, scale);
			table.insert(sarray, action);
			action = cc.MoveTo:create(0.1, cc.p(x, y));
			table.insert(sarray, action);
			action = cc.Spawn:create(sarray);
			table.insert(array, action);
			action = cc.Sequence:create(array);
			sprite:runAction(action);
		elseif nil ~= info.sprite then
			local t = info.time;
			local tpos = info.tpos;
			local pos = info.pos;
			local tsize = info.tsize;
			local scale = info.scale;

			local function play_it()
				local function cb1(armature_node, event_type, movement_id, frame_label)
					--print('xx: ', event_type, movement_id, frame_label);
					if 7 == event_type then -- compelete
						armature_node:removeFromParent(true);
						--callback_func
			--callback_play_eff;
						--print('i, #list, callback: ', i, #list, callback);
						if i == last_action_index and nil ~= callback then
							callback();
						end
					end
				end
				sprite:registerMovementEventHandler(cb1);
				local anim = sprite:getAnimation();
				anim:play();
			end

			local array = {};
			table.insert(array, cc.Hide:create());
			table.insert(array, cc.DelayTime:create(delay));
			table.insert(array, cc.Show:create());
			local function removeForNotFinishFlash()
				sprite:removeFromParent(true);
			end
			if nil ~= tpos then
				local spawns = {};
				local action = cc.MoveTo:create(t, tpos);
				table.insert(spawns, action);
				table.insert(spawns, cc.DelayTime:create(t));
				table.insert(spawns, cc.CallFunc:create(play_it));
				table.insert(array, cc.Spawn:create(spawns));
				if 0 == step then
					table.insert(array, cc.CallFunc:create(removeForNotFinishFlash));
				end

				local pp = cc.p(tpos.x-pos.x, tpos.y-pos.y);
				local r = math.atan2(pp.y, pp.x);
				local r1 = r * 360 / ( 2 * 3.14 );
				local r2 = 90 - r1;
				sprite:setRotation(r2);
				
				if nil ~= tsize then
					local s = sprite:getContentSize();
					sprite:setScale(scale);
				end
			else
				local sa = {};
				table.insert(sa, cc.DelayTime:create(t));
				table.insert(sa, cc.CallFunc:create(play_it));
				table.insert(array, cc.Spawn:create(sa));
				if 0 == step then
					table.insert(array, cc.CallFunc:create(removeForNotFinishFlash));
				end
			end
			--print('---- i: ', i);
			--[[
			table.insert(array, cc.CallFunc:create(callback_play_eff));
			if i == #list and nil ~= callback then
				table.insert(array, cc.CallFunc:create(callback));
			end
			]]--
			sprite:runAction(cc.Sequence:create(array));

			if nil ~= csprite then
				csprite:shake(0.2, radius, delay+0.1);
			end

			delay = delay + t;
		end
	end
	local flag = fsprite:isVisible();
	if false == flag and (0 == step or 2 == step or 3 == step) then
		a_play_eff_show(fsprite, delay, true);
	end

	return delay;
end

function anim_play_frame(layer, effname, pos, rotation, scale, callback, time, is_repeat) -- {
	local cost_time = 0;
	local filename, fullpath;
	local cache, sprite, animation, len;
	cache = cc.SpriteFrameCache:getInstance();
	filename = effname .. '.plist';
	fullpath = util.get_fullpath(F_ANIM, filename);
	cache:addSpriteFrames(fullpath);
	filename = effname .. '_1.png';
	sprite = cc.Sprite:createWithSpriteFrameName(filename);
	sprite:setPosition(pos);
	sprite:setRotation(rotation);
	sprite:setScale(scale);
	layer:addChild(sprite, ZORDER_EFFECT);
	animation = cc.Animation:create();
	len = 0;
	filename = effname .. '_' .. 1 .. '.png';
	local frame = cache:spriteFrameByName(filename);
	repeat
		len = len + 1;
		animation:addSpriteFrame(frame);
		filename = effname .. '_' .. len .. '.png';
		frame = cache:spriteFrameByName(filename);
	until nil == frame;
	animation:setDelayPerUnit(time);
	cost_time = cost_time + time * len;

	local array = {};
	table.insert(array, cc.Animate:create(animation));
	if nil ~= callback then
		table.insert(array, cc.CallFunc:create(callback));
	end

	if true == is_repeat then
		local action = cc.RepeatForever:create(cc.Sequence:create(array));
		if nil ~= tag then
			action:setTag(tag);
		end
		sprite:runAction(action);
		cost_time = 3; -- won't have repeat case now, so set to anything is ok
	else
		local action = cc.Sequence:create(array);
		if nil ~= tag then
			action:setTag(tag);
		end
		sprite:runAction(action);
	end
	
	return sprite, cost_time;
end -- anim_play_frame }

function attack_eff(layer, attacker, defender, sframe, tframe, time) -- {
	time = time or 0;
	local svv = 1;
	if sframe.y > HALF_HEIGHT then
		svv = -1;
	end
	local action, array, sarray;
	array = {};
	table.insert(array, cc.DelayTime:create(time));
	sarray = {};
	action = cc.ScaleTo:create(0.2, sframe.scale + 0.05);
	table.insert(array, action);
	action = cc.ScaleTo:create(0.1, sframe.scale + 0.03);
	table.insert(array, action);

	sarray = {};
	action = cc.ScaleTo:create(0.2, sframe.scale + 0.01);
	table.insert(sarray, action);
	action = cc.MoveTo:create(0.2, cc.p(sframe.x, sframe.y + svv*15));
	table.insert(sarray, action);
	action = cc.Spawn:create(sarray);
	action = cc.EaseIn:create(action, 0.1);
	table.insert(array, action);
	action = cc.Sequence:create(array);
	attacker:runAction(action);
	time = time + 0.4;

	local sprite = nil;
	local effname = 's_0_2';
	local filename, fullpath;
	local cache, sprite, animation, len;
	cache = cc.SpriteFrameCache:getInstance();
	filename = effname .. '.plist';
	if true == util.check_file(filename) then
		fullpath = util.get_fullpath(F_ANIM, filename);
		cache:addSpriteFrames(fullpath);
		filename = effname .. '_1.png';
		sprite = cc.Sprite:createWithSpriteFrameName(filename);
		sprite:setPosition(cc.p(tframe.x, tframe.y));
		layer:addChild(sprite, ZORDER_EFFECT);
		animation = cc.Animation:create();
		len = 0;
		filename = effname .. '_' .. 1 .. '.png';
		local frame = cache:spriteFrameByName(filename);
		repeat
			len = len + 1;
			animation:addSpriteFrame(frame);
			filename = effname .. '_' .. len .. '.png';
			frame = cache:spriteFrameByName(filename);
		until nil == frame;
		animation:setDelayPerUnit(0.1);

		array = {};
		sarray = {};
		table.insert(array, cc.Hide:create());
		table.insert(array, cc.DelayTime:create(time));
		table.insert(array, cc.Show:create());
		table.insert(array, cc.Animate:create(animation));
		table.insert(array, cc.CallFunc:create(callback_play_eff));

		action = cc.Sequence:create(array);
		sprite:runAction(action);

		defender:shake(0.2, 3, time+0.1*len/2);
	end

	array = {};
	table.insert(array, cc.DelayTime:create(time+0.1*len/2));
	sarray = {};
	action = cc.RotateTo:create(0.2, 0);
	table.insert(sarray, action);
	action = cc.ScaleTo:create(0.1, sframe.scale);
	table.insert(sarray, action);
	action = cc.MoveTo:create(0.1, cc.p(sframe.x, sframe.y));
	table.insert(sarray, action);
	action = cc.Spawn:create(sarray);
	table.insert(array, action);
	action = cc.Sequence:create(array);
	attacker:runAction(action);

	time = time + 0.1*len; 
	
	return sprite, time;
end -- attack_eff }

function attack_hit(layer, attacker, defender) -- {
	local time = 0;
	local zorder = defender:getLocalZOrder();
	defender:setLocalZOrder(zorder);
	attacker:setLocalZOrder(zorder+1);
	local ax, ay = attacker:getPosition();
	local ascale = attacker:getScale();
	local dx, dy = defender:getPosition();
	local dscale = defender:getScale();
	local gh = 1;
	local gv = 1;
	if ay > dy then
		gh = -1;
	end
	if ax > dx then
		gv = -1;
	end
	local action, array, sarray;
	array = {};
	sarray = {};
	action = cc.ScaleTo:create(0.2, ascale + 0.05);
	table.insert(sarray, action);
	action = cc.MoveTo:create(0.2, cc.p(ax-gv, ay-gh*15));
	table.insert(sarray, action);
	action = cc.Spawn:create(sarray);
	table.insert(array, action);
	action = cc.ScaleTo:create(0.1, ascale + 0.03);
	table.insert(array, action);

	sarray = {};
	action = cc.ScaleTo:create(0.2, ascale + 0.01);
	table.insert(sarray, action);
	action = cc.MoveTo:create(0.3, cc.p(dx+gv, dy + gh*15));
	table.insert(sarray, action);
	action = cc.Spawn:create(sarray);
	action = cc.EaseOut:create(action, 0.3);
	table.insert(array, action);

	sarray = {};
	action = cc.ScaleTo:create(0.1, ascale);
	table.insert(sarray, action);
	action = cc.MoveTo:create(0.2, cc.p(ax, ay));
	table.insert(sarray, action);
	action = cc.Spawn:create(sarray);
	action = cc.EaseIn:create(action, 0.2);
	table.insert(array, action);
	action = cc.Sequence:create(array);
	attacker:runAction(action);

	array = {};
	sarray = {};
	action = cc.ScaleTo:create(0.2, dscale + 0.05);
	table.insert(array, action);
	action = cc.ScaleTo:create(0.1, dscale + 0.03);
	table.insert(array, action);
	action = cc.DelayTime:create(0.2);
	table.insert(array, action);

	sarray = {};
	action = cc.ScaleTo:create(0.1, dscale + 0.01);
	table.insert(sarray, action);
	action = cc.MoveTo:create(0.2, cc.p(dx+gv*15*2, dy + gh*15*2));
	table.insert(sarray, action);
	action = cc.Spawn:create(sarray);
	action = cc.EaseOut:create(action, 0.2);
	table.insert(array, action);

	sarray = {};
	action = cc.ScaleTo:create(0.1, dscale);
	table.insert(sarray, action);
	action = cc.MoveTo:create(0.1, cc.p(dx, dy));
	table.insert(sarray, action);
	action = cc.Spawn:create(sarray);
	action = cc.EaseIn:create(action, 0.1);
	table.insert(array, action);
	action = cc.Sequence:create(array);
	defender:runAction(action);

	time = time + 0.8; 
	
	return time;
end -- attack_hit }

-- asprite --> attacker sprite , dsprite --> defender sprite
function action_skill(layer, asprite, dsprite, time)
	local laser = nil;
	local function remove_laser()
		laser.batch:removeFromParentAndCleanup(true);
		return;
	end
	local apos = cc.p(asprite:getPositionX(), asprite:getPositionY());
	local dpos = cc.p(dsprite:getPositionX(), dsprite:getPositionY());
	local fullpath = util.get_fullpath(F_PARTICLE, 'laser.plist');	
	laser = util.add_particle(layer, fullpath, apos, ZORDER_EFFECT);
	local pp = cc.p(dpos.x-apos.x, dpos.y-apos.y);
	local r = math.atan2(pp.y, pp.x);
	local r1 = r * 360 / ( 2 * 3.14 );
	local r2 = 90 - r1;
	local offset = math.sqrt(math.pow(pp.x, 2) + math.pow(pp.y, 2));
	local spos = laser.emitter:getPosVar();
	spos.y = offset*0.5;
	laser.emitter:setPosVar(spos);
	local tpos = cc.p(pp.x/2+apos.x, pp.y/2+apos.y);
	laser.batch:setPosition(tpos);
	laser.batch:setRotation(r2);

	local action, array;
	array = {};
	action = cc.DelayTime:create(time);
	table.insert(array, action);
	action = cc.CallFunc:create(remove_laser);
	table.insert(array, action);
	action = cc.Sequence:create(array);
	asprite:runAction(action);
	
	asprite:shake(time-0.1, 8, 0);
	dsprite:shake(time-0.1, 8, 0);
	
	return time + 0.1;
end

function a_particle_sac(...) -- {
	local args = {...};
	local sprite = args[1];
	local scale = sprite:getScale();
	local pname = 'c_sac.plist';
	local layer = sprite:getParent();
	local pos = cc.p(sprite:getPositionX(), sprite:getPositionY());
	local zorder = sprite:getLocalZOrder();

	local path = util.get_path(pname);
	local info = util.add_particle(layer, path, pos, zorder-1);
	scale = sprite:getScale();
	info.batch:setScale(scale);
end -- a_particle_sac end }

-- deprecated
function a_particle_shoot(sdata, data, parray)
	local action, array;
	local fsprite = data.att_sprite;
	local tsprite = data.sprite;
	local layer = data.layer;
	local fpos = cc.p(fsprite:getPositionX(), fsprite:getPositionY());
	local tpos = cc.p(tsprite:getPositionX(), tsprite:getPositionY());
	local fullpath = util.get_path('ab_tail.plist');
	local zorder = fsprite:getLocalZOrder();
	local info = util.add_particle(layer, fullpath, fpos, zorder+1);

	local pp = cc.p(tpos.x-fpos.x, tpos.y-fpos.y);
	local r = math.atan2(pp.y, pp.x);
	local r1 = r * 360 / ( 2 * 3.14 );
	local r2 = 90 - r1;
	local offset = math.sqrt(math.pow(pp.x, 2) + math.pow(pp.y, 2));
	local spos = info.emitter:getPosVar();
	spos.y = offset*0.5;
	spos.y = 0;
	info.emitter:setPosVar(spos);
	info.batch:setRotation(r2);

	array = {};
	action = cc.MoveTo:create(0.2, tpos);
	table.insert(array, action);
	action = cc.CallFunc:create(anim_callback_remove);
	table.insert(array, action);
	action = cc.Sequence:create(array);
	info.batch:runAction(action);

	action = cc.DelayTime:create(0.2);
	if nil ~= parray and nil ~= action then
		table.insert(parray, action);
	end
	return action;
end

--------------- ANIM_ACTION START ------------
function anim_action_use(use_index, front_index)
	--alog('DBEUG do anim_action_use');
	--alog('DEBUG use_index, front_index: ', use_index, front_index);
	local use_table_index, use_list_index, use_card_list, use_card;
	use_table_index, use_list_index, use_card_list, use_card 
		= anim_get_info(use_index);

	local anim_group = {};
	local alist, scale;

	if use_index == front_index then
		alog('DEBUG anim_action_use use_index == front_index: ', use_index);
		return anim_group;
	end

	if nil == front_index then
		local sprite = anim_get_sprite(use_card);
		local use_side = anim_index_side(use_index);
		if use_side ~= g_euser.side and use_card.status == CARD_COVER and use_table_index == T_HAND then
			alist = {
				info = use_card,
				sprite = sprite,
				anims = {
					{ anim_name = 'scale_front', pos = ccp(HALF_WIDTH, HALF_HEIGHT), scale = 1.5 },
				},
			};
			anim_group[#anim_group + 1] = { alist };
		
			alist = {
				sprite = sprite,
				card_info = use_card,
				anims = {
					{ anim_name = 'flip_card', orient = 'front' },
				},
			};
			anim_group[#anim_group + 1] = { alist };

			alist = {
				sprite = sprite,
				card_info = use_card,
				anims = {
					{ anim_name = 'show_full_card', time = 1 },
				},
			};
			anim_group[#anim_group + 1] = { alist };
		elseif use_table_index == T_HAND then
		end

		return anim_group;
	end

	local front_table_index, front_list_index, front_card_list, front_card;
	front_table_index, front_list_index, front_card_list, front_card 
		= anim_get_info(front_index);

	sprite = anim_get_sprite(front_card);
	scale = front_card_list.cscale;
	local pos = cc.p(front_card.frame.x, front_card.frame.y);
	
	alist = {
		sprite = sprite,
		anims = {
			{ anim_name = 'spawn', 
			  anim_parts = {
			      { anim_part = 'move', pos = pos },
				  { anim_part = 'scale', scale = scale },
				  { anim_part = 'rotate', rotation = 0 },
			  },
		    },
			{ anim_name = 'to_back' },
		},
	};
	anim_group[#anim_group + 1] = { alist };

	sprite = anim_get_sprite(use_card);

	alist = {
		info = use_card,
		sprite = sprite,
	 	anims = {
			{ anim_name = 'to_front' },
		},
	};
	anim_group[#anim_group + 1] = { alist };

	return anim_group;
end

function anim_action_trap(trap_index)
	local trap_table_index, trap_list_index, trap_card_list, trap_card;
	trap_table_index, trap_list_index, trap_card_list, trap_card 
		= anim_get_info(trap_index);

	local anim_group = {};
	local alist, scale;

	if trap_index == front_index then
		alog('DEBUG anim_action_trap trap_index == front_index: ', trap_index);
		return anim_group;
	end

	local sprite = anim_get_sprite(trap_card);
	local trap_side = anim_index_side(trap_index);
--	if trap_side ~= g_euser.side
--	and true ~= SHOW_ALL
	if trap_table_index == T_SUPPORT then
		alist = {
			info = trap_card,
			sprite = sprite,
			anims = {
				{ anim_name = 'scale_front', pos = ccp(HALF_WIDTH, HALF_HEIGHT), scale = 1.5 },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	
		alist = {
			sprite = sprite,
			card_info = trap_card,
			anims = {
				{ anim_name = 'flip_card', orient = 'front' },
			},
		};
		anim_group[#anim_group + 1] = { alist };

		alist = {
			sprite = sprite,
			card_info = trap_card,
			anims = {
				{ anim_name = 'show_full_card', time = .8 },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	end

	return anim_group;
end

function anim_action_add(add_index, card_id)
	local table_index, list_index, card_list, info = anim_get_info(add_index);
	local side = anim_index_side(add_index);

	local anim_list = {};
	local anim_group = {};
	local pos = anim_get_npos(add_index);
	pos.x = g_ui_table[side][T_DECK].x;
	pos.y = g_ui_table[side][T_DECK].y;
	local layer = layer_card.layer;

	--print('index : ', add_side, add_table_index, add_list_index);
	local c = g_logic_table[side][table_index][list_index];
	local rotation = 0;
	if side == SIDE_UP then
		rotation = 180;
	end
	info = add_ui_card(layer, card_list, pos, rotation, c, nil, nil, list_index);

	anim_arrange_list(add_index, anim_list, 'insert');

	local sprite = anim_get_sprite(info);
	local scale = sprite:getScale();
	anim_list[#anim_list + 1] = {
		info = info,
		sprite = sprite,
		anims = {
			{ anim_name = 'scale', scale = scale*1.5 },
			{ anim_name = 'scale', scale = scale },
		},
	};
	anim_group[#anim_group + 1] = anim_list;

	return anim_group;
end

function anim_action_anim(cid, src_index, atype, tlist, front_index) --{
	local front_table_index, front_list_index, front_card_list, front_card;
	front_table_index, front_list_index, front_card_list, front_card 
		= anim_get_info(front_index);

	local src_table_index, src_list_index, src_card_list, src_card;
	src_table_index, src_list_index, src_card_list, src_card 
		= anim_get_info(src_index);

	-- anim group
	local anim_group = {};
	local alist = nil;

	if nil ~= front_card and front_table_index == T_HAND then
		local front_side = anim_index_side(front_index);
		local hs = anim_get_sprite(g_ui_table[front_side][T_HERO][1]);
		local pos = ccp(hs:getPositionX(), hs:getPositionY());
		local scale = ANIM_SCALE_CENTER;--*0.6;--anim.SCALE_SHOW/3.5;
		local sprite = anim_get_sprite(front_card);

		alist = {
			info = front_card,
			sprite = sprite,
			anims = {
				{ anim_name = 'to_front' },
				{ anim_name = 'spawn', 
				  anim_parts = {
					  { anim_part = 'move', pos = pos },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  }
				},
				{ anim_name = 'to_back' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	end
	
	if nil == src_card or 0 == #tlist then
		return anim_group;
	end

	local is_screen_eff = false;
	local filename = '';
	if true == USE_FLASH then
		filename = string.format("s_%s_%d_skeleton.xml", atype, 2);
	else
		filename = string.format("s_%s_%d.plist", atype, 2);
	end
	if true ~= util.check_file(filename) then
		is_screen_eff = true;
	end

	anim_list = {};
	local sprite = anim_get_sprite(src_card);
	for i = 1, #tlist do
		local tar_index = tlist[i];
		local tar_table_index, tar_list_index, tar_card_list, tar_card;
		tar_table_index, tar_list_index, tar_card_list, tar_card 
			= anim_get_info(tar_index);
		local eff = nil;
		if front_table_index == T_HAND then
			eff = 'e_hide';
		end
		if nil ~= tar_card then
			local tsprite = anim_get_sprite(tar_card);
			if 1 == i then
				local tar_pos = cc.p(sprite:getPositionX(),sprite:getPositionY());
				alist = {
					sprite = tsprite,
					att_sprite = sprite,
					layer = layer_anim.layer,
					anims = {
						{ anim_name = 'damage_anim', atype = atype, step = 1, eff = eff },
					},
				};
				anim_group[#anim_group + 1] = { alist };
				anim_set_tlist_src(src_index);
			end
			if 506 == atype or 507 == atype then -- hp up or hp down
				anim_set_tlist_src(0);
				anim.eff_hp_count = anim.eff_hp_count + 1;
			elseif 508 == atype or 509 == atype then -- power up or power down
				anim_set_tlist_src(0);
				anim.eff_power_count = anim.eff_power_count + 1;
			else
				if true ~= is_screen_eff then
					anim_list[#anim_list + 1] = {
						sprite = tsprite,
						att_sprite = sprite,
						layer = layer_anim.layer,
						anims = {
							--{ anim_name ='particle', ptype = 'ab_tail' },
							{ anim_name = 'damage_anim', atype = atype, step=2 },
						},
					};
				else
					anim_list[#anim_list + 1] = {
						sprite = tsprite,
						anims = {
							{ anim_name = 'eff_sprite', duration = 0.5, radius = 5, 
														 delay = 0, etype = 'shake' },
						},
					};
				end
				anim_insert_tlist(tar_index);
			end
		end
	end
	if true == is_screen_eff then
		anim_list[#anim_list + 1] = {
			att_sprite = sprite,
			layer = layer_anim.layer,
			anims = {
				{ anim_name = 'damage_anim', atype = atype, step = 3 },
			},
		};
	end
	--[[
	anim_list[#anim_list + 1] = {
		layer_anim = layer_anim.layer,
		layer_card = layer_card,
		anims = {
			{ anim_name = 'eff_layer', etype = 'shake' },
		},
	};
	]]--
	anim_group[#anim_group + 1] = anim_list;

	return anim_group;
end -- anim_action_anim }

function anim_move_from_hand(src_index, tar_index, front_index) -- {
	local src_table_index, src_list_index, src_card_list, src_card;
	src_table_index, src_list_index, src_card_list, src_card 
		= anim_get_info(src_index);

	local tar_table_index, tar_list_index, tar_card_list, tar_card;
	tar_table_index, tar_list_index, tar_card_list
		= anim_get_info(tar_index);

	local tar_side = anim_index_side(tar_index);

	local anim_group = {};
	local anim_list = {};
	local alist;

	--print('front_index, src_index: ', front_index, src_index);
	if nil ~= front_index and front_index ~= src_index then

		local front_card = anim_get_card_info(front_index);
		local sprite = anim_get_sprite(front_card);
		local src_sprite = anim_get_sprite(src_card);
		local pos = cc.p(src_sprite:getPositionX(), src_sprite:getPositionY());
		local scale = src_sprite:getScaleX()/4*3;

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'spawn', 
				  anim_parts = {
				      { anim_part = 'move', pos = pos, efftype ='ease_out' },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  },
				},
				{ anim_name = 'to_back' },
			},
		}
		anim_group[#anim_group + 1] = { alist };

		alist = {
			sprite = sprite,
			anims = {	
				{ anim_name = 'particle', pname = 'dust' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	end

	local pos = anim_get_npos(tar_index);
	local sprite = anim_get_sprite(src_card);
	local layer = layer_card.layer;

	local info = add_ui_card(layer, tar_card_list, pos, 0, src_card.card, sprite, nil, tar_list_index);

	anim_arrange_list(tar_index, anim_list, 'insert');

	if src_table_index == T_GRAVE then
		anim_arrange_grave(src_index, anim_list, 'remove');
	end

	table.remove(src_card_list, src_list_index);

	anim_arrange_list(src_index, anim_list, 'remove');

	tar_card = tar_card_list[tar_list_index];
	pos = cc.p(tar_card.frame.x, tar_card.frame.y);
	local scale = tar_card_list.cscale;
	local rotation = tar_card.frame.rotation;
	sprite = anim_get_sprite(tar_card);

	if tar_table_index == T_RES then
		--local spos = cc.p(sprite:getPositionX(), sprite:getPositionY());
		local y2 = g_ui_table.label_res_max[tar_side]:getPositionY();
		pos.y = pos.y + (y2 - pos.y)/2;
		anim_list[#anim_list + 1] = {
			info = tar_card, 
			sprite = sprite,
			anims = {
				{ anim_name = 'to_front' },
				{ anim_name = 'spawn', 
				  anim_parts = {
					  { anim_part = 'bezier_move', pos=pos, efftype='ease_in' },
					  { anim_part = 'scale',  scale = ANIM_SCALE_CENTER },
					  { anim_part = 'rotate', rotation = rotation },
				  },
				},
				{ anim_name = 'to_back' },
				{ anim_name = 'hide' },
				{ anim_name = 'particle', ptype = 'sac' },
				{ anim_name = 'remove' },
			},
		};
		anim_group[#anim_group + 1] = anim_list;
		return anim_group;
	end
	anim_list[#anim_list + 1] = {
		sprite = sprite,
		anims = {
			{ anim_name = 'to_front' },
			{ anim_name = 'spawn', 
			  anim_parts = {
				  { anim_part = 'move', pos = pos, efftype = 'ease_in' },
				  { anim_part = 'scale',  scale = scale },
				  { anim_part = 'rotate', rotation = rotation },
			  },
			},
			{ anim_name = 'to_back' },
		},
	};
	if tar_table_index == T_SUPPORT and TRAP == tar_card.card.ctype then
		anim_list[#anim_list].card_info = tar_card;
		table.insert(anim_list[#anim_list].anims[2].anim_parts, {anim_part = 'flip_card', orient = 'back' });
	end
	anim_group[#anim_group + 1] = anim_list;

	--[[
	if tar_table_index == T_SUPPORT then
		alist = {
			sprite = sprite,
			card_info = tar_card,
			anims = {
				{ anim_name = 'flip_card', orient = 'back' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	end
	]]--

	anim_list = {};
	if tar_table_index == T_GRAVE then
		anim_arrange_grave(tar_index, anim_list, 'insert');
		anim_group[#anim_group + 1] = anim_list;
	end

	return anim_group;
end -- anim_move_from_hand end }

function anim_get_card_pos_rotation(ui_table, index)
	local cwidth = CARD_SIZE_2.width;
	local cheight = CARD_SIZE_2.height;
	local cscale = ui_table.cscale;
	local gap;
	if ui_table.ltype == UP_GRAVE or ui_table.ltype == DOWN_GRAVE or 
	   ui_table.ltype == UP_DECK or ui_table.ltype == DOWN_DECK then
		gap = 0;
	else
		gap = calculate_gap(#ui_table, cwidth*cscale, ui_table.width, ui_table.ltype);
	end
	local pos;
	local rotation = 0;
	pos, rotation = get_card_pos_rotation(ui_table, gap, index, #ui_table);	
	return pos, rotation;
end

function anim_move_in_deck(src_index, tar_index, front_index) -- {
	local src_table_index, src_list_index, src_card_list, src_card;
	src_table_index, src_list_index, src_card_list, src_card 
		= anim_get_info(src_index);

	local tar_table_index, tar_list_index, tar_card_list, tar_card;
	tar_table_index, tar_list_index, tar_card_list
		= anim_get_info(tar_index);

	local anim_group = {};
	local alist;

	local anim_list = {};

	--[[
	if nil ~= front_index and front_index ~= src_index then
		local front_card = anim_get_card_info(front_index);
		local sprite = anim_get_sprite(front_card);
		local src_sprite = anim_get_sprite(src_card);
		local pos = cc.p(src_sprite:getPositionX(), src_sprite:getPositionY());
		local scale = src_sprite:getScaleX()/4*3;

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'spawn', 
				  anim_parts = {
				      { anim_part = 'move', pos = pos, efftype = 'ease_out'  },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  },
				},
				{ anim_name = 'to_back' },
			},
		}
		anim_group[#anim_group + 1] = { alist };

		alist = {
			sprite = sprite,
			anims = {	
				{ anim_name = 'particle', pname = 'dust' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	end
	]]--

	local src_side = anim_index_side(src_index);
	local tar_side = anim_index_side(tar_index);

	local pos = anim_get_npos(src_index);
	local sprite = anim_get_sprite(src_card);
	local layer = layer_card.layer;

	local scale = src_card_list.cscale;
	local rotation = src_card.frame.rotation;

	table.remove(src_card_list, src_list_index);
	local info = add_ui_card(layer, tar_card_list, pos, 0, src_card.card, sprite, nil, tar_list_index, true);

	tar_card = tar_card_list[tar_list_index];
	pos = cc.p(tar_card.frame.x, tar_card.frame.y);
	sprite = anim_get_sprite(tar_card);

--	if tar_table_index == T_DECK then
--		info:flip_to_cover();
--	end

	-- need flip card to front
	alist = {
		sprite = sprite,
		card_info = tar_card,
		anims = {
			{ anim_name = 'to_front' },
			{ anim_name = 'spawn', 
			  anim_parts = {
				{ anim_name = 'move', pos = cc.p(pos.x+wfix(50), pos.y) },
				{ anim_name = 'rotate', rotation = 0 },
			  },
			},
			{ anim_name = 'to_zorder', zorder = ZORDER_CARD-1 },
			{ anim_name = 'spawn', 
			  anim_parts = {
				{ anim_name = 'rotate', rotation = rotation },
				{ anim_name = 'move', pos = pos },
			  },
			},
		},
	};

	if info.status == CARD_FRONT then
		table.insert(alist.anims[2].anim_parts,	{ anim_name = 'flip_card', orient = 'back' });
	end
	anim_group[#anim_group + 1] = { alist };

	if is_view_top() then
		tar_card = tar_card_list[1];
		sprite = anim_get_sprite(tar_card);
		alist = {
			sprite = sprite,
			card_info = tar_card,
			anims = {
				{ anim_name = 'flip_card', orient = 'front' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	end

	return anim_group;
end -- anim_move_in_deck end }

function anim_move_from_deck(src_index, tar_index, front_index) -- {
	local src_table_index, src_list_index, src_card_list, src_card;
	src_table_index, src_list_index, src_card_list, src_card 
		= anim_get_info(src_index);

	local tar_table_index, tar_list_index, tar_card_list, tar_card;
	tar_table_index, tar_list_index, tar_card_list
		= anim_get_info(tar_index);

	local anim_group = {};
	local alist;

	local anim_list = {};

	if nil ~= front_index and front_index ~= src_index then
		local front_card = anim_get_card_info(front_index);
		local sprite = anim_get_sprite(front_card);
		local src_sprite = anim_get_sprite(src_card);
		local pos = cc.p(src_sprite:getPositionX(), src_sprite:getPositionY());
		local scale = src_sprite:getScaleX()/4*3;

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'spawn', 
				  anim_parts = {
				      { anim_part = 'move', pos = pos, efftype = 'ease_out'  },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  },
				},
				{ anim_name = 'to_back' },
			},
		}
		anim_group[#anim_group + 1] = { alist };

		alist = {
			sprite = sprite,
			anims = {	
				{ anim_name = 'particle', pname = 'dust' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	end

	local src_side = anim_index_side(src_index);
	local tar_side = anim_index_side(tar_index);

	local pos = anim_get_npos(tar_index);
	local sprite = anim_get_sprite(src_card);
	local layer = layer_card.layer;

	local info = add_ui_card(layer, tar_card_list, pos, 0, src_card.card, sprite, nil, tar_list_index);

	if src_table_index == T_DECK then
		info:flip_to_cover();
	end

	anim_arrange_list(tar_index, anim_list, 'insert');

	table.remove(src_card_list, src_list_index);

	anim_arrange_list(src_index, anim_list, 'remove');

	tar_card = tar_card_list[tar_list_index];
	pos = cc.p(tar_card.frame.x, tar_card.frame.y);
	local scale = tar_card_list.cscale;
	local rotation = tar_card.frame.rotation;
	sprite = anim_get_sprite(tar_card);

	-- pos rotation should be same as in game.lua get_card_pos_rotation
	local tar_index_offset = anim_index_offset(tar_index);
	pos, rotation = anim_get_card_pos_rotation(tar_card_list, tar_index_offset);
	
	if ( tar_side == g_euser.side or true == data_handler.show_all_card or true == is_view_oppo()) and 
	   src_table_index == T_DECK then
		-- need flip card to front
		anim_list[#anim_list + 1] = {
			sprite = sprite,
			card_info = src_card,
			anims = {
				{ anim_name = 'to_front' },
				{ anim_name = 'spawn', 
				  anim_parts = {
					{ anim_name = 'flip_card', orient = 'front' },
					{ anim_name = 'deck_to_hand', end_pos = pos, scale = scale, tar_side = tar_side },
					{ anim_name = 'rotate', rotation = rotation },
				  },
				},
				{ anim_name = 'to_back' },
			},
		};
	else
		anim_list[#anim_list + 1] = {
			sprite = sprite,
			card_info = src_card,
			anims = {
				{ anim_name = 'to_front' },
				{ anim_name = 'spawn', 
				  anim_parts = {
					{ anim_name = 'deck_to_hand', end_pos = pos, scale = scale, tar_side = tar_side },
					{ anim_name = 'rotate', rotation = rotation },
				  },
				},
				{ anim_name = 'to_back' },
			},
		};
	end
	anim_group[#anim_group + 1] = anim_list;

	return anim_group;
end -- anim_move_from_deck end }

function anim_action_move(src_index, tar_index, front_index) -- {
	alog('DEBUG do anim_action_move src,tar,front: ', src_index, tar_index, front_index);
	local src_table_index, src_list_index, src_card_list, src_card;
	src_table_index, src_list_index, src_card_list, src_card 
		= anim_get_info(src_index);

	local tar_table_index, tar_list_index, tar_card_list, tar_card;
	tar_table_index, tar_list_index, tar_card_list
		= anim_get_info(tar_index);

	local anim_group = {};
	local alist;

	local anim_list = {};

	if #tar_card_list + 1 < tar_list_index then
		return anim_group;
	end

	if src_table_index == T_HAND then
		return anim_move_from_hand(src_index, tar_index, front_index);
	end

	local src_side = anim_index_side(src_index);
	local tar_side = anim_index_side(tar_index);
	
	if src_table_index == T_DECK then 
		if tar_table_index == T_DECK then
			return anim_move_in_deck(src_index, tar_index);
		else
			return anim_move_from_deck(src_index, tar_index, front_index);
		end
	end

	-- target ally or support back to hand , should turn to cover
	-- e.g retreat(132)
	if tar_side ~= g_euser.side and src_table_index ~= T_DECK 
		and tar_table_index == T_HAND and true ~= data_handler.show_all_card then

		local sprite = anim_get_sprite(src_card);
		alist = {
			sprite = sprite,
			card_info = src_card,
			anims = {
				{ anim_name = 'flip_card', orient = 'back' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	end

	if nil ~= front_index and front_index ~= src_index then
		local front_card = anim_get_card_info(front_index);
		local sprite = anim_get_sprite(front_card);
		local src_sprite = anim_get_sprite(src_card);
		local pos = cc.p(src_sprite:getPositionX(), src_sprite:getPositionY());
		local scale = src_sprite:getScaleX()/4*3;

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'spawn', 
				  anim_parts = {
				      { anim_part = 'move', pos = pos, efftype = 'ease_out'  },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  },
				},
				{ anim_name = 'to_back' },
			},
		}
		anim_group[#anim_group + 1] = { alist };

		alist = {
			sprite = sprite,
			anims = {	
				{ anim_name = 'particle', pname = 'dust' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	end
	
	local pos = anim_get_npos(tar_index);
	local sprite = anim_get_sprite(src_card);
	local layer = layer_card.layer;

	local lt, lb, rb; -- left_top, left_bottom, right_bottom;
	if src_table_index == T_GRAVE then
		local d = src_card.data;
		lt = d.left_top;
		lb = d.left_bottom;
		rb = d.right_bottom;
	end
	local info = add_ui_card(layer, tar_card_list, pos, 0, src_card.card, sprite, nil, tar_list_index);
	if nil ~= lt then info.data.left_top = lt; end
	if nil ~= lb then info.data.left_bottom = lb; end
	if nil ~= rb then info.data.right_bottom = rb; end

	anim_arrange_list(tar_index, anim_list, 'insert');

	if src_table_index == T_GRAVE then
		anim_arrange_grave(src_index, anim_list, 'remove');
	end

	table.remove(src_card_list, src_list_index);

	if src_table_index ~= T_GRAVE then
		anim_arrange_list(src_index, anim_list, 'remove');
	end

	tar_card = tar_card_list[tar_list_index];
	pos = cc.p(tar_card.frame.x, tar_card.frame.y);
	local scale = tar_card_list.cscale;
	local rotation = tar_card.frame.rotation;
	sprite = anim_get_sprite(tar_card);

	if src_table_index == T_GRAVE then
		anim_list[#anim_list + 1] = {
			sprite = sprite,
			anims = {
				{ anim_name='from_grave', ui_table = tar_card_list, index = tar_index, info = info },
				{ anim_name = 'show' },
			},
		};
	end
	
	anim_list[#anim_list + 1] = {
		sprite = sprite,
		anims = {
			{ anim_name = 'to_front' },
			{ anim_name = 'spawn', 
			  anim_parts = {
				  { anim_part = 'move', pos = pos, efftype = 'ease_in' },
				  { anim_part = 'scale',  scale = scale },
				  { anim_part = 'rotate', rotation = rotation },
			  },
			},
			{ anim_name = 'to_back' },
		},
	};
	anim_group[#anim_group + 1] = anim_list;

	anim_list = {};
	if tar_table_index == T_GRAVE then
		anim_arrange_grave(tar_index, anim_list, 'insert');
		anim_group[#anim_group + 1] = anim_list;
	end
	return anim_group;
end -- anim_action_move end }

function anim_action_move_attach(src_index_full, tar_index, front_index) -- {
	local str = tostring(src_index_full);
	local len = string.len(str);
	local str_index = string.sub(str, 1, 4);
	local str_num = string.sub(str, 5, len); 

	local src_index = tonumber(str_index);
	local attach_index = tonumber(str_num);

	local src_table_index, src_list_index, src_card_list, src_card;
	src_table_index, src_list_index, src_card_list, src_card 
		= anim_get_info(src_index);

	-- main anim group
	local anim_group = {};
	-- actions list
	local anim_list= {};
	local alist = nil;

	if nil ~= front_index and front_index ~= src_index_full then
		local front_table_index, front_list_index, front_card_list, front_card;
		front_table_index, front_list_index, front_card_list, front_card 
			= anim_get_info(front_index);

		local sprite = anim_get_sprite(front_card);
		local src_sprite = anim_get_sprite(src_card);
		local pos = ccp(src_sprite:getPositionX(), src_sprite:getPositionY());
		local scale = src_sprite:getScaleX() / 2;

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'spawn', 
				  anim_parts = {
				  	  { anim_part = 'move', pos = pos },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  },
				},
				{ anim_name = 'to_back' },
			},
		};
		anim_group[#anim_group + 1] = { alist };

		alist = {
			sprite = sprite,
			anims = {	
				{ anim_name = 'particle', pname = 'dust' },
			},
		};
		anim_group[#anim_group + 1] = { alist };

	end

	local attach_list = src_card.attach_list;

	if nil == attach_list or 0 == #attach_list then
		print('BUG attach_list == nil or 0', #attach_list);
		--alog('BUG attach_list == nil or 0');
		return anim_group;
	end
	--print('----xxxx----- ', src_index, #attach_list, attach_index);
	if attach_index > #attach_list then
	--[LUA] effect list: #eff_list=5
	--[LUA]     EFF card, id=38, index=2201, |
	--[LUA]     EFF move, src_index=2201, target_index=2305, |
	--[LUA]     EFF attach, target_index=2305, attach=0, acid=1032, id=38, |
	--[LUA]     EFF power, offset=1, index=2305, |
	--[LUA]     EFF resource, side=2, offset=-4, |
	-- need to create a attach card, but cannot get the card
	-- need 23052, and consider situation that play with ai, get many eff include
	-- add attach and remove attach
		print('anim attach_index > #attach_list');
		return anim_group;
	end

	local attach_card = attach_list[attach_index];
	
	if 1000 < attach_card.card.id and 0 == tar_index then
		-- TODO should make a destroy animation
		local src_sprite = anim_get_sprite(src_card);
		local pos = cc.p(src_sprite:getPositionX(), src_sprite:getPositionY());
		local sprite = anim_get_sprite(attach_card, pos);
		local count = #(sprite:getChildren() or {});
		alist = nil;
		--[[
		if 'cc.Node' == tolua.type(sprite) then
			alist = {
				sprite = sprite,
				anims = {
					{ anim_name = 'spawn', 
					  anim_parts = {
						  { anim_part = 'remove_csprite', obj = src_card },
					  },
					},
				},
			};
		else
		]]--
			alist = {
				sprite = sprite,
				anims = {
					{ anim_name = 'spawn', 
					  anim_parts = {
						  { anim_part = 'scale',  scale = 0 },
						  { anim_part = 'rotate', rotation = 0 },
						  { anim_part = 'remove_csprite', obj = src_card },
					  },
					},
				},
			};
		--end
		anim_group[#anim_group + 1] = { alist };
		table.remove(attach_list, attach_index);
		anim.last_rm_attach_index = src_index;
		return anim_group;
	end

	local tar_table_index, tar_list_index, tar_card_list, tar_card;
	tar_table_index, tar_list_index, tar_card_list, tar_card 
		= anim_get_info(tar_index);

	if #tar_card_list + 1 < tar_list_index then
		alog('BUG anim_action_move_attach #tar_card_list + 1 < tar_list_index');
		return anim_group;
	end

	local pos = ccp(src_card.frame.x, src_card.frame.y);
	local scale = src_card.frame.scale;
	local sprite = anim_get_sprite(attach_card, pos, scale);
	pos = anim_get_npos(tar_index);
	scale = tar_card_list.cscale;
	local layer = layer_card.layer;

	local info = add_ui_card(layer, tar_card_list, pos, 0, attach_card.card, sprite, nil, tar_list_index);
	info.t_index = tar_table_index;

	anim_arrange_list(tar_index, anim_list, 'insert');

	table.remove(attach_list, attach_index);

	-- TODO should reset the attach_list pos
	
	local tar_card = tar_card_list[tar_list_index];
	pos = cc.p(src_card.frame.x, src_card.frame.y);
	scale = src_card.frame.scale;
	sprite = anim_get_sprite(tar_card);
	local npos = cc.p(tar_card.frame.x, tar_card.frame.y);
	local nscale = tar_card_list.cscale;

	anim_list[#anim_list + 1] = {
		sprite = sprite,
		anims = {
			{ anim_name = 'to_front' },
			{ anim_name = 'spawn', 
			  anim_parts = {
			  	  { anim_part = 'move', pos = npos },
			      { anim_part = 'scale',  scale = nscale },
				  { anim_part = 'rotate', rotation = 0 },
			  },
			},
		    { anim_name = 'to_back' },
		},
	};
	anim_group[#anim_group + 1] = anim_list;

	anim_list = {};
	if tar_table_index == T_GRAVE then
		anim_arrange_grave(tar_index, anim_list, 'insert');
		anim_group[#anim_group + 1] = anim_list;
	end

	return anim_group;
end -- anim_action_move_attach }

function anim_action_attach_virtual(tar_index, src_index, id, acid, front_index)
	local tar_table_index, tar_list_index, tar_card_list, tar_card;
	tar_table_index, tar_list_index, tar_card_list, tar_card 
		= anim_get_info(tar_index);

	-- main anim group
	local anim_group = {};
	-- actions list
	local anim_list= {};

	if nil ~= front_index then

		local front_table_index, front_list_index, front_card_list, front_card;
		front_table_index, front_list_index, front_card_list, front_card 
			= anim_get_info(front_index);

		local sprite = anim_get_sprite(tar_card);
		local pos = ccp(sprite:getPositionX(), sprite:getPositionY());
		local scale = sprite:getScaleX() / 2;
		sprite = anim_get_sprite(front_card);

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'spawn', 
				  anim_parts = {
				  	  { anim_part = 'move', pos = pos },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  },
				},
				{ anim_name = 'to_back' },
			},
		};
		anim_group[#anim_group + 1] = { alist };

		alist = {
			sprite = sprite,
			anims = {	
				{ anim_name = 'particle', pname = 'dust' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	
	end

	local sprite = anim_get_sprite(tar_card);
	alist = {
		sprite = sprite,
		anims = {
			{ anim_name = 'attach', acid = acid },	
		},
	};
	anim_group[#anim_group + 1] = { alist };

	return anim_group;
end -- anim_action_attach_virtual }

function anim_action_attach(tar_index, src_index, id, acid, front_card_index)
	alog('DEBUG do anim_action_attach tar,src,id,acid,front: ', tar_index, src_index, id, acid, front_card_index);
	local src_table_index, src_list_index, src_card_list, src_card;
	src_table_index, src_list_index, src_card_list, src_card 
		= anim_get_info(src_index);
	
	local tar_table_index, tar_list_index, tar_card_list, tar_card;
	tar_table_index, tar_list_index, tar_card_list, tar_card 
		= anim_get_info(tar_index);
	
	-- main anim group
	local anim_group = {};
	-- actions list
	local anim_list= {};
	
	if nil == tar_card then
		return anim_group;
	end

	local attach_list = tar_card.attach_list;

	table.insert(attach_list, src_card);
	table.remove(src_card_list, src_list_index);

	anim_arrange_list(src_index, anim_list, 'remove');

	local attach_card = attach_list[#attach_list];
	local sprite = anim_get_sprite(attach_card);
	local pos = ccp(tar_card.frame.x, tar_card.frame.y);
	local scale = attach_card.frame.scale;
	
	anim_list[#anim_list + 1] = 
	{
		sprite = sprite,
		anims = {
			{ anim_name = 'to_front' },
			{ anim_name = 'spawn', 
			  anim_parts = {
			  	  { anim_part = 'move', pos = pos },
				  { anim_part = 'scale', scale = scale },
				  { anim_part = 'rotate', rotation = 0 },
			  }
			},
			{ anim_name = 'to_back' },
		}
	};
	anim_group[#anim_group + 1] = anim_list;

	return anim_group;
end -- anim_ation_attach }

-- e.g : anim_action_damage(1201, 2201, 1, 2);
function anim_action_damage(src_index, tar_index, dtype, power, atype) -- {
	local src_table_index, src_list_index, src_card_list, src_card;
	src_table_index, src_list_index, src_card_list, src_card 
		= anim_get_info(src_index);
		
	local tar_table_index, tar_list_index, tar_card_list, tar_card;
	tar_table_index, tar_list_index, tar_card_list, tar_card 
		= anim_get_info(tar_index);
	
	-- anim group
	local anim_group = {};
	local alist = nil;

	local src_sprite = anim_get_sprite(src_card);
	local tar_sprite = anim_get_sprite(tar_card);
	--local sf = { x = src_card.frame.x, y = src_card.frame.y, 
--					 scale = src_card_list.cscale };
	--local tf = { x = tar_card.frame.x, y = tar_card.frame.y, 
--					 scale = tar_card_list.cscale };

	alist = {
		sprite = tar_sprite,
		anims = {
			{ anim_name = 'to_back' },
		}
	};
	anim_group[#anim_group + 1] = { alist };
	if atype > 0 then
		local pos = cc.p(src_sprite:getPositionX(), src_sprite:getPositionY());
		local tar_pos = cc.p(tar_sprite:getPositionX(),tar_sprite:getPositionY());
		alist = {
			sprite = tar_sprite,
			att_sprite = src_sprite,
			layer = layer_anim.layer,
			anims = {
				{ anim_name = 'damage_anim', src_pos = pos, tar_pos = tar_pos, dtype = dtype, atype = atype, eff = eff },
			},
		};
	else
		alist = {
			def_sprite = tar_sprite,
			att_sprite = src_sprite,
			anims = {
				{ anim_name = 'at_normal', dtype = dtype },
			}
		};
	end
	anim_group[#anim_group + 1] = { alist };
	alist = {
		sprite = tar_sprite,
		anims = {
			{ anim_name = 'hp_num_change', offset = -power, flag ='negative' },
		}
	};
	anim_group[#anim_group + 1] = { alist };

	return anim_group;
	
end -- anim_action_damage }

-- fact, if dtype >= 5, do this anim
--so deathbone's skill do this anim
function anim_action_damage_map(src_index, tar_index, dtype, power, front_index, atype) -- {

	local front_table_index, front_list_index, front_card_list, front_card;
	front_table_index, front_list_index, front_card_list, front_card 
		= anim_get_info(front_index);

	local src_table_index, src_list_index, src_card_list, src_card;
	src_table_index, src_list_index, src_card_list, src_card 
		= anim_get_info(src_index);

	local tar_table_index, tar_list_index, tar_card_list, tar_card;
	tar_table_index, tar_list_index, tar_card_list, tar_card 
		= anim_get_info(tar_index);

	-- anim group
	local anim_group = {};
	local alist = nil;

	-- step 2
	--print('front_index, src_index: ', front_index, src_index);
	if nil ~= front_card and front_index ~= src_index then
		local front_side = anim_index_side(front_index);
		local hs = anim_get_sprite(g_ui_table[front_side][T_HERO][1]);
		local pos = ccp(hs:getPositionX(), hs:getPositionY());
		local scale = ANIM_SCALE_CENTER;--*0.6;--anim.SCALE_SHOW/3.5;
		local sprite = anim_get_sprite(front_card);

		alist = {
			info = front_card,
			sprite = sprite,
			anims = {
				{ anim_name = 'to_front' },
				{ anim_name = 'spawn', 
				  anim_parts = {
					  { anim_part = 'move', pos = pos },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  }
				},
				{ anim_name = 'to_back' },
			},
		};
		anim_group[#anim_group + 1] = { alist };

		sprite = anim_get_sprite(tar_card);
		local eff = nil;
		if front_table_index == T_HAND then
			eff = 'e_hide';
		end
		local tar_pos = ccp(sprite:getPositionX(), sprite:getPositionY());
		alist = {
			sprite = sprite,
			att_sprite = anim_get_sprite(front_card),
			layer = layer_anim.layer,
			anims = {
				{ anim_name = 'damage_anim', src_pos = pos, tar_pos = tar_pos, dtype = dtype, atype = atype, step = 1, eff = eff },
			},
		};
		anim_group[#anim_group + 1] = { alist };
		
		-- atype > 0 , eff will have two steps
		-- 1. go to target pos from origin pos
		-- 2. do eff
		--if 0 < atype and 3 ~= atype then
		if 0 < atype then
			alist = {
				sprite = sprite,
				att_sprite = anim_get_sprite(front_card),
				layer = layer_anim.layer,
				anims = {
					{ anim_name = 'damage_anim', src_pos = pos, tar_pos = tar_pos, dtype = dtype, atype = atype, step = 2 },
				},
			};
			anim_group[#anim_group + 1] = { alist };
		end

	elseif nil ~= front_card and front_index == src_index then

		local sprite = anim_get_sprite(front_card);
		local pos = ccp(front_card.frame.x, front_card.frame.y);
		local scale = front_card.frame.scale;

		alist = {
			sprite = sprite,
		 	anims = {	
				{ anim_name = 'to_front' },
				{ anim_name = 'spawn',
				  anim_parts = {
				  	  { anim_part = 'move', pos = pos },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  },
				},
				{ anim_name = 'to_back' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
		
		local src_sprite = anim_get_sprite(src_card);
		local tar_sprite = anim_get_sprite(tar_card);
		local src_pos = ccp(src_sprite:getPositionX(), src_sprite:getPositionY());
		local tar_pos = ccp(tar_sprite:getPositionX(), tar_sprite:getPositionY());
		alist = {
			sprite = tar_sprite,
		    att_sprite = anim_get_sprite(src_card),
			layer = layer_anim.layer,
			anims = {
				{ anim_name = 'damage_anim', src_pos = src_pos, tar_pos = tar_pos, dtype = dtype, atype = atype },
			},
		};
		anim_group[#anim_group + 1] = { alist };

	else
		local scale = src_card.frame.scale;
		local pos = ccp(src_card.frame.x, src_card.frame.y);
		local sprite = anim_get_sprite(src_card);
		local p = ccp(sprite:getPositionX(), sprite:getPositionY());
		local s = sprite:getScale();
		if p.x ~= pos.x or p.y ~= pos.y or s ~= scale then
			alist = {
				info = src_card,
				sprite = sprite,
				anims = {
					{ anim_name = 'spawn',
					  anim_parts = {
						  { anim_part = 'move', pos = pos },
						  { anim_part = 'scale', scale = scale },
						  { anim_part = 'rotate', rotation = 0 },
					  },
					},
				},
			};
			anim_group[#anim_group + 1] = { alist };
		end

	end
	if false == anim_remove_tlist(src_index) then
		--[[
		-- no need to do below
		-- multi target attack (atype > 500) should all do anim in the same
		--   time
		local src_pos, tar_pos;
		local src_sprite = anim_get_sprite(src_card);
		local sprite = anim_get_sprite(tar_card);
		src_pos = ccp(src_sprite:getPositionX(), src_sprite:getPositionY());
		tar_pos = ccp(sprite:getPositionX(), sprite:getPositionY());
		alist = {
			sprite = sprite,
			att_sprite = anim_get_sprite(src_card),
			layer = layer_anim.layer,
			anims = {
				{ anim_name = 'damage_anim', src_pos = src_pos, tar_pos = tar_pos, dtype = dtype, atype = atype, step = 2 },
			},
		};
		anim_group[#anim_group + 1] = { alist };
		]]--
	end

	local sprite = anim_get_sprite(tar_card);

	alist = {
		sprite = sprite,
		anims = {
			{ anim_name = 'hp_num_change', offset = -power, flag = 'negative' },	
		},
	};
	anim_group[#anim_group + 1] = { alist };
	
	return anim_group;
end -- anim_action_damage_map }

function anim_action_hp(tar_index, offset, front_index) -- {
	local anim_group = {};
	local alist = nil;

	if nil == tar_index then
		return anim_group;
	end

	local tar_table_index, tar_list_index, tar_card_list, tar_card;
	tar_table_index, tar_list_index, tar_card_list, tar_card 
		= anim_get_info(tar_index);

	if tar_table_index == T_GRAVE then
		local sprite = anim_get_sprite(tar_card);
		alist = {
			sprite = sprite,
			info = tar_card,
			anims = {
				{ anim_name = 'hp_num_change', offset = offset, flag = 'positive', no_eff = true },
			},
		};
		anim_group[#anim_group + 1] = { alist };
		return anim_group;
	end

	if nil ~= front_index and front_index ~= tar_index then

		local front_table_index, front_list_index, front_card_list, front_card;
		front_table_index, front_list_index, front_card_list, front_card 
			= anim_get_info(front_index);

		local sprite = anim_get_sprite(tar_card);
		local pos = ccp(sprite:getPositionX(), sprite:getPositionY());
		local scale = sprite:getScaleX() / 2;
		sprite = anim_get_sprite(front_card);

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'spawn', 
				  anim_parts = {
				  	  { anim_part = 'move', pos = pos },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  },
				},
				{ anim_name = 'to_back' },
			},
		};
		anim_group[#anim_group + 1] = { alist };

		alist = {
			sprite = sprite,
			anims = {	
				{ anim_name = 'particle', pname = 'dust' },
			},
		};
		anim_group[#anim_group + 1] = { alist };

	elseif front_index == tar_index then

		local front_table_index, front_list_index, front_card_list, front_card;
		front_table_index, front_list_index, front_card_list, front_card 
			= anim_get_info(front_index);

		local sprite = anim_get_sprite(front_card);
		alist = {
			sprite = sprite,
		 	anims = {
				{ anim_name = 'to_front' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	
	end

	local sprite = anim_get_sprite(tar_card);

	--[[
	local no_eff = false;
	if tar_table_index == T_GRAVE then
		no_eff = true;
	end
	]]--
	alist = {
		sprite = sprite,
		anims = {
			{ anim_name = 'hp_num_change', offset = offset, flag = 'positive' },
		},
	};
	anim_group[#anim_group + 1] = { alist };
	
	if nil ~= front_index and front_index == tar_index then

		local sprite = anim_get_sprite(tar_card);

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'to_front' },
			},
		};
		anim_group[#anim_group + 1] = { alist };

		local pos = ccp(tar_card.frame.x, tar_card.frame.y);
		local scale = tar_card.frame.scale;

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'spawn', 
				  anim_parts = {
				  	  { anim_part = 'move', pos = pos },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  },
				},
				{ anim_name = 'to_back' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	end

	return anim_group;
end -- anim_action_hp }

function anim_action_power(tar_index, offset, front_index) -- {

	local tar_table_index, tar_list_index, tar_card_list, tar_card;
	tar_table_index, tar_list_index, tar_card_list, tar_card 
		= anim_get_info(tar_index);

	local anim_group = {};
	local alist = nil;

	if tar_table_index == T_GRAVE then
		local sprite = anim_get_sprite(tar_card);
		alist = {
			sprite = sprite,
			info = tar_card,
			anims = {
				{ anim_name = 'power_num_change', offset = offset, tar_index = tar_index, no_eff = true},
			},
		};
		anim_group[#anim_group + 1] = { alist };
		return anim_group;
	end

	-- step 1
	if nil ~= front_index and front_index ~= tar_index then

		local front_table_index, front_list_index, front_card_list, front_card;
		front_table_index, front_list_index, front_card_list, front_card 
			= anim_get_info(front_index);

		local sprite = anim_get_sprite(tar_card);
		local pos = cc.p(sprite:getPositionX(), sprite:getPositionY());
		local scale = sprite:getScaleX() / 2;
		sprite = anim_get_sprite(front_card);

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'spawn', 
				  anim_parts = {
				  	  { anim_part = 'move', pos = pos },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  },
				},
				{ anim_name = 'to_back' },
			},
		};
		anim_group[#anim_group + 1] = { alist };

		alist = {
			sprite = sprite,
			anims = {	
				{ anim_name = 'particle', pname = 'dust' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	
	elseif front_index == tar_index then

		local front_table_index, front_list_index, front_card_list, front_card;
		front_table_index, front_list_index, front_card_list, front_card 
			= anim_get_info(front_index);

		local sprite = anim_get_sprite(front_card);

		alist = {
			sprite = sprite,
		 	anims = {
				{ anim_name = 'to_front' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	
	end

	local sprite = anim_get_sprite(tar_card);
	local table_index = anim_index_table_num(tar_index);
	if table_index ~= T_HERO then
		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'power_num_change', offset = offset, tar_index = tar_index },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	end

	if nil ~= front_index and front_index == tar_index then

		local sprite = anim_get_sprite(tar_card);

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'to_front' },
			},
		};
		anim_group[#anim_group + 1] = { alist };

		local pos = ccp(tar_card.frame.x, tar_card.frame.y);
		local scale = tar_card.frame.scale;

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'spawn', 
				  anim_parts = {
				  	  { anim_part = 'move', pos = pos },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  },
				},
				{ anim_name = 'to_back' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	end

	return anim_group;
end -- anim_action_power }

function anim_action_energy(side_index, offset, front_index) -- {
	
	local hero_card = g_ui_table[side_index][T_HERO][1];

	local front_table_index, front_list_index, front_card_list, front_card;
	front_table_index, front_list_index, front_card_list, front_card
		= anim_get_info(front_index);

	local anim_group = {};
	local alist = nil;

	-- step 1
	if nil ~= front_card and front_card ~= hero_card then

		local sprite = anim_get_sprite(hero_card);
		local pos = cc.p(sprite:getPositionX(), sprite:getPositionY());
		local scale = sprite:getScaleX() / 2;
		sprite = anim_get_sprite(front_card);

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'spawn', 
				  anim_parts = {
				  	  { anim_part = 'move', pos = pos },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  },
				},
				{ anim_name = 'to_back' },
			},
		};
		anim_group[#anim_group + 1] = { alist };

		alist = {
			sprite = sprite,
			anims = {	
				{ anim_name = 'particle', pname = 'dust' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	
	elseif nil ~= front_card and front_card == hero_card then

		local sprite = anim_get_sprite(front_card);

		alist = {
			sprite = sprite,
		 	anims = {
				{ anim_name = 'to_front' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	
	end

	local sprite = anim_get_sprite(hero_card);
	alist = {
		sprite = sprite,
		anims = {
			{ anim_name = 'power_num_change', offset = offset, tar_index = nil },
		},
	};
	anim_group[#anim_group + 1] = { alist };

	if nil ~= front_card and front_card == hero_card then

		local sprite = anim_get_sprite(hero_card);

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'to_front' },
			},
		};
		anim_group[#anim_group + 1] = { alist };

		local pos = ccp(hero_card.frame.x, hero_card.frame.y);
		local scale = hero_card.frame.scale;

		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'spawn', 
				  anim_parts = {
				  	  { anim_part = 'move', pos = pos },
					  { anim_part = 'scale', scale = scale },
					  { anim_part = 'rotate', rotation = 0 },
				  },
				},
				{ anim_name = 'to_back' },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	end

	return anim_group;
end -- anim_action_energy }

-- is_max == true  means change num for resource_max
-- is_assign == true means assign the value directly
function anim_action_resource(side_index, offset, is_max, is_assign) -- {

	local anim_group = {};
	local alist = nil;

	local sprite = nil;
	if true == is_max then
		sprite = g_ui_table.label_res_max[side_index];
	else
		sprite = g_ui_table.label_res[side_index];
	end

	--sprite = nil;
	if nil == sprite then
		return anim_group;
	end

	if true == is_assign then
		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'res_num_assign', value = offset },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	else
		alist = {
			sprite = sprite,
			anims = {
				{ anim_name = 'res_num_change', offset = offset },
			},
		};
		anim_group[#anim_group + 1] = { alist };
	end

	return anim_group;
end -- anim_action_resource }

function anim_action_show(index) -- {
	local table_index, list_index, table_list, card;
	table_index, list_index, table_list, card = anim_get_info(index);

	local anim_group = {};
	local alist;
	if nil == card then
		return anim_group;
	end
	local sprite = anim_get_sprite(card);
	local scale = ANIM_SCALE_CENTER;
	local pos = ccp(HALF_WIDTH, HALF_HEIGHT);

	alist = {
		info = card,
		sprite = sprite,
		anims = {
			{ anim_name = 'to_front' },
			{ anim_name = 'scale_front', pos = pos, scale = scale },
			{ anim_name = 'to_back' },
		},
	};
	anim_group[#anim_group + 1] = { alist };

	return anim_group;
end -- anim_action_show }

function anim_action_back(index) -- {
	local table_index, list_index, table_list, card;
	table_index, list_index, table_list, card = anim_get_info(index);

	local anim_group = {};
	local alist;
	if nil == card then
		return anim_group;
	end
	local scale = table_list.cscale;
	local pos = cc.p(card.frame.x, card.frame.y);
	local sprite = anim_get_sprite(card);

	alist = {
		info = card,
		sprite = sprite,
		anims = {
			{ anim_name = 'to_front' },
			{ anim_name = 'scale_back', pos = pos, scale = scale },
			{ anim_name = 'to_back' },
		},
	};
	anim_group[#anim_group + 1] = { alist };

	return anim_group;
end -- anim_action_back }

function anim_action_view_top(index) -- {
	local anim_group = {};
	local alist = nil;
	local sprite = nil;
	local card = nil;

	local tbl = index_table_num(index);
	local side = index_side(index);

	local ui_deck_table = g_ui_table[side][tbl];
	if #ui_deck_table <=0 then
		return anim_group;
	end

	card = ui_deck_table[1];
	if card.status == CARD_FRONT then
		return anim_group;
	end
	sprite = card.sprite;
	if nil == sprite then
		return anim_group;
	end

	alist = {
		sprite = sprite,
		card_info = card,
		anims = {
			{ anim_name = 'to_front' },
			{ anim_name = 'flip_card', orient = 'front' },
		},
	};
	anim_group[#anim_group + 1] = { alist };
	return anim_group;
end -- anim_action_view_top }

function anim_action_hide_top(index) -- {
	local anim_group = {};
	local alist = nil;
	local sprite = nil;
	local card = nil;

	if true == is_view_oppo() then
		return anim_group;
	end

	local tbl = index_table_num(index);
	local side = index_side(index);

	local ui_deck_table = g_ui_table[side][tbl];
	if #ui_deck_table <=0 then
		return anim_group;
	end

	card = ui_deck_table[1];
	if card.status == CARD_COVER then
		return anim_group;
	end
	sprite = card.sprite;
	if nil == sprite then
		return anim_group;
	end

	alist = {
		sprite = sprite,
		card_info = card,
		anims = {
			{ anim_name = 'flip_card', orient = 'back' },
		},
	};
	anim_group[#anim_group + 1] = { alist };
	return anim_group;
end -- anim_action_hide_top }

function anim_action_view_oppo(index) -- {
	local anim_group = {};
	local anim_list = {};
	local sprite = nil;
	local card = nil;

	local side = index_side(index);
	if g_euser.side == side then
		return anim_group;
	end
	local tbl = index_table_num(index);

	local ui_hand_table = g_ui_table[side][tbl];
	if #ui_hand_table <=0 then
		return anim_group;
	end

	for i=1, #ui_hand_table do
		card = ui_hand_table[i];
		sprite = card.sprite;
		if nil ~= sprite and card.status == CARD_COVER then
			anim_list[#anim_list + 1] = {
				sprite = sprite,
				card_info = card,
				anims = {
					{ anim_name = 'flip_card', orient = 'front' },
				},
			};
		end
	end

	if #anim_list > 0 then
		anim_group[#anim_group + 1] = anim_list;
	end
	return anim_group;
end -- anim_action_view_oppo }

function anim_action_hide_oppo(index) -- {
	local anim_group = {};
	local anim_list = {};
	local sprite = nil;
	local card = nil;

	if true == is_view_oppo() then
		return anim_group;
	end

	local tbl = index_table_num(index);
	local side = index_side(index);
	if g_euser.side == side then
		return anim_group;
	end

	local ui_hand_table = g_ui_table[side][tbl];
	if #ui_hand_table <=0 then
		return anim_group;
	end

	for i=1, #ui_hand_table do
		card = ui_hand_table[i];
		sprite = card.sprite;
		if nil ~= sprite and card.status == CARD_FRONT then
			anim_list[#anim_list + 1] = {
				sprite = sprite,
				card_info = card,
				anims = {
					{ anim_name = 'flip_card', orient = 'back' },
				},
			};
		end
	end

	if #anim_list > 0 then
		anim_group[#anim_group + 1] = anim_list;
	end
	return anim_group;
end -- anim_action_hide_oppo }
--------------- ANIM_ACTION END   ------------

function make_anim(eff) -- {
	local anim_group = {};
	print('DEBUG make_anim eff ', eff[1]);

	if 'card' == eff[1] then
		anim_group = anim_action_use(eff.index, eff.front_index);
	elseif 'add' == eff[1] then
		anim_group = anim_action_add(eff.index, eff.cid);
	elseif 'anim' == eff[1] then
		local list = {};
		local len = eff.total or 0;
		for i = 1, len do
			local target = eff['target' .. i];
			--print('--- !!! --- target: ', target);
			table.insert(list, target);
		end
		anim_group = anim_action_anim(eff.id, eff.index, eff.atype, list, eff.front_index);
	elseif 'move' == eff[1] then
		if eff.src_index < 10000 then
			anim_group = anim_action_move(eff.src_index, eff.target_index, eff.front_index);
			--alog('DEBUG make_anim #anim_group: ', #anim_group);
		else
			anim_group = anim_action_move_attach(eff.src_index, eff.target_index, eff.front_index);
		end	
	elseif 'attach' == eff[1] then
		if eff.attach == 0 then
			anim_group = anim_action_attach_virtual(eff.target_index, eff.attach, eff.id, eff.acid, eff.front_index);
		else
			anim_group = anim_action_attach(eff.target_index, eff.attach, eff.id, eff.acid, eff.front_index);
		end
	elseif eff[1] == 'damage' then
		if g_scene:is_stage(STAGE_PVG) then
			local tb = index_table_num(eff.target_index);
			local s = index_side(eff.target_index);
			if tb == T_HERO and s == SIDE_UP then
				return {};
			end
		end
		if eff.dtype < 5 then
			anim_group = anim_action_damage(eff.src_index, eff.target_index, eff.dtype, eff.power, eff.atype);
		else
			anim_group = anim_action_damage_map(eff.src_index, eff.target_index, eff.dtype, eff.power, eff.front_index, eff.atype);
		end

	elseif eff[1] == 'hp' then
		anim_group = anim_action_hp(eff.index, eff.offset, eff.front_index);

	elseif eff[1] == 'power' then
		anim_group = anim_action_power(eff.index, eff.offset, eff.front_index);

	elseif eff[1] == 'energy' then
		anim_group = anim_action_energy(eff.side, eff.offset, eff.front_index);

	elseif eff[1] == 'resource' then
		if g_scene:is_stage(STAGE_PVG) then
			if eff.side == SIDE_UP then
				return {};
			end
		end
		anim_group = anim_action_resource(eff.side, eff.offset, false);

	elseif eff[1] == 'resource_value' then
		if g_scene:is_stage(STAGE_PVG) then
			if eff.side == SIDE_UP then
				return {};
			end
		end
		anim_group = anim_action_resource(eff.side, eff.value, false, true);

	elseif eff[1] == 'resource_max' then
		if g_scene:is_stage(STAGE_PVG) then
			if eff.side == SIDE_UP then
				return {};
			end
		end
		anim_group = anim_action_resource(eff.side, eff.offset, true);

	elseif eff[1] == 'trap' then
		anim_group = anim_action_trap(eff.index);

	elseif eff[1] == 'view_top' then
		anim_group = anim_action_view_top(eff.index);

	elseif eff[1] == 'hide_top' then
		anim_group = anim_action_hide_top(eff.index);

	elseif eff[1] == 'view_oppo' then
		anim_group = anim_action_view_oppo(eff.index);

	elseif eff[1] == 'hide_oppo' then
		anim_group = anim_action_hide_oppo(eff.index);
		

	elseif eff[1] == 'scale_front' then
		anim_group = anim_action_show(eff.index);

	elseif eff[1] == 'scale_back' then
		anim_group = anim_action_back(eff.index);

	end
	return anim_group;
end -- make_anim }

--------------- ACTION START ------------
function a_action_delay(card_action, anim_one, parray)
	local action = nil;
	local sprite = anim_one.sprite;
	local dtime = card_action.d_time or 0.5;
	action = cc.DelayTime:create(dtime);

	if nil ~= parray then
		table.insert(parray, action);
	end

	return action;
end

function a_action_scalefront(anim_action, anim_group, parray)
	local action, actions, animation;
	local info = anim_group.info;
	local sprite = anim_group.sprite;
	local pos = anim_action.pos;
	local scale = anim_action.scale;
	local rotation = 0;--info.frame.rotation;

	actions = {};
	action = cc.MoveTo:create(0.05, pos);
	table.insert(actions, action);
	action = cc.ScaleTo:create(0.05, scale/3*2);
	table.insert(actions, action);
	action = cc.RotateTo:create(0.05, rotation); 
	table.insert(actions, action);
	animation = {};
	table.insert(animation, cc.Spawn:create(actions));
	action = cc.EaseIn:create(cc.ScaleTo:create(0.1, scale+0.1), 0.1);
	table.insert(animation, action);
	action = cc.ScaleTo:create(0.1, scale-0.05);
	table.insert(animation, action);
	action = cc.EaseIn:create(cc.ScaleTo:create(0.2, scale), 0.2);
	table.insert(animation, action);

	action = cc.Sequence:create(animation);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_scaleback(anim_action, anim_group, parray)
	local action, actions, animation, spos, tpos;
	local info = anim_group.info;
	local sprite = anim_group.sprite;
	local pos = anim_action.pos;
	local scale = anim_action.scale;
	local cscale = sprite:getScaleX();
	local rotation = info.frame.rotation;
	spos = ccp(sprite:getPositionX(), sprite:getPositionY());

	animation = {};
	action = cc.EaseIn:create(cc.ScaleTo:create(0.05, cscale+0.1), 0.1);
	table.insert(animation, action);
	action = cc.ScaleTo:create(0.05, cscale-0.1);
	table.insert(animation, action);
	actions = {};
	tpos = cc.p((pos.x-spos.x)/2 + spos.x, (pos.y-spos.y)/2 + spos.y);
	action = cc.MoveTo:create(0.05, tpos);
	table.insert(actions, action);
	action = cc.ScaleTo:create(0.05, scale);
	table.insert(actions, action);
	action = cc.RotateTo:create(0.05, rotation); 
	table.insert(actions, action);
	table.insert(animation, cc.Spawn:create(actions));
	action = cc.EaseIn:create(cc.MoveTo:create(0.2, pos), 0.3);
	table.insert(animation, action);
	action = cc.DelayTime:create(0.03);
	table.insert(animation, action);

	action = cc.Sequence:create(animation);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_spawn(card_action, anim_one, parray)
	local action = nil;
	local sprite = anim_one.sprite;
	local spawn_array = {};
	for j = 1, #card_action.anim_parts do
		anim_get_action(card_action.anim_parts[j], anim_one, spawn_array);
	end
	action = cc.Spawn:create(spawn_array);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_move(sdata, data, parray)
	local action = nil;
	local pos = sdata.pos;
	local efftype = sdata.efftype;
	if nil == pos then
		pos = cc.p(sdata.x, sdata.y);
	end
	action = cc.MoveTo:create(0.3, pos);
	if 'ease_in' == efftype then
		action = cc.EaseIn:create(action, 0.3);
	elseif 'ease_out' == efftype then
		action = cc.EaseOut:create(action, 0.3);
	end

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_beziermove(sdata, data, parray)
	local action = nil;
	local sprite = data.sprite;
	local efftype = sdata.efftype;
	local spos = cc.p(sprite:getPositionX(), sprite:getPositionY());
	local epos = sdata.pos;
	local time, x, y, end_point, control_point_1, control_point_2;
	time = 0.4;

	end_point = epos;
	if epos.x >= spos.x then
		x = spos.x + (epos.x - spos.x) / 3;
	else
		x = spos.x - (spos.x - epos.x) / 3;
	end
	if epos.y >= spos.y then
		y = spos.y + hfix(50);
	else
		y = spos.y - hfix(50);
	end
	control_point_1 = cc.p(x, y);
	if epos.x >= spos.x then
		x = epos.x - (epos.x - spos.x) / 3;
	else
		x = epos.x + (spos.x - epos.x) / 3;
	end
	if epos.y >= spos.y then
		y = spos.y + hfix(30);
	else
		y = spos.y - hfix(30);
	end
	control_point_2 = cc.p(x, y);
	local bezier = { control_point_1, control_point_2, end_point };
	action = cc.BezierTo:create(time, bezier);

	if 'ease_in' == efftype then
		action = cc.EaseIn:create(action, time);
	elseif 'ease_out' == efftype then
		action = cc.EaseOut:create(action, time);
	end

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_scale(sdata, data, parray)
	local action = nil;
	local scalex, scaley;
	if nil ~= sdata.scale then
		scalex = sdata.scale;
		scaley = scalex;
	else
		scalex = sdata.x;
		scaley = sdata.y;
	end
	action = cc.ScaleTo:create(0.3, scalex, scaley);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_rotate(sdata, data, parray)
	local action = nil;
	action = cc.RotateTo:create(0.3, sdata.rotation);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_bezier(sdata, data, parray)
	local action = nil;
	local endx = sdata.endx;
	local endy = sdata.endy;
	local cp1x = sdata.cp1x;
	local cp1y = sdata.cp1y;
	local cp2x = sdata.cp2x;
	local cp2y = sdata.cp2y;
	
	local control_point_1 = cc.p(cp1x, cp1y);
	local control_point_2 = cc.p(cp2x, cp2y);
	local end_point = cc.p(endx, endy);
	local bezier = { control_point_1, control_point_2, end_point };
	action = cc.BezierTo:create(0.3 , bezier);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_attach(card_action, anim_one, parray)
	local action = nil;

	--[LUA] effect list: #eff_list=5
	--[LUA]     EFF card, id=38, index=2201, |
	--[LUA]     EFF move, src_index=2201, target_index=2305, |
	--[LUA]     EFF attach, target_index=2305, attach=0, acid=1032, id=38, |
	--[LUA]     EFF power, offset=1, index=2305, |
	--[LUA]     EFF resource, side=2, offset=-4, |
	-- need to create a attach card, but cannot get the card
	-- need 23052, and consider situation that play with ai, get many eff include
	-- add attach and remove attach

	action = cc.DelayTime:create(0.01);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;

	--[[
	local sprite = anim_one.sprite;
	local sx = anim_one.sprite:getPositionX();
	local sy = anim_one.sprite:getPositionY();

	local layer = layer_anim.layer;
	local eff_name = 'attach_1';
	local delay_per_unit = 0.05;
	local pos = ccp(sx, sy);
	local rotation = sprite:getRotation();
	local scale = sprite:getScaleX();
	local callback = callback_play_eff;
	local sprite, time = anim_play_frame(layer, eff_name, pos, rotation, scale, callback, delay_per_unit);

	action = CCDelayTime:create(time);
	return action;
	]]--
end

function anim_eff_numpop(layer, font, sprite, desc, offset)
	local path = util.get_path(font);
	local pos = cc.p(sprite:getPositionX(), sprite:getPositionY());
	local size = sprite:getContentSize();
	local scale = sprite:getScaleX();
	pos.x = pos.x - size.width*scale/2;
	pos.y = pos.y - size.height*scale/2;
	local sx = desc:getPositionX();
	local sy = desc:getPositionY();
	pos.x = pos.x + sx * scale;
	pos.y = pos.y + sy * scale;
	local label = util.add_labelbmf(layer, offset, path, pos, ANCHOR_CENTER_CENTER, ZORDER_EFFECT);

	pos.y = pos.y + 40;
	local actions = {};
	table.insert(actions, cc.EaseOut:create(cc.MoveTo:create(0.5, pos), 0.5));
	table.insert(actions, cc.CallFunc:create(anim_sprite_clean));
	label:runAction(cc.Sequence:create(actions));
end

function a_action_poweranim(card_action, anim_one, parray)
	local action = nil;
	--local sprite = anim_one.sprite;

	action = cc.DelayTime:create(0);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_powernumchange(card_action, anim_one, parray)
	local action = nil;
	local sprite = anim_one.sprite;
	local layer = sprite:getParent();
	local offset = card_action.offset;
	local no_eff = card_action.no_eff;
	if true == no_eff then
		local info = anim_one.info;
		if nil ~= info then
			if nil ~= info.data then
				if nil ~= info.data.left_bottom then
					info.data.left_bottom = info.data.left_bottom + offset;
				end
			end
		end
		action = cc.DelayTime:create(0.1);
		if nil ~= parray then
			table.insert(parray, action);
		end
		return action;
	end
	local power_desc = sprite:getChildByTag(TAG_POWER);	
	tolua.cast(power_desc, "cc.Label");
	if nil == power_desc then
		alog('ERROR power_desc == nil');
		action = cc.DelayTime:create(0.2);
		return action;
	end
	local color;
	if card_action.flag == 'positive' then
		color = cc.c3b(248, 0, 0);
	else
		color = cc.c3b(0, 248, 0);
	end
	--local power_desc = sprite:getChildByTag(TAG_POWER);	
	--tolua.cast(power_desc, 'CCLabelBMFont');
	local power = tonumber(power_desc:getString()) + card_action.offset;
	if power < 0 then
		power = 0;
	end
	power_desc:setString(power);
	local is_out = false;
	local time = 0.1;
	if 0 < anim.eff_power_count then
		anim.eff_power_count = anim.eff_power_count - 1;
		if 0 == anim.eff_power_count then
			time = DURATION_NUM_EFF;
		end
		is_out = true;
	end
	if card_action.tar_index == anim.last_rm_attach_index then
		anim.last_rm_attach_index = 0;
		is_out = true;
	end
	if true == is_out then
		--anim_eff_numpop(layer, sprite, power_desc, offset, color);
		anim_eff_numpop(layer, FT_9, sprite, power_desc, offset);
		action = cc.DelayTime:create(time);
		if nil ~= parray then
			table.insert(parray, action);
		end
		return action;
	end

	--anim_eff_numpop(layer, sprite, power_desc, offset, color);
	anim_eff_numpop(layer, FT_9, sprite, power_desc, offset);
	-- the damage anim length is 0.5s, add 1s delayTime to wait damage anim finish
	action = cc.DelayTime:create(DURATION_NUM_EFF);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_hpanim(card_action, anim_one, parray)
	local action = nil;
	local sprite = anim_one.sprite;
	-- light animation
	--local sprite_width = sprite:getContentSize().width * sprite:getScaleX();
	--local sprite_height = sprite:getContentSize().height * sprite:getScaleY();
	local sx = sprite:getPositionX();
	local sy = sprite:getPositionY();

	--[[
	local layer = sprite:getParent();
	local pos = ccp(sx, sy);
	local rotation = sprite:getRotation();
	local scale = sprite:getScaleX();
	local callback = callback_play_eff;
	local action_sprite, time = anim_play_frame(layer, 'hp_1', pos, rotation, scale, callback, 0.3);
	]]--
	time = 0;

	action = cc.DelayTime:create(time);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;

end

function a_action_hpnumchange(card_action, anim_one, parray)
	local action = nil;
	local sprite = anim_one.sprite;
	local layer = sprite:getParent();
	local offset = card_action.offset;
	local no_eff = card_action.no_eff;
	if true == no_eff then
		local info = anim_one.info;
		if nil ~= info then
			if nil ~= info.data then
				if nil ~= info.data.right_bottom then
					info.data.right_bottom = info.data.right_bottom + offset;
				end
			end
		end
		action = cc.DelayTime:create(0.1);
		if nil ~= parray then
			table.insert(parray, action);
		end
		return action;
	end
	local hp_desc = sprite:getChildByTag(TAG_HP);	
	tolua.cast(hp_desc, "cc.Label");
	if nil == hp_desc then
		alog('ERROR hp_desc == nil');
		action = cc.DelayTime:create(0.2);
		if nil ~= parray then
			table.insert(parray, action);
		end
		return action;
	end

	--[[
	local color;
	if card_action.flag == 'positive' then
		color = cc.c3b(0, 248, 0);
	else
		color = cc.c3b(248, 0, 0);
	end
	]]--
	-- reset the sprite's hp
	--local hp_desc = sprite:getChildByTag(TAG_HP);	
	--tolua.cast(hp_desc, 'CCLabelBMFont');
	local hp = tonumber(hp_desc:getString()) + card_action.offset;
	if hp < 0 then
		hp = 0;
	end
	hp_desc:setString(hp);
	local is_out = false;
	local time = 0.1;
	if 0 < anim.eff_hp_count then
		anim.eff_hp_count = anim.eff_hp_count - 1;
		if 0 == anim.eff_hp_count then
			time = DURATION_NUM_EFF;
		end
		is_out = true;
	end
	if card_action.tar_index == anim.last_rm_attach_index then
		anim.last_rm_attach_index = 0;
		is_out = true;
	end
	if true == is_out then
		--anim_eff_numpop(layer, sprite, hp_desc, offset, color);
		anim_eff_numpop(layer, FT_10, sprite, hp_desc, offset);
		action = cc.DelayTime:create(time);
		if nil ~= parray then
			table.insert(parray, action);
		end
		return action;
	end

	--anim_eff_numpop(layer, sprite, hp_desc, offset, color);
	anim_eff_numpop(layer, FT_10, sprite, hp_desc, offset);
	-- the damage anim length is 0.5s, add 1s delayTime to wait damage anim finish
	action = cc.DelayTime:create(DURATION_NUM_EFF);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_resnumchange(card_action, anim_one, parray)
	local action = nil;
	local sprite = anim_one.sprite;
	local layer = layer_anim.layer;
	local offset = card_action.offset;
	local path = util.get_path(FT_11);
	local pos = cc.p(sprite:getPositionX(), sprite:getPositionY());
	local size = sprite:getContentSize();
	local scale = sprite:getScaleX();
	local label = util.add_labelbmf(layer, offset, path, pos, ANCHOR_CENTER_CENTER, ZORDER_EFFECT);
	--[[
	if offset < 0 then
		label:setColor(cc.c3b(248, 0, 0));
	else
		label:setColor(cc.c3b(0, 248, 0));
	end
	]]--
	pos.y = pos.y + 40;
	local actions = {};
	table.insert(actions, cc.EaseOut:create(cc.MoveTo:create(0.5, pos), 0.5));
	table.insert(actions, cc.CallFunc:create(anim_sprite_clean));
	label:runAction(cc.Sequence:create(actions));

	-- the damage anim length is 0.5s, add 1s delayTime to wait damage anim finish
	action = cc.DelayTime:create(0.5);

	-- reset the res label
	local new_res = tonumber(sprite:getString()) + offset;
	if new_res < 0 then
		new_res = 0;
	end
	sprite:setString(new_res);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_resnumassign(card_action, anim_one, parray)
	local action = nil;
	local sprite = anim_one.sprite;
	local layer = layer_anim.layer;
	local value = card_action.value;
	--local fullpath = util.get_fullpath(F_FONT, FNT_CARD);
	local path = util.get_path(FT_11);
	local pos = cc.p(sprite:getPositionX(), sprite:getPositionY());
	local size = sprite:getContentSize();
	local scale = sprite:getScaleX();
	local label = util.add_labelbmf(layer, value, path, pos, ANCHOR_CENTER_CENTER, ZORDER_EFFECT);
	--[[
	if value < 0 then
		label:setColor(cc.c3b(248, 0, 0));
	else
		label:setColor(cc.c3b(0, 248, 0));
	end
	]]--
	pos.y = pos.y + 40;
	local actions = {};
	table.insert(actions, cc.EaseOut:create(cc.MoveTo:create(0.5, pos), 0.5));
	table.insert(actions, cc.CallFunc:create(anim_sprite_clean));
	label:runAction(cc.Sequence:create(actions));

	-- the damage anim length is 0.5s, add 1s delayTime to wait damage anim finish
	action = cc.DelayTime:create(0.5);

	-- reset the res label
	sprite:setString(value);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_abli(card_action, anim_one, parray)
	local action = nil;
	local sprite = anim_one.sprite;
	--[[
	local sx = sprite:getPositionX();
	local sy = sprite:getPositionY();

	local layer = sprite:getParent();
	local pos = ccp(sx, sy);
	local rotation = sprite:getRotation();
	local scale = sprite:getScaleX();
	local callback = callback_play_eff;
	local acton_sprite, time = anim_play_frame(layer, 'attack_4', pos, rotation, scale, callback, 0.1);

	]]--
	local time = 0;
	action = cc.DelayTime:create(time);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;

end

function a_action_atnormal(card_action, anim_one, parray)
	local action = nil;
	local time = 0;
	local attacker = anim_one.att_sprite;
	local defender = anim_one.def_sprite;
	local layer = layer_anim.layer;
	local dtype = card_action.dtype;
	--[[
	local sframe = card_action.sframe;
	local tframe = card_action.tframe;
	local svv = 1;
	if sframe.y > HALF_HEIGHT then
		svv = -1;
	end
	]]--

--	if 1 == dtype or 4 == dtype then
		if true == USE_FLASH then
			--time = play_flash(layer, 0, attacker, defender, 0, false);
			time = attack_hit(layer, attacker, defender);
		else
			local esprite;
			esprite,time = attack_eff(layer, attacker, defender, sframe, tframe,time);
		end
		time = time + 0.2;
--	end
	local action = cc.DelayTime:create(time);

	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_damageanim(card_action, anim_one, parray)
	local action = nil;
	local time = 0;
	local att_sprite = anim_one.att_sprite;
	local sprite = anim_one.sprite;
	local layer = layer_anim.layer;
	local atype = card_action.atype or 0;
	local dtype = card_action.dtype;
	local eff = card_action.eff;

	--[[
	if atype == 3 then -- laser
		-- also relative to anim_action_damage_map
		local time = action_skill(layer, att_sprite, sprite, 1.0);
		local action = cc.DelayTime:create(time);

		if nil ~= parray then
			table.insert(parray, action);
		end
		return action;
	elseif atype > 0 then
	]]--
	if atype > 0 then
		local step = card_action.step;
		if true == USE_FLASH then
			time = play_flash(layer, atype, att_sprite, sprite, step, eff);
		else
			time = play_eff(layer, atype, att_sprite, sprite, step, eff);
		end
		action = cc.DelayTime:create(time);
		if nil ~= parray then
			table.insert(parray, action);
		end
		return action;
	end

	if 1 == dtype then
		--[[
		--local asprite = anim_one.att_sprite;
		local f = card_action.f;
		local eff_name = 'attack_1';
		local dlu = 0.06; -- delay_per_unit;
		local time = action_fight(layer, att_sprite, sprite, f, eff_name, dlu);
		]]--
		local time = 0;
		local action = cc.DelayTime:create(time);
		if nil ~= parray then
			table.insert(parray, action);
		end
		return action;
	end
	
	local sx = sprite:getPositionX();
	local sy = sprite:getPositionY();

	local eff_name = nil;
	local delay_per_unit = 0;
	if 1 == dtype then
		eff_name = 'attack_1';
		delay_per_unit = 0.07;

	--[[
	elseif 8 == dtype then
		eff_name = 'attack_3';
		delay_per_unit = 0.1;
	]]--

	--elseif 7 == dtype or 6 == dtype or 9 == dtype then
	--else
		--eff_name = 'attack_2';
		--delay_per_unit = 0.1;
	
	else
		local action = cc.DelayTime:create(0.01);
		if nil ~= parray then
			table.insert(parray, action);
		end
		return action;
	end
	if nil ~= eff_name then
		local pos = ccp(sx, sy);
		local rotation = sprite:getRotation();
		local scale = sprite:getScaleX();
		local callback = callback_play_eff;
		local sprite, time = anim_play_frame(layer, eff_name, pos, rotation, scale, callback, delay_per_unit);

		action = cc.DelayTime:create(time);
		if nil ~= parray then
			table.insert(parray, action);
		end
		return action;
	end

	action = cc.DelayTime:create(0.1);
	if nil ~= parray then
		table.insert(parray, action);
	end

	return action;
end

function a_action_efflayer(card_action, anim_one, parray)
	local action = nil;
	local time = 0;
	local layer_anim = anim_one.layer_anim;
	local layer_card = anim_one.layer_card;
	local etype = card_action.etype;

	if 'shake' == etype then
		if nil ~= layer_anim then
			layer_anim:shake(0.2, 6, 0);
		end
		if nil ~= layer_card then
			layer_card:shake(0.2, 6, 0);
		end
	end

	action = cc.DelayTime:create(0.1);
	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_effsprite(card_action, anim_one, parray)
	local action = nil;
	local time = 0;
	local sprite = anim_one.sprite;
	local etype = card_action.etype;
	local duration = card_action.duration;
	local radius = card_action.radius;
	local delay = card_action.delay;

	if nil ~= sprite then
		if 'shake' == etype then
			sprite:shake(duration, radius, delay);
		end
	end

	action = cc.DelayTime:create(0.1);
	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_tofront(card_action, anim_one, parray)
	local action = nil;
	local sprite = anim_one.sprite;
	action = cc.CallFunc:create(callback_front);
	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_toback(card_action, anim_one, parray)
	local action = nil;
	local sprite = anim_one.sprite;
	action = cc.CallFunc:create(callback_table);
	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_tozorder(card_action, anim_one, parray)
	local action = nil;
	local sprite = anim_one.sprite;
	local zorder = card_action.zorder;
	local function cb()
		local layer = sprite:getParent();
		layer:reorderChild(sprite, zorder);
	end
	action = cc.CallFunc:create(cb);
	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end


function a_action_remove(card_action, anim_one, parray)
	local action = nil;
	local sprite = anim_one.sprite;
	local card = anim_one.info.card;
	g_sprite_cache[card] = nil;
	anim.cache[card] = nil;
	action = cc.CallFunc:create(anim_callback_remove);
	if nil ~= parray then
		table.insert(parray, action);
	end
	return action;
end

function a_action_showfullcard(card_action, anim_one, parray)
	local action = nil;
	local card_info = anim_one.card_info;
	local osprite = anim_one.sprite;
	local time = card_action.time;
	local owidth = osprite:getContentSize().width * osprite:getScaleX();

	local sprite = card_info:get_action_sprite(layer_anim.layer, cc.p(HALF_WIDTH, HALF_HEIGHT), 0, 1);
	local scale = owidth/sprite:getContentSize().width;
	sprite:setScale(scale);
	local scale_time = 0.1;
	local cwidth = FULL_WIDTH - wfix(50);
	local cheight = FULL_HEIGHT - hfix(300);
	local scale_to = get_card_scale(cwidth, cheight, CARD_SIZE);

	local array = {};
	table.insert(array, cc.ScaleTo:create(scale_time, scale_to));
	table.insert(array, cc.DelayTime:create(time));
	table.insert(array, cc.ScaleTo:create(scale_time, scale));
	table.insert(array, cc.CallFunc:create(callback_remove_sprite));
	sprite:runAction(cc.Sequence:create(array));

	--sprite:flip_to_front();
	action = cc.DelayTime:create(time+scale_time*2);
	if nil ~= parray and nil ~= action then
		table.insert(parray, action);
	end
	return action;
end

function a_action_flipcard(card_action, anim_one, parray)
	local action = nil;
	local sprite = anim_one.sprite;
	local card_info = anim_one.card_info;
	local orient = card_action.orient;

	local function callback_to_front()
		alog('DEBUG action_flipcard callback_front');
		card_info:flip_to_front();
		return;
	end

	local function callback_to_back()
		card_info:flip_to_cover();
	end

	local orbit_time = 0.3;
	local anims_array = {};
	local orbit1 = cc.OrbitCamera:create(orbit_time, 1, 0, 0, -90, 0, 0);
	local orbit2 = cc.OrbitCamera:create(orbit_time, 1, 0, 90, -90, 0, 0);
	table.insert(anims_array, orbit1);
	if orient == 'back' then
		table.insert(anims_array, cc.CallFunc:create(callback_to_back));
	else
		table.insert(anims_array, cc.CallFunc:create(callback_to_front));
	end
	table.insert(anims_array, orbit2);

	action = cc.Sequence:create(anims_array);

	--sprite:flip_to_front();
	if nil ~= parray and nil ~= action then
		table.insert(parray, action);
	end
	return action;
end

function a_action_particle(card_action, anim_one, parray)
	local action = nil;
	if 'sac' == card_action.ptype then
		local function show_tail(...)
			local args = { ... };
			local sprite = args[1];
			local x, y = sprite:getPosition();
			local res;
			if y > HALF_HEIGHT then
				res = g_ui_table.label_res_max[SIDE_UP];
			else
				res = g_ui_table.label_res_max[SIDE_DOWN];
			end
			local tx, ty = res:getPosition();
			local parent = sprite:getParent();
			local path = util.get_path('sac_eff.plist');
			local tail = util.add_particle(parent, path, cc.p(x, y), 64);
			local tlist = {};
			table.insert(tlist, cc.MoveTo:create(0.5, cc.p(tx, ty)));
			tail.batch:runAction(cc.Sequence:create(tlist));
		end
		local alist = {};
		table.insert(alist, cc.CallFunc:create(show_tail));
		table.insert(alist, cc.DelayTime:create(0.8));
		action = cc.Spawn:create(alist);
		--action = cc.CallFunc:create(a_particle_sac);
		if nil ~= parray and nil ~= action then
			table.insert(parray, action);
		end
		return action;
	end
	--[[
	if 'ab_tail' == card_action.ptype then
		action = a_particle_shoot(card_action, anim_one, parray);
		return action;
	end
	]]--
	local sprite = anim_one.sprite;
	local scale = card_action.scale or 1;
	local pname = card_action.pname .. '.plist';
	local fullpath;
	local layer = sprite:getParent();
	local pos = cc.p(sprite:getPositionX(), sprite:getPositionY());
	local zorder = sprite:getLocalZOrder();

	fullpath = util.get_fullpath(F_PARTICLE, pname);
	local info = util.add_particle(layer, fullpath, pos, zorder-1);
	scale = sprite:getScale();
	info.batch:setScale(scale);

	action = cc.DelayTime:create(0.5);
	if nil ~= parray and nil ~= action then
		table.insert(parray, action);
	end
	return action;
end

function a_action_hide(card_action, anim_one, parray)
	local sprite = anim_one.sprite;
	action = cc.Hide:create();
	if nil ~= parray and nil ~= action then
		table.insert(parray, action);
	end
	return action;
end

function a_action_show(card_action, anim_one, parray)
	local sprite = anim_one.sprite;
	action = cc.Show:create();
	if nil ~= parray and nil ~= action then
		table.insert(parray, action);
	end
	return action;
end

function a_action_fade(card_action, anim_one, parray)
	--local sprite = anim_one.sprite;
	local f_to = card_action.f_to;
	local time = card_action.time or 0.3;

	action = cc.FadeTo:create(time, f_to);
	if nil ~= parray and nil ~= action then
		table.insert(parray, action);
	end
	return action;
end

function a_action_decktohand(card_action, anim_one, parray)
	local sprite = anim_one.sprite;
	local dpos = cc.p(sprite:getPositionX(), sprite:getPositionY());
	local hpos = card_action.end_pos;
	local scale = card_action.scale;
	local tar_side = card_action.tar_side;

	local factor = 1;
	if tar_side ~= g_euser.side then
		factor = -1;
	end
	local farray, array, action, x, y;
	farray = {};
	array = {};

	local end_point, control_point_1, control_point_2;
	spos = dpos;
	epos = hpos;
	end_point = epos;
	--conf.controlPoint_1 = ccp(dpos.x+(hpos.x-dpos.x)/2, spos.y-50);
	--conf.controlPoint_2 = ccp(epos.x-10, epos.y-40);
	--conf.controlPoint_1 = ccp(dpos.x+(hpos.x-dpos.x)/2, spos.y+50*factor);
	--conf.controlPoint_2 = ccp(epos.x-10, epos.y+40*factor);
	x = dpos.x + (hpos.x - dpos.x) / 2;
	y = spos.y + hfix(50) * factor;
	control_point_1 = cc.p(x, y);
	x = epos.x - wfix(10);
	y = epos.y + hfix(40) * factor;
	control_point_2 = cc.p(x, y);
	local bezier = { control_point_1, control_point_2, end_point };
	action = cc.BezierTo:create(0.5, bezier);
	action = cc.EaseOut:create(action, 0.5);
	table.insert(array, action);

	action = cc.Sequence:create(array);
	array = {};
	table.insert(array, action);

	action = cc.ScaleTo:create(0.5, scale);
	table.insert(array, action);

	action = CCSpawn:create(array);
	table.insert(farray, action);

	action = cc.Sequence:create(farray);
	if nil ~= parray and nil ~= action then
		table.insert(parray, action);
	end

	return action;
end

function a_action_fromgrave(card_action, anim_one, parray)
	local info = card_action.info;
	local ui_table = card_action.ui_table;
	local index = card_action.index;
	local side = anim_index_side(index);
	local t = anim_index_table_num(index);
	if true == data_handler.show_all_card then
		info:get_front();
	elseif side ~= g_euser.side and (t == T_HAND or t == T_DECK) then
		info:get_cover();
	else
		info:get_front();
	end

	action = cc.DelayTime:create(0.1);
	if nil ~= parray and nil ~= action then
		table.insert(parray, action);
	end

	return action;
end

function a_action_tograve(card_action, anim_one, parray)
	local info = card_action.info;
	local ui_table = card_action.ui_table;
	local index = card_action.index;
	local pos = info:get_grave_pos(ui_table, index);
	local sprite = info:change_grave(pos, ui_table.pic_scale);

	action = cc.DelayTime:create(0.1);
	if nil ~= parray and nil ~= action then
		table.insert(parray, action);
	end

	return action;
end

function a_action_removecsprite(card_action, anim_one, parray)
	local action = nil;
	local obj = card_action.obj;
	obj:remove_sprite();

	action = cc.DelayTime:create(0.1);
	if nil ~= parray and nil ~= action then
		table.insert(parray, action);
	end
	return action;
end
--------------- ACTION END   ------------

-- data is the whole info, include sprite, layer or sth
-- sdata is sub data, just list[i]
function anim_get_action(sdata, data, array) -- {
	local action = nil;
	local tname = sdata.anim_name;
	-- just for spawn, should remove
	if nil == sdata.anim_name and nil ~= sdata.anim_part then
		tname = sdata.anim_part;
	end
	--------
	if tname == 'delay' then
		action = a_action_delay(sdata, data, array);

	elseif tname == 'scale_front' then
		action = a_action_scalefront(sdata, data, array);

	elseif tname == 'scale_back' then
		action = a_action_scaleback(sdata, data, array);
	
	elseif tname == 'spawn' then
		action = a_action_spawn(sdata, data, array);
	
	elseif tname == 'move' then
		action = a_action_move(sdata, data, array);

	elseif tname == 'bezier_move' then
		action = a_action_beziermove(sdata, data, array);

	elseif tname == 'scale' then
		action = a_action_scale(sdata, data, array);

	elseif tname == 'rotate' then
		action = a_action_rotate(sdata, data, array);

	elseif tname == 'bezier' then
		action = a_action_bezier(sdata, data, array);
		
	elseif tname == 'attach' then
		action = a_action_attach(sdata, data, array);

	elseif tname == 'power_anim' then
		action = a_action_poweranim(sdata, data, array);

	elseif tname == 'power_num_change' then
		action = a_action_powernumchange(sdata, data, array);

	elseif tname == 'hp_anim' then
		action = a_action_hpanim(sdata, data, array);
	
	elseif tname == 'hp_num_change' then
		action = a_action_hpnumchange(sdata, data, array);

	elseif tname == 'res_num_change' then
		action = a_action_resnumchange(sdata, data, array);

	elseif tname == 'res_num_assign' then
		action = a_action_resnumassign(sdata, data, array);

	-- let the card shine
	elseif tname == 'abli' then
		action = a_action_abli(sdata, data, array);

	elseif tname == 'at_normal' then
		action = a_action_atnormal(sdata, data, array);

	elseif tname == 'damage_anim' then
		action = a_action_damageanim(sdata, data, array);

	elseif tname == 'eff_layer' then
		action = a_action_efflayer(sdata, data, array);

	elseif tname == 'eff_sprite' then
		action = a_action_effsprite(sdata, data, array);

	-- change zorder, move the card to top
	elseif tname == 'to_front' then
		action = a_action_tofront(sdata, data, array);
	
	-- change zorder, move the card to table
	elseif tname == 'to_back' then
		action = a_action_toback(sdata, data, array);

	elseif tname == 'to_zorder' then
		action = a_action_tozorder(sdata, data, array);

	elseif tname == 'remove' then
		action = a_action_remove(sdata, data, array);

	elseif tname == 'show_full_card' then
		action = a_action_showfullcard(sdata, data, array);

	elseif tname == 'flip_card' then
		action = a_action_flipcard(sdata, data, array);

	elseif tname == 'particle' then
		action = a_action_particle(sdata, data, array);

	elseif tname == 'hide' then
		action = a_action_hide(sdata, data, array);

	elseif tname == 'show' then
		action = a_action_show(sdata, data, array);

	elseif tname == 'fade' then
		action = a_action_fade(sdata, data, array);

	elseif tname == 'deck_to_hand' then
		action = a_action_decktohand(sdata, data, array);

	elseif tname == 'from_grave' then
		action = a_action_fromgrave(sdata, data, array);

	elseif tname == 'to_grave' then
		action = a_action_tograve(sdata, data, array);

	elseif tname == 'remove_cpsrite' then
		action = a_action_removecsprite(sdata, data, array);
	end

	return action;
end -- anim_get_action end }

function anim_call_next()
	--alog('DEBUG do anim_call_next counter, length: ', anim.anim_list_counter, anim.anim_list_length);
	anim.anim_list_counter = anim.anim_list_counter + 1;
	if anim.anim_list_counter >= anim.anim_list_length then
		if nil == anim.anim_list then
			alog('DEBUG anim_call_next anim.anim_list == nil');
			anim_run_efflist(anim.eff_list);
			return;
		end
		if 0 == #anim.anim_list then
			alog('DEBUG anim_call_next #anim.anim_list == 0');
			anim_run_efflist(anim.eff_list);
			return;
		end
		run_anim(anim.anim_list[1], anim.anim_list);
	end
end

function run_sprite_actions(anim_one) -- {
	--alog('DBEUG run_sprite_actions() start');
	if nil == anim_one.anims then 
		--print('run_sprite_actions nil == anim_one.anims');
		return; 
	end
	
	-- can nil, just set layer visible
	if nil == anim_one.sprite then
		-- if no sprite actions, use the hero sprite run the callback_next
		--alog('DEBUG run_sprite_actions sprite is nil');
		anim_one.sprite = anim_get_sprite(g_ui_table[g_current_side][T_HERO][1]);
	end
	
	local anims_array = {};
	local callFunc = nil;
	
	local reorder_list = {};
	local card_actions = anim_one.anims;
	
	-- make real sprite action
	--alog('DEBUG #card_actions: ', #card_actions);
	local action = nil;
	for i = 1, #card_actions do
		--alog('DBEUG card_actions[i].anim_name: ', i, card_actions[i].anim_name);
		anim_get_action(card_actions[i], anim_one, anims_array);
	end

	--table.insert(anims_array, cc.DelayTime:create(0.5)); 
	table.insert(anims_array, cc.CallFunc:create(anim_call_next));
	--alog('DEBUG run_sprite_actions arraycount: ', anims_array:count());
	if nil ~= anim_one.sprite then
		anim_one.sprite:runAction(cc.Sequence:create(anims_array));
	else
		alog('ERROR anim_one.sprite is nil !!!');
	end
end   -- run_sprite_actions end }

function anim_get_sprite(cinfo, pos, scale)
	if nil == cinfo then
		alog('BUG anim_get_sprite cinfo == nil');
		anim_end();
		return;
	end
	local sprite = nil;
	local card = cinfo.card;
	sprite = anim.cache[card];
	if nil ~= sprite then
		return sprite;
	end
	sprite = cinfo.sprite;
	sprite = switch_layer(sprite, layer_anim.layer);
	-- because attachment add to layer from sprite, position will be wrong,
	-- so should set it
	if nil ~= pos then
		sprite:setPosition(pos);
	end
	if nil ~= scale then
		sprite:setScale(scale);
	end
	-- in case: card from deck maybe invisible
	-- because: if pos in deck more than 4, card will be set to invisible
	sprite:setVisible(true);
	anim.cache[card] = sprite;
	return sprite;
end

function anim_run_efflist(list)
	--alog('DEBUG do run_efflist #list: ', #list);
	-- 1.has anim == {true, {{anim}, {anim}}}
	-- 2.all eff_list finish == {false, {}}
	-- 3.error == {false, nil}
	local anim_info = efflist_to_anim(list);
	--local has_anim = anim_info[1];
	--local anim_group = anim_info[2];
	local has_anim = anim_info.has_anim;
	local anim_group = anim_info.anim_group;

	if nil == anim_group then
		alog('DEBUG run_efflist anim_group == nil'); 
		anim_return('run_efflist nil==anim_group');
		return;
	end

	if false == has_anim then
		alog('DEBUG run_efflist has_anim == false'); 
		anim_return();
		return;
	end

	if 0 == #anim_group then
		anim_run_efflist(list);
	else
		anim.anim_list = anim_group;
		run_anim(anim_group[1], anim_group);
	end
	return;
end

function anim_sprite_clean(...)
	local arg = {...}
	local sprite = arg[1];
	if nil == sprite then
		alog('BUG nil == sprite');
		return nil;
	end
	sprite:stopAllActions();
	sprite:setVisible(false);
	sprite:removeFromParentAndCleanup(true);
end

function anim_return(err)
	alog('DEBUG do anim_return');
	if nil ~= err then
		alog('ERROR ' .. err);
	end
	anim_end();
end

function anim_start(q)
	disable_touch();
	
	kdebug("----------vvvvvvv START ANIM MAIN!!!!! vvvvvvv----------");
	g_scene:add_layer(ZORDER_LAYER_ANIM, layer_anim:create());

	-- init to {};
	anim.eff_list = {};
	anim.anim_list = {};
	-- g_callback_list write here only!
	anim.callback_list = q.callback_list;

	--alog('DBEUG anim_start #eff_list, front_card_index: ', #q.eff_list, q.front_card_index);
	anim.eff_list = anim_preprocess_efflist(q.eff_list, q.front_card_index);
	if 0 == #anim.eff_list then
		anim_end();
		return;
	end
	anim_run_efflist(anim.eff_list);
	return;
end

function anim_end(force_quit)

	if true == force_quit then
		for k, v in pairs(anim.cache) do
			g_sprite_cache[k] = nil;
		end
	else
		for k, v in pairs(anim.cache) do
			--alog('anim_end stopAllActons ', k.id, k.name);
			v:stopAllActions();
			v = switch_layer(v, layer_card.layer);
			g_sprite_cache[k] = v;
		end
	end

	anim.cache = {};
	anim_remove_tlist(nil, true); 
	anim.eff_hp_count = 0;
	anim.eff_power_count = 0;
	anim.last_rm_attach_index = 0;

	layer_anim:remove();
	if true == force_quit then
		anim.queue = {};
	else
		--alog('DEBUG anim_end queue before remove: ', #anim.queue);
		table.remove(anim.queue, 1);
		--alog('DEBUG anim_end queue after remove: ', #anim.queue);
	end

	enable_touch();

	print('----------^^^^^^ END ANIM MAIN!!!!! ^^^^^^----------');

	if #anim.queue > 0 then
		--alog('DEBUG anim_end #anim.queue: ', #anim.queue);
		local q = anim.queue[1];
		anim_start(q);
		return;
	end

	alog(' >>>>>>>>>> ANIM QUEUE EMPTY <<<<<<<<<<<<<');
	
	-- callback to deck, anim is done
	anim.callback_list = anim.callback_list or {};

	for i = 1, #anim.callback_list do
		local callback = anim.callback_list[i];
		if nil ~= callback then
			callback();
		end
	end
end

function anim.main(eff_list, callback_list, front_card_index)
	local list = {
		eff_list = eff_list,
		callback_list = callback_list,
		front_card_index = front_card_index,
	};
	alog('DEBUG anim.main queue before insert: ', #anim.queue);
	local is_empty = false;
	if 0 == #(anim.queue or {}) then
		is_empty = true;
	end
	table.insert(anim.queue, list);
	--alog('DEBUG anim.main queue after insert: ', #anim.queue);
	if true == is_empty then
		local q = anim.queue[1];
		anim_start(q);
	end
end
-- /////////////////////// ANIM END   ///////////////////////////

-- /////////////////////// NETWORK START ///////////////////////////
function pop_chat(parent, pos, alias, time, str, is_vip)
	if nil == parent then
		return;
	end
	alias = alias or '';
	str = str or '';
	time = time or '';
	alias = alias or '';
	is_vip = is_vip or 0;
	--local fullrect = cc.rect(0, 0, 176, 91);
	--local insetrect = cc.rect(85, 42, 6, 4);
	--local size = cc.size(176, 91);
	--local fullpath = util.get_fullpath(F_IMAGE, 'bg_99.png');
	local fullrect = cc.rect(0, 0, 64, 64);
	local insetrect = cc.rect(30, 30, 4, 4);
	local size = cc.size(176, 91);
	local fullpath = util.get_path('bg_156.png');
	local sprite = util.add_scale9sprite(parent, fullpath, pos, ANCHOR_CENTER_DOWN, fullrect, insetrect, size); 

	local width = 0;
	local height = 0;

	local pos;
	local icon_vip = nil;
	local icon_width = 0;
	if is_vip == 1 then
		local fpath = util.get_path('pic_59.png');
		pos = ccp(0, 3);
		icon_vip = util.add_sprite(sprite, fpath, pos, ANCHOR_LEFT_UP, 100);
		icon_vip:setScale(.8);
		icon_width = icon_vip:getContentSize().width * .8;
		pos = cc.p(icon_width + 3, 0);
	else
		pos = cc.p(0, 0);
	end
	local tlabel = util.add_labelttf(sprite, alias, nil, 23, pos, util.c4b_red, ANCHOR_LEFT_UP, 100);
	local theight = tlabel:getContentSize().height;
	local rlabel = util.add_labelttf(sprite, str, nil, 23, cc.p(0, 0), util.c4b_white, ANCHOR_LEFT_UP, 100);
	if rlabel:getContentSize().width > wfix(400) then
		rlabel:removeFromParentAndCleanup(true);
		rlabel = util.add_labelttf(sprite, str, nil, 23, cc.p(0, 0), util.c4b_white, ANCHOR_LEFT_UP, 100, cc.size(wfix(400), 70), cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_TOP);
	end
	local rwidth = rlabel:getContentSize().width;
	if tlabel:getContentSize().width + icon_width > rwidth then
		rwidth = tlabel:getContentSize().width + icon_width;
	end
	local rheight = rlabel:getContentSize().height;
	width = rwidth + 32;
	height = theight + rheight + 50;
	if width < 176 then width = 176; end
	if height < 91 then height = 91; end
	sprite:setContentSize(width, height);
	tlabel:setPosition(cc.p(20, height - 15));
	rlabel:setPosition(cc.p(20, height - 45));
	if nil ~= icon_vip then
		icon_vip:setPosition(cc.p(15, height - 12));
--		icon_vip:setPosition(cc.p(0,0));
		tlabel:setPosition(cc.p(20 + icon_width + 3, height - 15));
	end

	--util.add_labeloutline(sprite, str, nil, 25, cc.p(size.width/2, size.height/2), util.c4b_white, util.c4b_black, 1, ANCHOR_CENTER_CENTER, 1, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);

	local actions = {};
	table.insert(actions, cc.DelayTime:create(2));
	table.insert(actions, cc.CallFunc:create(callback_remove_sprite));

	sprite:runAction(cc.Sequence:create(actions));
end

-- channel: C_WORLD, C_ROOM, C_LOG
-- fid: from_id
-- fname: from_name
-- msg: message
function add_chat_msg(channel, eid, alias, msg, time, is_vip)
	if channel ~= C_LOG then
		msg = util.string_cut_by_size(msg, nil);
	end
	local list = g_chat_list[channel];
	if nil == list then
		kerror("channel[%d] not exist", channel);
		return;
	end
	local info;
	info = {channel = channel, eid = eid, alias = alias, msg = msg, time = time, is_vip = is_vip or 0 }; 
	table.insert(list, info);
	list = g_chat_list[C_ALL];
	if nil ~= list and channel ~= C_LOG then
		table.insert(list, info);
	end
	layer_chat:refresh();
	if g_scene:is_battle() and eid ~= g_euser.eid and layer_chat.layer == nil and (channel == C_ROOM or channel == C_PRIVATE) then
		if nil ~= layer_table.btn_chat then
			--local s = layer_table.btn_chat;
			--local x, y = s:getPosition();
			--local size = s:getContentSize();
			--local pos = cc.p(x+size.width/2*s:getScaleX(),y+size.height/2*s:getScaleY());
			local pos = cc.p(HALF_WIDTH, HALF_HEIGHT+50);
			pop_chat(layer_touch.layer, pos, alias, time, msg, is_vip);
		end
	end
end



function net_greconn(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
end

function net_gerr(input_list, str, check)
	if check == -99 then
		local layer, name = layer_msg:create(input_list[3],logout);
		layer:setTag(TAG_MSG_OTHER_LOGIN);
		g_scene:add_layer(ZORDER_LAYER_MSG, layer, name);
		return;
	end
	show_err(str);
	if g_scene:is_stage(STAGE_PVP) then
		net_send("ginfo");
		return;
	end
	if g_scene:is_stage(STAGE_PVE) then
		refresh_layer_card();
		return;
	end
end

function net_reconn(input_list, str, check)
	 local director = cc.Director:getInstance();
	 local scene = g_scene.this_scene or director:getRunningScene();
	 if nil ~= scene:getChildByTag(TAG_MSG_OTHER_LOGIN) then
		 return;
	 end 
	if true == g_scene:is_online() then
		local msg = '连接错误,点击重连[' .. str .. ']';
		g_scene:add_layer(ZORDER_LAYER_MSG,layer_msg:create(msg,callback_reconn));
	end
end

function show_err(str, is_max_size)
	--add_chat_msg(C_LOG, 1, '系统', str, get_time());
	show_msg_box(str, is_max_size);
end

function show_msg_box(str, is_max_size)
	if true == is_max_size then
		local size = cc.size(FULL_WIDTH-50, FULL_HEIGHT-100);
		local function cb()
			util.relaunch_game();
		end
		g_scene:add_layer(ZORDER_LAYER_MSG, layer_msg:create(str, cb, size));
	else
		g_scene:add_layer(ZORDER_LAYER_MSG, layer_msg:create(str));
	end
end

function show_msg(str)
	local layer, sprite, pos, size, path;
	layer = layer_touch.layer;
	pos = cc.p(HALF_WIDTH, FULL_HEIGHT/4*3);
	local fullrect = cc.rect(0, 0, 404, 260);
	local insetrect = cc.rect(198, 125, 8, 10);
	size = cc.size(wfix(512), 260);
	path = util.get_path('bg_121.png');
	sprite = util.add_scale9sprite(layer, path, pos, ANCHOR_CENTER_CENTER, fullrect, insetrect, size); 

	util.add_labeloutline(sprite, str, nil, 30, cc.p(size.width/2, size.height/2), util.c4b_white, util.c4b_black, 1, ANCHOR_CENTER_CENTER, 50, cc.size(size.width-50, size.height-50), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);

	local animation = {};
	local action = cc.MoveBy:create(0.7, cc.p(wfix(0), hfix(50)));
	table.insert(animation, cc.EaseIn:create(action, 0.7));
	table.insert(animation, cc.FadeTo:create(0.5, 158));

	local action_final = {};
	table.insert(action_final, cc.Sequence:create(animation));
	table.insert(action_final, cc.CallFunc:create(callback_remove_sprite));

	sprite:runAction( cc.Sequence:create( action_final ) );
end

function callback_reconn()
	if g_scene:is_stage(STAGE_LOGIN) then
		return;
	end
	g_scene:connect_to_net();
	local u = util.load_rms('username', 'string');
	local p = util.load_rms('password', 'string');
	--print('DEBUG net_reconn u, p', u, p);
	if nil == u or nil == p then
		g_scene:login();
		return;
	end
	net_cmd_log(u, p);
end

-- CMD getsite type
-- type: 0 DEVICE_UNKNOWN 1 DEVICE_IOS 2 DEVICE_ANDROID
-- RET getsite type url
function net_getsite(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local dtype = check;
	local url = input_list[3];
	if nil == url then return; end
	util.open_url(url);
end

function go_download_client()
	local dtype = DEVICE_UNKNOWN;
	local platform = cc.Application:getInstance():getTargetPlatform();
	if platform == cc.PLATFORM_OS_IPHONE or platform==cc.PLATFORM_OS_IPAD then
		dtype = DEVICE_IOS;
	elseif platform == cc.PLATFORM_OS_ANDROID then
		dtype = DEVICE_ANDROID;
	elseif platform == cc.PLATFORM_OS_WINDOWS then
	end
	local cmd = 'getsite ' .. dtype;
	net_send(cmd);
end

-- CMD log [username] [password] [platform] [channel]
-- platform/channel is optional
-- RET log [eid] [st] [alias] [icon] [gid] [gpos] [gname] [level] [exp] [exp_next]
--         [exp_this] [logic_ver] [game_ver] [client_ver] [has_get_reward] 
--         [has_card] [course]
-- gpos see in GUILD_POS
-- if no guild gid 0  gpos 0 gname _no_guild
function net_log(input_list, str, check)
	if check <= 0 then -- eid cannot be 0 either
		g_euser.username = '';
		show_err(str);
		return;
	end
	local logic_version = tonumber(input_list[13]);
	local game_version = tonumber(input_list[14]);
	local client_version = tonumber(input_list[15]);
	--kdebug("version: client[%d]game[%d]logic[%d]", client_version, game_version, logic_version);
	--[[ skip check now
	if client_version > CLIENT_VERSION then
		local t = '客户端版本过旧，请点击确认下载安装新版本';
		local c = go_download_client;
		g_scene:add_layer(ZORDER_LAYER_MSG,layer_msg:create(t, c));
		return;
	end
	if game_version > tonumber(GAME_VERSION) then
		local t = '资源版本过旧，请点击确认进行更新';
		local c = util.relaunch_game;
		g_scene:add_layer(ZORDER_LAYER_MSG,layer_msg:create(t, c));
		return;
	end
	if logic_version > tonumber(LOGIC_VERSION) then
		local t = '资源版本过旧，请点击确认进行更新';
		local c = util.relaunch_game;
		g_scene:add_layer(ZORDER_LAYER_MSG,layer_msg:create(t, c));
		return;
	end
	--]]
	g_euser.eid      = check;
	g_euser.st       = tonumber(input_list[3]);
	g_euser.alias    = input_list[4];
	g_euser.icon     = input_list[5];
	g_euser.gid      = tonumber(input_list[6]);
	g_euser.gpos     = tonumber(input_list[7]);
	g_euser.gname    = input_list[8];
	g_euser.level    = tonumber(input_list[9]);
	g_euser.exp      = tonumber(input_list[10]);
	g_euser.exp_next = tonumber(input_list[11]);
	g_euser.exp_this = tonumber(input_list[12]);
	g_euser.has_get_reward = tonumber(input_list[16]);
	local has_card = tonumber(input_list[17]);
	set_value_for_g_tutor(input_list[18]);
	g_tutor_change = nil;

	util.save_rms('last_eid', g_euser.eid, 'string');
	if is_ver(VER_UCSDK) then
		uc_submit_data("RoleLog");
	end
	if is_ver(VER_LJSDK) then
		ljsdk_submit_data("enterServer");
	end

	if g_scene:is_stage(STAGE_LOGIN) then
		layer_login:save_info();
	end

	local cmd;
	if g_euser.st >= ST_ROOM then
		cmd = 'room';
		net_send(cmd);
		return;
	end
	if 1 == has_card then
		-- send lcard , if return err, means did not pick hero
		--cmd = 'lcard';
		--net_send(cmd);
		log_to_map();
		return;
	end
	g_scene:role();
	--net_send('lmerge');
	--net_send('lconstant');
	--net_send('course');
end

function log_to_map()
	g_euser.all_str = nil;
	g_scene:map();
	net_send('lconstant', true);
	if true == util.trigger_tutor(TUTOR_FIRST_INTRO) then
		return;
	end
	if g_euser.level > 5 and nil == layer_dragstory.layer and nil == layer_dragtutorial.layer then
		show_notice();
	end
end

-- CMD room   -- list the room info 
-- room_id 0 means create room
-- CMD room [channel]  -- create a room in channel
-- CMD room [channel] [room_id] -- join a room with channel and room_id
-- create room with channel and room_id and password
-- CMD room [channel] [room_id] [passowrd] 
-- join room with channel and room_id and password
-- CMD room [channel] [room_id] [passowrd] 
-- RET room [channel] [room_id] [st] [password] [num_guest] [guest[0]_info] 
--          [guest[1]_info] .. [game_type] ..
-- if game_type == GAME_CHAPTER then will get chapter_target
--                      [target_num] [target1] [p1] [p2] ... 
-- guset_info == [eid] [alias] [icon]
-- only CMD3 will broadcast
function net_room(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local channel = check;
	local room_id = tonumber(input_list[3]);
	local st = tonumber(input_list[4]);
	local pwd = input_list[5];
	local glist_num = 0;
	if nil ~= g_euser.room_data then
		local l = g_euser.room_data.guest_list or {};
		glist_num = #l;
	end
		
	local guest_list = {};
	local index = 6;
	local gcount = tonumber(input_list[index]);
	index = index + 1;
	for i = 1, gcount do
		local l = {};
		l.eid = tonumber(input_list[index]);
		index = index + 1;
		l.alias = input_list[index];
		index = index + 1;
		l.icon = input_list[index];
		index = index + 1;
		table.insert(guest_list, l);
	end
	g_euser.room_data = {
		channel = channel,
		room_id = room_id,
		st = st,
		guest_list = guest_list,
	};
	--print('index: ', index);
	local game_type = tonumber(input_list[index]);
	--print('game_type: ', game_type);
	index = index + 1;
	if game_type == GAME_CHAPTER then
		local target_list = {};
		local target_count = tonumber(input_list[index]);
		index = index + 1;
		for i = 1, target_count do
			local l = {};
			l.target_type = tonumber(input_list[index]);
			index = index + 1;
			l.p1 = tonumber(input_list[index]);
			index = index + 1;
			l.p2 = tonumber(input_list[index]);
			index = index + 1;
			table.insert(target_list, l);
			g_euser.room_data.target_list = target_list;
		end
	end

	--[[
	if g_scene:is_stage(STAGE_PVP) then
		layer_card:update_player_info(g_euser.room_data);
	end
	]]--

	if (g_scene:is_stage(STAGE_PVP) or g_scene:is_stage(STAGE_PVG)) and st >= g_euser.st then
		-- if a guest come in while battling, no need to do_greconn
		if st > g_euser.st then
			do_greconn();
			return;
		end
		if glist_num ~= #(g_euser.room_data.guest_list) then
			return;
		end
		if true ~= layer_result.is_done and st == ST_GAME then
			g_euser.st = st;
			layer_card:set_wait_result();
			return;
		end
		if nil ~= layer_result.layer and st == ST_GAME then -- start new game
			g_euser.st = st;
			local cmd = 'ginfo';
			net_send(cmd);
			return;
		end
	end
	g_euser.st = st;
	if ST_GAME == g_euser.st then
		local cmd = 'ginfo';
		net_send(cmd);
		return;
	end
	if not g_scene:is_stage(STAGE_MAP) then
		g_scene:map();
	end

	if nil == layer_room.layer then
		g_scene:add_layer(ZORDER_LAYER_ROOM, layer_room:create(channel, room_id, guest_list[1]));
	end
	if #guest_list > 1 then
		layer_room:insert_player(guest_list[#guest_list]);
		if guest_list[1].eid == g_euser.eid then
			layer_room:show_start();
		end
	end
end

-- CMD lmerge
-- RET lmerge AABBCC...(CARD_ARRAY_LIST*2 char)
-- list require
function net_lmerge(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local str = input_list[2];
	g_euser.merge_str = str;
end

-- CMD lconstant
-- RET lconstant key=value key=value ...
function net_lconstant(input_list, str, check)
	for i = 1, #input_list do
		local m = input_list[i];
		local ms = csplit(m, "=");
		local key = ms[1];
		local value = ms[2];
		g_constant[key] = value;
	end
end

function save_for_collection(input_list)
	local from_id = tonumber(input_list[3]);
	local cards = input_list[4];
	local num = 0;
	local len = string.len(cards);
	for i = 1, len do
		local t = string.sub(cards, i, i);
		t = tonumber(t);
		if nil ~= t and t > 0 then
			num = num + 1;
		end
	end
	g_euser.collection = num;
	if 0 < len then
		g_euser.collection_rate = num / len;
	else
		g_euser.collection_rate = 0;
	end
end

-- CMD lcard [in_total] [from_id]  -- array mode in_total = 400 , from_id = 1
--                                 -- from_id is optional, default = 1
-- CMD lcard                       -- load all cards
-- RET lcard [total] [from_id] 3056...98            -- array mode
-- RET lcard [total] [from_id = 0] 8 22 22 23 23 26 ... -- list mode
function net_lcard(input_list, str, check)
	if -6 == check then -- anysdk switch account to a new reg account, no lcard
		g_scene:role();
		return;
	elseif check < 0 then
		show_err(str);
		return;
	end
	save_for_collection(input_list);
	local total = check;
	local from_id = tonumber(input_list[3]);
	local cards = input_list[4];
	g_euser.all_str = cards;
	if g_scene:is_stage(STAGE_LOGIN) or g_scene:is_stage(STAGE_ROLE) then
		g_scene:map();
		net_send('lconstant', true);
		net_send('course');
		if g_euser.level > 5 then
			show_notice();
		end
	elseif g_scene:is_stage(STAGE_DECK) then
		g_euser.slot_str = c_get_slot_str(g_euser.deck_str, g_euser.all_str);
		local slot_array = c_str_array(g_euser.slot_str);	
		layer_deck:set_slot_cards(slot_array, 1);
		if true == util.trigger_tutor(TUTOR_DECK_MOVE_CARD) then
			return;
		end
		check_do_tutor_wait_net();
		--[[
		if g_tutor_wait_net == tutor_deck_2 then
			g_tutor_wait_net();
			util.set_tutor(TUTOR_DECK, true, true);
		end
		]]--
	elseif g_scene:is_stage(STAGE_SGDECK) then
		local card_array = c_str_array(g_euser.all_str);
		layer_sgdeck:set_card_own(card_array);
	elseif g_scene:is_stage(STAGE_SHOP) then
		g_list_shop = g_list_shop or {};
		if 0 == #g_list_shop then
		    layer_shop:callback_reloadlist();
		else
			layer_shop:add_to_list(g_list_shop);
		end
	elseif g_scene:is_stage(STAGE_BOOK) then
		layer_book:refresh_list();
	elseif g_scene:is_stage(STAGE_MAP) then
		-- do nothing
		g_scene:add_layer(ZORDER_LAYER_INFO, layer_info:create(g_euser));
	else
		g_scene:map();
	end
end

-- CMD sta 
-- RET sta [eid] [level] [rating] [gold] [crystal] [game_count]
--         [win] [lose] [draw] [run] [icon] [alias] [gid] [gpos] [gname]
--         [exp] [exp_next] [exp_this] [sex] [signature] [unread_msg_count]
--         [power] [power_last_refresh_time] [monthly_end_date] [chapter_pos]
--         [course]
-- five minutes add one power
function net_sta(input_list, str, check)
	if check < 0 then
		show_err(str);
	else
		local eid = check;
		if eid ~= g_euser.eid then
			return;
		end
		g_euser.level      = tonumber(input_list[3]);
		g_euser.rating     = tonumber(input_list[4]);
		g_euser.gold       = tonumber(input_list[5]);
		g_euser.crystal    = tonumber(input_list[6]);
		g_euser.game_count = tonumber(input_list[7]);
		g_euser.win        = tonumber(input_list[8]);
		g_euser.lose       = tonumber(input_list[9]);
		g_euser.draw       = tonumber(input_list[10]);
		g_euser.run        = tonumber(input_list[11]);
		g_euser.icon       = input_list[12];
		g_euser.alias      = input_list[13];
		g_euser.gid        = tonumber(input_list[14]);
		g_euser.gpos       = tonumber(input_list[15]);
		g_euser.gname      = input_list[16];
		g_euser.exp        = tonumber(input_list[17]);
		g_euser.exp_next   = tonumber(input_list[18]);
		g_euser.exp_this   = tonumber(input_list[19]);
		g_euser.sex        = tonumber(input_list[20]);
		g_euser.signature  = input_list[21];
		g_euser.un_read_msg_count = tonumber(input_list[22]);
		g_euser.power      = tonumber(input_list[23]);
		-- power add 1 point per 300 sec
		g_euser.power_last_refresh_time = tonumber(input_list[24]);
		--[[
		if g_euser.power > 0 then
			local t = os.date("*t", g_euser.power_last_refresh_time);
			local str = string.format("%d年%02d月%02d日 %02d时%02d分%02d秒", t.year, t.month, t.day, t.hour, t.min, t.sec);
			print('str: ', str);
		end
		print('power, time: ', g_euser.power, g_euser.power_last_refresh_time, os.time());
		]]--
		if #input_list >= 26 then
			g_euser.monthly_end_date = tonumber(input_list[25]);
			--local t = os.date("*t", g_euser.monthly_end_date);
			--local str = string.format("%d年%02d月%02d日 %02d时%02d分%02d秒", t.year, t.month, t.day, t.hour, t.min, t.sec);
			--print('str: ', str);

			g_euser.chapter_pos		= tonumber(input_list[26]);
			local course = tonumber(input_list[27]);
			set_value_for_g_tutor(course);
			g_tutor_change = nil;
		end

		--layer_chat:show_vip(is_vip_member(g_euser));
		--local t = os.date("*t", g_euser.power_last_refresh_time);
		--local str = string.format("%d年%02d月%02d日 %02d时%02d分%02d秒", t.year, t.month, t.day, t.hour, t.min, t.sec);
		--print('str: ', str);
		--[[
		local str = '';
		for i = 21, #input_list do
			str = str .. input_list[i];
			if i < #input_list then
				str = str .. ' ';
			end
		end
		g_euser.signature = str;
		]]--

		layer_infobar:update_info(true);
		if g_scene:is_stage(STAGE_MAP) then
			layer_map:update_info();
		end
		if g_scene:is_stage(STAGE_SHOP) then
			layer_chat:update_info();
		end
	end
end

-- CMD wchat [msg]
-- 2 return;
-- RET 1  wchat 0  -- 0 means send success -- <0 means fail (only sender get)
-- RET 2  wchat [eid] [alias] [is_vip] [is_pop] [msg]
function net_wchat(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	-- check == 0 means ok
	if 0 == check then
		-- send success;
		return;
	end
	local eid = check;
	local alias = input_list[3];
	local is_vip = tonumber(input_list[4]);
	local is_pop = tonumber(input_list[5]);
	local msg = '';
	for i = 6, #input_list do
		msg = msg .. input_list[i] .. ' ';
	end
	local time = get_time();
	add_chat_msg(C_WORLD, eid, alias, msg, time, is_vip);

	if 1 == is_pop then
		util.show_horselamp(msg, 1);
	end
	--show_lamp(msg, 1);
end

-- CMD rchat [msg]
-- RET rchat [eid] [alias] [is_vip] [is_pop] [msg]
function net_rchat(input_list, str, check)
	if check <= 0 then
		show_err(str);
		return;
	end
	local eid = check;
	local alias = input_list[3];
	local is_vip = tonumber(input_list[4]);
	local is_pop = tonumber(input_list[5]);
	--local msg = input_list[4];
	local msg = '';
	for i = 6, #input_list do
		msg = msg .. input_list[i] .. ' ';
	end
	local time = get_time();
	--print('time: ', time);
	add_chat_msg(C_ROOM, eid, alias, msg, time, is_vip);
	if 1 == is_pop then
		util.show_horselamp(msg, 1);
	end
end

-- CMD gchat [msg]
-- RET gchat [eid] [alias] [is_vip] [is_pop] [msg]
function net_gchat(input_list, str, check)
	if check <= 0 then
		show_err(str);
		return;
	end
	local eid = check;
	local alias = input_list[3];
	local is_vip = tonumber(input_list[4]);
	local is_pop = tonumber(input_list[5]);
	--local msg = input_list[4];
	local msg = '';
	for i = 6, #input_list do
		msg = msg .. input_list[i] .. ' ';
	end
	local time = get_time();
	--print('time: ', time);
	add_chat_msg(C_GUILD, eid, alias, msg, time, is_vip);
	if 1 == is_pop then
		util.show_horselamp(msg, 1);
	end
end

-- CMD fchat [eid] [msg]
-- RET fchat [eid] [alias] [is_vip] [is_pop] [msg]
function net_fchat(input_list, str, check)
	if check <= 0 then
		show_err(str);
		return;
	end
	local eid = check;
	local alias = input_list[3];
	local is_vip = tonumber(input_list[4]);
	local is_pop = tonumber(input_list[5]);
	--local msg = input_list[4];
	local msg = '';
	for i = 6, #input_list do
		msg = msg .. input_list[i] .. ' ';
	end
	local time = get_time();
	--print('time: ', time);
	add_chat_msg(C_PRIVATE, eid, alias, msg, time, is_vip);
	if 1 == is_pop then
		util.show_horselamp(msg, 1);
	end
end

function init_net_play()
	g_net_play_cache = {};
end
--init_net_play(); -- do in do_game
-- cmd index .....
function do_greconn()
	local last_index = #g_net_play_cache;
	local cmd = 'greconn ' .. last_index;
	net_send(cmd);
end
function check_miss_cmd(index, str, input_list)
	local cmd = g_net_play_cache[index];
	if true == LOCAL_CMD then
		if nil ~= cmd then
			if str == cmd then
				--print('========= has play local: ', str);
			elseif 'n' == input_list[2] then
				--print('========= has play local n : ', str);
				layer_card:handle_next_timeout(input_list[3]);
			else
				local cmd = 'ginfo';
				net_send(cmd);
			end
			return false;
		end
	end
	local last_index = #g_net_play_cache;
	if index < last_index + 1 then
		return false;
	end
	if index > last_index + 1 then
		do_greconn();
		return false;
	end
	-- when cmd to efflist get error, should remove it from g_net_play_cache
	-- @see in cmd_game_to_logic
	table.insert(g_net_play_cache, str);
	return true;
end

function str_cut_num(num, str)
	local len = string.len(num);
	len = len + 2; -- one space and start from next one character
	str = string.sub(str, len);
	return str;
end

function cut_cmd_num(input_list, str)
	local index = tonumber(input_list[1]);
	if nil == index then
		return nil;
	end
	if false == check_miss_cmd(index, str, input_list) then
		return nil;
	end
	str = str_cut_num(input_list[1], str);
	return str;
end
function net_play(input_list, str)
	str = cut_cmd_num(input_list, str); 	
	if nil == str then
		return;
	end
	table.remove(input_list, 1);
	local eff_list = nil; 
	local err = nil;
	if g_net_cmdsize > 0 then
		g_net_cmdsize = g_net_cmdsize - 1;
		table.insert(g_game_play_list, str);
		if 1 >= g_net_cmdsize then
			g_net_cmdsize = 0;
			layer_preload:start();
		end
		return;
	end
	if not g_scene:is_stage(STAGE_PVP) and not g_scene:is_stage(STAGE_PVG) then
		table.insert(g_game_play_list, str);
		return;
	end
	push_cmd_list(str, { refresh_layer_card }, nil);
end

function local_play(cmd)
	local total = #g_net_play_cache + 1;
	cmd = string.format("%d %s", total, cmd);
	local input_list = csplit(cmd, ' ');
	net_play(input_list, cmd);
end

function do_ai()
	local cmd = 'local_ai';
	play_game_cmd(cmd);
end

function cb_net_game()
	local side = g_game_info.side;
	local cmd_size = g_game_info.cmd_size;
	local seed = g_game_info.seed;
	local deck1_array = g_game_info.deck1_array;
	local deck2_array = g_game_info.deck2_array;
	local timeout = g_game_info.timeout;
	local game_type = g_game_info.game_type;
	local solo_data = g_game_info.solo_data;
	local robot_data = g_game_info.robot_data;
	local hero_info = g_game_info.hero_info;
	g_scene:pvp(side, seed, deck1_array, deck2_array, timeout, solo_data, robot_data, hero_info);
	if nil ~= g_euser.room_data then
		g_euser.room_data.game_type = game_type;
	end
	if cmd_size > 0 then
		if g_scene:is_stage(STAGE_PVP) then
			layer_card:hide_all_btn();
		end
		for i = 1, #g_game_play_list do
			local play_str = g_game_play_list[i];
			local eff_list = nil; 
			local err = nil;
			eff_list, err = cmd_game_to_logic(play_str, true);
		end
		g_game_play_list = {};
		data_handler:clean_ui_table();
		layer_card:init_cards();
		refresh_layer_card();
		layer_card:handle_next_timeout(timeout);
		layer_table:change_side(g_current_side);
		return;
	end
	if 0 < #g_game_play_list then
		for i = 1, #g_game_play_list do
			local str = g_game_play_list[i];
			push_cmd_list(str, { refresh_layer_card }, nil);
		end
		layer_card:handle_next_timeout(timeout);
		layer_table:change_side(g_current_side);
		return;
	end
	layer_card:handle_next_timeout(timeout);
	layer_table:change_side(g_current_side);
end

-- CMD game
-- RET game [side] [cmd_size] [seed] [timeout] [game_type] [is_auto]
--          [hp1] [hp2] [energy1] [energy2]
--          [card_len] [deck_400_1] [card_len] [deck_400_2]
-- where side = 1, 2 or 99, 1, 2 are players, 99 is wathcer
-- start_side = 1 or 2
-- if card_len == 0, means deck is deck400
-- if card_len > 0, means deck is list deck [1 22 23 35 ...]
function net_game(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	data_handler:cleanup();
	local side = check;
	local cmd_size = tonumber(input_list[3]);
	local seed = tonumber(input_list[4]);
	local timeout = tonumber(input_list[5]);
	local game_type = tonumber(input_list[6]);
	layer_card.FORCE_AUTO = tonumber(input_list[7]);--0 can manual,1 can only auto
	--local deck1_array = input_list[7];
	--local deck2_array = input_list[8];
	local hp1 = tonumber(input_list[8]);
	local hp2 = tonumber(input_list[9]);
	local energy1 = tonumber(input_list[10]);
	local energy2 = tonumber(input_list[11]);
	local index = 12;
	local card_len1		= tonumber(input_list[index]);
	index = index + 1;
	local deck1 = "";
	if card_len1 > 0 then
		local len = index+card_len1-1;
		for i = index, len do
			deck1 = deck1 .. ' ' .. input_list[i];
			index = index+1;
		end
	else
		deck1 = input_list[index];
		index = index+1;
	end
	local card_len2		= tonumber(input_list[index]);
	index = index + 1;
	local deck2 = "";
	if card_len2 > 0 then
		local len = index+card_len2-1;
		for i = index, len do
			deck2 = deck2 .. ' ' .. input_list[i];
			index = index+1;
		end
	else
		deck2 = input_list[index];
		index = index+1;
	end
	local deck1_array = deck1;
	local deck2_array = deck2;
	g_game_info = {
		side = side,
		cmd_size = cmd_size,
		seed = seed,
		deck1_array = deck1_array,
		deck2_array = deck2_array,
		hero_info = {
			hp1 = hp1,
			hp2 = hp2,
			energy1 = energy1,
			energy2 = energy2,
		},
		timeout = timeout,
		game_type = game_type,
	};
	g_game_play_list = {};
	init_net_play();
	if cmd_size > 0 then
		g_scene:preload(cb_net_game, layer_preload.WAIT, STAGE_PVP);
		g_net_cmdsize = cmd_size + 1;
		return;
	end
	g_scene:preload(cb_net_game, layer_preload.START, STAGE_PVP);
end

function cb_net_gate()
	local side = g_game_info.side;
	local cmd_size = g_game_info.cmd_size;
	local seed = g_game_info.seed;
	local deck1_array = g_game_info.deck1_array;
	local gate_list = g_game_info.gate_list;
	local gate_id = g_game_info.gate_id;
	local gr = g_game_info.gr;
	g_scene:pvg(side, seed, deck1_array, gate_list, gr, gate_id);
	if cmd_size > 0 then
		if g_scene:is_stage(STAGE_PVG) then
			layer_card:hide_all_btn();
		end
		for i = 1, #g_game_play_list do
			local play_str = g_game_play_list[i];
			local eff_list = nil; 
			local err = nil;
			eff_list, err = cmd_game_to_logic(play_str, true);
		end
		g_game_play_list = {};
		data_handler:clean_ui_table();
		layer_card:init_cards();
		refresh_layer_card();
		layer_card:handle_next_timeout(timeout);
		layer_table:change_side(g_current_side);
		return;
	end
	if 0 < #g_game_play_list then
		for i = 1, #g_game_play_list do
			local str = g_game_play_list[i];
			push_cmd_list(str, { refresh_layer_card }, nil);
		end
		layer_card:handle_next_timeout(timeout);
		layer_table:change_side(g_current_side);
		return;
	end
	layer_card:handle_next_timeout(timeout);
	layer_table:change_side(g_current_side);
end

-- CMD gate gate_id
-- gate_id get in a gate game
-- RET gate [gate_id] [side] [cmd_size] [seed] [deck_400_1] [gate_count] [r1] [c1] .. [rn] [cn]
-- n == gate_count
-- where side = 1, 2 or 99, 1, 2 are players, 99 is wathcer
-- start_side = 1 or 2
function net_gate(input_list, str, check)
	if check < 0 then
		if -6 == check then
			str = "体力不足\n（体力每5分钟回复1点）";
		end
		if -99 == check then
			show_gate();
			return;
		end
		show_err(str);
		return;
	end
	local gate_id = check;
	local side = tonumber(input_list[3]);
	data_handler:cleanup();
	local cmd_size = tonumber(input_list[4]);
	local seed = tonumber(input_list[5]);
	local deck1_array = input_list[6];
	local gate_count = tonumber(input_list[7]);
	local gate_list = {};
	local index = 8;
	for i = 1, gate_count do
		local r = tonumber(input_list[index]);
		index = index + 1;
		local c = tonumber(input_list[index]);
		index = index + 1;
		gate_list[r] = gate_list[r] or {};
		table.insert(gate_list[r], c);
	end
	local gr = {}; -- round number to add ally
	for k, _ in pairs(gate_list) do
		local r = tonumber(k);
		if nil ~= r then
			table.insert(gr, k);
		end
	end
	table.sort(gr, function(a, b)
		return a < b;
	end);
	g_game_info = {
		side = side,
		cmd_size = cmd_size,
		seed = seed,
		deck1_array = deck1_array,
		gate_list = gate_list,
		gate_id = gate_id,
		gr = gr,
	};
	g_game_play_list = {};
	init_net_play();
	if cmd_size > 0 then
		g_scene:preload(cb_net_gate, layer_preload.WAIT, STAGE_PVG);
		g_net_cmdsize = cmd_size + 1;
		return;
	end
	g_scene:preload(cb_net_gate, layer_preload.START, STAGE_PVG);
end

-- CMD gate_msg gate_id
-- RET gate_msg gate_id size info1 ... infon
-- info: round card_id msg
function net_gate_msg(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local gate_id = check;
	local size = tonumber(input_list[3]);
	local list = {};
	local index = 4;
	for i = 1, size do
		local l = {};
		l.round = tonumber(input_list[index]);
		index = index + 1;
		l.card_id = tonumber(input_list[index]);
		index = index + 1;
		l.msg = input_list[index];
		index = index + 1;
		table.insert(list, l);
	end
	layer_table:add_gate_msg(list);
end

-- CMD lgate
-- RET lgate my_gate_pos total_size page_size info1 info2 ... infon
-- info = gate_id title gold crystal exp focus_card power
function net_lgate(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local my_gate_pos = check;
	local total_size = tonumber(input_list[3]);
	local start_id = tonumber(input_list[4]);
	local page_size = tonumber(input_list[5]);
	local list = {};
	local index = 6;
	local size = page_size;
	local is_full = false;
	for i = 1, size do
		local l = {};
		l.gate_id = tonumber(input_list[index]);
		index = index + 1;
		l.title = input_list[index];
		index = index + 1;
		l.gold = tonumber(input_list[index]);
		index = index + 1;
		l.crystal = tonumber(input_list[index]);
		index = index + 1;
		l.exp = tonumber(input_list[index]);
		index = index + 1;
		l.focus_card = tonumber(input_list[index]);
		index = index + 1;
		l.power = tonumber(input_list[index]);
		index = index + 1;
		if l.gate_id > my_gate_pos then
			is_full = true;
		else
			table.insert(list, l);
		end
	end
	layer_gate:add_list(list, start_id, total_size, is_full);
	if g_tutor_wait_net == show_tutor_do_gate then
		g_tutor_wait_net();
	end
end

-- CMD gift key_code
-- RET gift eid gold crystal card_count card_id_1 .. card_id_n
function net_gift(input_list, str, check)
	if check < 0 then
		if -6 == check then
			show_err("兑换码不存在");
		elseif -16 == check then
			show_err("兑换码已使用");
		elseif -26 == check then
			show_err("兑换码已过期");
		elseif -36 == check then
			show_err("兑换码无效");-- diffrent channel
		elseif -46 == check then
			show_err("该账号已经兑换过同类型的礼包");
		else
			show_err(str);
		end
		layer_code:clean_input();
		return;
	end
	if nil ~= layer_code.layer then
		layer_code:remove();
	end
	local eid = check;
	local gold_offset = tonumber(input_list[3]);
	local crystal_offset = tonumber(input_list[4]);
	g_euser.gold = g_euser.gold + gold_offset;
	g_euser.crystal = g_euser.crystal + crystal_offset;
	layer_infobar:update_info();
	local card_count = tonumber(input_list[5]);
	local index = 6;
	local list = {};
	for i = 1, card_count do
		local cid = tonumber(input_list[index]);
		local rc = g_card_list[cid];
		if nil == rc then
			rc = hero_list[cid];
		end
		local card = clone(rc);
		table.insert(list, card);
		index = index + 1;
	end
	g_scene:add_layer(ZORDER_LAYER_POPCLIST, layer_popclist:create(list));
	if 0 >= gold_offset and 0 >= crystal_offset then return; end
	local msg = '恭喜获得';
	if gold_offset > 0 then
		msg = msg .. string.format("\n[%d]金币", gold_offset);
	end
	if crystal_offset > 0 then
		msg = msg .. string.format("\n[%d]水晶", crystal_offset);
	end
	g_scene:add_layer(ZORDER_LAYER_MSG,layer_msg:create(msg,nil));
end

-- CMD fdata
-- RET fdata pve_time pve_gold_reward pve_gold_cost 
--           pvp_gold_time pvp_gold_reward pvp_gold_cost
--           pvp_crystal_time pvp_crystal_reward pvp_crystal_cost
--           pvp_free_reward pvp_free_lose
--           pve_free_reward pve_free_lose
--           pve_status pvp_gold_status pvp_crystal_status
--           pve_free_status pvp_free_status
--           pvp_gold_start_time pvp_gold_end_time
--           pvp_crystal_start_time pvp_crystal_end_time
-- status 1 open 2 close
function net_fdata(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local data = {};
	data.pve_time = check;
	data.pve_gold_reward = tonumber(input_list[3]);
	data.pve_gold_cost = tonumber(input_list[4]);
	data.pvp_gold_time = tonumber(input_list[5]);
	data.pvp_gold_reward = tonumber(input_list[6]);
	data.pvp_gold_cost = tonumber(input_list[7]);
	data.pvp_crystal_time = tonumber(input_list[8]);
	data.pvp_crystal_reward = tonumber(input_list[9]);
	data.pvp_crystal_cost = tonumber(input_list[10]);
	data.pvp_free_reward = tonumber(input_list[11]);
	data.pvp_free_lose = tonumber(input_list[12]);
	data.pve_free_reward = tonumber(input_list[13]);
	data.pve_free_lose = tonumber(input_list[14]);
	data.pve_status = tonumber(input_list[15]);
	data.pvp_gold_status = tonumber(input_list[16]);
	data.pvp_crystal_status = tonumber(input_list[17]);
	data.pve_free_status = tonumber(input_list[18]);
	data.pvp_free_status = tonumber(input_list[19]);
	data.pvp_gold_start_time = tonumber(input_list[20]);
	data.pvp_gold_end_time = tonumber(input_list[21]);
	data.pvp_crystal_start_time = tonumber(input_list[22]);
	data.pvp_crystal_end_time = tonumber(input_list[23]);
	if nil ~= layer_service.layer then
		layer_service:add_info(data);
	end
end

-- CMD fight game_type
-- if game_type == GAME_SOLO_GOLD or GAME_SOLO_FREE
-- RET room ...
-- if game_type == GAME_VS_GOLD or GAME_VS_CRYSTAL or GAME_VS_FREE
function net_fight(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
end

function net_cancel(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if 0 == check then
		layer_quick:stop_waiting();
	end
end

function reset_win_data()
	g_net_win_data = nil;
end

function get_winner_name(wside)
	local data = g_euser.room_data;
	if nil == data then return "??"; end
	local list = data.guest_list;
	local name = nil;
	local info = list[wside];
	if nil == info then
		return name;
	end
	name = info.alias;
	return name;
end

function show_layer_result(win_tag, info)
	local layer, name = layer_result:create(win_tag, info);
	g_scene:add_layer(ZORDER_LAYER_RESULT, layer, name);
end

function callback_net_win()
	local wside = g_net_win_data.wside;
	local wtype = g_net_win_data.wtype;
	local offset_rating = g_net_win_data.rating; 
	local offset_gold = g_net_win_data.gold; 
	local offset_exp = g_net_win_data.exp;
	local offset_crystal = g_net_win_data.crystal;
	local level = g_net_win_data.level;
	local exp_next = g_net_win_data.exp_next;
	-- for replay
	local is_replay = g_net_win_data.is_replay;
	--
	if true == is_replay then
		local name = g_net_win_data.name;
		g_net_win_data.winnername = name;
	else
		g_net_win_data.winnername = get_winner_name(g_net_win_data.wside);
	end
	local flag;
	if true == is_replay then
		flag = layer_result.TAG_GUEST;
	elseif SIDE_GUEST == g_euser.side then
		flag = layer_result.TAG_GUEST;
	elseif wside == g_euser.side then
		flag = layer_result.TAG_WIN;
	elseif 9 == wside then
		flag = layer_result.TAG_DRAW;
	else
		flag = layer_result.TAG_LOSE;
	end
	show_layer_result(flag, g_net_win_data);
	reset_win_data();
end

-- CMD fold
-- RET win win_side win_type rating gold exp level next_exp player_exp card_id
--     crystal
--     guest_pos game_type ...
-- exp is offset
-- for win_side 1 or 2 win_type 1(surrender) or 0(normal)
-- win_side == 9 means draw
-- card_id > 0 ---> has prize card
-- guest_pos = 0 or 1 or 9, 9 for not player guest
-- if game_type == GAME_CHAPTER
--     chapter_id stage_id target_count target_info1 target_info2 ...
--     reward_count reward_info1 reward_info2 ... reward_pos
-- target_info = target p1 p2 value done(0-not finish, 1-finish)
-- reward_info = reward count
-- reward_pos = which reward you get, base 0, if winner != 1, reward_pos = -1
-- game_type see in GAME_XXX
-- if game_type == GAME_QUICK
--     reward_count reward_info1 ..
--     reward_pos
function net_win(input_list, str, check)
	if check < 0 then
		if -8 == check then
			callback_reconn();
			return;
		end
		show_err(str);
		return;
	end
	g_net_win_data = {}; -- also reset to nil in data_handler.cleanup
	g_net_win_data.wside = check;
	g_net_win_data.wtype = tonumber(input_list[3]);
	g_net_win_data.rating = tonumber(input_list[4]); -- offset
	g_net_win_data.gold = tonumber(input_list[5]); -- offset
	g_net_win_data.exp = tonumber(input_list[6]); -- offset
	-- add offset_exp to g_euser.exp in layer_result show_level_up
	g_net_win_data.level = tonumber(input_list[7]); 
	g_net_win_data.exp_next = tonumber(input_list[8]);
	g_net_win_data.exp_player = tonumber(input_list[9]); -- exp after add
	g_net_win_data.card_id = tonumber(input_list[10]);
	g_net_win_data.crystal = tonumber(input_list[11]);
	g_net_win_data.guest_pos = tonumber(input_list[12]);
	g_net_win_data.game_type = tonumber(input_list[13]);
	g_euser.gold = g_euser.gold + g_net_win_data.gold;
	g_euser.crystal = g_euser.crystal + g_net_win_data.crystal;
	local index = 14;
	if g_net_win_data.game_type == GAME_CHAPTER then
		local l = {};
		l.chapter_id = tonumber(input_list[index]);
		index = index + 1;
		l.stage_id = tonumber(input_list[index]);
		index = index + 1;
		l.list_target = {};
		local target_count = tonumber(input_list[index]);
		index = index + 1;
		for i = 1, target_count do
			local ll = {};
			ll.target_type = tonumber(input_list[index]);
			index = index + 1;
			ll.p1 = tonumber(input_list[index]);
			index = index + 1;
			ll.p2 = tonumber(input_list[index]);
			index = index + 1;
			ll.value = tonumber(input_list[index]);
			index = index + 1;
			ll.done = tonumber(input_list[index]);
			index = index + 1;
			table.insert(l.list_target, ll);
		end
		l.list_reward = {};
		local reward_count = tonumber(input_list[index]);
		index = index + 1;
		for i = 1, reward_count do
			local ll = {};
			ll.reward_type = tonumber(input_list[index]);
			index = index + 1;
			ll.reward_num = tonumber(input_list[index]);
			index = index + 1;
			table.insert(l.list_reward, ll);
		end
		l.reward_pos = tonumber(input_list[index]);
		if l.reward_pos > -1 then
			l.reward_pos = l.reward_pos + 1;
		end
		index = index + 1;
		g_net_win_data.chapter_info = l;
	elseif g_net_win_data.game_type == GAME_QUICK then
		local l = {};
		l.list_reward = {};
		local reward_count = tonumber(input_list[index]);
		index = index + 1;
		for i = 1, reward_count do
			local ll = {};
			ll.reward_type = tonumber(input_list[index]);
			index = index + 1;
			ll.reward_num = tonumber(input_list[index]);
			index = index + 1;
			table.insert(l.list_reward, ll);
		end
		l.reward_pos = tonumber(input_list[index]);
		if l.reward_pos > -1 then
			l.reward_pos = l.reward_pos + 1;
		end
		index = index + 1;
		g_net_win_data.rinfo = l;
	end
	if 1 == layer_card.FORCE_AUTO then
		if 0 < #(g_game_play_list or {}) then
			return;
		end
	end
	check_cmd_finish();
end

-- CMD fold
function net_fold(input_list, str, check)
	if check < 0 then
		if -8 == check then
			callback_reconn();
			return;
		end
		show_err(str);
	else
	end
end

function dl_res_pic(filename)
    local flag = util.check_file(filename);
	if false == flag then
		return;
	end   
	local list = {}; 
	local fullpath = util.get_fullpath(F_RES, filename); 
	local file = io.open(fullpath, "r"); 
	if nil ~= file then
		local data = file:read("*all");
		local lines = csplit(data, "[\n\r]");
		for i = 1, #lines do
			--print('line: ', i, lines[i]);
			table.insert(list, lines[i]);
		end   
		io.close(file);
	end   

	for i = 1, #list do
		local fname = list[i];
		local is_exist = util.check_file(fname);
		--print('fname, exist: ', fname, is_exist);
		if true ~= is_exist then
			--print('card is_exist: ', i, is_exist);
			send_dres(fname);
		end   
	end   
end

function send_dres(filename)
	if nil == filename then return; end
	LayerSocket:dlRes(filename);
end

function net_dres(input_list, str, check)
	if check < 0 then
		--show_err(str);
		return;
	end
	local filename = input_list[3];
	if 'cardlist.log' == filename then
		dl_res_pic(filename);
	end
	-- in Android, fopen cannot read file in resource because resource is in apk
	-- so must unzip the apk first
	--local fullpath = util.get_fullpath(F_PIC, 'card0.png');
	--local md5 = MD5Checksum:GetMD5(fullpath);
	--print('fullpath, md5: ', fullpath, md5);
	-- done
end

-- CMD lai
-- RET lai total [ai_info1] [ai_info2] ...
-- ai_info: eid, alias, icon, rating, exp, gold, present_card, level
function net_lai(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if nil == layer_solo.layer then return; end
	local total = check;
	local list_ai = {};
	local index = 3;
	for i = 1, total do
		local list = {};
		list.eid = tonumber(input_list[index]);
		index = index + 1;
		list.alias = input_list[index];
		index = index + 1;
		list.icon = input_list[index];
		index = index + 1;
		list.rating = tonumber(input_list[index]);
		index = index + 1;
		list.exp = tonumber(input_list[index]);
		index = index + 1;
		list.gold = tonumber(input_list[index]);
		index = index + 1;
		list.present_card = input_list[index];
		index = index + 1;
		list.level = tonumber(input_list[index]);
		index = index + 1;
		table.insert(list_ai, list);
	end
	layer_solo:add_list(list_ai);
	--util.trigger_tutor(TUTOR_SOLO);
	--util.upload_tutor();
end

-- CMD ldeck                  -- load all cards
-- RET ldeck [slot_id] [slot_name] [deck400] -- array mode
function net_ldeck(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local slot_id = check;
	local slot_name = input_list[3];
	local cards = input_list[4];
	g_euser.deck_str = cards;
	if g_scene:is_stage(STAGE_DECK) then
		--layer_deck.deck_sid = slot_id;
		local deck_array = c_str_array(cards);	
		layer_deck:set_deck_cards(deck_array, 1);
		layer_deck:change_to_slot(nil, slot_id, slot_name);
	end
end

-- CMD load_hero_deck
-- RET load_hero_deck hero_id slot_id hp energy deck
function net_load_hero_deck(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if not g_scene:is_stage(STAGE_MYDECK) then
		return;
	end
	local l = {};
	l.hero_id = check;
	l.slot_id = tonumber(input_list[3]);
	g_euser.hero_id = l.hero_id;
	g_euser.slot_id = l.slot_id;
	l.hp = tonumber(input_list[4]);
	l.energy = tonumber(input_list[5]);
	local deck = input_list[6];
	g_euser.deck_str = deck;
	l.deck_array = c_str_array(deck);	
	layer_mydeck:update_info(l);
end

-- CMD list_hero_slot hero_id
-- RET list_hero_slot hero_id slot_percent num_row slot_info ...
-- slot_info = slot_id card_count
function net_list_hero_slot(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if not g_scene:is_stage(STAGE_PICKDECK) then
		return;
	end
	local hero_id = check;
	local slot_percent = tonumber(input_list[3]);
	local num_row = tonumber(input_list[4]);
	local list = {};
	local index = 5;
	for i = 1, num_row do
		local l = {};
		l.slot_id = tonumber(input_list[index]);
		index = index + 1;
		l.card_count = tonumber(input_list[index]);
		index = index + 1;
		table.insert(list, l);
	end
	layer_pickdeck:add_list(hero_id, slot_percent, list);
	check_do_tutor_wait_net();
end

-- CMD get_hero_slot hero_id slot_id
-- RET get_hero_slot hero_id slot_id percent slot
function net_get_hero_slot(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local hero_id = check;
	local slot_id = tonumber(input_list[3]);
	local percent = tonumber(input_list[4]);
	local slot = input_list[5];
	local deck_array = c_str_array(slot);	
	if 0 == #(deck_array) then
		local hcard = hero_list[hero_id];
		if nil == hcard then
			show_err("错误英雄ID");
			return;
		end
		local hero_card = clone(hcard);
		local count = 1;
		table.insert(deck_array, { card = hero_card, count = count });
		local s1 = "";
		if hero_id > 1 then
			s1 = string.sub(slot, 1, hero_id-1);
		end
		local s2 = "";
		if hero_id < string.len(slot) then
			s2 = string.sub(slot, hero_id+1, string.len(slot));
		end
		slot = s1 .. count .. s2;
	end
	g_euser.deck_str = slot;
	if g_scene:is_stage(STAGE_DECK) then
		layer_deck:set_deck_cards(deck_array, 1);
		layer_deck:change_to_slot(nil, slot_id, slot_name);
		return;
	end
	if g_scene:is_stage(STAGE_SGDECK) then
		layer_sgdeck:set_list(deck_array, percent);
		local cmd = 'lcard ' .. CARD_ARRAY_LIST;
		net_send(cmd);
		return;
	end
end

-- CMD insert_hero_slot hero_id
-- RET insert_hero_slot hero_id slot_id
function net_insert_hero_slot(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if not g_scene:is_stage(STAGE_PICKDECK) then
		return;
	end
	local hero_id = check;
	local slot_id = tonumber(input_list[3]);
	--g_scene:pickdeck(hero_id);
	--g_scene:pickdeck();
	--[[
	local function cb()
		local cmd = string.format("get_hero_slot %d %d", hero_id, slot_id);
		net_send(cmd);
	end
	g_scene:go(GUI_DECK, "deck", { callback = cb });
	]]--
	g_scene:deck();
	local cmd = string.format("get_hero_slot %d %d", hero_id, slot_id);
	net_send(cmd, true);
end

-- CMD update_hero_slot hero_id slot_id slot
-- RET update_hero_slot hero_id slot_id
function net_update_hero_slot(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if not g_scene:is_stage(STAGE_DECK) then
		return;
	end
	local hero_id = check;
	local slot_id = tonumber(input_list[3]);
	g_scene:pickdeck();
	check_do_tutor_wait_net();
end

-- CMD choose_hero_slot hero_id slot_id
-- RET choose_hero_slot hero_id slot_id
function net_choose_hero_slot(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if not g_scene:is_stage(STAGE_PICKDECK) then
		return;
	end
	local hero_id = check;
	local slot_id = tonumber(input_list[3]);
	g_euser.hero_id = hero_id;
	g_euser.slot_id = slot_id;
	layer_pickdeck:reload();
end

-- CMD slotlist
-- RET slotlist [count] [slot_info1] [slot_info2] [slot_info3] ... 
-- [slot_info] = [slot_id] [slot_name]
function net_slotlist(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local count = check;
	local index = 3;
	local list = {};
	for i = 1, count do
		local l = {};
		l.tag = tonumber(input_list[index]);
		index = index + 1;
		l.title = input_list[index];
		index = index + 1;
		table.insert(list, l);
	end
	if g_scene:is_stage(STAGE_DECK) then
		layer_deck:set_slot_list(list);
	end
end

-- CMD lslot id
-- RET lslot [slot_id] [slot_name] [deck400]
function net_lslot(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local slot_id = check;
	local slot_name = input_list[3];
	local cards = input_list[4];
	local slot_array = c_str_array(cards);	
	if g_scene:is_stage(STAGE_DECK) then
		layer_deck:change_to_slot(slot_array, slot_id, slot_name);
	end
end

-- CMD rslot slot_id slot_name
-- RET rslot [slot_id] [slot_name]
function net_rslot(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	--[[
	local eid = check;
	local sid = tonumber(input_list[3]);
	local name = input_list[4];
	]]--
end

-- CMD bslot flag id
--     flag: ==0 get slot price; ==1 buy slot by gold; ==2 buy slot by crystal
--    if flag==0:
-- RET bslot [flag] [id] [gold] [crystal]
--    if flag == 1 or 2:
-- RET bslot [flag] [id] [gold] [crystal]
function net_bslot(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local flag = check;
	local sid = tonumber(input_list[3]);
	local gold = tonumber(input_list[4]);
	local crystal = tonumber(input_list[5]);
	if 0 == flag then
		if g_scene:is_stage(STAGE_DECK) then
			layer_deck:set_buy_slot_btn(sid, gold, crystal);
		end
		return;
	end
	if 1 == flag or 2 == flag then
		if g_scene:is_stage(STAGE_DECK) then
			show_msg('购买成功');
			if nil ~= layer_pick.layer then
				layer_pick:remove();
			end
			layer_deck:pick_deck();
		end
		return;
	end
end

-- CMD reg [username] [password] [platform] [channel] 
-- platform/channel is optional
-- RET reg [eid] [alias]
function net_reg(input_list, str, check)
	if check <= 0 then -- eid cannot be 0
		g_euser.username = '';
		show_err(str);
	else
		g_euser.eid = check;
		g_euser.alias = input_list[3];
		g_euser.level      = tonumber(input_list[4]);
		g_euser.exp        = tonumber(input_list[5]);
		g_euser.exp_next   = tonumber(input_list[6]);
		g_euser.exp_this   = tonumber(input_list[7]);
		g_euser.st = ST_NULL;
		-- send lcard , if return err, means did not pick hero
		if is_ver(VER_UCSDK) then
			uc_submit_data("RoleReg");
		end
		if is_ver(VER_LJSDK) then
			ljsdk_submit_data("createRole");
		end
		local cmd = 'lcard';
		net_send(cmd);
	end
end

-- CMD alias [alias]
-- RET alias 0 [alias] -- 0 means success
-- -16 alias:already_set
function net_alias(input_list, str, check)
	if check < 0 then 
		if -16 ~= check then
			g_euser.alias = '';
			show_err(str);
			return;
		end
	else
		g_euser.alias = input_list[3];
	end
	if g_scene:is_stage(STAGE_ROLE) then
		layer_role:pick_level();
	end
end

-- CMD ralias [type]
-- type: 0 for male, 1 for female
-- RET ralias [type] [alias]
function net_ralias(input_list, str, check)
	if check < 0 then 
		return;
	end
	if g_scene:is_stage(STAGE_ROLE) then
		local alias = input_list[3];
		layer_role:get_new_alias(alias);
	end
end

-- CMD job [hero_id] [level] -- 1 ~ 5 default 1
-- RET job [hero_id] [level]
function net_job(input_list, str, check)
	if check < 0 then
		show_err(str);
	else
		g_euser.hero_id = check;
		g_euser.game_level = tonumber(input_list[3]);

		--local cmd = 'lcard';
		--net_send(cmd);
		log_to_map();

		if is_ver(VER_LJSDK) then
			ljsdk_submit_data("createRole");
		end
	end
end

-- CMD ljob
-- RET ljob total hero_id1 hero_id2 ...
function net_ljob(input_list, str, check)
	if check < 0 then
		show_err(str);
	else
		local total = check;
		local list = {};
		local index = 3;
		for i = 1, total do
			local hid = tonumber(input_list[index]);
			index = index + 1;
			table.insert(list, hid);
		end
		if g_scene:is_stage(STAGE_ROLE) then
			layer_role:init_list(list);
		end
	end
end

-- CMD sprofile [icon] [sex] [signature]
-- RET sprofile [eid] [icon] [sex] [signature] 
function net_sprofile(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local eid = check;
	if eid ~= g_euser.eid then
		return;
	end
	g_euser.icon = input_list[3];
	g_euser.sex = tonumber(input_list[4]);
	local str = '';
	for i = 5, #input_list do
		str = str .. input_list[i];
		if i ~= #input_list then
			str = str .. ' ';
		end
	end
	g_euser.signature = str;
	if nil == layer_info.layer then
		return;
	end
	g_scene:add_layer(ZORDER_LAYER_INFO, layer_info:create(g_euser));
	if g_scene:is_stage(STAGE_MAP) then
		layer_map:update_info();
	end
end

-- CMD lreplay 
-- RET lreplay [eid] [total] [replay_info1] [replay_info2] .. 
-- replay_info: gameid, winner, version, eid1, eid2, lv1, lv2, icon1, icon2, alias1, alias2
function net_lreplay(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local eid = check;
	local total = tonumber(input_list[3]);
	local list_replay = {}
	local index = 4;
	for i = 1, total do
		local l = {};
		l.gameid = input_list[index];
		index = index + 1;
		local winner = tonumber(input_list[index]);
		index = index + 1;
		l.version = input_list[index];
		index = index + 1;
		local eid1 = tonumber(input_list[index]);
		index = index + 1;
		local eid2 = tonumber(input_list[index]);
		index = index + 1;
		local lv1 = tonumber(input_list[index]);
		index = index + 1;
		local lv2 = tonumber(input_list[index]);
		index = index + 1;
		local icon1 = input_list[index];
		index = index + 1;
		local icon2 = input_list[index];
		index = index + 1;
		local alias1 = input_list[index];
		index = index + 1;
		local alias2 = input_list[index];
		index = index + 1;
		local einfo = nil;
		if eid1 ~= eid then
			einfo = { eid = eid1, icon = icon1, alias = alias1, lv = lv1 };	
		else
			einfo = { eid = eid2, icon = icon2, alias = alias2, lv = lv2 };	
		end
		l.einfo = einfo;
		local is_win = false;
		if (1 == winner and eid1 == eid) or 
		   (2 == winner and eid2 == eid) then
			is_win = true;
		end
		l.is_win = is_win;
		table.insert(list_replay, l);
	end
	if nil ~= layer_info.layer then
		g_scene:add_layer(ZORDER_LAYER_VIDEO,layer_video:create(eid,list_replay));
	end
end

-- CMD replay gameid
-- RET replay [code] [gameid] [game_type] [winner] [star] [seed] [start_side] 
--            [ver] [eid1] [eid2]
--            [lv1] [lv2] [icon1] [icon2] [alias1] [alias2] 
--            [deck1] [deck2] [param] [cmd]
-- deck1 deck2 param are in nscan format
function net_replay(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local code = check .. '';
	local gameid = input_list[3];
	local game_type = tonumber(input_list[4]);
	local winner = tonumber(input_list[5]);
	local star = tonumber(input_list[6]);
	local seed = tonumber(input_list[7]);
	local start_side = tonumber(input_list[8]);
	local ver = tonumber(input_list[9]);
	local eid1 = tonumber(input_list[10]);
	local eid2 = tonumber(input_list[11]);
	local lv1 = tonumber(input_list[12]);
	local lv2 = tonumber(input_list[13]);
	local icon1 = input_list[14];
	local icon2 = input_list[15];
	local alias1 = input_list[16];
	local alias2 = input_list[17];

	local f1, f2 = string.find(str, code);
  	local tt = string.sub(str, f2+2, string.len(str));

	--local deck1 = input_list[16];
	--local deck2 = input_list[17];
	--[[
	local temp = '';
	for i = 1, 17 do
		temp = temp .. input_list[i] .. ' ';
	end
	local spos = string.len(temp) + 1;
	str = string.sub(str, spos);
	]]--
	local myside = SIDE_GUEST;
	if eid1 == g_euser.eid then
		myside = 1;
	elseif eid2 == g_euser.eid then
		myside = 2;
	end
	g_euser.room_data = {
		guest_list = {
			{ eid = eid1, alias = alias1, icon = 0, },
			{ eid = eid2, alias = alias2, icon = 0, },
		},
	};

	if true == DEBUG_MODE then
		-- set stage here is for set all hand card to front in init
		-- see in add_ui_card, when hand card init in layer_card
		g_scene.this_stage = STAGE_REPLAY;
		------------
	end
	--g_scene:replay(myside, seed, deck1, deck2);
	g_scene:replay(myside, seed, tt);
	--[[
	local list_cmd = csplit(str, ';');
	for i = 1, #(list_cmd or {}) do
		local cmd = list_cmd[i];
		local ilist = csplit(cmd, ' ');
		if 'fold' ~= ilist[2] and '@win' ~= ilist[2] then
			local len = string.len(ilist[1]);
			len = len + 2; -- one space and start from next one character
			cmd = string.sub(cmd, len);
			local eff_list = nil;
			local err = nil;
			push_cmd_list(cmd, { refresh_layer_card }, nil);
		end
	end
	check_cmd_finish();
	]]--
	local name;
	if 1 == winner then
		name = alias1;
	else
		name = alias2;
	end
	g_net_win_data = { name = name, is_replay = true };
end

-- CMD sdeck [slot_id] [deck400]
-- RET sdeck [slot_id]
function net_sdeck(input_list, str, check)
	if check < 0 then
		show_err(str);
		if g_scene:is_stage(STAGE_DECK) then
			if true == layer_deck.is_should_quit then
				layer_deck.is_should_quit = false;
			end
		end
		return;
	end
	show_msg(t_lang("SAVE_SUCCESS"));
	-- check == 0 means ok
	if g_scene:is_stage(STAGE_DECK) then
		if true == layer_deck.is_should_quit then
			layer_deck.callback_return(0);
			return;
		end
		--g_scene:go(GUI_DECK, "deck");
		g_scene:deck();
	end
end

-- only server send to client
-- RET quickmsg msg
function net_quickmsg(input_list, str, check)
	if nil ~= layer_quick.layer then return; end
	local msg = input_list[2];
	local function cb()
		show_quick();
	end
	g_scene:add_layer(ZORDER_LAYER_MSG, layer_msg:create(msg, cb, nil, true));
end

-- CMD quick 9(optional)
-- RET quick flag [max_wait_time]
-- flag : 0 ok
--        9 cancel quick ok
function net_quick(input_list, str, check)
	if check < 0 then
		show_err(str);
		layer_quick:remove();
		return;
	end
	if nil == layer_quick.layer then return; end
	if 0 == check then
		local time = tonumber(input_list[3]);
		layer_quick:start_waiting(time);
	elseif 9 == check then
		layer_quick:stop_waiting();
	end
end

-- CMD leave
-- RET leave [eid] [st]
-- for leaver , st == ST_LOGIN
-- for other  , st is the room.state, client should double check it
function net_leave(input_list, str, check)
	if check < 0 then
		show_err(str);
	else
		reset_win_data();
		local eid = check;
		local st = tonumber(input_list[3]);
		if eid == g_euser.eid then
			g_euser.st = st;
		else
			if nil ~= layer_room.layer then
				layer_room:hide_start(eid);
			end
			if nil ~= g_euser.room_data then
				local l = g_euser.room_data.guest_list or {};
				for i = 1, #l do
					local info = l[i];
					if eid == info.eid then
						table.remove(l, i);
						break;
					end
				end
			end
			
			return;
		end
		if not g_scene:is_stage(STAGE_MAP) then
			g_scene:map();
		end
	end
end

-- CMD lchan
-- RET lchan [channel[0].info] [channel[1].info] ...
-- where channel[x].info = channel_id, channel_title
function net_lchan(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if not g_scene:is_stage(STAGE_MAP) then return; end
	if nil == layer_lroom.layer then return; end
	local list = {};
	local index = 2;
	while nil ~= input_list[index] do
		local cid = tonumber(input_list[index]);
		local ctitle = input_list[index+1];
		local l = { cid = cid, title = ctitle };
		table.insert(list, l);
		index = index + 2;
	end
	--[[
	for i = 1, #list do
		local info = list[i];
		if '2' == info.id then
			table.remove(list, 3);
			table.insert(list, 1, info);
			break;
		end
	end
	]]--
	layer_lroom:set_list_channel(list);
end

-- CMD lroom [channel] [room_type] 
-- RET lrrom [channel] [room[0].info] [room[1].info] ...
-- where room[x].info = chan_id, room_id, num_guest, pwd_flag, room_title
-- pwd_flag 0==no password, 1==has password
-- channel == 9: for all channel
-- room_type == 0: all room
--           == 1: free room
--           == 2: play room
function net_lroom(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local channel = check;
	local list = {};
	local index = 3;
	while nil ~= input_list[index] do
		local l = {};
		l.cid = input_list[index]; -- channel id
		index = index + 1;
		l.id = input_list[index]; -- room id
		index = index + 1;
		l.num_guest = tonumber(input_list[index]);
		index = index + 1;
		l.pwd_flag = tonumber(input_list[index]);
		index = index + 1;
		l.title = input_list[index];
		index = index + 1;
		l.channel = channel;
		table.insert(list, l);
	end
	if nil ~= layer_lroom.layer then
		layer_lroom:refresh_list(channel, list);
		return;
	end
	if nil ~= layer_lwait.layer then
		layer_lwait:refresh_list(channel, list);
		return;
	end
end

function g_list_check_exist(list, id)
	list = list or {};
	for i = 1, #list do
		local info = list[i];
		local cid = info.cid;
		if cid == id then
			return true;
		end
	end
	return false;
end
-- CMD shop [card_id] [size]
-- RET shop [count] loop( [card_id] [card_buy_gold] [card_sell_gold] [card_buy_crystal] [card_sell_crystal] [piece_buy_gold] [piece_sell_gold] [piece_buy_crystal] [piece_sell_crystal]  )
-- RET shop [err_code] [err_msg]
function net_shop(input_list, str, check)
	if check < 0 then
		show_err(str);
	else
		local count = check;
		local list = {};
		local last_id = -1;
		local index = 3;
		for i = 1, count do
			local l = {};
			l.cid = tonumber(input_list[index]);
			if i == count then
				last_id = l.cid;
			end
			index = index + 1;
			l.c_buygold = tonumber(input_list[index]);
			index = index + 1;
			l.c_sellgold = tonumber(input_list[index]);
			index = index + 1;
			l.c_buycrystal = tonumber(input_list[index]);
			index = index + 1;
			l.c_sellcrystal = tonumber(input_list[index]);
			index = index + 1;
			l.p_buygold = tonumber(input_list[index]);
			index = index + 1;
			l.p_sellgold = tonumber(input_list[index]);
			index = index + 1;
			l.p_buycrystal = tonumber(input_list[index]);
			index = index + 1;
			l.p_sellcrystal = tonumber(input_list[index]);
			index = index + 1;
			l.card = clone_card_by_id(l.cid);
			if nil ~= l.card then
				if true ~= SHOP_PAGE then
					if false == g_list_check_exist(g_list_shop, l.cid) then
						table.insert(list, l);
					end
				else
					table.insert(list, l);
				end
			end
		end
		for i = 1, #list do
			table.insert(g_list_shop, list[i]);
		end
		for i = 1, #g_list_shop do
			local d1 = g_list_shop[i];
			if d1.card.id > 20 then
				local c1 = d1.card.cost;
				for j = 1, i do
					local d2 = g_list_shop[j];
					if d2.card.id > 20 then
						local c2 = d2.card.cost;
						if c1 <= c2 then
							table.remove(g_list_shop, i);
							table.insert(g_list_shop, j, d1);
							break;
						end
					end
				end
			end
		end
		if true ~= SHOP_PAGE then
			g_list_shop.last_id = g_list_shop.last_id - 1;
			if 0 == count and 0 >= g_list_shop.last_id then
				if g_scene:is_stage(STAGE_SHOP) then
					--print(' shop list size: ', #g_list_shop);
					layer_shop:add_to_list(g_list_shop);
				elseif g_scene:is_stage(STAGE_DECK) and nil~=layer_book.layer then
					layer_book:add_to_list(g_list_shop);
				end
			end
		else
			if g_scene:is_stage(STAGE_SHOP) then
				layer_shop:add_to_list(list, last_id);
			end
		end
	end
end

-- card_type: 0 card, 1 piece
-- CMD buy [card_id] [card_type] [money_type] [buy_count]
-- RET buy [eid] [card_id] [card_type] [money_type] [buy_count] [gold_offset] [crystal_offset]
-- RET buy [err_code] [err_msg]
-- fyi: money_type 0--gold 1--crystal
function net_buy(input_list, str, check)
	if check < 0 then
		show_err(str);
	else
		local eid = check;
		local card_id = tonumber(input_list[3]);
		local card_type = tonumber(input_list[4]);
		local money_type = tonumber(input_list[5]);
		local buy_count = tonumber(input_list[6]);
		local gold_offset = tonumber(input_list[7]);
		local crystal_offset = tonumber(input_list[8]);
		g_euser.gold = g_euser.gold + gold_offset;
		g_euser.crystal = g_euser.crystal + crystal_offset;
		if g_scene:is_stage(STAGE_SHOP) then
			--net_send('lcard');
			layer_infobar:update_info();
			layer_shop:update_my_cards(card_id, buy_count);
			layer_shop:update_pop_card_count(card_id, buy_count);
			--layer_shoppop:update_count();
		end
		show_msg('买入成功');
	end
end

-- CMD sell [card_id] [card_type] [money_type] [sell_count]
-- RET sell [eid] [card_id] [card_type] [money_type] [sell_count] [gold_offset] [crystal_offset]
-- RET sell [err_code] [err_msg]
-- fyi: money_type 0--gold 1--crystal
function net_sell(input_list, str, check)
	if check < 0 then
		show_err(str);
	else
		local eid = check;
		local card_id = tonumber(input_list[3]);
		local card_type = tonumber(input_list[4]);
		local money_type = tonumber(input_list[5]);
		local sell_count = tonumber(input_list[6]);
		local gold_offset = tonumber(input_list[7]);
		local crystal_offset = tonumber(input_list[8]);
		g_euser.gold = g_euser.gold + gold_offset;
		g_euser.crystal = g_euser.crystal + crystal_offset;
		if g_scene:is_stage(STAGE_SHOP) then
			net_send('lcard');
			layer_infobar:update_info();
			layer_shop:update_my_cards(card_id, -sell_count);
			layer_shoppop:update_count();
		end
		show_msg('卖出成功');
	end
end

-- CMD lpiece
-- RET lpiece eid piece_count_str
function net_lpiece(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if not g_scene:is_stage(STAGE_PIECE) then
		return;
	end
	local eid = check;
	local piece_count_str = input_list[3];
	local list = c2_str_array(piece_count_str);
	layer_piece:update_all_piece(list);
	if true == util.trigger_tutor(TUTOR_PIECE_MERGE) then
		return;
	end
	check_do_tutor_wait_net();
end

-- CMD cpiece [start_card_id] [size]
-- RET cpiece [count] loop( [card_id] [merge_count] [gold] [crystal] )
function net_cpiece(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if not g_scene:is_stage(STAGE_PIECE) then
		return;
	end
	local eid = check;
	local merge_count_str = input_list[3];
	local list = c2_str_array(merge_count_str);
	g_list_piece = {};
	for i = 1, #list do
		local info = list[i];
		local l = {};
		l.card_id = info.cid;
		l.current_piece_count = 0;
		l.merge_count = info.count;
		--l.gold = 0;
		--l.crystal = 0;
		l.card = clone_card_by_id(l.card_id);
		if nil ~= l.card then
			if false == g_list_check_exist(g_list_piece, l.card_id) then
				table.insert(g_list_piece, l);
			end
		end
	end
	-- sort by cost
	for i = 1, #g_list_piece do
		local d1 = g_list_piece[i];
		if d1.card.id > 20 then
			local c1 = d1.card.cost;
			for j = 1, i do
				local d2 = g_list_piece[j];
				if d2.card.id > 20 then
					local c2 = d2.card.cost;
					if c1 <= c2 then
						table.remove(g_list_piece, i);
						table.insert(g_list_piece, j, d1);
						break;
					end
				end
			end
		end
	end
	layer_piece:add_to_list(g_list_piece);

	--[[
	local count = check;
	local list = {};
	local last_id = -1;
	local index = 3;
	for i = 1, count do
		local l = {};
		l.card_id = tonumber(input_list[index]);
		if i == count then
			last_id = l.card_id;
		end
		index = index + 1;
		--l.current_piece_count = tonumber(input_list[index]);
		--index = index + 1;
		l.current_piece_count = 0;
		l.merge_count = tonumber(input_list[index]);
		index = index + 1;
		l.gold = tonumber(input_list[index]);
		index = index + 1;
		l.crystal = tonumber(input_list[index]);
		index = index + 1;
		l.card = clone_card_by_id(l.card_id);
		if nil ~= l.card then
			if false == g_list_check_exist(g_list_piece, l.card_id) then
				table.insert(list, l);
			end
		end
	end
	for i = 1, #list do
		table.insert(g_list_piece, list[i]);
	end
	-- sort by cost
	for i = 1, #g_list_piece do
		local d1 = g_list_piece[i];
		if d1.card.id > 20 then
			local c1 = d1.card.cost;
			for j = 1, i do
				local d2 = g_list_piece[j];
				if d2.card.id > 20 then
					local c2 = d2.card.cost;
					if c1 <= c2 then
						table.remove(g_list_piece, i);
						table.insert(g_list_piece, j, d1);
						break;
					end
				end
			end
		end
	end
	g_list_piece.last_id = g_list_piece.last_id - 1;
	if 0 == count and 0 >= g_list_piece.last_id then
		if g_scene:is_stage(STAGE_PIECE) then
			layer_piece:add_to_list(g_list_piece);
		end
	end
	]]--
end

-- CMD piece_chapter card_id
-- RET piece_chapter card_id count chapter_info1 ...
-- chapter_info = chapter_name chapter_id stage_id
function net_piece_chapter(input_list, str, check)
	if check < 0 then
		if -6 == check then
			return;
		end
		show_err(str);
		return;
	end
	local card_id = check;
	local count = tonumber(input_list[3]);
	local list = {};
	local index = 4;
	for i = 1, count do
		local l = {};
		l.chapter_name = input_list[index];
		index = index + 1;
		l.chapter_id = tonumber(input_list[index]);
		index = index + 1;
		l.stage_id = tonumber(input_list[index]);
		index = index + 1;
		table.insert(list, l);
	end
	if nil ~= layer_alert.layer then
		layer_alert:set_get_piece_tip(card_id, list);
		return;
	end
end

-- CMD mpiece card_id
-- RET mpiece eid card_id count gold crystal
function net_mpiece(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local eid = check;
	local card_id = tonumber(input_list[3]);
	local count = tonumber(input_list[4]);
	local gold = tonumber(input_list[5]);
	local crystal = tonumber(input_list[6]);
	g_euser.gold = g_euser.gold + gold;
	g_euser.crystal = g_euser.crystal + crystal;
	if not g_scene:is_stage(STAGE_PIECE) then
		return;
	end
	show_msg("合成成功");
	layer_infobar:update_info();
	layer_piece:update_piece(card_id, count);
	check_do_tutor_wait_net();
end

-- CMD daily_log
-- RET daily_log continus_log_day has_get_reward day1_reward_info .. day7_reward..
-- day(x)_reward_info: [day] [gold] [crystal] [card_list] [piece_list]
-- card_list: [card_count] [card_id1] [card_id2] ...
-- piece_list: [list_count] [piece_info1] [piece_info2] ...
-- piece_info: [piece_id] [piece_count]
function net_daily_log(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if nil == layer_daily.layer then return; end
	local data = {};
	data.log_day = check;
	data.has_get_reward = tonumber(input_list[3]);
	data.day_info = {};
	local index = 4;
	for i = 1, 7 do
		local l = {};
		l.day = tonumber(input_list[index]);
		index = index + 1;
		l.gold = tonumber(input_list[index]);
		index = index + 1;
		l.crystal = tonumber(input_list[index]);
		index = index + 1;
		l.clist = {};
		local card_count = tonumber(input_list[index]);
		index = index + 1;
		for j = 1, card_count do
			local card_id = tonumber(input_list[index]);
			index = index + 1;
			table.insert(l.clist, { cid = card_id, is_piece = false });
		end
		local piece_count = tonumber(input_list[index]);
		index = index + 1;
		for j = 1, piece_count do
			local piece_id = tonumber(input_list[index]);
			index = index + 1;
			local piece_count = tonumber(input_list[index]);
			index = index + 1;
			table.insert(l.clist,{cid = piece_id, piece_count = piece_count, is_piece = true});
		end
		table.insert(data.day_info, l);
	end
	layer_daily:set_data(data);
end

-- CMD daily_reward day
-- RET daily_reward day gold crystal card_list piece_list
-- card_list: [card_count] [card_id1] [card_id2] ...
-- piece_list: [list_count] [piece_info1] [piece_info2] ...
-- piece_info: [piece_id] [piece_count]
function net_daily_reward(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if nil == layer_daily.layer then return; end
	local data = {};
	data.day = check;
	data.gold = tonumber(input_list[3]);
	data.crystal = tonumber(input_list[4]);
	g_euser.gold = g_euser.gold + data.gold;
	g_euser.crystal = g_euser.crystal + data.crystal;
	layer_infobar:update_info();
	local index = 5;
	local card_count = tonumber(input_list[index]);
	index = index + 1;
	data.clist = {};
	for j = 1, card_count do
		local card_id = tonumber(input_list[index]);
		index = index + 1;
		table.insert(data.clist, { cid = card_id, is_piece = false });
	end
	local piece_count = tonumber(input_list[index]);
	index = index + 1;
	for j = 1, piece_count do
		local piece_id = tonumber(input_list[index]);
		index = index + 1;
		local piece_count = tonumber(input_list[index]);
		index = index + 1;
		table.insert(data.clist,{cid=piece_id,piece_count=piece_count,is_piece = true});
	end
	show_msg("领取成功");
	layer_daily:cb_get_reward(data);
end

-- CMD pshop
-- RET pshop remain_time cost_gold refresh_gold piece_info1 ... piece_info6
-- piece_info: [piece_id] [piece_count] [gold] [crystal]
-- piece_count: if < 0, means this piece has already buy.
-- gold/crystal: both == 0, means this piece should only buy by vip.
function net_pshop(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if not g_scene:is_stage(STAGE_MYSTERY) then return; end
	local data = {};
	data.remain_time = check;
	data.cost_gold = tonumber(input_list[3]);
	g_euser.gold = g_euser.gold + data.cost_gold;
	layer_infobar:update_info();
	data.refresh_gold = tonumber(input_list[4]);
	data.list = {};
	local index = 5;
	for i = 1, 6 do
		local l = {};
		l.piece_id = tonumber(input_list[index]);
		index = index + 1;
		l.piece_count = tonumber(input_list[index]);
		index = index + 1;
		l.gold = tonumber(input_list[index]);
		index = index + 1;
		l.crystal = tonumber(input_list[index]);
		index = index + 1;
		table.insert(data.list, l);
	end
	layer_mystery:set_data(data);
end
--[[ -- same as pshop, so go to pshop
function net_rpshop(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
end
]]--

-- CMD lpshop
-- RET lpshop 0 card_deck400
function net_lpshop(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if not g_scene:is_stage(STAGE_MYSTERY) then return; end
	local deck = input_list[3];
	local list = c_str_array(deck);
	g_scene:add_layer(ZORDER_LAYER_PMYSTERY, layer_pmystery:create(list));
end

-- CMD pbuy pos
-- RET pbuy pos card_id count gold crystal
function net_pbuy(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local pos = check;
	local card_id = tonumber(input_list[3]);
	local count = tonumber(input_list[4]);
	local gold = tonumber(input_list[5]);
	local crystal = tonumber(input_list[6]);
	g_euser.gold = g_euser.gold + gold;
	g_euser.crystal = g_euser.crystal + crystal;
	layer_infobar:update_info();
	if g_scene:is_stage(STAGE_MYSTERY) then
		if nil ~= layer_mispop.layer then
			layer_mispop:remove();
		end
		layer_mystery:cb_buy(pos);
		show_msg("购买成功");
	end
end

-- CMD moneyexchange crystal
-- RET moneyexchange gold_offset crystal_offset
function net_moneyexchange(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local gold_offset = check;
	local crystal_offset = tonumber(input_list[3]);
	g_euser.gold = g_euser.gold + gold_offset;
	g_euser.crystal = g_euser.crystal + crystal_offset;
	layer_infobar:update_info();
	show_msg("兑换成功");
end

-- CMD ladder ladder_type
-- RET ladder ladder_type total [info1] [info2] ...
-- info:
--    LADDER_RATING  --> [eid] [rank] [rating] [alias] [icon]
--    LADDER_LEVEL   --> [eid] [rank] [level]  [alias] [icon]
--    LADDER_GUILD   --> [gid] [rank] [level]  [gname] [icon]
--    LADDER_COLLECT --> [eid] [rank] [count]  [gname] [icon]
--    LADDER_GOLD    --> [eid] [rank] [gold]   [gname] [icon]
--    LADDER_CHAPTER --> eid rank chapter_id stage_id star_count name icon
-- last info is self info, e.g: total 11, so 11 is mine, check eid
function net_ladder(input_list, str, check)
	if check < 0 then
		show_err(str);
		if g_scene:is_stage(STAGE_RANK) then
			layer_rank:set_list({});
		end
		return;
	end
	local ladder_type = check;
	local list_ladder = {};
	local total = tonumber(input_list[3]);
	local index = 4;
	for i = 1, total do
		local info = {};
		--table.insert(info, tonumber(input_list[index])); -- eid or gid
		info.info_id = tonumber(input_list[index]); -- eid or gid
		index = index + 1;
		info.rank = tonumber(input_list[index]); -- rank
		index = index + 1;

		if ladder_type == LADDER_CHAPTER then
			info.chapter_id = tonumber(input_list[index]);
			index = index + 1;
			info.stage_id = tonumber(input_list[index]);
			index = index + 1;
			info.star_count = tonumber(input_list[index]);
			index = index + 1;
			info.name = input_list[index];
			index = index + 1;
			info.icon = tonumber(input_list[index]);
			index = index + 1;
		else
			info.point = tonumber(input_list[index]); --rating,level,count,gold
			index = index + 1;
			info.name = input_list[index]; -- alias or gname
			index = index + 1;
			info.icon = tonumber(input_list[index]); -- icon
			index = index + 1;
		end
		info.ladder_type = ladder_type;
		table.insert(list_ladder, info);
	end
	if g_scene:is_stage(STAGE_RANK) then
		layer_rank:set_list(list_ladder);
	end
end

-- CMD notice type
-- if 0 == type
-- RET notice type count title1 title2 title3 ...
-- if 0 < type
-- RET notice type title
function net_notice(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if nil == layer_notice.layer then return; end
	if 0 == check then
		local count = tonumber(input_list[3]);
		local list = {};
		local index = 4;
		for i = 1, count do
			local title = input_list[index];
			if not is_ver(VER_UCSDK) or string.find(title, "Q群") == nil then
				table.insert(list, { t = i, title = title });
			end
			index = index + 1;
		end
		layer_notice:add_list(list);
		return;
	end
	-- 0 < check
	local detail = '';
	for i = 3, #input_list do
		detail = detail .. input_list[i];
		if i ~= #input_list then
			detail = detail .. ' ';
		end
	end
	--print(string.format("\nbefore[\n%s\n]", detail));
	detail = string.gsub(detail, "(^)", '\n');
	--print(string.format("\nafter[\n%s\n]", detail));
	layer_notice:set_detail(check, detail);
end

-- CMD flist start_num page_size optional_alias
-- RET flist eid total [friend_info1] [friend_info2] ...
-- friend_info: eid is_online alias icon
-- is_online: 0==offline  1==online
function net_flist(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if nil == layer_friend.layer then return; end
	local teid = check;
	if teid ~= g_euser.eid then return; end
	local list = {};
	local total = tonumber(input_list[3]);
	local start_num = tonumber(input_list[4]);
	local num_row = tonumber(input_list[5]);
	local index = 6;
	for i = 1, num_row do
		local l = {};
		l.eid = tonumber(input_list[index]);
		index = index + 1;
		l.is_online = tonumber(input_list[index]);
		index = index + 1;
		l.alias = input_list[index];
		index = index + 1;
		l.icon = input_list[index];
		index = index + 1;
		if 1 == l.is_online then
			table.insert(list, 1, l);
		else
			table.insert(list, l);
		end
	end
	layer_friend:add_list(list, 1, total, start_num);
end

-- CMD fsta eid
-- RET fsta eid alias lv rating gold crystal gid gpos count win lose draw run
--          icon exp sex friend_flag signature
-- friend_flag --> 0 not friend, 1 is friend
function net_fsta(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local info = {};
	info.eid = check;
	info.alias = input_list[3];
	info.level = tonumber(input_list[4]);
	info.rating = tonumber(input_list[5]);
	info.gold = tonumber(input_list[6]);
	info.crystal = tonumber(input_list[7]);
	info.gid = tonumber(input_list[8]);
	info.gpos = tonumber(input_list[9]);
	info.gname = input_list[10];
	info.game_count = tonumber(input_list[11]);
	info.win = tonumber(input_list[12]);
	info.lose = tonumber(input_list[13]);
	info.draw = tonumber(input_list[14]);
	info.run = tonumber(input_list[15]);
	info.icon = input_list[16];
	info.exp = tonumber(input_list[17]);
	info.exp_next = tonumber(input_list[18]);
	info.exp_this = tonumber(input_list[19]);
	info.sex = tonumber(input_list[20]);
	info.is_frd = tonumber(input_list[21]);
	info.signature = input_list[22];

	g_scene:add_layer(ZORDER_LAYER_INFO, layer_info:create(info));
end

-- CMD fsearch alias
-- RET fsearch total info1 info2 ...
-- info: eid, is_online, alias, icon, lv
-- is_online: 0==offline  1==online
function net_fsearch(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local total = check;
	local index = 3;
	local list = {};
	for i = 1, total do
		local l = {};
		l.eid = tonumber(input_list[index]);
		index = index + 1;
		l.is_online = tonumber(input_list[index]);
		index = index + 1;
		l.alias = input_list[index];
		index = index + 1;
		l.icon = input_list[index];
		index = index + 1;
		l.level = tonumber(input_list[index]);
		index = index + 1;
		table.insert(list, l);
	end
	if nil ~= layer_findfrd.layer then
		layer_findfrd:remove();
	end
	local layer, name = layer_sfriend:create(list);
	g_scene:add_layer(ZORDER_LAYER_SFRIEND, layer, name, true);
	--[[
	layer_findfrd:remove();
	layer_friend:remove();
	local layer, name = layer_friend:create();
	g_scene:add_layer(ZORDER_LAYER_FRIEND, layer, name, true);
	layer_friend:add_list(list, 2);
	]]--
end

-- CMD fadd friend_eid
-- RET fadd my_eid friend_eid
function net_fadd(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local eid = check;
	if eid == g_euser.eid then
		show_msg('添加成功');
		if nil ~= layer_sfriend.layer then
			layer_sfriend:remove();
		end
		if nil ~= layer_friend.layer then
			layer_friend:remove();
			get_friend_list();
			return;
		end
		if nil ~= layer_chatpop.layer then
			layer_chatpop:remove();
			return;
		end
		return;
	end
end

-- CMD fdel friend_eid
-- RET fdel my_eid friend_eid
function net_fdel(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local eid = check;
	--local feid = tonumber(input_list[
	if eid ~= g_euser.eid then
		return;
	end
	show_msg('删除成功');
	if nil ~= layer_friend.layer then
		layer_friend:remove();
		get_friend_list();
	end
end

-- CMD course
-- RET course eid course
function net_course(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local eid = check;
	if eid ~= g_euser.eid then
		return;
	end
	set_value_for_g_tutor(input_list[3]);
	g_tutor_change = nil;
	--[[
	if true == util.trigger_tutor(TUTOR_STORY) then
		return;
	end
	]]--

	if false == OLD_TUTOR then return; end
	if nil == layer_dragstory.layer and 5 == g_euser.level then
		local flag = util.trigger_tutor(TUTOR_PAY_AD);
		if true == flag then
			local btn = layer_chat.btn_mission;
			if nil ~= btn then
				local finger = btn:getChildByTag(TAG_MISSION_FINGER);
				if nil ~= finger then
					finger:removeFromParent(true);
				end
			end
		end
	end
end

-- CMD scourse
-- RET scourse eid course
function net_scourse(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local eid = check;
	if eid ~= g_euser.eid then
		return;
	end
	set_value_for_g_tutor(input_list[3]);
	g_tutor_change = nil;
		
end

-- CMD lpay pay_type
-- RET lpay pay_type count pay_info
-- pay_info = [pay_code] [pay_price] [money_type] [money] [title] [description]
-- pay_price: double, real rmb
-- pay_type 1:支付宝 2:快钱 3:app store 4:allinpay 6:anysdk 7:ucsdk
-- money_type 0:gold 1:crystal
function net_lpay(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if nil == layer_pay.layer then return; end
	local pay_type = check;
	local count = tonumber(input_list[3]) or 0;
	local list = {};
	index = 4;
	for i = 1, count do
		local l = {};
		l.pay_code = tonumber(input_list[index]) or 0;
		index = index + 1;
		l.pay_price = tonumber(input_list[index]) or 0;
		index = index + 1;
		l.money_type = tonumber(input_list[index]) or 0;
		index = index + 1;
		l.money = tonumber(input_list[index]) or 0;
		index = index + 1;
		l.title = input_list[index];
		index = index + 1;
		l.description = input_list[index];
		index = index + 1;
		if l.pay_price >= 600 or true == DEBUG_MODE then
			table.insert(list, l);
		end
	end
	layer_pay:add_list(pay_type, list);
	util.trigger_tutor(TUTOR_PAY);
end

-- RET @pay order_no player_id game_money_type game_money channel price
--          extra_gold extra_crystal monthly_end_date extra_card_list
-- extra_card_list: size card_data1 card_data2...
-- card_data: card_id card_count
-- game_money_type 0 gold 1 crystal
-- channel 1:支付宝 2:快钱 3:app store 4:allinpay
function net_atpay(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local order_no = input_list[2];
	local player_id = input_list[3];
	local game_money_type = input_list[4];
	local game_money = input_list[5];
	local channel = input_list[6];
	local price = input_list[7];
	local extra_gold = input_list[8];
	local extra_crystal = input_list[9];
	local monthly_end_date = input_list[10];
	local card_list_size = input_list[11];
	local list_card = {};
	local index = 12;
	for i = 1, card_list_size do
		local l = {};
		l.card_id = tonumber(input_list[index]);
		index = index + 1;
		l.count = tonumber(input_list[index]);
		index = index + 1;
		table.insert(list_card, l);
	end
	local nn = tonumber(game_money_type)==1 and '水晶' or '金币';
	local tip = string.format("充值 %d %s成功", tonumber(game_money), nn);
	local size = cc.size(wfix(505), hfix(302));--realsize
	if #input_list >= 10 then
		local extra_gold = tonumber(input_list[8]);
		local extra_crystal = tonumber(input_list[9]);
		local monthly_end_date = tonumber(input_list[10]);
		if g_euser.monthly_end_date < monthly_end_date then
			local end_time = os.date("*t", monthly_end_date);
			tip = tip .. string.format("\n获得至 %d 年 %d 月 %d 日的月卡特权"
			, end_time.year, end_time.month, end_time.day);
			g_euser.monthly_end_date = monthly_end_date;
		end
		if extra_gold > 0 or extra_crystal > 0 then
			size.height = size.height + hfix(26);
			tip = tip .. "\n\n首次充值,额外获得:";
			if extra_gold > 0 then
				tip = tip .. string.format("\n%d 金币", extra_gold);
				size.height = size.height + hfix(13);
			end
			if extra_crystal > 0 then
				tip = tip .. string.format("\n%d 水晶", extra_crystal);
				size.height = size.height + hfix(13);
			end
			-- TODO: hard code for first pay
			tip = tip .. "\n英雄 宙斯[1]";
			tip = tip .. "\n魔法 火球[4]";
			size.height = size.height + hfix(26);
		end
	end
	g_scene:add_layer(ZORDER_LAYER_MSG, layer_msg:create(tip, nil, size));
	net_send('sta', true);
end

-- CMD lguild [start_id] [page_size] [key]
-- start_id start from 0
-- RET lguild [start_id] [size] [g_info1] [g_info2]...
-- size <= page_size
-- g_info = gid total_member glevel gold crystal gname master_name
function net_lguild(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local start_id = check;
	local size = tonumber(input_list[3]);
	local index = 4;
	local list_guild = {};
	for i = 1, size do
		local l = {};
		l.gid = tonumber(input_list[index]);
		index = index + 1;
		l.total_member = tonumber(input_list[index]);
		index = index + 1;
		l.glevel = tonumber(input_list[index]);
		index = index + 1;
		l.gold = tonumber(input_list[index]);
		index = index + 1;
		l.crystal = tonumber(input_list[index]);
		index = index + 1;
		l.gname = input_list[index];
		index = index + 1;
		l.master_name = input_list[index];
		index = index + 1;
		table.insert(list_guild, l);
	end
	if g_scene:is_stage(STAGE_LGUILD) then
		layer_lguild:add_list(list_guild, start_id);
		return;
	end
end

-- CMD gapply [gid]
-- RET gapply [eid] [gid] [gpos] [gname]
function net_gapply(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local eid = check;
	local gid = tonumber(input_list[3]);
	local gpos = tonumber(input_list[4]);
	local gname = input_list[5];
	if eid == g_euser.eid then
		g_euser.gid = gid;
		g_euser.gpos = gpos;
		g_euser.gname = gname;
	end
	if g_scene:is_stage(STAGE_LGUILD) then
		layer_lguild:reload_data();
		return;
	end
end

-- CMD gquit [eid_optional:for_kick]
-- for normal quit: just quit
-- for master kick member: gquit [member_eid]
-- RET gquit [eid]
function net_gquit(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local eid = check;
	if eid == g_euser.eid then
		g_euser.gid = 0;
		g_euser.gpos = GUILD_POS_NONE;
		g_euser.gname = get_guild_name();
		g_euser.guild_data = nil;
		show_msg("你被踢出公会了");
		if g_scene:is_stage(STAGE_LGUILD) then
			g_scene:lguild();
		elseif g_scene:is_stage(STAGE_GUILD) or g_scene:is_stage(STAGE_WELFARE) 
		 or g_scene:is_stage(STAGE_LMEMBER) or g_scene:is_stage(STAGE_LSTOCK) then
			g_scene:map();
		end
	end
	if g_scene:is_stage(STAGE_LMEMBER) then
		layer_lmember:remove_member(eid);
		return;
	end
	if g_scene:is_stage(STAGE_LAPPLY) then
		layer_lapply:remove_apply(eid);
		return;
	end
end

-- CMD cguild
-- RET cguild 0 [create_guild_gold] [create_guild_crystal]
-- CMD cguild [gname]
-- RET cguild [gid] [gname]
function net_cguild(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if 0 == check then
		local gold = tonumber(input_list[3]);
		local crystal = tonumber(input_list[4]);
		scene:add_layer(ZORDER_LAYER_CGUILD, layer_cguild:create(gold, crystal));
		return;
	end
	local gid = check;
	local gname = input_list[3];
	g_euser.gid = gid;
	g_euser.gpos = GUILD_POS_MASTER;
	g_euser.gname = gname;
	if g_scene:is_stage(STAGE_LGUILD) then
		net_send('guild');
		return;
	end
end

-- CMD guild [gid_optional] [notice_optional]
-- note: empty gid means my guild
-- RET guild gid total_member max_member glevel gold crystal consume master_alias 
--     master_icon gname notice
function net_guild(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local l = {};
	l.gid = check;
	l.total_member = tonumber(input_list[3]);
	l.max_member = tonumber(input_list[4]);
	l.glevel = tonumber(input_list[5]);
	l.gold = tonumber(input_list[6]);
	l.crytal = tonumber(input_list[7]);
	l.consume = tonumber(input_list[8]);
	l.master_alias = input_list[9];
	l.master_icon = input_list[10];
	l.gname = input_list[11];
	l.notice = input_list[12];
	g_scene:guild(l);
end

-- CMD gbonus [get_flag]
-- get_flag==0 means only check, but not really get the bonus
-- get_flag==1 means get bonus
-- RET gbonus eid check_flag guild_gold rate gshare bonus_gold 
--     last_bonus_time(sec)
-- e.g. guild_gold=10000 rate=0.05(5%) gshare=0.1(10%) so bonus_gold=50(int)
-- ERR gbonus -6 already_get_bonus
function net_gbonus(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local eid = check;
	if eid ~= g_euser.eid then
		return;
	end
	local l = {};
	l.check_flag = tonumber(input_list[3]);
	l.guild_gold = tonumber(input_list[4]);
	l.rate = tonumber(input_list[5]);
	l.gshare = tonumber(input_list[6]);
	l.bonus_gold = tonumber(input_list[7]);
	l.last_bonus_time = tonumber(input_list[8]);
	if g_scene:is_stage(STAGE_WELFARE) then
		layer_welfare:set_data(l);
	end
end

-- CMD glv [gid_optional]
-- RET glv gid current_level current_gold current_member_max current_consume_gold
--     next_level levelup_gold next_member_max next_consume_gold
function net_glv(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if not g_scene:is_stage(STAGE_GUILD) then
		return;
	end
	local l = {};
	l.gid = check;
	l.current_lv = tonumber(input_list[3]);
	l.current_gold = tonumber(input_list[4]);
	l.current_mb_max = tonumber(input_list[5]);
	l.current_cs_gold = tonumber(input_list[6]);
	l.next_lv = tonumber(input_list[7]);
	l.levelup_gold = tonumber(input_list[8]);
	l.next_mb_max = tonumber(input_list[9]);
	l.next_cs_gold = tonumber(input_list[10]);
	--local tip = string.format("升到%d级(人数上限[%d],每日消耗[%d])需要%d金币,确定升级?", next_lv, next_mb_max, next_cs_gold, levelup_gold);
	layer_guild:ask_levelup_guild(l);
end

-- CMD glevelup
-- RET glevelup gid new_level gold_reduce(-negative) new_member_max new_consume
function net_glevelup(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local gid = check;
	local current_lv = tonumber(input_list[3]);
	local gold_reduce = tonumber(input_list[4]);
	local current_mb_max = tonumber(input_list[5]);
	local current_cs_gold = tonumber(input_list[6]);
	net_send('guild');
	show_msg('升级成功');
end

-- CMD dguild 
-- only master can do
-- RET dguild [gid]
function net_dguild(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local gid = check;
	if gid == g_euser.gid then
		g_euser.gid = 0;
		g_euser.gpos = GUILD_POS_NONE;
		g_euser.gname = get_guild_name();
		g_euser.guild_data = nil;
	end
	g_scene:lguild();
end

-- CMD glist [flag] [start_id] [page_size] [gid_optional]
-- flag: 0 = all member include apply
--       1 = all member without apply
--       9 = apply
-- optional: gid , to check other guild's list
-- RET glist [flag] [start_id] [total_member] [member_info1] [member_info2] ...
-- member_info: eid gpos alias icon rating last_login gshare level
function net_glist(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local flag = check;
	local start_id = tonumber(input_list[3]);
	local size = tonumber(input_list[4]);
	local index = 5;
	local list_member = {};
	for i = 1, size do
		local l = {};
		l.eid = tonumber(input_list[index]);
		index = index + 1;
		l.gpos = tonumber(input_list[index]);
		index = index + 1;
		l.alias = input_list[index];
		index = index + 1;
		l.icon = input_list[index];
		index = index + 1;
		l.rating = input_list[index];
		index = index + 1;
		l.last_login = tonumber(input_list[index]);
		index = index + 1;
		l.gshare = input_list[index];
		index = index + 1;
		l.level = tonumber(input_list[index]);
		index = index + 1;
		table.insert(list_member, l);
	end
	table.sort(list_member, function(a, b)
		return ((tonumber(a.gshare) or 0) > (tonumber(b.gshare) or 0));
	end);
	if g_scene:is_stage(STAGE_LMEMBER) then
		layer_lmember:add_list(list_member, start_id);
	elseif g_scene:is_stage(STAGE_LAPPLY) then
		layer_lapply:add_list(list_member, start_id);
	elseif g_scene:is_stage(STAGE_LSTOCK) then
		layer_lstock:add_list(list_member, start_id);
	end
end

-- CMD gsearch [flag] [start_id] [page_size] [search_data] [gid_optional]
-- flag: 0 = all member include apply
--       1 = all member without apply
--       9 = apply
-- optional: gid , to check other guild's list
-- search_data can be eid or alias
-- RET gsearch [flag] [start_id] [total_member] [member_info1] [member_info2] ...
-- member_info: eid gpos alias icon rating last_login gshare level
function net_gsearch(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local flag = check;
	local start_id = tonumber(input_list[3]);
	local size = tonumber(input_list[4]);
	local index = 5;
	local list_member = {};
	for i = 1, size do
		local l = {};
		l.eid = tonumber(input_list[index]);
		index = index + 1;
		l.gpos = tonumber(input_list[index]);
		index = index + 1;
		l.alias = input_list[index];
		index = index + 1;
		l.icon = input_list[index];
		index = index + 1;
		l.rating = input_list[index];
		index = index + 1;
		l.last_login = tonumber(input_list[index]);
		index = index + 1;
		l.gshare = input_list[index];
		index = index + 1;
		l.level = tonumber(input_list[index]);
		index = index + 1;
		table.insert(list_member, l);
	end
	table.sort(list_member, function(a, b)
		return ((tonumber(a.gshare) or 0) > (tonumber(b.gshare) or 0));
	end);
	if g_scene:is_stage(STAGE_LMEMBER) then
		layer_lmember:add_search_list(list_member, start_id);
	elseif g_scene:is_stage(STAGE_LAPPLY) then
		layer_lapply:add_search_list(list_member, start_id);
	elseif g_scene:is_stage(STAGE_LSTOCK) then
		layer_lstock:add_search_list(list_member, start_id);
	end
end

-- CMD gpos [gid] [pos]
-- pos = 1 is invalid
-- RET gpos [eid] [pos] [gid]
function net_gpos(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local eid = check;
	local pos = tonumber(input_list[3]);
	local gid = tonumber(input_list[4]);
	if eid == g_euser.eid then
		g_euser.gid = gid;
		g_euser.gpos = pos;
		if g_scene:is_stage(STAGE_LGUILD) then
			layer_lguild:reload_data();
			net_send('guild');
			return;
		end
	end
	if g_scene:is_stage(STAGE_LAPPLY) then
		layer_lapply:remove_apply(eid);
		return;
	end
	if g_scene:is_stage(STAGE_LMEMBER) then
		layer_lmember:update_pos(eid, pos);
		return;
	end
	--[[
	if g_scene:is_stage(g_scene.LPOS) then
		g_layer_lpos:update_pos(eid, pos);
		return;
	end
	]]--
end

-- CMD deposit 
-- RET deposit eid gid my_deposit_gold my_deposit_crystal gshare 
--     guild_deposit_gold guild_deposit_crystal
function net_deposit(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local eid = check;
	if eid ~= g_euser.eid then
		return;
	end
	local info = {};
	info.gid = tonumber(input_list[3]);
	info.my_gold = tonumber(input_list[4]);
	info.my_crystal = tonumber(input_list[5]);
	info.gshare = tonumber(input_list[6]);
	info.guild_gold = tonumber(input_list[7]);
	info.guild_crystal = tonumber(input_list[8]);
	if g_scene:is_stage(STAGE_INVEST) then
		layer_invest:set_data(info);
	end
end

-- CMD gdeposit gold
-- RET gdeposit eid gid gold
function net_gdeposit(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local eid = check;
	local gid = tonumber(input_list[3]);
	local gold = tonumber(input_list[4]);
	g_euser.gold = g_euser.gold - gold;
	if nil ~= g_euser.guild_data then
		g_euser.guild_data.gold = g_euser.guild_data.gold + gold;
	end
	if g_scene:is_stage(STAGE_INVEST) then
		layer_infobar:update_info();
		g_scene:invest();
		local str = string.format("成功捐献%d金币", gold);
		show_msg(str);
		return;
	end
end

-- CMD ldeposit start_id page_size
-- RET ldeposit start_id page_size [deposit_info1] [deposit_info2] ...
-- deposit_info = deposit_date eid alias icon gold crystal
function net_ldeposit(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if nil == layer_ldeposit.layer then return; end
	local start_id = check;
	local page_size = tonumber(input_list[3]);
	local index = 4;
	local list = {};
	for i = 1, page_size do
		local l = {};
		l.deposit_date = tonumber(input_list[index]);
		index = index + 1;
		l.eid = tonumber(input_list[index]);
		index = index + 1;
		l.alias = input_list[index];
		index = index + 1;
		l.icon = input_list[index];
		index = index + 1;
		l.gold = tonumber(input_list[index]);
		index = index + 1;
		l.crystal = tonumber(input_list[index]);
		index = index + 1;
		l.gpos = tonumber(input_list[index]);
		index = index + 1;
		table.insert(list, l);
	end
	layer_ldeposit:add_list(list, start_id);
end

-- CMD challenge type eid
-- RET challenge type flag eid alias
--  type == 0: challenge someone
--  type == 1: challenge cancel
--  type == 2: challenge accept
--  type == 3: challenge refuse
--  flag == 0:sender
--  flag == 1:receiver
function net_challenge(input_list, str, check)
	if check < 0 then
		if -36 == check then
			if nil ~= layer_fight.layer then
				layer_fight:remove();
			end
		end
		show_err(str);
		return;
	end
	local ctype = check;
	local flag = input_list[3];
	local eid = tonumber(input_list[4]);
	local alias = input_list[5];
	if 0 == ctype and '1' == flag then -- receiver
		pop_answer_fight(eid, alias);
	end
	if (1 == ctype or 2 == ctype or 3 == ctype) and '1' == flag then --receiver
		if nil ~= layer_fight.layer then
			layer_fight:remove();
		end
	end
end

-- mtype:  1=MISSION_LEVEL,  2=AI, 3=VS,  4=CHALLENGE,  5=BEI_CHALLENG
-- 6=REPLAY,  7=CHAT,  8=FRIEND,  9=SHOP,  10=CARD,  11=COLLECTION
-- 13=VIEW, 16=gate
-- status: 0=cannot accept, 1=accepted and not finish, 2=finished and not reward
-- 3=got reward
-- daily: 0=not show reset time, 1=show reset time
-- CMD mlist [mlist_type] [start_id]
-- if mlist_type == MLIST_CHAPTER
-- CMD mlist [mlist_type] [chapter_id] [start_id]
-- RET mlist [mlist_type] [start_id] [total] [mission1] [mission2] ...
-- if mlist_type == MLIST_CHAPTER
-- RET mlist [mlist_type] [chapter_id] [start_id] [total] [mission1] [mission2]...
-- mission = [mid] [status] [mtype] [n1] [p1] [p2] [p3] 
--           [exp] [gold] [crystal] [power] [card_count] [card_list]
--           [piece_count] [piece_list(id, count)]
--           [reward_card] [exp] 
--		     [gold] [crystal] 
--           [daily] [reset_time] [mtext]
-- start_id: ==0 first page
-- total: == 10, may has next page
function net_mlist(input_list, str, check)
	if check < 0 then
		return;
	end
	local mlist_type = check;
	local index = 3;
	local chapter_id = tonumber(input_list[index]);
	index = index + 1;
	local start_id = tonumber(input_list[index]);
	index = index + 1;
	local total = tonumber(input_list[index]);
	index = index + 1;
	local list = {};
	for i = 1, total do
		local l = {};
		l.mid = tonumber(input_list[index]);
		index = index + 1;
		l.status = tonumber(input_list[index]);
		index = index + 1;
		l.mtype = tonumber(input_list[index]);
		index = index + 1;
		l.n1 = tonumber(input_list[index]);
		index = index + 1;
		l.p1 = tonumber(input_list[index]);
		index = index + 1;
		l.p2 = tonumber(input_list[index]);
		index = index + 1;
		l.p3 = tonumber(input_list[index]);
		index = index + 1;
		l.exp = tonumber(input_list[index]);
		index = index + 1;
		l.gold = tonumber(input_list[index]);
		index = index + 1;
		l.crystal = tonumber(input_list[index]);
		index = index + 1;
		l.power = tonumber(input_list[index]);
		index = index + 1;
		local card_count = tonumber(input_list[index]);
		index = index + 1;
		l.clist = {};
		for j = 1, card_count do
			local card_id = tonumber(input_list[index]);
			index = index + 1;
			table.insert(l.clist, { cid = card_id, is_piece = false });
		end
		local piece_count = tonumber(input_list[index]);
		index = index + 1;
		for j = 1, piece_count do
			local card_id = tonumber(input_list[index]);
			index = index + 1;
			local piece_count = tonumber(input_list[index]);
			index = index + 1;
			table.insert(l.clist, {cid=card_id,piece_count=piece_count,is_piece=true});
		end
		l.daily = tonumber(input_list[index]);
		index = index + 1;
		l.reset_time = input_list[index];
		index = index + 1;
		local mtext = input_list[index];
		index = index + 1;
		mtext = string.gsub(mtext, "n1", l.n1);
		mtext = string.gsub(mtext, "p1", l.p1);
		mtext = string.gsub(mtext, "p2", l.p2);
		mtext = string.gsub(mtext, "p3", l.p3);
		local tl = csplit(mtext, "(^)");
		local tl2 = {};
		for i = 1, #tl do
			local m = tl[i];
			m = string.gsub(m, "_", ' ');
			table.insert(tl2, m);
		end
		local title = tl2[1] or '';
		local detail = '';
		for i = 2, #tl2 do
			m = tl2[i];
			detail = detail .. m;
			if i < #tl2 then
				detail = detail .. '\n';
			end
		end
		if 1 == l.daily then
			title = '(每日)' .. title;
		end
		l.title = title;
		l.detail = detail;
		if g_euser.level < 5 and 16 == l.mtype and l.mid > 100 then
			table.insert(list, 1, l);
		else
			table.insert(list, l);
		end
	end
	local has_more = false;
	if #list >= 10 then
		has_more = true;
	end
	if g_scene:is_stage(STAGE_CHAPTER) then
		layer_chapter:set_mlist(list);
		return;
	end
	if nil == layer_mission.layer then return; end
	layer_mission:add_list(list, has_more);
	check_do_tutor_wait_net();
	--[[
	if g_tutor_wait_net == show_tutor_do_mission then
		g_tutor_wait_net();
	end
	]]--
end

-- CMD mreward [mid]
-- RET mreward [mid] [reward_card] [reward_exp] [gold] [crystal] [lv_offset]
-- RET mreward [mid] [reward_exp] [gold] [crystal] [power] [lv_offset]
--             [card_count] [card_list] [piece_count] [piece_list]
-- card_list: id1, id2 ...
-- piece_list: id1, count1, id2, count2 ...
function net_mreward(input_list, str, check)
	if check < 0 then
		return;
	end
	local is_chapter = false;
	if g_scene:is_stage(STAGE_CHAPTER) then
		is_chapter = true;
		g_scene:chapter();
	end
	local mid = check;
	local exp_offset = tonumber(input_list[3]);
	local gold_offset = tonumber(input_list[4]);
	local crystal_offset = tonumber(input_list[5]);
	local power_offset = tonumber(input_list[6]);
	g_euser.exp = g_euser.exp + exp_offset;
	g_euser.gold = g_euser.gold + gold_offset;
	g_euser.crystal = g_euser.crystal + crystal_offset;
	g_euser.power = g_euser.power + power_offset;
	layer_infobar:update_info();
	local lv_offset = tonumber(input_list[7]);
	g_euser.level = g_euser.level + lv_offset;
	layer_map:update_info();
	local list = {};
	local index = 8;
	local count = tonumber(input_list[index]);
	index = index + 1;
	for i = 1, count do
		local cid = tonumber(input_list[index]);
		index = index + 1;
		table.insert(list, { card = clone_card_by_id(cid), is_piece = false });
	end
	count = tonumber(input_list[index]);
	index = index + 1;
	for i = 1, count do
		local cid = tonumber(input_list[index]);
		index = index + 1;
		local count = tonumber(input_list[index]);
		index = index + 1;
		table.insert(list, { card = clone_card_by_id(cid), piece_count = count, is_piece = true });
	end
	if #list > 0 then
		local info = list[1];
		local is_piece = info.is_piece;
		local card = info.card;
		local layer, name = layer_cardshow:create(list);
		local tip = "恭喜获得奖励！";
		util.add_labelttf(layer, tip, nil, 27, cc.p(HALF_WIDTH, FULL_HEIGHT), util.c4b_white, ANCHOR_CENTER_UP, 100, cc.size(FULL_WIDTH, 100), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
		g_scene:add_layer(ZORDER_LAYER_CARDSHOW, layer, name);
	end

	show_msg('领取成功');
	if true == is_chapter then
		return;
	end
	--net_send('sta', true);
	--if g_euser.level < 5 then
--		g_tutor_wait_net = show_tutor_do_mission;
--	end
	show_mission_list();
	check_do_tutor_wait_net();
	--net_send('course', true);
end

-- only server send to client
-- RET mchange [flag]
-- flag: 1 = has new mission
--       2 = has target ok mission
--       3 = has new mission and target ok mission
function net_mchange(input_list, str, check)
	if check < 0 then
		return;
	end
	local flag = check;
	g_mission_tip = flag;
	if g_scene:is_stage(STAGE_MAP) then
		layer_map:tip_btn_mission();

	end
end

-- CMD kick eid
-- RET kick eid room.state
function net_kick(input_list, str, check)
	if check < 0 then
		return;
	end
	local eid = check;
	local rstate = tonumber(input_list[3]);
	if nil ~= layer_room.layer then
		if eid == g_euser.eid then
			layer_room:remove();
			return;
		end
		layer_room:hide_start(eid);
	end
end

-- CMD match_cancel match_id
-- RET match_cancel match_id max_player current_player
function net_match_cancel(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local match_id = input_list[2];
	local max_player = tonumber(input_list[3]);
	local current_player = tonumber(input_list[4]);
	show_msg('退赛成功');
	if nil ~= layer_lmatch.layer then
		layer_lmatch:refresh_my_status(match_id, max_player, current_player);
	end
end

-- CMD player_data eid_option
-- RET player_data match_data round_date my_info oppo_info
-- match_data = match_id status round title max_player start_time MATCH_ROUND_TIME
-- 				MAX_DAILY_ROUND t1 t2 t3 t4 tn
-- player_info = eid round team_id win lose draw tid point alias icon
-- oppo_info and round_date may null if match.status == MATCH_STATUS_READY
-- match status
-- see in MATCH STATUS DEFINE
function net_player_data(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local index = 2
	local mdata = {}; -- match data
	mdata.match_id = input_list[index];
	index = index + 1;
	mdata.match_status = tonumber(input_list[index]);
	index = index + 1;
	mdata.round = tonumber(input_list[index]);
	index = index + 1;
	mdata.title = input_list[index];
	index = index + 1;
	mdata.max_player = tonumber(input_list[index]);
	index = index + 1;
	mdata.start_time = tonumber(input_list[index]);
	index = index + 1;
	mdata.match_round_time = tonumber(input_list[index]);
	index = index + 1;
	local max_daily_round = tonumber(input_list[index]);
	index = index + 1;
	local daily_info = {};
	for i = 1, max_daily_round do
		local t = tonumber(input_list[index]);
		index = index + 1;
		if t > 0 then
			table.insert(daily_info, t);
		end
	end
	mdata.daily_info = daily_info;

	local round_date = tonumber(input_list[index]);
	index = index + 1;

	local player_info = {};
	player_info.eid = tonumber(input_list[index]);
	index = index + 1;
	player_info.round = tonumber(input_list[index]);
	index = index + 1;
	player_info.team_id = tonumber(input_list[index]);
	index = index + 1;
	player_info.win = tonumber(input_list[index]);
	index = index + 1;
	player_info.lose = tonumber(input_list[index]);
	index = index + 1;
	player_info.draw = tonumber(input_list[index]);
	index = index + 1;
	player_info.tid = tonumber(input_list[index]);
	index = index + 1;
	player_info.point = tonumber(input_list[index]);
	index = index + 1;
	player_info.icon = tonumber(input_list[index]);
	index = index + 1;
	player_info.alias = input_list[index];
	index = index + 1;

	local oppo_info = nil;
	if MATCH_STATUS_READY < mdata.match_status then 
		oppo_info = {};
		oppo_info.eid = tonumber(input_list[index]);
		index = index + 1;
		oppo_info.round = tonumber(input_list[index]);
		index = index + 1;
		oppo_info.team_id = tonumber(input_list[index]);
		index = index + 1;
		oppo_info.win = tonumber(input_list[index]);
		index = index + 1;
		oppo_info.lose = tonumber(input_list[index]);
		index = index + 1;
		oppo_info.draw = tonumber(input_list[index]);
		index = index + 1;
		oppo_info.tid = tonumber(input_list[index]);
		index = index + 1;
		oppo_info.point = tonumber(input_list[index]);
		index = index + 1;
		oppo_info.icon = tonumber(input_list[index]);
		index = index + 1;
		oppo_info.alias = input_list[index];
		index = index + 1;
	end
	local layer, name = layer_matchdata:create(mdata, player_info, oppo_info, round_date);
	g_scene:add_layer(ZORDER_LAYER_MATCHDATA, layer, name, true);
end

-- CMD arenatarget
-- RET arenatarget my_rank reward_gold reward_crystal buy_times_count 
--                 buy_times_crystal has_reward arena_times
--                 size arena_info1 ...
-- arena_info: rank eid icon lv win_rate alias
-- if 0==has_reward show arena_times
function net_arenatarget(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if not g_scene:is_stage(STAGE_PCLG) then return; end
	local data = {};
	data.rank = check;
	data.gold = tonumber(input_list[3]);
	data.crystal = tonumber(input_list[4]);
	data.buy_times_count = tonumber(input_list[5]);
	data.buy_times_crystal = tonumber(input_list[6]);
	data.has_reward = tonumber(input_list[7]);
	data.remain_time = tonumber(input_list[8]);
	data.arena_time = tonumber(input_list[9]); -- challenge times
	local row_num = tonumber(input_list[10]);
	local index = 11;
	data.list = {};
	for i = 1, row_num do
		local l = {};
		l.rank = tonumber(input_list[index]);
		index = index + 1;
		l.eid = tonumber(input_list[index]);
		index = index + 1;
		l.icon = input_list[index];
		index = index + 1;
		l.level = tonumber(input_list[index]);
		index = index + 1;
		l.rating = input_list[index];
		index = index + 1;
		l.alias = input_list[index];
		index = index + 1;
		table.insert(data.list, l);
	end
	layer_pclg:set_info(data);
end

-- CMD arenatop
-- RET arenatop my_rank size arena_info1 ...
-- arenatop = rank eid icon lv win_rate alias
function net_arenatop(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local my_rank = check;
	local row_num = tonumber(input_list[3]);
	local index = 4;
	local list = {};
	for i = 1, row_num do
		local l = {};
		l.rank = tonumber(input_list[index]);
		index = index + 1;
		l.info_id = tonumber(input_list[index]); -- eid
		index = index + 1;
		l.icon = input_list[index];
		index = index + 1;
		l.level = tonumber(input_list[index]);
		index = index + 1;
		l.rating = input_list[index];
		index = index + 1;
		l.name = input_list[index]; -- alias
		index = index + 1;
		l.ladder_type = LADDER_ARENA;
		table.insert(list, l);
	end
	table.insert(list, { rank = my_rank });
	if g_scene:is_stage(STAGE_RANK) then
		layer_rank:set_list(list);
	end
end

-- CMD arenagame eid_target
-- RET room ... //normal start a battle
function net_arenagame(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
end

-- CMD arenareward
-- RET arenareward rank gold crystal
function net_arenareward(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	show_pclg();
	local rank = check;
	local gold = tonumber(input_list[3]);
	local crystal = tonumber(input_list[4]);
	g_euser.gold = g_euser.gold + gold;
	g_euser.crystal = g_euser.crystal + crystal;
	layer_infobar:update_info();
end

-- CMD arenatimes
-- RET arenatimes ok times gold crystal
function net_arenatimes(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if not g_scene:is_stage(STAGE_PCLG) then return; end
	local times = tonumber(input_list[3]);
	local gold = tonumber(input_list[4]);
	local crystal = tonumber(input_list[5]);
	g_euser.gold = g_euser.gold + gold;
	g_euser.crystal = g_euser.crystal + crystal;
	layer_infobar:update_info();
	layer_pclg:update_ctime(times);
end

-- get to 50 ranking list
-- CMD rlist
-- RET rlist gold crystal remain_time rank challenge_time row_num info1 info2 ...
-- info = eid, rank, icon, rating, alias
function net_rlist(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local gold = check;
	local crystal = tonumber(input_list[3]);
	local remain_time = tonumber(input_list[4]);
	local rank = tonumber(input_list[5]);
	local challenge_time = tonumber(input_list[6]);
	local row_num = tonumber(input_list[7]);
	local index = 8;
	local list = {};
	for i = 1, row_num do
		local l = {};
		l.eid = tonumber(input_list[index]);
		index = index + 1;
		l.level = tonumber(input_list[index]);
		index = index + 1;
		l.rank = tonumber(input_list[index]);
		index = index + 1;
		l.icon = input_list[index];
		index = index + 1;
		l.rating = input_list[index];
		index = index + 1;
		l.alias = input_list[index];
		index = index + 1;
		table.insert(list, l);
	end
	layer_prank:show_rank(list, gold, crystal, remain_time, rank, challenge_time);
end

-- get rank target list could be challenged
-- CMD rtarlist
-- RET rtarlist gold crystal remain_time rank challenge_time row_num info1 info2 ...
-- info = eid, rank, icon, rating, alias
function net_rtarlist(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	-- deprecated --
	-- use arenatarget --
	--[[
	if not g_scene:is_stage(STAGE_PCLG) then return; end
	local data = {};
	data.gold = check;
	data.crystal = tonumber(input_list[3]);
	data.remain_time = tonumber(input_list[4]);
	data.rank = tonumber(input_list[5]);
	data.challenge_time = tonumber(input_list[6]);
	local row_num = tonumber(input_list[7]);
	local index = 8;
	data.list = {};
	for i = 1, row_num do
		local l = {};
		l.eid = tonumber(input_list[index]);
		index = index + 1;
		l.level = tonumber(input_list[index]);
		index = index + 1;
		l.rank = tonumber(input_list[index]);
		index = index + 1;
		l.icon = input_list[index];
		index = index + 1;
		l.rating = input_list[index];
		index = index + 1;
		l.alias = input_list[index];
		index = index + 1;
		table.insert(data.list, l);
	end
	layer_pclg:set_info(data);
	--layer_prank:show_challenge(list, gold, crystal, remain_time, rank, challenge_time);
	]]--
end

-- if everything normal and target is offline, will ret to room
-- RET: * if target player online
-- rgame [eid] [target_eid] [icon] [target_icon] [alias] [target_alias] [challenge_time]
-- >>> please show a dialog in client for player to send CMD rcancel for cancel the challenge
-- and target player will receive RET
-- rchallenge [eid] [icon] [alias]
-- >>> please show a count-down 10 second dialog in client for player to send CMD rresp for accept/refuse the challenge, after 10 second, auto close the dialog
-- * else
-- room ...    -- normally start a battle
-- @Notice if [target_eid] is not in target list, it will send back
-- rgame -1 rank_has_changed
-- please resend CMD: rtarlist to refresh target list
-- CMD rgame [target_eid] [target_rank]
-- RET rgame [eid] [target_eid] [target_icon] [target_alias] [time_left]
function net_rgame(input_list, str, check)
	if check < 0 then
		if -1 == check then
			g_scene:prank();
			return; 
		end
		show_err(str);
		return;
	end
	local target_eid = tonumber(input_list[3]);
	local target_alias = input_list[5];
	local time_left = tonumber(input_list[6]);
	local s = string.format("正向[%s]发出挑战，等待对方回应", target_alias);
	g_scene:add_layer(ZORDER_LAYER_PRANK_TIP,layer_prank_tip:create(s, layer_prank_tip.TYPE_WAIT, {eid=target_eid,time_left=time_left}));
end

-- RET rchallenge eid target_eid target_icon target_alias time_left
function net_rchallenge(input_list, str, check)
	if check < 0 then
		if -1 == check then
			g_scene:prank();
			return; 
		end
		show_err(str);
		return;
	end
	local target_eid = tonumber(input_list[3]);
	local target_icon = input_list[4];
	local target_alias = input_list[5];
	local time_left = tonumber(input_list[6]);
	local s = string.format("[%s]向你发出挑战", target_alias);
	g_scene:add_layer(ZORDER_LAYER_PRANK_TIP,layer_prank_tip:create(s, layer_prank_tip.TYPE_REPLY, {eid=target_eid,time_left=time_left}));
end

-- CMD rcancel target_eid
-- RET rcancel 0
function net_rcancel(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if nil ~= layer_prank_tip.layer then
		layer_prank_tip:remove();
	end
end

-- CMD rresp eid resp
-- RET if accept challenge ( resp = 1 )
--        room .. -- normally start battle
--     else
--        rgame_resp 0 ( resp = 0)
-- @Notice it will leave 10 second to accept to accept challenge, if overtime, challenger will auto enter a battle with ai, player be challenged need not send this cmd
function net_rresp(input_list, str, check)
	if nil ~= layer_prank_tip.layer then
		layer_prank_tip:remove();
	end
	if check < 0 then
		-- rresp -6 resp_ranking_game:not_be_challenged eid[1074
		if -6 == check then return; end
		show_err(str);
		return;
	end
end

-- CMD lhero
-- RET lhero count hero_id_1 ... hero_id_n ncount hero_id_1 ... hero_id_n
function net_lhero(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local list_has = {};
	local list_not = {};
	local index = 3;
	local count = check;
	for i = 1, count do
		local hid = tonumber(input_list[index]);
		local c = hero_list[hid];
		if nil ~= c then
			table.insert(list_has, { hid = hid, name = c.name });
		end
		index = index + 1;
	end
	count = tonumber(input_list[index]);
	index = index + 1;
	for i = 1, count do
		local hid = tonumber(input_list[index]);
		local c = hero_list[hid];
		if nil ~= c then
			table.insert(list_not, { hid = hid, name = c.name });
		end
		index = index + 1;
	end
	if nil ~= layer_hero.layer then
		layer_hero:add_list(list_has, list_not);
	end
end

-- CMD hero_mlist hero_id
-- RET hero_mlist hero_id hp energy count mission_info .. n
-- mission_info : m_id m_status mtype mission_n1 p1 p2 p3 reward_type 
--                reward_count mtext
-- reward_type : 1 hp    2 energy
function net_hero_mlist(input_list, str, check)
	if check < 0 then
		layer_hero.mark_cmd = nil;
		show_err(str);
		return;
	end
	local hinfo = {};
	hinfo.hid = check;
	hinfo.hp = tonumber(input_list[3]);
	hinfo.energy = tonumber(input_list[4]);
	local count = tonumber(input_list[5]);
	local index = 6;
	local list = {};
	hinfo.mlist = list;
	for i = 1, count do
		local l = {};
		l.mid = tonumber(input_list[index]);
		index = index + 1;
		l.status = tonumber(input_list[index]);
		index = index + 1;
		l.mtype = tonumber(input_list[index]);
		index = index + 1;
		l.n1 = tonumber(input_list[index]);
		index = index + 1;
		l.p1 = tonumber(input_list[index]); -- chapter and stage. e.g 108
		index = index + 1;
		l.p2 = tonumber(input_list[index]);
		index = index + 1;
		l.p3 = tonumber(input_list[index]);
		index = index + 1;
		l.reward_type = tonumber(input_list[index]);
		index = index + 1;
		l.reward_count = tonumber(input_list[index]);
		index = index + 1;
		local mtext = input_list[index];
		index = index + 1;
		mtext = string.gsub(mtext, "n1", 
							string.format("[color=00AA00]%d[/color]", l.n1));
		mtext = string.gsub(mtext, "p1", 
							string.format("[color=AA0000]%d[/color]", l.p1));
		mtext = string.gsub(mtext, "p2", 
							string.format("[color=AA0000]%d[/color]", l.p2));
		mtext = string.gsub(mtext, "p3", 
							string.format("[color=AA0000]%d[/color]", l.p3));
		--[[
		mtext = string.gsub(mtext, "n1", l.n1);
		mtext = string.gsub(mtext, "p1", l.p1);
		mtext = string.gsub(mtext, "p2", l.p2);
		mtext = string.gsub(mtext, "p3", l.p3);
		]]--
		local tl = csplit(mtext, "(^)");
		local tl2 = {};
		for i = 1, #tl do
			local m = tl[i];
			m = string.gsub(m, "_", ' ');
			table.insert(tl2, m);
		end
		local detail = '';
		for i = 1, #tl2 do
			m = tl2[i];
			detail = detail .. m;
			if i < #tl2 then
				detail = detail .. '\n';
			end
		end
		--detail = string.format("[color=FF0000]%s[/color]", detail);
		l.desc = detail;
		table.insert(list, l);
	end
	if g_scene:is_stage(STAGE_HERO) or nil ~= layer_result.layer then
		g_scene:add_layer(ZORDER_LAYER_HEROMISS, layer_heromiss:create(hinfo));
	end
end

-- CMD shero_mis hero_id mission_id
-- RET shero_mis hero_id mission_id hp energy
function net_shero_mis(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if not g_scene:is_stage(STAGE_HERO) then return; end
	if nil == layer_heromiss.layer then return; end
	local hero_id = check;
	local mission_id = tonumber(input_list[3]);
	local hp = tonumber(input_list[4]);
	local energy = tonumber(input_list[5]);
	--layer_heromiss:update_mission(hero_id, mission_id, hp, energy);
	layer_hero:show_hero_mlist(hero_id);
end

-- CMD list_message [start_num] [page_size]
-- RET list_message [eid] [start_num] [page_size] [total_message_num] [real_page_n     um] [message_info1] [message_info2] ...
-- message_info: [message_id] [send_eid] [send_alias] [time] [unread] [title]
-- unread: 1 == unread, 0 == readed
function net_list_message(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if nil == layer_mail.layer then return; end
	local eid = check;
	local start_num = tonumber(input_list[3]);
	local page_size = tonumber(input_list[4]);
	local total_message_num = tonumber(input_list[5]);
	local real_page_num = tonumber(input_list[6]);
	local list = {};
	local index = 7;
	for i = 1, real_page_num do
		local l = {};
		l.message_id = tonumber(input_list[index]);
		index = index + 1;
		l.send_id = tonumber(input_list[index]);
		index = index + 1;
		l.send_alias = input_list[index];
		index = index + 1;
		l.time = tonumber(input_list[index]);
		index = index + 1;
		l.read_flag = tonumber(input_list[index]);
		index = index + 1;
		l.title = input_list[index];
		index = index + 1;
		table.insert(list, l);
	end
	layer_mail:add_list(list, start_num, total_message_num);
end

-- CMD read_message [message_id]
-- RET read_message [eid] [message_id] [recv_eid] [send_eid] [send_alias] [time] [     unread] [title] [message]
function net_read_message(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local time = input_list[7];
	local title = input_list[9];
	local message = input_list[10];
	local t = os.date("*t", time);
	local str = string.format("%d年%02d月%02d日 %02d时%02d分%02d秒", t.year, t.month, t.day, t.hour, t.min, t.sec);
	message = string.format("收件时间:[%s]\n\n%s", str, message);
	layer_mail:delete_read_cell();
	g_scene:add_layer(ZORDER_LAYER_MAILTEXT,layer_mailtext:create(title,message));
end

-- CMD match_apply match_id
-- RET match_apply match_id max_player current_player
function net_match_apply(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local match_id = input_list[2];
	local max_player = tonumber(input_list[3]);
	local current_player = tonumber(input_list[4]);
	show_msg('参赛成功');
	if nil ~= layer_lmatch.layer then
		layer_lmatch:refresh_my_status(match_id, max_player, current_player,true);
	end
end

-- CMD @match_delete match_id
-- RET @match_delete match_id ok
function net_atmatch_delete(input_list, str, check)
	if check < 0 then
		return;
	end
	local match_id = check;
	show_msg('删除成功');
	if nil ~= layer_cmatch.layer then
		layer_cmatch:remove();
	end
end

-- CMD @match_add max_player start_date t1 t2 t3 t4 title
-- RET @match_add match_id
-- start_date = yyyyMMdd
-- t1, t2, t3, t4 = HHii
function net_atmatch_add(input_list, str, check)
	if check < 0 then
		return;
	end
	local match_id = check;
	show_msg('创建成功');
	if nil ~= layer_cmatch.layer then
		layer_cmatch:remove();
	end
end

-- CMD @match_init match_id
-- RET @match_add match_id ok
function net_atmatch_init(input_list, str, check)
	if check < 0 then
		return;
	end
	local match_id = check;
	show_msg('准备比赛成功');
end

-- CMD lmatch
-- RET lmatch [my_match_id] [match_count] [match_info]
-- match_info: match_id match_status round title max_player current_player
--             start_time match_round_time daily_info
-- my_match_id: the match which I took part in
-- start_time: yyyymmdd
-- match_round_time: sec
-- daily_info: max_daily_round t1 t2 ... tn (n=max_daily_round)
-- t1, t2 ... tn = time_t, base 1970-01-01, 0 <= ti < 24 * 60 * 60
-- match status
-- see in MATCH STATUS DEFINE
function net_lmatch(input_list, str, check)
	if check < 0 then
		return;
	end
	local my_match_id = input_list[2];
	local match_count = tonumber(input_list[3]);
	local list = {};
	local index = 4;
	for i = 1, match_count do
		local l = {};
		l.match_id = input_list[index];
		index = index + 1;
		l.match_status = tonumber(input_list[index]);
		index = index + 1;
		l.round = tonumber(input_list[index]);
		index = index + 1;
		l.title = input_list[index];
		index = index + 1;
		l.max_player = tonumber(input_list[index]);
		index = index + 1;
		l.current_player = tonumber(input_list[index]);
		index = index + 1;
		l.start_time = tonumber(input_list[index]);
		index = index + 1;
		l.match_round_time = tonumber(input_list[index]);
		index = index + 1;
		local daily_info = {};
		local max_daily_round = tonumber(input_list[index]);
		index = index + 1;
		for i = 1, max_daily_round do
			local t = tonumber(input_list[index]);
			index = index + 1;
			if t > 0 then
				table.insert(daily_info, t);
			end
		end
		l.daily_info = daily_info;
		table.insert(list, l);
	end
	layer_lmatch:add_list(list, my_match_id);
end


-- CMD: list_solo [solo_id]
-- RET: list_solo [solo_id] [num] [info1] [info2] ...
-- info: [id] [hero_id] [alias]
function net_list_solo(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if nil == layer_chapter.layer then return; end
	local solo_id	= tonumber(input_list[2]);
	local num		= tonumber(input_list[3]);
	local list		= {};
	local index		= 4;
	for i = 1, num do
		local info = {};
		info.id			= tonumber(input_list[index]);
		index			= index + 1;
		info.hero_id	= tonumber(input_list[index]);
		index			= index + 1;
		info.alias		= input_list[index];
		index			= index + 1;
		table.insert(list, info);
	end
	layer_chapter:add_list(list);
end

-- CMD lchapter
-- RET lchapter chapter_pos size chapter_info1 chapter_info2 ...
-- chapter_info: chapter_id, chapter_name
function net_lchapter(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local chapter_id = check;
	local size = tonumber(input_list[3]);
	if 0 == size then
		return;
	end
	local list = {};
	local index = 4;
	local markid = layer_chapter.last_chapter_id;
	-- when finish last stage in a chapter, won't go next chapter
	if nil ~= markid and true == layer_chapter.is_in_last_stage then
		markid = markid+1;
	end
	local has_cid = false;
	for i = 1, size do
		local l = {};
		l.chapter_id = tonumber(input_list[index]);
		index = index + 1;
		l.chapter_name = input_list[index];
		index = index + 1;
		table.insert(list, l);
		if l.chapter_id == markid then
			has_cid = true;
		end
	end
	if false == has_cid then
		markid = chapter_id;
	end
	layer_chapter.list_chapter = list;
	get_chapter_data(markid, true);
end

function get_chapter_data(cid, no_loading)
	layer_chapter.last_chapter_id = cid;
	net_send(string.format("chapter_data %d", cid), no_loading);
end

-- CMD chapter_data chapter_id
-- chapter_id 0 means get the current chapter that player process to
-- RET chapter chapter_id total_chapter_size chapter_name 
--             stage_size stage_info1 stage_info2 ... stage_data
-- chapter_id also means chapter_pos
-- stage_info: stage_id, stage_name
-- stage_data: 0999999 or 121309999  , the len is the stage_size
--             0,1,2,3==finish and star num, 8==not fight 9==lock
function net_chapter_data(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if nil == layer_chapter.layer then return; end
	local chapter_id = check;
	local total_chapter_size = tonumber(input_list[3]);
	local chapter_name = input_list[4];
	local stage_size = tonumber(input_list[5]);
	local list = {};
	local index = 6;
	for i = 1, stage_size do
		local l = {};
		l.stage_id = tonumber(input_list[index]);
		index = index + 1;
		table.insert(list, l);
	end
	local stage_data = input_list[index];
	if string.len(stage_data) == stage_size then
		for i = 1, #list do
			local l = list[i];
			local f = tonumber(string.sub(stage_data, i, i)) or 9;
			l.flag = f;
		end
	end
	--layer_chapter:set_title(chapter_id);
	layer_chapter:set_title(chapter_id, chapter_name, total_chapter_size);
	layer_chapter:set_list_tower(list);
	net_send(string.format("mlist %d %d 0", MLIST_CHAPTER, chapter_id), true);
end

-- CMD chapter_stage chapter_id stage_id
-- RET chapter_stage chapter_id stage_id stage_name stage_msg
--                   target_count target_info1 target_info2 ...
--                   exp power reward_count reward_info1 reward_info2 ...
--                   has_dialog dialog_1 ..
-- dialog: name, icon, side, dialog -- side_up 1 side_down 0
-- target_info: target_type p1 p2
-- CHAPTER_TARGET_MY_HERO_HP            1
-- CHAPTER_TARGET_ROUND                 2
-- CHAPTER_TARGET_WIN                   3
-- CHAPTER_TARGET_MY_ALLY               4
-- CHAPTER_TARGET_MY_SUPPORT            5
-- CHAPTER_TARGET_MY_ABILITY            6
-- CHAPTER_TARGET_MY_CARD               7
-- CHAPTER_TARGET_OPPO_ALLY             8
-- CHAPTER_TARGET_OPPO_SUPPORT          9
-- CHAPTER_TARGET_OPPO_ABILITY          10
-- CHAPTER_TARGET_OPPO_CARD             11
-- CHAPTER_TARGET_MY_GRAVE              = 12;
-- CHAPTER_TARGET_OPPO_GRAVE            = 13;
-- reward_info: reward_type reward_num
-- CHAPTER_REWARD_GOLD                  1
-- CHAPTER_REWARD_CRYSTAL               2
-- CHAPTER_REWARD_PIECE                 3
-- CHAPTER_REWARD_CARD                  4
-- CHAPTER_REWARD_EXP                   5
-- CHAPTER_REWARD_POWER                 6
-- see define in CHAPTER CONSTANT
function net_chapter_stage(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if nil == layer_chapter.layer then return; end
	local data = {};
	data.chapter_id = check;
	data.stage_id = tonumber(input_list[3]);
	data.stage_name = input_list[4];
	data.stage_msg = input_list[5];
	local list_target = {};
	data.list_target = list_target;
	local target_count = tonumber(input_list[6]);
	local index = 7;
	for i = 1, target_count do
		local l = {};
		l.target_type = tonumber(input_list[index]);
		index = index + 1;
		l.p1 = tonumber(input_list[index]);
		index = index + 1;
		l.p2 = tonumber(input_list[index]);
		index = index + 1;
		table.insert(list_target, l);
	end
	data.exp = tonumber(input_list[index]);
	index = index + 1;
	data.power = tonumber(input_list[index]);
	index = index + 1;
	local tip_count = tonumber(input_list[index]);
	index = index + 1;
	local list_tip = {};
	data.list_tip = list_tip;
	for i = 1, tip_count do
		local l = {};
		l.tip_card_id = tonumber(input_list[index]);
		index = index + 1;
		table.insert(list_tip, l);
	end
	local list_reward = {};
	data.list_reward = list_reward;
	local reward_count = tonumber(input_list[index]);
	index = index + 1;
	local has_rgold = false;
	local has_rcrystal = false;
	local has_rpower = false;
	local has_rexp = false;
	for i = 1, reward_count do
		local l = {};
		l.reward_type = tonumber(input_list[index]);
		index = index + 1;
		l.reward_num = tonumber(input_list[index]);
		index = index + 1;
		if l.reward_type == CHAPTER_REWARD_CRYSTAL then
			if false == has_rcrystal then
				has_rcrystal = true;
				table.insert(list_reward, l);
			end
		elseif l.reward_type == CHAPTER_REWARD_GOLD then 
			if false == has_rgold then
				has_rgold = true;
				table.insert(list_reward, l);
			end
		elseif l.reward_type == CHAPTER_REWARD_POWER then 
			if false == has_rpower then
				has_rpower = true;
				table.insert(list_reward, l);
			end
		elseif l.reward_type == CHAPTER_REWARD_EXP then 
			if false == has_rexp then
				has_rexp = true;
				table.insert(list_reward, l);
			end
		else
			table.insert(list_reward, l);
		end
	end
	local dialog_count = tonumber(input_list[index]);
	index = index + 1;
	local ldialog = {};
	for i = 1, dialog_count do
		local l = {};
		local ttt = input_list[index];
		index = index + 1;
		local ll = csplit(ttt, ':');
		l.name = util.replace_str(ll[1], '_0_', g_euser.alias);
		l.icon = tonumber(ll[2]);
		if 0 == l.icon then
			l.icon = g_euser.icon;
		end
		l.side = tonumber(ll[3]);
		l.dialog = util.replace_str(ll[4], '_0_', g_euser.alias);
		table.insert(ldialog, l);
	end
	g_scene:add_layer(ZORDER_LAYER_STAGE, layer_stage:create(data, ldialog));
	local function cb()
		check_do_tutor_wait_net();
	end
	if 0 == #ldialog then
		cb();
		return;
	end
	local pinfo = layer_chapter:get_select_info().data;
	if nil == pinfo then
		cb();
		return;
	end
	local flag = pinfo.flag;
	-- 0,1,2,3==finish and star num, 8==not fight 9==lock
	if flag >= 0 and flag <= 3 then
		cb();
		return;
	end
	tutor_show_dialog(ldialog, cb);
end

-- RET chapter_reward 0
-- means can get reward, client show choices
-- CMD chapter_reward
-- RET chapter_reward 1 chapter_id stage_id reward_type reward_num
-- reward_type:
-- CHAPTER_REWARD_GOLD          1
-- CHAPTER_REWARD_CRYSTAL       2
-- CHAPTER_REWARD_PIECE         3
-- CHAPTER_REWARD_CARD          4
-- CHAPTER_REWARD_EXP           5
-- CHAPTER_REWARD_POWER         6
-- reward_num maybe count or card_id depends on the reward_type
function net_chapter_reward(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	if 0 == check then
		--[[
		-- pop choice
		local chapter_id = tonumber(input_list[3]);
		local stage_id = tonumber(input_list[4]);
		local star = tonumber(input_list[5]);
		local msg = string.format("chapter_id[%d], stage_id[%d], star[%d]", chapter_id, stage_id, star);
		local index = 6;
		for i = 1, 3 do
			local data = {};
			data.target_type = tonumber(input_list[index]);
			index = index + 1;
			data.p1 = tonumber(input_list[index]);
			index = index + 1;
			data.p2 = tonumber(input_list[index]);
			index = index + 1;
			local value = tonumber(input_list[index]);
			index = index + 1;
			msg = string.format("%s\n%s", msg, layer_stage:get_target_msg(data));
			msg = string.format("%s[value=%d]", msg, value);
			if value > data.p1 and value > data.p2 then
				msg = string.format("%s完成", msg);
			else
				msg = string.format("%s未完成", msg);
			end
			--msg = string.format("%s\ntarget[%d],p1[%d],p2[%d],value[%d]", msg, t, p1, p2, value);
		end
		layer_table.chapter_reward_msg = msg;
		if nil ~= layer_result.layer and true ~= layer_result.is_set_chapter_msg then
			layer_result.need_open_chapter = true;
			layer_result.label_crm:setString(msg);
		end
		net_send('chapter_reward');
		]]--
		return;
	end
	if nil == layer_result.layer then return; end
	local chapter_id = tonumber(input_list[3]);
	local stage_id = tonumber(input_list[4]);
	local reward_type = tonumber(input_list[5]);
	local reward_num = tonumber(input_list[6]);
	local msg = string.format("chapter_id[%d], stage_id[%d], reward_type[%d], reward_num[%d]", chapter_id, stage_id, reward_type, reward_num);
	local pos = cc.p(0, FULL_HEIGHT);
	local size = cc.size(FULL_WIDTH, FULL_HEIGHT);
	util.add_labelttf(layer_result.layer, msg, nil, 25, pos, util.c4b_white, ANCHOR_LEFT_UP, 50, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_TOP); 
end

-- CMD chapter chapter_id stage_id
-- RET room ...
-- 'ginfo' return 'solo_plus
function net_chapter(input_list, str, check)
	if check < 0 then
		if -25 == check or -46 == check then
			show_msg("关卡未开放");
			return;
		elseif -6 == check then
			show_err("体力不足");
			return;
		end
		show_err(str);
		return;
	end
end

-- CMD: solo_plus [solo_id]
-- RET: room ...
-- CMD: ginfo
-- RET: solo_plus [side] [cmd_size] [seed] [timeout] [deck1] [solo_hero] [solo_type] [solo_max_ally] [solo_type_list] [c1] [c2] ... [cn]
-- RET: solo_plus [side] [cmd_size] [seed] [timeout]
--                [solo_type] [solo_max_ally] [solo_max_hp] 
--                [my_hero_hp] [my_hero_energy] [solo_type_list]
--                [card_len1] [deck1]
--                [card_len2] [deck2]
-- if card_len == 0, means deck is deck400
-- if card_len > 0, means deck is list deck [1 22 23 35 ...]
-- type_flag maybe 00, 01, 10, 11 ....
function net_solo_plus(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	data_handler:cleanup();
	local side			= check;
	local cmd_size		= tonumber(input_list[3]);
	local seed			= tonumber(input_list[4]);
	local timeout		= tonumber(input_list[5]);
	local solo_data			= {};
	solo_data.type_flag		= tonumber(input_list[6]);
	local f	= solo_data.type_flag;
	f = math.floor((f%100)/10); -- f 0 close, f 1 open
	solo_data.check_teach   = f;
	solo_data.max_ally		= tonumber(input_list[7]);
	solo_data.max_hp		= tonumber(input_list[8]);
	solo_data.myhero_hp		= tonumber(input_list[9]);
	solo_data.myhero_energy = tonumber(input_list[10]);
	solo_data.type_list		= input_list[11];
	local index = 12;
	local card_len1		= tonumber(input_list[index]);
	index = index + 1;
	local deck1 = "";
	if card_len1 > 0 then
		local len = index+card_len1-1;
		for i = index, len do
			deck1 = deck1 .. ' ' .. input_list[i];
			index = index+1;
		end
	else
		deck1 = input_list[index];
		index = index+1;
	end
	local card_len2		= tonumber(input_list[index]);
	index = index + 1;
	local deck2 = "";
	if card_len2 > 0 then
		local len = index+card_len2-1;
		for i = index, len do
			deck2 = deck2 .. ' ' .. input_list[i];
			index = index+1;
		end
	else
		deck2 = input_list[index];
		index = index+1;
	end
	solo_data.deck2_list	= deck2;

	g_game_info = {
		side = side,
		cmd_size = cmd_size,
		seed		= seed,
		deck1_array	= deck1,
		timeout		= timeout,
		solo_data	= solo_data,
	};
	g_game_play_list = {};
	init_net_play();
	if cmd_size > 0 then
		g_scene:preload(cb_net_game, layer_preload.WAIT, STAGE_PVP);
		g_net_cmdsize = cmd_size + 1;
		return;
	end
	g_scene:preload(cb_net_game, layer_preload.START, STAGE_PVP);
end

-- CMD: ginfo
-- RET: robot_game [side] [cmd_size] [seed] [timeout] [game_type] [deck1] [solo_hero] [c1] [c2] ... [cn]
function net_robot_game(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	data_handler:cleanup();
	local side			= check;
	local cmd_size		= tonumber(input_list[3]);
	local seed			= tonumber(input_list[4]);
	local timeout		= tonumber(input_list[5]);
	local game_type		= tonumber(input_list[6]);
	local deck1_array	= input_list[7];
	local f1, f2 = string.find(str, deck1_array);
  	local tt = string.sub(str, f2+2, string.len(str));
	local robot_data		= {};
	robot_data.deck2_list	= tt;

	--[[
	robot_data.hero			= tonumber(input_list[8]);
	robot_data.deck2_list	= input_list[9];
	for i = 10, #input_list do
		robot_data.deck2_list = robot_data.deck2_list .. ' ' .. input_list[i];
	end
	]]--

	g_game_info = {
		side = side,
		cmd_size = cmd_size,
		seed		= seed,
		deck1_array	= deck1_array,
		timeout		= timeout,
		game_type	= game_type,
		robot_data	= robot_data,
	};
	g_game_play_list = {};
	init_net_play();
	if cmd_size > 0 then
		g_scene:preload(cb_net_game, layer_preload.WAIT, STAGE_PVP);
		g_net_cmdsize = cmd_size + 1;
		return;
	end
	g_scene:preload(cb_net_game, layer_preload.START, STAGE_PVP);
end


-- no use
function net_atwin(input_list, str, check)
	if check < 0 then
		if true == DEBUG_MODE then
			show_err(str);
		end
		return;
	end
end

-- CMD lottery [type] [times]
-- if type == 0, get lottery price, times maybe empty
-- RET lottery eid 0 lottery_one_gold lottery_one_crystal lottery_ten_gold 
--     lottery_ten_crystal
-- if type == 1, gold lottery; type == 2, crystal lottery
-- times == 1 or 10, define lottery price and cid count
-- RET lottery eid type gold crystal 1 cid1
-- RET lottery eid type gold crystal 10 cid1 cid2 ... cid10
function net_lottery(input_list, str, check)
	if check < 0 then
		show_err(str);
		return;
	end
	local eid = check;
	local ltype = tonumber(input_list[3]);
	if 0 == ltype then
		local one_gold = math.abs(tonumber(input_list[4]) or 0);
		local one_crystal = math.abs(tonumber(input_list[5]) or 0);
		local ten_gold = math.abs(tonumber(input_list[6]) or 0);
		local ten_crystal = math.abs(tonumber(input_list[7]) or 0);
		if nil == layer_lottery.layer then return; end
		layer_lottery:add_price(one_gold, ten_gold, one_crystal, ten_crystal);
		if g_tutor_wait_net == tutor_pay_ad_2 then
			g_tutor_wait_net();
		end
		return;
	end
	local gold_offset = tonumber(input_list[4]) or 0;
	local crystal_offset = tonumber(input_list[5]) or 0;
	g_euser.gold = g_euser.gold + gold_offset;
	g_euser.crystal = g_euser.crystal + crystal_offset;
	layer_infobar:update_info();
	local count = tonumber(input_list[6]) or 0;
	local list = {};
	local index = 7;
	for i = 1, count do
		local cid = tonumber(input_list[index]);
		local rc = g_card_list[cid];
		if nil == rc then
			rc = hero_list[cid];
		end
		local card = clone(rc);
		table.insert(list, card);
		index = index + 1;
	end
	--[[
	if 1 == #list then
		local card = list[1];
		local layer, name = layer_mispop:create(card);
		layer_mispop:show_eff1();
		local tip = "获得新卡牌！快去牌堆上阵新卡吧！";
		util.add_labelttf(layer, tip, nil, 27, cc.p(HALF_WIDTH, FULL_HEIGHT), util.c4b_white, ANCHOR_CENTER_UP, 100, cc.size(FULL_WIDTH, 100), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
		g_scene:add_layer(ZORDER_LAYER_MISPOP, layer, name);
		return;
	end
	]]--
	g_scene:add_layer(ZORDER_LAYER_POPCLIST, layer_popclist:create(list, true));
end

function net_ljsdk(input_list, str, check)
	local event = input_list[2];
	--print("ljsdk event: " .. event);
	if event == "log_fail" then
		local reason = input_list[3];
		local customParams = input_list[4];
		show_msg("ljsdk login fail: " .. reason);
		g_euser.lj_userid = 0;
		return;
	end
	if event == "log_succ" then
		local uid			= input_list[3];
		local product_code	= input_list[4];
		local channel_id	= input_list[5];
		local token			= input_list[6];
--		show_msg("ljsdk login uid: " .. uid);
		g_euser.lj_userid = uid;
		--show_msg("sid: " .. sid);
		show_netloading();
		local xhr = cc.XMLHttpRequest:new();
		xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_STRING;
		local r = string.format("http://%s:8899/pay_server/ljsdklogin?userId=%s&productCode=%s&channel=%s&token=%s", IP_ADDR, uid, product_code, channel_id, token);
		xhr:open("GET", r);
		local function callback_xhr()
			hide_netloading();
			--local status = "Http Status Code:" .. xhr.statusText;
			local ret = xhr.response;
			--show_msg(ret);
			--print(ret);
			local function parse_json_str(jstr, key)
				local p1, p2 = string.find(jstr, key);
				if nil == p1 then
					return nil;
				end
				local pstart = p2 + 4;
				local pend = pstart;
				for i = pstart, string.len(jstr) do
					local c = string.sub(jstr, i, i);
					if '"' == c then
						pend = i;
						break;
					end
				end
				if pend <= pstart then
					return nil;
				end
				local ret = string.sub(jstr, pstart, pend-1);
				return ret;
			end
			local status = parse_json_str(ret, "status");
			if "0" ~= status then
				show_msg("登录验证失败");
				return;
			end
			local password = parse_json_str(ret, "password");
			local username = parse_json_str(ret, "username");
			--print('username:' .. username);
			--print('password:' .. password);
			--print('status:' .. status);
			layer_login:cb_login_for_ucsdk(username, password);
		end
		xhr:registerScriptHandler(callback_xhr);
		xhr:send();
		return;
	end
	if event == "log_out" then
		if stage ~= STAGE_LOGIN then
			g_scene:close_connect();
			g_euser.lj_userid = 0;
			g_scene:login();
		end
		return;
	end
	if event == "exit" then
		ask_exit();
		return;
	end
	if event == "force_exit" then
		exit_game();
		return;
	end
end

function net_ucsdk(input_list, str, check)
	local event = input_list[2];
	--print("ljsdk event: " .. event);
	if event == "sdkinit" then
		--[[
		local ret = input_list[3];
		if ret == "succ" then
			show_msg("初始化成功");
			return;
		end
		if ret == "fail" then
			show_msg("初始化失败");
			return;
		end
		]]--
		return;
	end
	if event == "log_succ" then
		local sid = input_list[3];
		--show_msg("sid: " .. sid);
		show_netloading();
		local xhr = cc.XMLHttpRequest:new();
		xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_STRING;
		local r = string.format("http://%s:8899/pay_server/uclogin?sid=%s", IP_ADDR, sid);
		xhr:open("GET", r);
		local function callback_xhr()
			hide_netloading();
			--local status = "Http Status Code:" .. xhr.statusText;
			local ret = xhr.response;
			--show_msg(ret);
			--print(ret);
			local function parse_json_str(jstr, key)
				local p1, p2 = string.find(jstr, key);
				if nil == p1 then
					return nil;
				end
				local pstart = p2 + 4;
				local pend = pstart;
				for i = pstart, string.len(jstr) do
					local c = string.sub(jstr, i, i);
					if '"' == c then
						pend = i;
						break;
					end
				end
				if pend <= pstart then
					return nil;
				end
				local ret = string.sub(jstr, pstart, pend-1);
				return ret;
			end
			local status = parse_json_str(ret, "status");
			if "0" ~= status then
				show_msg("登录验证失败");
				return;
			end
			local password = parse_json_str(ret, "password");
			local username = parse_json_str(ret, "username");
			--print('username:' .. username);
			--print('password:' .. password);
			--print('status:' .. status);
			layer_login:cb_login_for_ucsdk(username, password);
		end
		xhr:registerScriptHandler(callback_xhr);
		xhr:send();
		return;
	end
	if event == "log_fail" then
		local code = input_list[3];
		local pszmsg = input_list[4];
		show_msg("log fail: (" .. code .. ") msg:" .. pszmsg);
		return;
	end
	if event == "log_cancel" then return; end
	if event == "pay_succ" then return; end
	if event == "pay_succ" then
		show_msg("调用成功");
		return;
	end
	if event == "pay_close" then return; end
	if event == "pay_fail" then
		show_msg("调用失败");
		return;
	end
end

function net_9yousdk(input_list, str, check)
	local event = input_list[2];
	if event == "log_succ" then
		local pszUserId = input_list[3];
		g_euser.user_id = pszUserId;
--		local accId = input_list[4];
		--show_msg("sid: " .. sid);
		show_netloading();
		local xhr = cc.XMLHttpRequest:new();
		xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_STRING;
--		local r = string.format("http://%s:8899/pay_server/9youlogin?userId=%s&accId=%s", IP_ADDR, pszUserId, accId);
		local r = string.format("http://%s:8899/pay_server/9youlogin?userId=%s", IP_ADDR, pszUserId);
		xhr:open("GET", r);
		local function callback_xhr()
			hide_netloading();
			--local status = "Http Status Code:" .. xhr.statusText;
			local ret = xhr.response;
			--show_msg(ret);
			--print(ret);
			local function parse_json_str(jstr, key)
				local p1, p2 = string.find(jstr, key);
				if nil == p1 then
					return nil;
				end
				local pstart = p2 + 4;
				local pend = pstart;
				for i = pstart, string.len(jstr) do
					local c = string.sub(jstr, i, i);
					if '"' == c then
						pend = i;
						break;
					end
				end
				if pend <= pstart then
					return nil;
				end
				local ret = string.sub(jstr, pstart, pend-1);
				return ret;
			end
			local status = parse_json_str(ret, "status");
			if "0" ~= status then
				show_msg("登录验证失败");
				return;
			end
			local password = parse_json_str(ret, "password");
			local username = parse_json_str(ret, "username");
			--print('username:' .. username);
			--print('password:' .. password);
			--print('status:' .. status);
			layer_login:cb_login_for_9yousdk(username, password);
		end
		xhr:registerScriptHandler(callback_xhr);
		xhr:send();
		return;
	end
	if event == "pay_cancel" then
		show_msg("支付取消");
		return;
	end
	if event == "pay_failed" then
		g_scene:add_layer(ZORDER_LAYER_MSG, layer_msg:create('支付失败'));
		return;
	end
	if event == "pay_succ" then
		show_msg("支付成功, 正在进行服务器确认");
		return;
	end
end

g_net_command_list = {
	['log'] = net_log,
	['getsite'] = net_getsite,
	['room'] = net_room,
	['lmerge'] = net_lmerge,
	['lconstant'] = net_lconstant,
	['lcard'] = net_lcard,
	['sta'] = net_sta,
	['wchat'] = net_wchat,
	['rchat'] = net_rchat,
	['gchat'] = net_gchat,
	['fchat'] = net_fchat,
	['s'] = net_play,
	['t'] = net_play,
	['b'] = net_play,
	['n'] = net_play,
	['game'] = net_game,
	['ginfo'] = net_game,
	['gate'] = net_gate,
	['gate_msg'] = net_gate_msg,
	['lgate'] = net_lgate,
	['gift'] = net_gift,
	['fdata'] = net_fdata,
	['fight'] = net_fight,
	['win'] = net_win,
	['fold'] = net_fold,
	['greconn'] = net_greconn,
	['gerr'] = net_gerr;
	['reconn'] = net_reconn;
	['ERROR'] = net_show_err,
	['dres'] = net_dres,
	['lai'] = net_lai,
	['ldeck'] = net_ldeck,
	['load_hero_deck'] = net_load_hero_deck,
	['list_hero_slot'] = net_list_hero_slot,
	['get_hero_slot'] = net_get_hero_slot,
	['insert_hero_slot'] = net_insert_hero_slot,
	['update_hero_slot'] = net_update_hero_slot,
	['choose_hero_slot'] = net_choose_hero_slot,
	['slotlist'] = net_slotlist,
	['lslot'] = net_lslot,
	['rslot'] = net_rslot,
	['bslot'] = net_bslot,
	['reg'] = net_reg,
	['alias'] = net_alias,
	['ralias'] = net_ralias,
	['job'] = net_job,
	['ljob'] = net_ljob,
	['sprofile'] = net_sprofile,
	['lreplay'] = net_lreplay,
	['replay'] = net_replay,
	['sdeck'] = net_sdeck,
	['quickmsg'] = net_quickmsg,
	['quick'] = net_quick,
	['leave'] = net_leave,
	['lchan'] = net_lchan,
	['lroom'] = net_lroom,
	['join'] = net_room,  -- should remove later
	['shop'] = net_shop,
	['buy'] = net_buy,
	['sell'] = net_sell,
	['ladder'] = net_ladder,
	['notice'] = net_notice,
	['flist'] = net_flist,
	['fsearch'] = net_fsearch,
	['fadd'] = net_fadd,
	['fdel'] = net_fdel,
	['fsta'] = net_fsta,
	['course'] = net_course,
	['scourse'] = net_scourse,
	['lpay'] = net_lpay,
	['lguild'] = net_lguild,
	['gapply'] = net_gapply,
	['gquit'] = net_gquit,
	['cguild'] = net_cguild,
	['guild'] = net_guild,
	['gbonus'] = net_gbonus,
	['glv'] = net_glv,
	['glevelup'] = net_glevelup,
	['dguild'] = net_dguild,
	['glist'] = net_glist,
	['gsearch'] = net_gsearch,
	['gpos'] = net_gpos,
	['deposit'] = net_deposit,
	['gdeposit'] = net_gdeposit,
	['ldeposit'] = net_ldeposit,
	['challenge'] = net_challenge,
	['mlist'] = net_mlist,
	['mreward'] = net_mreward,
	['mchange'] = net_mchange,
	['kick'] = net_kick,
	['lmatch'] = net_lmatch,
	['match_apply'] = net_match_apply,
	['match_cancel'] = net_match_cancel,
	['player_data'] = net_player_data,
	['arenatarget'] = net_arenatarget,
	['arenatop'] = net_arenatop,
	['arenagame'] = net_arenagame,
	['arenareward'] = net_arenareward,
	['arenatimes'] = net_arenatimes,
	['rlist'] = net_rlist,
	['rtarlist'] = net_rtarlist,
	['rgame'] = net_rgame,
	['rchallenge'] = net_rchallenge,
	['rcancel'] = net_rcancel,
	['rresp'] = net_rresp,
	['lhero'] = net_lhero,
	['hero_mlist'] = net_hero_mlist,
	['shero_mis'] = net_shero_mis,
	['lhero'] = net_lhero,
	['list_message'] = net_list_message,
	['read_message'] = net_read_message,
	['list_solo'] = net_list_solo,
	['lchapter'] = net_lchapter,
	['chapter_data'] = net_chapter_data,
	['chapter_stage'] = net_chapter_stage,
	['chapter_reward'] = net_chapter_reward,
	['chapter'] = net_chapter,
	['solo_plus'] = net_solo_plus,
	['robot_game'] = net_robot_game,
	['lpiece'] = net_lpiece,
	['cpiece'] = net_cpiece,
	['piece_chapter'] = net_piece_chapter,
	['mpiece'] = net_mpiece,
	['daily_log'] = net_daily_log,
	['daily_reward'] = net_daily_reward,
	['pshop'] = net_pshop,
	['rpshop'] = net_pshop,
	['lpshop'] = net_lpshop,
	['pbuy'] = net_pbuy,
	['moneyexchange'] = net_moneyexchange,
	['@match_add'] = net_atmatch_add,
	['@match_delete'] = net_atmatch_delete,
	['@match_init'] = net_atmatch_init,
	['@win'] = net_atwin,
	['@pay'] = net_atpay,

	['batch'] = net_batch,
	['ppiece'] = net_ppiece,
	['mpiece'] = net_mpiece,
	['xcadd'] = net_xcadd,
	['xcbuy'] = net_xcbuy,
	['xclist'] = net_xclist,
	['pick'] = net_pick,
	['sdebug'] = net_sdebug,
	['ldebug'] = net_ldebug,
	['ljsdk'] = net_ljsdk,
	['ucsdk'] = net_ucsdk,
	['9yousdk'] = net_9yousdk,
	['lottery'] = net_lottery,
};


function net_listener(str)
	--hide_netloading();
	kdebug("net_receive[%s]", str);
	add_chat_msg(C_LOG, 0, '日志', str, get_time());
	local input_list;
	input_list = split_string(str);
	local check = tonumber(input_list[2]);
	if nil ~= check and -8 == check then
		local current_status = tonumber(input_list[4]) or 0;
		-- -8 not_enough_st 5 < 15
		if current_status == ST_NULL then
			g_scene:login();
		elseif current_status == ST_LOGIN then
			g_scene:map();
		elseif current_status >= ST_ROOM then
			net_send('room');
		end
		return;
	end

	if nil ~= tonumber(input_list[1]) then
		net_play(input_list, str, check);
		return;
	end
	for k, v in pairs(g_net_command_list) do
		if k==input_list[1] then
			hide_netloading(); -- do it here, don't hide when get a unknown cmd
			v(input_list, str, check);
			return; -- early exit
		end
	end

end

function get_platform()
	local p = PLATFORM_UNKNOWN;
	local platform = cc.Application:getInstance():getTargetPlatform();
	if platform == cc.PLATFORM_OS_IPHONE then
		p = PLATFORM_IPHONE;
	elseif platform == cc.PLATFORM_OS_IPAD then
		p = PLATFORM_IPAD;
	elseif platform == cc.PLATFORM_OS_MAC then
		p = PLATFORM_MAC;
	elseif platform == cc.PLATFORM_OS_ANDROID then
		p = PLATFORM_ANDROID;
	elseif platform == cc.PLATFORM_OS_WINDOWS then
		p = PLATFORM_WINDOWS;
	end
	return p;
end

function get_channel()
	--local c = tonumber(CPID) or 0;
	local c = tonumber(CHANNEL_VER) or 0;
	return c;
end

function net_cmd_reg(username, password)
	local p = get_platform();
	local c = get_channel();
	local cmd = string.format("reg %s %s %d %d", username, password, p, c);
	net_send(cmd);
end

function net_cmd_log(username, password)
	local p = get_platform();
	local c = get_channel();
	local cmd = string.format("log %s %s %d %d", username, password, p, c);
	net_send(cmd);
end


function net_send_dres(filename)
	if nil == filename then
		return;
	end
	LayerSocket:dlres(filename .. '\n');
end
-- /////////////////////// NETWORK END  ///////////////////////////

-- /////////////////////// LAYER START ///////////////////////////

layer_touch = { -- start

} -- layer_touch end

layer_ltarget = {
	name = 'layer_ltarget',
	layer = nil,
	bg = nil,

	cleanup = function(self)
		self.layer = nil;
		self.bg = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, list)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_LTARGET, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 100));

		local path = util.get_path('bg_121.png');
		local frect = cc.rect(0, 0, 404, 260); -- fullrect
		local irect = cc.rect(200, 128, 4, 4); -- insetrect
		local size = cc.size(540, 288);
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, size, 10); 
		self.bg = bg;

		local path = util.get_path('bg_156.png');
		local frect = cc.rect(0, 0, 64, 64); -- fullrect
		local irect = cc.rect(30, 30, 4, 4); -- insetrect
		local size = cc.size(491, 157); -- realsize
		local pos = cc.p(26, 96);
		util.add_scale9sprite(bg, path, pos, ANCHOR_LEFT_DOWN, frect, irect, size, 15); 

		local path = util.get_path(FT_2);
		local tg, str;
		for i = 1, #(list or {}) do
			tg = list[i];
			pos = cc.p(44, 203-(i-1)*45);
			str = i .. '.';
			util.add_labelbmf(bg, str, path, pos, ANCHOR_LEFT_DOWN, 30);

			pos = cc.p(98, 209-(i-1)*45);
			str=string.format("%s",layer_stage:get_target_msg(tg,true));
			local label = rich_label.new(bg, pos, str, "Arial", 24, 460, 2, cc.c4b(240, 240, 203, 255), 30);
		end

    	if nil ~= msg then
			pos = cc.p(size.width/2, size.height-50);
			local lsize = cc.size(size.width-40, size.height - 80 - 100);
			util.add_labeloutline(bg, msg, nil, 25, pos, util.c4b_white, util.c4b_black, 1, ANCHOR_CENTER_UP, 50, lsize, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_TOP);
    	end

		local items = {};

		pos = cc.p(208, 23);
		add_item_2(items, 'btn_122.png', 'btn_122_s.png', self.back, ANCHOR_LEFT_DOWN, pos);

		util.add_menu(bg, items, 60);

		return self.layer, self.name;
	end,

	back = function()
		local self = layer_ltarget;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_ltarget;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
	end,
} -- layer_msg end

layer_text = {
	name = 'layer_text',
	layer = nil,

	cleanup = function(self)
		self.layer = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, title, text)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_TEXT, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 50));
		local data, label;
		local offsetheight, sprite, rect = init_bg_pop(self.layer, GUI_NOTICE, '今日公告', self.back, nil, true);

		gui_add_sprite(self.layer, 'cell', GUI_NOTICE, ANCHOR_UP);
		gui_add_sprite(self.layer, 'icon', GUI_NOTICE, ANCHOR_UP);
		gui_add_label(self.layer, title, 22, 'cell_title', GUI_NOTICE, ANCHOR_UP);

		sprite, data = gui_add_sprite(self.layer, 'bg_table', GUI_NOTICE, ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));
		--label, data = gui_add_label(self.layer, text, 22, 'detail', GUI_NOTICE, ANCHOR_DOWN);
		label, data = gui_add_label(self.layer, text, 23, 'detail', GUI_NOTICE, ANCHOR_DOWN, nil, 0, offsetheight);
		--label:setContentSize(cc.size(data.width, data.height+offsetheight));
		label:setAlignment(cc.TEXT_ALIGNMENT_LEFT,cc.VERTICAL_TEXT_ALIGNMENT_TOP);

		local items = {};
		local item;
		item, data = gui_add_item(items, 'btn_return', GUI_NOTICE, self.close, ANCHOR_UP);
		util.add_menu(self.layer, items, data.zorder);

		--[[
		local bgsize = cc.size(wfix(600), hfix(900));
		local bg, rect = init_bg_for_popview(self.layer,title,bgsize,self.back);
		local pos = cc.p(20, 10);
		local size = cc.size(bgsize.width-40, bgsize.height-10-110);
		util.add_labelttf(bg, text, nil, 25, pos, util.c4b_white, ANCHOR_LEFT_DOWN, 40, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_TOP);
		]]--

		return self.layer, self.name;
	end,

	back = function()
		local self = layer_text;
		self:close();
		if nil ~= layer_notice.layer then
			layer_notice.back();
		end
	end,

	close = function()
		local self = layer_text;
		self:remove();
	end,

	action = function()
		local self = layer_text;
		self.back();
	end,

	handler = function(event, x, y)
		local self = layer_text;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
	end,
} -- layer_text end

layer_mailtext = {
	name = 'layer_mailtext',
	layer = nil,

	cleanup = function(self)
		self.layer = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, title, text)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_MAILTEXT, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 50));
		local data, label;
		local offsetheight, sprite, rect = init_bg_pop(self.layer, GUI_MAIL, '信箱', self.back, nil, true);

		gui_add_sprite(self.layer, 'p_bg_title', GUI_MAIL, ANCHOR_UP);
		gui_add_sprite(self.layer, 'p_icon', GUI_MAIL, ANCHOR_UP);
		gui_add_label(self.layer, title, 22, 'p_title', GUI_MAIL, ANCHOR_UP);

		sprite, data = gui_add_sprite(self.layer, 'frame', GUI_MAIL, ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));
		label, data = gui_add_label(self.layer, text, 22, 'p_detail', GUI_MAIL, ANCHOR_DOWN);
		label:setContentSize(cc.size(data.width, data.height+offsetheight));
		label:setAlignment(cc.TEXT_ALIGNMENT_LEFT,cc.VERTICAL_TEXT_ALIGNMENT_TOP);

		local items = {};
		local item;
		item, data = gui_add_item(items, 'btn_close', GUI_MAIL, self.close, ANCHOR_UP);
		util.add_menu(self.layer, items, data.zorder);

		return self.layer, self.name;
	end,

	back = function()
		local self = layer_mailtext;
		self:close();
		if nil ~= layer_mail.layer then
			layer_mail.back();
		end
	end,

	close = function()
		local self = layer_mailtext;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_mailtext;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
	end,
} -- layer_mailtext end

-- deprecated
layer_cserver = { -- start
	name = 'layer_cserver',
	layer = nil,
	list = nil,
	cwidth = nil,
	cheight = nil,
	rect = nil,
	callback = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.rect = nil;
		self.callback = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, list, cb)	
		self:remove();

		self.list = list or {};
		self.callback = cb;
		self.layer = cc.Layer:create();

		util.add_layer_color(self.layer, cc.c4b(0, 0, 0, 128), 0);

		util.reg_handler(self.layer, -ZORDER_LAYER_CSERVER, self.handler, true);

		self.cheight = 100;
		local theight = self.cheight * #self.list;
		theight = theight > (FULL_HEIGHT/4*3) and (FULL_HEIGHT/4*3) or theight;
		theight = theight < self.cheight and self.cheight or theight;

		local path = util.get_path('bg_121.png');
		local frect = cc.rect(0, 0, 404, 260); -- fullrect
		local irect = cc.rect(200, 128, 4, 4); -- insetrect
		local size = cc.size(FULL_WIDTH-50, theight);
		local pos = cc.p((FULL_WIDTH-size.width)/2, (FULL_HEIGHT-size.height)/2);

		util.add_scale9sprite(self.layer, path, pos, ANCHOR_LEFT_DOWN, frect, irect, size, 1); 
		self.rect = cc.rect(pos.x, pos.y, size.width, size.height);

		self.cwidth = size.width;
		local tsize = cc.size(size.width-10, size.height-10);
		pos = cc.p((FULL_WIDTH-tsize.width)/2, (FULL_HEIGHT-tsize.height)/2);
		util.add_tableview(self.layer, tsize, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, 10);

		return self.layer, self.name;
	end,

	close = function(self)
		play_tap_1();
		self:remove();
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_cserver;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			if nil ~= self.callback then
				self.callback(idx + 1);
			end
			self:close();
			return 0;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local info = self.list[idx + 1];
			local height = self.cheight;
			local width = self.cwidth;
			local name = info.name;
			local state = info.state;
			local str = string.format("%s [ %s ]", name, state);
			local pos = ccp(width/2, height/2);
			util.add_label(cell, str, 30, pos, util.c_white,ANCHOR_CENTER_CENTER);

			local path = util.get_path('line_1.png');
			pos = ccp(width/2, 0);
			local line = util.add_sprite(cell, path, pos, ANCHOR_CENTER_DOWN);
			line:setScaleX((width-40)/line:getContentSize().width);
			return cell;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_cserver;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.close();
		end
	end,

	onTouchBegan = function(self, x, y)
		local r = self.rect;
		if nil == r or x < r.x or x > r.x+r.width or y < r.y or y > r.y+r.height then
			self:close();
		end
		return true;
	end,

	onTouchMoved = function(self, x, y)		

	end,

	onTouchEnded = function(self, x, y)	
	end,
} -- layer_cserver end

-- deprecated
layer_more = {
	name = 'layer_more',
	layer = nil,
	rect = nil,
	cwidth = nil,
	cheight = nil,
	tableview = nil,
	list = nil,
	callback = nil,
	callback_delete = nil,

	cleanup = function(self)
		self.layer = nil;
		self.tableview = nil;
		self.rect = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.list = nil;
		self.callback = nil;
		self.callback_delete = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, mtype, list, bpos, bsize, cb, cb2)
		self:remove();

		list = list or {};
		self.callback = cb;
		self.callback_delete = cb2;
		self.list = list;
		self.layer = cc.Layer:create();
		
		util.reg_handler(self.layer, -ZORDER_LAYER_MORE, self.handler, true);

		util.add_layer_color(self.layer, cc.c4b(0, 0, 0, 128), 0);

		self.cheight = 100;
		local theight = self.cheight * #self.list;
		theight = theight > (FULL_HEIGHT/4*3) and (FULL_HEIGHT/4*3) or theight;
		theight = theight < self.cheight and self.cheight or theight;

		local fullrect = cc.rect(0, 0, 64, 54);
		local insetrect = cc.rect(30, 25, 4, 4);
		local size = cc.size(FULL_WIDTH-50, theight);
		local pos = cc.p((FULL_WIDTH-size.width)/2, (FULL_HEIGHT-size.height)/2);
		local path = util.get_path('text_box.png');

		util.add_scale9sprite(self.layer, path, pos, ANCHOR_LEFT_DOWN, fullrect, insetrect, size, 1); 
		self.rect = cc.rect(pos.x, pos.y, size.width, size.height);

		self.cwidth = size.width;
		local tsize = cc.size(size.width-10, size.height-10);
		pos = cc.p((FULL_WIDTH-tsize.width)/2, (FULL_HEIGHT-tsize.height)/2);
		util.add_tableview(self.layer, tsize, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, 10);

		return self.layer, self.name;
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_more;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			self:choose(idx+1);
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local name = self.list[idx + 1];
			
			local width = self.cwidth;
			local height = self.cheight;
			local pos = ccp(50, height/2);
			local label = util.add_label(cell, name, 30, pos, util.c_white, ANCHOR_LEFT_CENTER, nil, cc.size(width, height), cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
			local path = util.get_path('line_1.png');
			pos = ccp(width/2, 0);
			local line = util.add_sprite(cell, path, pos, ANCHOR_CENTER_DOWN);
			line:setScaleX((width-40)/line:getContentSize().width);

			local items = {};
			local item;

			local fname =util.get_fullpath(F_IMAGE,'btn_2.png');
			pos = ccp(width-80, height/2);
			item = util.create_item_image(fname, fname, pos, ANCHOR_LEFT_CENTER, self.delete);
			item:setTag(idx+1);
			table.insert(items, item);

			util.add_menu(cell, items, 1);
			return cell;
		end
	end, -- tableview_handler end }

	choose = function(self, index)
		local str = self.list[index];
		self.callback(str, index);
		self:remove();
	end,

	delete = function(...)
		local self = layer_more;
		if nil == self.callback_delete then
			return;
		end
		local arg = { ... };
		local item = arg[2];
		local index = item:getTag();
		self.callback_delete(index);
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_more;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self:remove();
		end
	end,

	onTouchBegan = function(self, x, y)
		local r = self.rect;
		if nil == r or x < r.x or x > r.x+r.width or y < r.y or y > r.y+r.height then
			self:remove();
		end
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
	end,

} -- layer_more end


layer_map = { -- start    
	name = 'layer_map',
	layer = nil,
	btn_pve = nil,
	btn_lottery = nil,
	btn_deck = nil,
	bg = nil,
	touch_x = nil,
	sx = nil,
	bg_width = nil,
	list = nil,
	sprite_icon = nil,
	label_lv = nil,
	label_vip = nil,
	is_scroll = nil,
	list_more = nil,
	btn_mission = nil,
	btn_daily = nil,
	btn_chapter = nil,
	btn_more = nil,
	btn_deck = nil,
	btn_piece = nil,

	cleanup = function(self)
		self.layer = nil;
		self.btn_pve = nil;
		self.btn_lottery = nil;
		self.btn_deck = nil;
		self.bg = nil;
		self.touch_x = nil;
		self.sx = nil;
		self.bg_width = nil;
		self.list = nil;
		self.sprite_icon = nil;
		self.label_lv = nil;
		self.label_vip = nil;
		self.is_scroll = nil;
		self.list_more = nil;
		self.btn_mission = nil;
		self.btn_daily = nil;
		self.btn_chapter = nil;
		self.btn_more = nil;
		self.btn_deck = nil;
		self.btn_piece = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();
		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_MAP, self.handler, true);

		self.list_more = {};
		local sprite, data;
		sprite, data = gui_add_sprite(self.layer, 'glass', GUI_MAIN, ANCHOR_DOWN);
		sprite, data = gui_add_sprite(self.layer, 'tree', GUI_MAIN, ANCHOR_DOWN);
		local scale = sprite:getScale();
		local th = FULL_HEIGHT-wfix(60);
		if th > data.height then
			-- tree png is 640x900 , make it scale fix the screen
			scale = th/sprite:getContentSize().height;
			sprite:setScale(scale);
		end
		sprite = gui_add_sprite(self.layer, 'sky', GUI_MAIN, ANCHOR_DOWN);
		sprite:setScale(scale);
		scale = 1;
		local bg;
		bg, data = gui_add_sprite(self.layer, 'bg', GUI_MAIN, ANCHOR_DOWN);
		self.bg = bg;
		bg:setScale(scale);
		self.bg_width = bg:getContentSize().width * scale;
		--sprite = gui_add_sprite(bg, 'ground_shadow', GUI_MAIN, ANCHOR_DOWN);
		--sprite:setScale(scale);

		sprite,data = gui_add_sprite(self.layer, 'cloud1', GUI_MAIN, ANCHOR_UP);
		self:cloud_eff(sprite, cc.p(data.x, data.y), 1, 0);
		sprite,data = gui_add_sprite(self.layer, 'cloud2', GUI_MAIN, ANCHOR_UP);
		self:cloud_eff(sprite, cc.p(data.x, data.y), 10, 0);
		sprite,data = gui_add_sprite(self.layer, 'cloud3', GUI_MAIN, ANCHOR_UP);
		self:cloud_eff(sprite, cc.p(data.x, data.y), 3, 0);
		--sprite,data = gui_add_sprite(self.layer, 'cloud2', GUI_MAIN, ANCHOR_UP);
		--self:cloud_eff(sprite, cc.p(956, 823), 15, 0.3);

		self.list = {};
		local function sort(s, l)
			for i = 1, #l do
				local dd = l[i];
				if s.zorder < dd.zorder then
					table.insert(l, i, s);
					return;
				end
			end
			table.insert(l, s);
		end
		sprite,data = gui_add_sprite(bg, 'icon_pve', GUI_MAIN, ANCHOR_DOWN);
		--table.insert(self.list, { tag = 1, sprite = sprite });
		sort({ tag = 1, sprite = sprite, zorder = data.zorder }, self.list);
		sprite,data = gui_add_sprite(bg, 'icon_war', GUI_MAIN, ANCHOR_DOWN);
		self.btn_chapter = sprite;
		--table.insert(self.list, { tag = 2, sprite = sprite });
		sort({ tag = 2, sprite = sprite, zorder = data.zorder }, self.list);
		sprite,data = gui_add_sprite(bg, 'icon_guild', GUI_MAIN, ANCHOR_DOWN);
		--table.insert(self.list, { tag = 3, sprite = sprite });
		sort({ tag = 3, sprite = sprite, zorder = data.zorder }, self.list);
		sprite,data = gui_add_sprite(bg, 'icon_pvp', GUI_MAIN, ANCHOR_DOWN);
		--table.insert(self.list, { tag = 4, sprite = sprite });
		sort({ tag = 4, sprite = sprite, zorder = data.zorder }, self.list);
		sprite,data = gui_add_sprite(bg, 'icon_rank', GUI_MAIN, ANCHOR_DOWN);
		--table.insert(self.list, { tag = 5, sprite = sprite });
		sort({ tag = 5, sprite = sprite, zorder = data.zorder }, self.list);
		sprite,data = gui_add_sprite(bg, 'icon_mail', GUI_MAIN, ANCHOR_DOWN);
		--table.insert(self.list, { tag = 6, sprite = sprite });
		sort({ tag = 6, sprite = sprite, zorder = data.zorder }, self.list);
		sprite,data = gui_add_sprite(bg, 'icon_wait', GUI_MAIN, ANCHOR_DOWN);
		sort({ tag = 7, sprite = sprite, zorder = data.zorder }, self.list);

		local items = {};
		local item, data;

		item,data=gui_add_item(items, 'mission', GUI_MAIN, show_mission_list, ANCHOR_UP);
		self.btn_mission = item;

		item,data=gui_add_item(items, 'daily', GUI_MAIN, show_daily_list, ANCHOR_UP);
		self.btn_daily = item;

		item,data=gui_add_item(items, 'chat', GUI_MAIN, show_chat, ANCHOR_UP);

		item,data=gui_add_item(items, 'btn_more', GUI_MAIN, self.show_more, ANCHOR_UP);

		self:add_more_list(items, data);
		self.btn_more = item;

		item,data=gui_add_item(items, 'btn_info', GUI_MAIN, self.show_info, ANCHOR_UP);

		util.add_menu(self.layer, items, data.zorder);

		local path = get_icon_path(g_euser.icon);
		local mask_path = util.get_path('picon_1_mask_1.png');
		sprite = gui_add_mask_image(self.layer, path, mask_path, 'icon_player', GUI_MAIN, ANCHOR_UP);
		self.sprite_icon = sprite;

		sprite = gui_add_sprite(self.layer, 'icon_vip1', GUI_MAIN, ANCHOR_UP);
		if true == is_vip_member(g_euser) then
			--gui_add_sprite(self.layer, 'icon_vip1', GUI_MAIN, ANCHOR_UP);
			str = '0';
			--self.label_vip = gui_add_label(self.layer, str, 18, 'num_vip', GUI_MAIN, ANCHOR_UP);
			path = util.get_path(FT_2);
			self.label_vip = gui_add_labelbmf(self.layer, str, path, 'num_vip', GUI_MAIN, ANCHOR_UP); 
		else
			util.set_gray(sprite);
			--gui_add_sprite(self.layer, 'icon_vip2', GUI_MAIN, ANCHOR_UP);
		end
		local str;
		str = g_euser.alias;
		gui_add_label(self.layer, str, 18, 'alias', GUI_MAIN, ANCHOR_UP);
		path = util.get_path(FT_3);
		str = '' .. g_euser.level;
		self.label_lv = gui_add_labelbmf(self.layer, str, path, 'level', GUI_MAIN, ANCHOR_UP, cc.TEXT_ALIGNMENT_CENTER);

		self.btn_more:setSelectedIndex(1);
		self.show_more(1, self.btn_more, true);
		self:tip_btn_mission();

		return self.layer, self.name;
	end,

	cloud_eff = function(self, sprite, pos, speed, delay)
		local px = 0-sprite:getContentSize().width*sprite:getScaleX();
		sprite:setPosition(pos);
		local function start_repeat()
			local l = {};
			table.insert(l, cc.DelayTime:create(delay));
			local function move_back()
				sprite:setPosition(cc.p(px, pos.y));
			end
			table.insert(l, cc.CallFunc:create(move_back));
			local time = (FULL_WIDTH - px) / speed;
			table.insert(l, cc.MoveTo:create(time, cc.p(FULL_WIDTH, pos.y)));
			sprite:runAction(cc.RepeatForever:create(cc.Sequence:create(l)));
		end
		local list = {};
		local time = (FULL_WIDTH - pos.x) / speed;
		table.insert(list, cc.MoveTo:create(time, cc.p(FULL_WIDTH, pos.y)));
		table.insert(list, cc.CallFunc:create(start_repeat));
		sprite:runAction(cc.Sequence:create(list));
	end,

	tip_btn_mission = function(self)
		-- layer_map
		local btn = self.btn_mission;
		if nil == btn then return; end
		local sprite = btn:getChildByTag(360);
		if nil ~= sprite then
			sprite:removeFromParentAndCleanup(true);
		end
		local fname = nil;
		if 1 == g_mission_tip then -- has new mission
			fname = 'icon_75.png';
		elseif 2 == g_mission_tip then -- has target ok mission
			fname = 'icon_74.png';
		elseif 3 == g_mission_tip then -- has new and target ok mission
			fname = 'icon_75.png';
		else
			sprite = btn:getChildByTag(340);
			if nil ~= sprite then
				sprite:removeFromParentAndCleanup(true);
			end
			sprite = btn:getChildByTag(320);
			if nil ~= sprite then
				sprite:removeFromParentAndCleanup(true);
			end
			return;
		end
		local scale = btn:getScale();
		local size = btn:getContentSize();
		local x1 = 0;
		local x2 = size.width;
		local y1 = 0;
		local y2 = size.height;
		local path = util.get_path(fname);
		local pos = cc.p(x2, y2);
		sprite = util.add_sprite(btn, path, pos, ANCHOR_RIGHT_UP, 60);
		sprite:setTag(360);

		local array = {};
		table.insert(array, cc.JumpBy:create(1, cc.p(0, 0), 25, 2));
		table.insert(array, cc.DelayTime:create(2));
		sprite:runAction(cc.RepeatForever:create(cc.Sequence:create(array)));

		--[[
		local speed = 250;
		local tx = (x2 - x1) / speed;
		local ty = (y2 - y1) / speed;

		sprite = btn:getChildByTag(340);
		if nil == sprite then
			path = util.get_path('tutor_star.png');
			pos = cc.p(x1, y1);
			sprite = util.add_sprite(btn, path, pos, ANCHOR_CENTER_CENTER, 40);
			sprite:setTag(340);

			array = {};
			table.insert(array, cc.MoveTo:create(ty, cc.p(x1, y2)));
			table.insert(array, cc.MoveTo:create(tx, cc.p(x2, y2)));
			table.insert(array, cc.MoveTo:create(ty, cc.p(x2, y1)));
			table.insert(array, cc.MoveTo:create(tx, cc.p(x1, y1)));
			sprite:runAction(cc.RepeatForever:create(cc.Sequence:create(array)));
			sprite:runAction(cc.RepeatForever:create(cc.RotateBy:create(1, 360)));
		end

		sprite = btn:getChildByTag(320);
		if nil == sprite then
			path = util.get_path('tutor_tail.plist');
			pos = cc.p(x1, y1);
			local p = util.add_particle(btn, path, pos, 20);
			sprite = p.batch;
			sprite:setTag(320);

			array = {};
			table.insert(array, cc.MoveTo:create(ty, cc.p(x1, y2)));
			table.insert(array, cc.MoveTo:create(tx, cc.p(x2, y2)));
			table.insert(array, cc.MoveTo:create(ty, cc.p(x2, y1)));
			table.insert(array, cc.MoveTo:create(tx, cc.p(x1, y1)));
			sprite:runAction(cc.RepeatForever:create(cc.Sequence:create(array)));
		end
		]]--
	end,

	add_more_list = function(self, items, data)
		self.list_more.pos = cc.p(data.x+data.width/2, data.y+data.height/2);
		item = add_item_2(items, 'icon_46.png', 'icon_46_s.png', self.cb_more, ANCHOR_CENTER_CENTER, self.list_more.pos);
		item:setTag(21);
		item:setOpacity(0);
		item:setEnabled(false);
		table.insert(self.list_more, item);

		item = add_item_2(items, 'icon_67.png', 'icon_67_s.png', self.cb_more, ANCHOR_CENTER_CENTER, self.list_more.pos);
		item:setTag(22);
		item:setOpacity(0);
		item:setEnabled(false);
		table.insert(self.list_more, item);
		self.btn_deck = item;

		item = add_item_2(items, 'icon_68.png', 'icon_68_s.png', self.cb_more, ANCHOR_CENTER_CENTER, self.list_more.pos);
		item:setTag(23);
		item:setOpacity(0);
		item:setEnabled(false);
		if true == util.check_tutor(TUTOR_SHOW_PIECE) then
			table.insert(self.list_more, item);
		end
		self.btn_piece = item;

		item = add_item_2(items, 'icon_94.png', 'icon_94_s.png', self.cb_more, ANCHOR_CENTER_CENTER, self.list_more.pos);
		item:setTag(24);
		item:setOpacity(0);
		item:setEnabled(false);
		table.insert(self.list_more, item);

		item = add_item_2(items, 'icon_71.png', 'icon_71_s.png', self.cb_more, ANCHOR_CENTER_CENTER, self.list_more.pos);
		item:setTag(25);
		item:setOpacity(0);
		item:setEnabled(false);
		table.insert(self.list_more, item);

		item = add_item_2(items, 'icon_81.png', 'icon_81_s.png', self.cb_more, ANCHOR_CENTER_CENTER, self.list_more.pos);
		item:setTag(26);
		item:setOpacity(0);
		item:setEnabled(false);
		table.insert(self.list_more, item);

		--[[
		item = add_item_2(items, 'icon_88.png', 'icon_88_s.png', self.cb_more, ANCHOR_CENTER_CENTER, self.list_more.pos);
		item:setTag(27);
		item:setOpacity(0);
		item:setEnabled(false);
		table.insert(self.list_more, item);
		]]--

		item = add_item_2(items, 'icon_89.png', 'icon_89_s.png', self.cb_more, ANCHOR_CENTER_CENTER, self.list_more.pos);
		item:setTag(27);
		item:setOpacity(0);
		item:setEnabled(false);
		table.insert(self.list_more, item);

		item = add_item_2(items, 'icon_93.png', 'icon_93_s.png', self.cb_more, ANCHOR_CENTER_CENTER, self.list_more.pos);
		item:setTag(28);
		item:setOpacity(0);
		item:setEnabled(false);
		table.insert(self.list_more, item);

		item = add_item_2(items, 'icon_98.png', 'icon_98_s.png', self.cb_more, ANCHOR_CENTER_CENTER, self.list_more.pos);
		item:setTag(29);
		item:setOpacity(0);
		item:setEnabled(false);
		table.insert(self.list_more, item);

		item = add_item_2(items, 'icon_101.png', 'icon_101_s.png', self.cb_more, ANCHOR_CENTER_CENTER, self.list_more.pos);
		item:setTag(30);
		item:setOpacity(0);
		item:setEnabled(false);
		table.insert(self.list_more, item);

	end,

	show_more = function(tag, sender, no_eff)
		play_tap_3();
		local self = layer_map;
		-- self.toggle_info:getSelectedIndex()  0 : off     1 : on
		sender = tolua.cast(sender, "cc.MenuItemToggle");
		local t = sender:getSelectedIndex();  --0 : off     1 : on
		local pos = self.list_more.pos;
		local tag_action = 323;
		local delay = 0;
		if 1 == t then
			local function enablebtn(...)
				local args = {...};
				local b = args[1];
				b:setEnabled(true);
			end
			local x = pos.x;
			local y = pos.y - 60;
			for i = 1, #self.list_more do
				local btn = self.list_more[i];
				btn:stopActionByTag(tag_action);
				if btn:getRotation() == 0 then
					btn:setRotation(-180);
				end
				--[[
				local x, y;
				if i > 7 then
					local m = i - 7;
					x = pos.x - 100;
					y = pos.y - 100;
					x = x-math.floor((m-1)/6)*100;
					y = y-((m-1)%6+1)*100;
				else
					x = pos.x-math.floor((i-1)/7)*100;
					y = pos.y-((i-1)%7+1)*100;
				end
				]]--
				local bsize = btn:getContentSize();
				local bscale = btn:getScale();
				local th = bsize.height*bscale/2;
				if y - th*2 < 0 then
					y = pos.y - 130 - th;
					x = pos.x - 100;
				else
					y = y - th;
				end

				local tpos = cc.p(x, y);
				if true == no_eff then
					btn:setEnabled(true);
					btn:setOpacity(255);
					btn:setRotation(0);
					btn:setPosition(tpos);
				else
					local array = {};
					local sa = {};
					delay = (FULL_HEIGHT - pos.y)*0.001;
					table.insert(array, cc.DelayTime:create(delay));
					table.insert(sa, cc.FadeIn:create(0.2));
					table.insert(sa, cc.MoveTo:create(0.2, tpos));
					table.insert(sa, cc.RotateTo:create(0.2, 0));
					table.insert(array, cc.Spawn:create(sa));
					table.insert(array, cc.CallFunc:create(enablebtn));
					local action = cc.Sequence:create(array);
					action:setTag(tag_action);
					btn:runAction(action);
					--delay = delay + 0.1;
				end
				y = y - th;
			end
			return;
		end
		--delay = delay + 0.1 * (#self.list_more - 1);
		local function disenablebtn(...)
			local args = {...};
			local b = args[1];
			b:setEnabled(false);
		end
		for i = 1, #self.list_more do
			local btn = self.list_more[i];
			btn:stopActionByTag(tag_action);
			if btn:getRotation() == 0 then
				btn:setRotation(180);
			end
			if true == no_eff then
				btn:setEnabled(false);
				btn:setOpacity(0);
				btn:setRotation(0);
				btn:setPosition(pos);
			else
				local array = {};
				local sa = {};
				delay = (FULL_HEIGHT - pos.y)*0.001;
				table.insert(array, cc.DelayTime:create(delay));
				table.insert(sa, cc.FadeOut:create(0.2));
				table.insert(sa, cc.MoveTo:create(0.2, pos));
				table.insert(sa, cc.RotateTo:create(0.2, 0));
				table.insert(array, cc.Spawn:create(sa));
				table.insert(array, cc.CallFunc:create(disenablebtn));
				local action = cc.Sequence:create(array);
				action:setTag(tag_action);
				btn:runAction(action);
				--delay = delay - 0.1;
			end
		end
	end,

	refresh_more = function(self)
		-- self.toggle_info:getSelectedIndex()  0 : off     1 : on
		sender = tolua.cast(sender, "cc.MenuItemToggle");
		local t = sender:getSelectedIndex();  --0 : off     1 : on
		local pos = self.list_more.pos;
		local tag_action = 323;
		local delay = 0;
		if 1 == t then
			local function enablebtn(...)
				local args = {...};
				local b = args[1];
				b:setEnabled(true);
			end
			for i = 1, #self.list_more do
				local btn = self.list_more[i];
				btn:stopActionByTag(tag_action);
				if btn:getRotation() == 0 then
					btn:setRotation(-180);
				end
				local x, y;
				if i > 7 then
					local m = i - 7;
					x = pos.x - 100;
					y = pos.y - 100;
					x = x-math.floor((m-1)/6)*100;
					y = y-((m-1)%6+1)*100;
				else
					x = pos.x-math.floor((i-1)/7)*100;
					y = pos.y-((i-1)%7+1)*100;
				end
				local tpos = cc.p(x, y);
				if true == no_eff then
					btn:setEnabled(true);
					btn:setOpacity(255);
					btn:setRotation(0);
					btn:setPosition(tpos);
				else
					local array = {};
					local sa = {};
					table.insert(array, cc.DelayTime:create(delay));
					table.insert(sa, cc.FadeIn:create(0.2));
					table.insert(sa, cc.MoveTo:create(0.2, tpos));
					table.insert(sa, cc.RotateTo:create(0.2, 0));
					table.insert(array, cc.Spawn:create(sa));
					table.insert(array, cc.CallFunc:create(enablebtn));
					local action = cc.Sequence:create(array);
					action:setTag(tag_action);
					btn:runAction(action);
					delay = delay + 0.1;
				end
			end
			return;
		end
		delay = delay + 0.1 * (#self.list_more - 1);
		local function disenablebtn(...)
			local args = {...};
			local b = args[1];
			b:setEnabled(false);
		end
		for i = 1, #self.list_more do
			local btn = self.list_more[i];
			btn:stopActionByTag(tag_action);
			if btn:getRotation() == 0 then
				btn:setRotation(180);
			end
			if true == no_eff then
				btn:setEnabled(false);
				btn:setOpacity(0);
				btn:setRotation(0);
				btn:setPosition(pos);
			else
				local array = {};
				local sa = {};
				table.insert(array, cc.DelayTime:create(delay));
				table.insert(sa, cc.FadeOut:create(0.2));
				table.insert(sa, cc.MoveTo:create(0.2, pos));
				table.insert(sa, cc.RotateTo:create(0.2, 0));
				table.insert(array, cc.Spawn:create(sa));
				table.insert(array, cc.CallFunc:create(disenablebtn));
				local action = cc.Sequence:create(array);
				action:setTag(tag_action);
				btn:runAction(action);
				delay = delay - 0.1;
			end
		end
	end,

	show_info = function()
		if nil == g_euser.all_str then
			net_send("lcard", true);
			-- open info in lcard
			return;
		end
		g_scene:add_layer(ZORDER_LAYER_INFO, layer_info:create(g_euser));
	end,

	update_info = function(self)
		if nil == self.layer then
			return;
		end
		local str;

		local level = '' .. g_euser.level;
		self.label_lv:setString(level);

		self.sprite_icon:removeFromParentAndCleanup(true);
		local path1 = get_icon_path(g_euser.icon);
		local path2 = util.get_path('picon_1_mask_1.png');
		self.sprite_icon = gui_add_mask_image(self.layer, path1, path2, 'icon_player', GUI_MAIN, ANCHOR_UP);
	end,

	cb_more = function(...)
		local self = layer_map;
		local args = {...};
		local tag = args[2]:getTag();
		print('cb_more: ', tag);
		self:cb_tap(tag);
	end,

	check_tap = function(self, x, y)
		local bgx = self.bg:getPositionX();
		local bscale = self.bg:getScale();
		--for i = 1, #self.list do
		x = x - bgx;
		for i = #self.list, 1, -1 do
			local info = self.list[i];
			local tag = info.tag;
			local sprite = info.sprite;
			local x1, y1 = sprite:getPosition();
			x1 = x1 * bscale;
			y1 = y1 * bscale;
			--x1 = x1 + bgx;
			local size = sprite:getContentSize();
			local w = size.width * sprite:getScaleX() * bscale;
			local h = size.height * sprite:getScaleY() * bscale;
			local x2 = x1 + w;
			local y2 = y1 + h;
			if x > x1 and x < x2 and y > y1 and y < y2 then
				return tag;
			end
		end
		return -1;
	end,

	cb_tap = function(self, tag)
		play_tap_3();
		if 1 == tag then
			show_pclg();
		elseif 2 == tag then
			show_list_solo();
		elseif 3 == tag then
			if true == g_euser:has_guild() then
				net_send('guild');
			else
				g_scene:lguild();
			end
		elseif 4 == tag then
			show_quick();
		elseif 5 == tag then
			--g_scene:rank();
			--g_scene:go(GUI_RANK, "rank");
			g_scene:rank();
		elseif 6 == tag then
			--show_lottery();
			show_mail();
			--g_scene:mail();
		elseif 7 == tag then
			local layer, name = layer_lwait:create();
			g_scene:add_layer(ZORDER_LAYER_LWAIT, layer, name, true);
			layer_lwait.callback_reload();
		elseif 21 == tag then
			--g_scene:go(GUI_HERO, "hero");
			g_scene:hero();
		elseif 22 == tag then
			--g_scene:go(GUI_MYDECK, "mydeck");
			g_scene:mydeck();
		elseif 23 == tag then
			--g_scene:go(GUI_PIECE, "piece");
			g_scene:piece();
		elseif 24 == tag then
			--logout();
			g_scene:option();
		elseif 25 == tag then
			--g_scene:go(GUI_MYSTERY, "mystery");
			g_scene:mystery();
		elseif 26 == tag then
			g_scene:shop();
		elseif 27 == tag then
			show_notice();
		elseif 28 == tag then
			g_scene:book();
		elseif 29 == tag then
			local layer, name = layer_lroom:create();
			g_scene:add_layer(ZORDER_LAYER_LROOM, layer, name, true);
			net_send('lchan', true);
		elseif 30 == tag then
			get_friend_list();
		elseif 97 == tag then
			--show_service();
		elseif 98 == tag then
		elseif 99 == tag then
			--g_scene:option();
			--show_gate();
		end
	end,

	add_color_layer = function(self)
		local fullrect = cc.rect(0, 0, 64, 64);
		local insetrect = cc.rect(6, 6, 52, 52);
		local realsize = cc.size(FULL_WIDTH, FULL_HEIGHT);
		local pos = cc.p(0, 0);
		local fullpath = util.get_fullpath(F_IMAGE, 'bg_main_color.png');

		util.add_scale9sprite(self.layer, fullpath, pos, ANCHOR_LEFT_DOWN, fullrect, insetrect, realsize, 0); 

		fullpath = util.get_fullpath(F_PARTICLE, 'bg_main.plist');
		pos = ccp(HALF_WIDTH, HALF_HEIGHT);
		util.add_particle(self.layer, fullpath, pos, 2);
	end,

	not_enough_level = function(...)
		local args = {...};
		local index = args[2]:getTag();
		show_msg(index .. '级开启');
	end,

	callback_tap = function(...)
		local self = layer_map;
		play_tap_3();
		local args = {...};
		local index = args[2]:getTag();
		if 1 == index then
			show_service();
		elseif 2 == index then
			show_gate();
		elseif 3 == index then
			local layer, name = layer_lroom:create();
			g_scene:add_layer(ZORDER_LAYER_LROOM, layer, name, true);
			net_send('lchan', true);
		elseif 4 == index then
			get_friend_list();
		elseif 5 == index then
			--g_scene:go(GUI_DECK, "deck");
			g_scene:deck();
		elseif 6 == index then
			--g_scene:shop();
			show_lottery();
		end
	end,

	handler = function(event, x, y)
		local self = layer_map;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
			-- kelton: int win32, cannot add a loading view while onEnter
			net_send('sta', true);
			util.upload_tutor();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			if nil ~= layer_quick.layer then
				layer_quick.callback_return();
				return;
			end
			if nil ~= layer_solo.layer then
				layer_solo.callback_return();
				return;
			end
			if nil ~= layer_lock.layer then
				layer_lock.close();
				return;
			end
			if nil ~= layer_lroom.layer then
				layer_lroom.callback_return();
				return;
			end
			if nil ~= layer_findfrd.layer then
				layer_findfrd:remove();
				return;
			end
			if nil ~= layer_friend.layer then
				layer_friend.callback_return();
				return;
			end
--			local s = '是否要登出';
--			g_scene:add_layer(ZORDER_LAYER_TIP,layer_tip:create(s, logout));
			if is_ver(VER_UCSDK) then
				UCSdkHandler:destroyFloatButton();
				UCSdkHandler:exitSDK();
			elseif is_ver(VER_LJSDK) then
				LJSdkImpl:exit(layer_net.layer);
			else
				ask_exit();
			end
		end
	end,

	onTouchBegan = function (self, x, y)
		self.is_scroll = false;
		if nil == self.bg then return; end
		self.sx = self.bg:getPositionX();
		self.touch_x = x;
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		if nil == self.bg then return; end
		local offset = x - self.touch_x;
		local nx = self.sx;
		if math.abs(offset) > 20 then
			local bx = self.bg:getPositionX();
			nx = nx + offset;
			if nx > 0 then
				nx = 0;
			elseif nx + self.bg_width < FULL_WIDTH then
				nx = FULL_WIDTH - self.bg_width;
			end
			self.bg:setPositionX(nx);
			self.is_scroll = true;
		end
	end,
	
	onTouchEnded = function(self, x, y)
		if nil == self.bg then return; end
		if true == self.is_scroll then return; end
		local tag = self:check_tap(x, y);
		if -1 == tag then return; end
		self:cb_tap(tag);
		print('layer_map tap tag: ', tag);
	end,

} -- layer_map end

layer_infobar = { -- start
	name = 'layer_infobar',
	layer = nil,
	label_gold = nil,
	label_crystal = nil,
	label_energy = nil,
	to_gold = nil,
	to_crystal = nil,
	to_energy = nil,
	btn_back = nil,

	cleanup = function(self)
		self.layer = nil;
		self.label_gold = nil;
		self.label_crystal = nil;
		self.btn_back = nil;
		self.to_gold = nil;
		self.to_crystal = nil;
		self.to_energy = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();
		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_INFOBAR, self.handler, false);

		local path = util.get_path(FT_1);
		local str;
		gui_add_sprite(self.layer, 'top_bar', GUI_MAIN, ANCHOR_UP);
		str = g_euser.gold;
		self.label_gold = gui_add_labelbmf(self.layer, str, path, 'num_gold', GUI_MAIN, ANCHOR_UP, cc.TEXT_ALIGNMENT_RIGHT);

		str = g_euser.crystal;
		self.label_crystal = gui_add_labelbmf(self.layer, str, path, 'num_crystal', GUI_MAIN, ANCHOR_UP, cc.TEXT_ALIGNMENT_RIGHT);

		str = "/90";
		gui_add_labelbmf(self.layer, str, path, 'num_energy', GUI_MAIN, ANCHOR_UP, cc.TEXT_ALIGNMENT_RIGHT);
		str = get_power();
		self.label_energy = gui_add_labelbmf(self.layer, str, path, 'num_energy', GUI_MAIN, ANCHOR_UP, cc.TEXT_ALIGNMENT_RIGHT);
		self.label_energy:setPositionX(self.label_energy:getPositionX()-wfix(50));

		local items = {};
		local item, data;

		item,data=gui_add_item(items, 'btn_gold', GUI_MAIN, self.get_gold, ANCHOR_UP);
		item,data=gui_add_item(items, 'btn_crystal', GUI_MAIN, self.get_crystal, ANCHOR_UP);
		--item,data=gui_add_item(items, 'btn_energy', GUI_MAIN, self.get_energy, ANCHOR_UP);

		util.add_menu(self.layer, items, data.zorder);

		return self.layer, self.name;

	end,

	update_info = function(self, no_eff)
		--self.layer:unscheduleUpdate();
		if nil == self.layer then return; end
		self.to_gold = g_euser.gold;
		self.to_crystal = g_euser.crystal;
		self.to_energy = math.floor(g_euser.power);
		if true == no_eff then
			self.label_gold:setString(self.to_gold);
			self.label_crystal:setString(self.to_crystal);
			self.label_energy:setString(self.to_energy);
			return;
		end
		local tg = tonumber(self.label_gold:getString()) or 0;
		local tc = tonumber(self.label_crystal:getString()) or 0;
		local te = tonumber(self.label_energy:getString()) or 0;
		if self.to_gold==tg and self.to_crystal==tc and self.to_energy==te then
			return;
		end
		--self.layer:scheduleUpdateWithPriorityLua(self.update_number, 1);
		local function fly(s, tx, delay, label, vchange, vset)
			local x, y = s:getPosition();
			local c1, c2, ep, bezier, action;
			local t = math.random(1, 5+delay*10)/10;
			local array = {};
			local ll = {};
			ep = cc.p(tx, FULL_HEIGHT-wfix(28));
			if vchange > 0 then
				c1 = cc.p(wfix(100), y);
				c2 = cc.p(tx-wfix(35), FULL_HEIGHT-wfix(60));
				bezier = { c1, c2, ep };
				action = cc.BezierTo:create(t, bezier);
				action = cc.EaseIn:create(action, t);
				table.insert(array, action);
			else
				s:setPosition(ep);
				table.insert(array, cc.DelayTime:create(t/2));
			end
			action = cc.ScaleTo:create(0.3, 1.4);
			table.insert(ll, action);
			action = cc.FadeOut:create(0.3);
			table.insert(ll, action);
			action = cc.Spawn:create(ll);
			table.insert(array, action);
			local function cb_vchange()
				label:setString((tonumber(label:getString()) or 0)+vchange);
			end
			local function cb_vset()
				label:setString(vset);
			end
			if nil == vset then
				table.insert(array, cc.CallFunc:create(cb_vchange));
			else
				table.insert(array, cc.CallFunc:create(cb_vset));
			end
			table.insert(array, cc.CallFunc:create(callback_remove_sprite));
			s:runAction(cc.Sequence:create(array));
		end
		local path, pos, s, c;
		local list = {};
		if self.to_gold ~= tg then
			table.insert(list, {
				label = self.label_gold,
				path = util.get_path("icon_69.png"),
				tx = wfix(195),
				to_v = self.to_gold,
				v = tg,
			});
		end
		if self.to_crystal ~= tc then
			table.insert(list, {
				label = self.label_crystal,
				path = util.get_path("icon_70.png"),
				tx = wfix(397),
				to_v = self.to_crystal,
				v = tc,
			});
		end
		if self.to_energy ~= te then
			table.insert(list, {
				label = self.label_energy,
				path = util.get_path("icon_80.png"),
				tx = wfix(595),
				to_v = self.to_energy,
				v = te,
			});
		end
		local fx = HALF_WIDTH;
		local fy = FULL_HEIGHT/4*3;
		for i = 1, #list do
			local info = list[i];
			local label = info.label;
			local path = info.path;
			local tx = info.tx;
			local to_v = info.to_v;
			local v = info.v;
			local offset = to_v - v;
			local c = math.floor(math.abs(offset)/5);
			if c < 1 then c = 1; end
			if c > 10 then c = 10; end
			local vchange = math.floor(offset/c);
			for i = 1, c do
				local pos = cc.p(fx, fy);
				local s = util.add_sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, 100);
				local vset = nil;
				if i == c then
					vset = to_v;
				end
				fly(s, tx, (i-1)*0.2, label, vchange, vset);
			end
		end
	end,

	update_number = function(...)
		local self = layer_infobar;
		local args = {...};
		local tg = tonumber(self.label_gold:getString()) or 0;
		local tc = tonumber(self.label_crystal:getString()) or 0;
		local te = tonumber(self.label_energy:getString()) or 0;
		if tg==self.to_gold and tc==self.to_crystal and te==self.to_energy then
			self.layer:unscheduleUpdate();
			return;
		end
		local list = {};
		table.insert(list, {
			label = self.label_gold,
			offset = self.to_gold - tg,
			v = tg,
		});
		table.insert(list, {
			label = self.label_crystal,
			offset = self.to_crystal - tc,
			v = tc,
		});
		table.insert(list, {
			label = self.label_energy,
			offset = self.to_energy - te,
			v = te,
		});
		for i = 1, #list do
			local info = list[i];
			local label = info.label;
			local offset = info.offset;
			local v = info.v;
			if offset ~= 0 then
				local gap = math.floor(offset/2);
				if math.abs(gap) < 1 then 
					gap = math.floor(offset/math.abs(offset)); 
				end
				local str = v + gap;
				label:setString(str);
			end
		end
	end,

	get_gold = function()
		local layer, name = layer_exchange:create();
		g_scene:add_layer(ZORDER_LAYER_EXCHANGE, layer, name, true);
	end,
	
	get_crystal = function()
		go_pay();
	end,

	get_energy = function()
	end,
	
	handler = function(event, x, y)
		local self = layer_infobar;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)

	end,

} -- layer_infobar end

layer_bottombar = { -- start    
	name = 'layer_bottombar',
	layer = nil,
	cwidth = nil,
	chegiht = nil,
	can_touch = nil,
	icon_scale = nil,
	range = nil,
	clarrow = nil,
	crarrow = nil,
	twidth = nil,
	toffset = nil,
	title_color = nil,
	title_scolor = nil,
	tableview = nil,
	--markx = nil,
	touchend = nil,
	bicondata = nil,

	cleanup = function(self)
		self.layer = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.can_touch = nil;
		self.icon_scale = nil;
		self.range = nil;
		self.clarrow = nil;
		self.crarrow = nil;
		self.twidth = nil;
		self.title_color = nil;
		self.title_scolor = nil;
		self.tableview = nil;
		--self.markx = nil;
		self.touchend = nil;
		self.bicondata = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.can_touch = true;
		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_BOTTOMBAR, self.handler, true);

		local path, pos, data, scale, sprite;
		--sprite,data = gui_add_sprite(self.layer,'bg_bottom',GUI_MAIN,ANCHOR_DOWN);
		gui_add_sprite(self.layer,'bottombar_cover',GUI_MAIN,ANCHOR_DOWN);

		data = gui_get_data('b1_text', GUI_MAIN, ANCHOR_DOWN);
		self.title_color = cc.c4b(data.r, data.g, data.b, 255);
		self.title_scolor = cc.c4b(data.sr, data.sg, data.sb, 255);

		self.bicondata = gui_get_data('bg_bottom_icon', GUI_MAIN, ANCHOR_DOWN);
		
		data,scale = gui_get_data('area_bottom', GUI_MAIN, ANCHOR_DOWN);
		self.icon_scale = scale;
		self.range = { y1 = data.y, y2 = data.y + data.height };

		self.list = {
			{ name = '排行榜', icon = 'icon_8', tag = 1, limit = 1 },
			{ name = '信件', icon = 'icon_39', tag = 10, limit = 1},
			{ name = '竞技场', icon = 'icon_prank', tag = 9, limit = 1},
			{ name = '公会', icon = 'icon_20', tag = 6, limit = 1 },
			--{ name = '比赛', icon = 'icon_34', tag = 8, limit = 1 },
			{ name = '公告', icon = 'icon_11', tag = 4, limit = 1 },
			{ name = '选项', icon = 'icon_12', tag = 5, limit = 1 },
		};
		if false == is_ver(VER_APPSTORE) and false == is_ver(VER_UCSDK) and false == is_anysdk_oppo() then
			local l = { name = '论坛', icon = 'icon_9', tag = 2, limit = 1 };
			--table.insert(self.list, 2, l);
			table.insert(self.list, l);
		end
		if false == is_ver(VER_UCSDK) then
			local l = { name = '客服', icon = 'icon_10', tag = 3, limit = 1 };
			--table.insert(self.list, 3, l);
			table.insert(self.list, l);
		end
		if true == DEBUG_MODE or is_ver(VER_APAY) or is_ver(VER_APPSTORE) or is_anysdk_show_pay() or is_ver(VER_UCSDK) or is_ver(VER_LJSDK) then
			local l = { name = '充值', icon = 'icon_19', tag = 7, limit = 1 };
			table.insert(self.list, 4, l);
		end

		pos = ccp(data.x, data.y);
		local size = cc.size(data.width, data.height);
		self.cwidth = size.width/5;
		--self.cwidth = self.bicondata.width;
		self.cheight = size.height;
		self.twidth = size.width;
		pos = cc.p(data.x, data.y);
		local toffset = self.toffset;
		local tv = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		self.tableview = tv;
		tv:setBounceable(false);
		self.clarrow, self.crarrow = util.add_arrows(self.layer, pos, size, self.cwidth, #self.list, cc.p(0, 0));
		if nil ~= toffset then
			tv:setContentOffset(toffset);
		end

		return self.layer, self.name;

	end,

	set_show = function(self, is_visible)
		if nil == self.layer then
			return;
		end
		self.can_touch = is_visible;
		self.layer:setVisible(is_visible);
	end,

	callback_tap = function(self, info)
		if nil == info then
			return;
		end
		if true ~= self.can_touch then
			return;
		end
		play_tap_2();
		local index = info.tag;
		if 1 == index then
			g_scene:rank();
		elseif 2 == index then
			if true ~= is_ver(VER_ANYSDK)
			or 930 ~= tonumber(AgentManager:getInstance():getChannelId() or "0") then
				util.open_url("http://www.17kapai.com/forum-134-1.html");
			else
				util.open_url('http://bbs.youxiqun.com');
			end
		elseif 3 == index then
			g_scene:gm();
		elseif 4 == index then
			show_notice();
		elseif 5 == index then
			g_scene:option();
		elseif 6 == index then
			if true == g_euser:has_guild() then
				net_send('guild');
			else
				g_scene:lguild();
			end
		elseif 7 == index then
			go_pay();
		elseif 8 == index then
			show_match();
		elseif 9 == index then
			g_scene:prank();
		elseif 10 == index then
			g_scene:mail();
		end
	end,

	add_to_list = function(self, list)
		self.etable:insert_list(list);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_bottombar;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			self.toffset = view:getContentOffset();
			util.handle_arrows(self.clarrow, self.crarrow, #self.list, self.cwidth, self.twidth, self.toffset);
			if true == self.touchend then
				local toffset = self.toffset;
				self.touchend = nil;
				print('on touch end');
				local tx = toffset.x; --self.markx or 0;
				local p = math.floor(math.abs(tx) / self.cwidth);
				local p2 = math.floor(math.abs(tx)) % self.cwidth;
				if p2 > self.cwidth/2 then
					p = p + 1;
				end
				if p >= #self.list then
					p = #self.list - 1;
				end
				toffset.x = - (p * self.cwidth);
				self.tableview:setContentOffset(toffset, true);
			end
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.list[idx + 1];
			local limit = info.limit;
			if true ~= DEBUG_MODE and g_euser.level < limit then
				show_msg(limit .. '级开启');
				return;
			end
			self:callback_tap(info);
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight ,self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local info = self.list[idx + 1];
			local name = info.name or '';
			local limit = info.limit;
			local icon = info.icon;
			local fname, path, pos;
			--[[
			path = util.get_path('btn_9.png');
			pos = cc.p(width/2, height/2);
			sprite = util.add_sprite(cell, path, pos, ANCHOR_CENTER_CENTER, 1);
			sprite:setTag(TAG_CELL_BG);
			sprite:setScale(self.icon_scale);
			]]--
			path = util.get_path(self.bicondata.fname1);
			pos = cc.p(width/2, height/2);
			sprite = util.add_sprite(cell, path, pos, ANCHOR_CENTER_CENTER, 8);
			sprite:setTag(TAG_CELL_BG);
			sprite:setScale(self.icon_scale);

			if true ~= DEBUG_MODE and g_euser.level < limit then
				path = util.get_path('icon_15.png');
			else
				fname = icon .. '.png';
				path = util.get_path(fname);
			end
			pos = cc.p(width/2, height/2+5*self.icon_scale);
			sprite = util.add_sprite(cell, path, pos, ANCHOR_CENTER_CENTER, 10);
			--sprite:setTag(TAG_CELL_BG);
			sprite:setScale(self.icon_scale);

			pos = cc.p(width/2, 0);
			local label = util.add_labeloutline(cell, name, nil, 25, pos, self.title_color, self.title_scolor, 2, ANCHOR_CENTER_DOWN, 30);
			label:setScale(self.icon_scale);
			
			--[[
			fname = 'label_' .. string.sub(icon, 6, string.len(icon)) .. '.png';
			fullpath = util.get_fullpath(F_IMAGE, fname);
			pos = cc.p(self.cwidth/2, self.cheight/2 - 50*self.icon_scale);
			sprite = util.add_sprite(cell, fullpath, pos, ANCHOR_CENTER_DOWN);
			sprite:setTag(TAG_CELL_LABEL);
			sprite:setScale(self.icon_scale);
			]]--
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.list[idx + 1];
			local limit = info.limit;
			local icon = info.icon;
			local sprite = cell:getChildByTag(TAG_CELL_BG);
			if nil ~= sprite then
				local path = util.get_path(self.bicondata.fname2);
				local tc = cc.Director:getInstance():getTextureCache();
				local texture = tc:addImage(path);
				if nil == texture then return; end
				sprite:setTexture(texture);
			end
			--[[
			local sprite = cell:getChildByTag(TAG_CELL_LABEL);
			if nil ~= sprite then
				local fname = 'label_' .. string.sub(icon, 6, string.len(icon)) .. '_s.png';
				local fullpath = util.get_fullpath(F_IMAGE, fname);
				local tc = cc.Director:getInstance():getTextureCache();
				local texture = tc:addImage(fullpath);
				if nil == texture then return; end
				sprite:setTexture(texture);
			end
			]]--
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.list[idx + 1];
			local limit = info.limit;
			local icon = info.icon;
			local sprite = cell:getChildByTag(TAG_CELL_BG);
			if nil ~= sprite then
				local path = util.get_path(self.bicondata.fname1);
				local tc = cc.Director:getInstance():getTextureCache();
				local texture = tc:addImage(path);
				if nil == texture then return; end
				sprite:setTexture(texture);
			end
			--[[
			local sprite = cell:getChildByTag(TAG_CELL_LABEL);
			if nil ~= sprite then
				local fname = 'label_' .. string.sub(icon, 6, string.len(icon)) .. '.png';
				local fullpath = util.get_fullpath(F_IMAGE, fname);
				local tc = cc.Director:getInstance():getTextureCache();
				local texture = tc:addImage(fullpath);
				if nil == texture then return; end
				sprite:setTexture(texture);
			end
			]]--
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_bottombar;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		if y > self.range.y2 or y < self.range.y1 then
			return false;
		end
		if true ~= self.can_touch then
			return false;
		end
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		--if nil == self.tableview then return; end
		--self.markx = self.tableview:getContentOffset().x;
	end,
	
	onTouchEnded = function(self, x, y)
		if nil == self.tableview then return; end
		--self.markx = self.tableview:getContentOffset().x;
		self.touchend = true;
		--[[
		print('on touch end');
		if nil == self.tableview then return; end
		local toffset = self.tableview:getContentOffset();
		--print('---touch end--- x: ', toffset.x, self.cwidth);
		--local tx = toffset.x;
		local tx = self.markx or 0;
		local p = math.floor(math.abs(tx) / self.cwidth);
		toffset.x = - (p * self.cwidth);
		print('---touch end--- p, x: ', p, toffset.x);
		self.tableview:setContentOffset(toffset, true);
		--self.tableview:setContentOffsetInDuration(toffset, 0.1);
		]]--

	end,

} -- layer_bottombar end

layer_chat = { -- start
	name = 'layer_chat',
	lchannel = {
		{ name = 'C_ALL', tag = C_ALL },
		{ name = 'C_WORLD', tag = C_WORLD },
		--{ name = 'C_ROOM', tag = C_ROOM },
		{ name = 'C_GUILD', tag = C_GUILD },
		{ name = 'C_PRIVATE', tag = C_PRIVATE },
		--{ name = 'C_LOG', tag = C_LOG },  			
	};
	chat_cwidth = nil,
	chat_cheight = nil,
	data_cell = nil,
	channel_cwidth = nil,
	channel_cheight = nil,
	channel_twidth = nil,
	data_tab = nil,
	layer = nil,
	chat_target = nil,
	channeltags = {},
	chat_view = nil,
	tchannel = nil, -- channel tab table view
	channel_speak = nil,
	channel_btn = nil,
	input_bar = nil,
	full_btn = nil,
	current_tab = nil,
	list = {},
	chat_view_height = 0,
	editlabel = nil,
	editrect = nil,
	editbox = nil,
	bg_chat = nil,
	clarrow = nil, -- channel left arrow
	crarrow = nil, -- channel right arrow
	twidth = nil, -- channel tableview width
	bar = nil,
	tap = nil,
	tpoint = nil,
	guest_list = nil,
	sprite_icon = nil,
	icon_vip = nil,
	icon_alias = nil,
	data_guest = nil,

	cleanup = function(self)
		self.layer = nil;
		self.chat_cwidth = nil;
		self.chat_cheight = nil;
		self.data_cell = nil;
		self.channel_cwidth = nil;
		self.channel_cheight = nil;
		self.channel_twidth = nil;
		self.data_tab = nil;
		self.channeltags = {};
		self.chat_view = nil;
		self.tchannel = nil;
		self.channel_speak = nil;
		self.channel_btn= nil;
		self.input_bar = nil;
		self.full_btn = nil;
		self.current_tab = nil;
		self.list = {};
		self.chat_view_height = 0;
		self.editlabel = nil;
		self.editrect = nil;
		self.editbox = nil;
		self.bg_chat = nil;
		self.clarrow = nil;
		self.crarrow = nil;
		self.twidth = nil;
		self.bar = nil;
		self.tap = nil;
		self.tpoint = nil;
		self.guest_list = nil;
		self.sprite_icon = nil;
		self.icon_vip = nil;
		self.icon_alias = nil;
		self.data_guest = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, is_battle)
		self:remove();
		self.list = {};
		self.layer = cc.Layer:create();

		--if g_scene:is_battle() then
		self.lchannel = {
			{ name = 'C_ALL', tag = C_ALL },
			{ name = 'C_WORLD', tag = C_WORLD },
			--{ name = 'C_ROOM', tag = C_ROOM },
			{ name = 'C_GUILD', tag = C_GUILD },
			{ name = 'C_PRIVATE', tag = C_PRIVATE },
			--{ name = 'C_LOG', tag = C_LOG },  			
		};
		util.reg_handler(self.layer, -ZORDER_LAYER_CHAT, self.handler, true);
		if true == is_battle then
			table.insert(self.lchannel, 2, { name = 'C_ROOM', tag = C_ROOM });
			self:init_chat_view(GUI_BCHAT, C_ROOM, C_ROOM);
		elseif nil ~= layer_room.layer then
			table.insert(self.lchannel, 2, { name = 'C_ROOM', tag = C_ROOM });
			self:init_chat_view(GUI_CHAT, C_ROOM, C_ROOM);
		else
			self:init_chat_view(GUI_CHAT, C_ALL, C_WORLD);
		end

		return self.layer, self.name;

	end,

	back = function()
		local self = layer_chat;
		self:remove();
	end,

	init_chat_view = function(self, ltype, default_channel, default_input)
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		local sprite, data, pos, size;
		local offsetheight = init_bg_pop(self.layer, ltype, '聊天', self.back, nil, true);
		self.rect = rect;

		sprite, data = gui_add_sprite(self.layer, 'bg_table', ltype, ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));
		sprite, data = gui_add_sprite(self.layer, 'shader', ltype, ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));

		-------- channel list start ------
		data = gui_get_data('tab_cell', ltype, ANCHOR_UP);
		self.data_tab = data;
		self.channel_cwidth = data.width;
		self.channel_cheight = data.height;
		data = gui_get_data('tab_table', ltype, ANCHOR_UP);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height);
		self.channel_twidth = size.width;
		self.tchannel = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_channel_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		self:change_channel(default_channel);
		self.clarrow, self.crarrow = util.add_arrows(self.layer, pos, size, self.channel_cwidth, #self.lchannel, cc.p(0, 0));
		-------- channel list end ------
		-------- chat msg list start ------
		data = gui_get_data('cell', ltype, ANCHOR_DOWN);
		self.data_cell = data;
		self.chat_cwidth = data.width;
		self.chat_cheight = data.height;
		data = gui_get_data('table', ltype, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height+offsetheight);
		self.chat_view_height = size.height;
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.chat_view = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);
		-------- chat msg list end ------
		-------- input bar start ------
		local items = {};
		local item;

		--[[
		item, data = gui_add_item(items, 'btn_send', ltype, self.send_chat, ANCHOR_DOWN);
		util.add_text_to_sprite_by_data(item, data, "发送", 25, 2);
		]]--

		item, data = gui_add_item(items, 'btn_channel', ltype, self.callback_channel, ANCHOR_DOWN);
		util.add_stroke_to_sprite_by_data(item, data, "", 25, 2);
		self.channel_btn = item;
		self:handle_channel_btn(default_input);

		util.add_menu(self.layer, items, data.zorder);

		gui_add_sprite(self.layer, 'bg_input', ltype, ANCHOR_DOWN);

		self.editbox, data = gui_add_editbox(self.layer, 't_input', ltype, ANCHOR_DOWN, 22, self.edit_box_handler, 60, t_lang("CHAT_TIP_ENTER"));
		self.editbox:setVisible(false);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height);
		self.editlabel = util.add_labelttf(self.layer, t_lang("CHAT_TIP_ENTER"), nil, 25, pos, cc.c4b(data.r, data.g, data.b, 255), ANCHOR_LEFT_DOWN, data.zorder, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_CENTER); 
		self.editrect = { x1= pos.x, x2 = pos.x + size.width,
						  y1= pos.y, y2 = pos.y + size.height }; 
		-------- input bar end ------
		if ltype == GUI_BCHAT then
			self:set_guest_view();
		end
	end,

	set_guest_view = function(self)
		local gnum = 0;
		self.guest_list = {};
		if nil ~= g_euser.room_data then
			local lindex = 3;
			local l = g_euser.room_data.guest_list or {};
			for i = lindex, #l do
				table.insert(self.guest_list, l[i]);
			end
			gnum = #l -  lindex + 1;
		end
		local path, str;
		local ltype = GUI_BCHAT;
		gui_add_sprite(self.layer, 'g_bg', ltype, ANCHOR_UP);
		gui_add_sprite(self.layer, 'g_bg_title', ltype, ANCHOR_UP);
		gui_add_label(self.layer, '观战人数:', 24, 'g_title', ltype, ANCHOR_UP);
		path = util.get_path(FT_4);
		str = '' .. gnum;
		gui_add_labelbmf(self.layer, str, path, 'g_num', ltype, ANCHOR_UP);
		-------- guest list start ------
		data = gui_get_data('g_cell', ltype, ANCHOR_UP);
		data.height = data.height + 5;
		self.data_guest = data;
		data = gui_get_data('g_table', ltype, ANCHOR_UP);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height);
		util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.guest_tv_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);
		-------- chat msg list end ------
	end,

	guest_tv_handler = function(...)  -- { start
		local self = layer_chat;
		local args = {...};
		local event = args[1];
		local view = args[2];
		if "numberOfCellsInTableView" == event then
			return #(self.guest_list or {});
		elseif "scrollViewDidScroll" == event then
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.guest_list[idx + 1];
			g_scene:add_layer(ZORDER_LAYER_CHATPOP, layer_chatpop:create(info));
			return 0;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			local data = self.data_guest;
			return data.height, data.width;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local data = self.data_guest;
			local width = data.width;
			local height = data.height;
			local info = self.guest_list[idx + 1];
			local alias = info.alias;
			local icon = info.icon;
			print('hi', idx);

			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'g_icon', GUI_BCHAT, ANCHOR_UP);
			path = get_icon_path(icon);
			size = sprite:getContentSize();
			sprite = util.add_sprite(sprite, path,cc.p(size.width/2,size.height/2),ANCHOR_CENTER_CENTER,-1);
			sprite:setScale((size.width-10)/sprite:getContentSize().width);

			local str = string.format("%s", alias);
			gui_add_label_on_cell(cell,data,str,25,'g_name',GUI_BCHAT,ANCHOR_UP);

			return cell;
		end
	end, -- tableview_handler end }

	tableview_handler = function(...)  -- { start
		local self = layer_chat;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.list[idx+1];
			if nil == info then return; end
			if info.eid == g_euser.eid then return; end
			if tonumber(info.eid) == 1501 then return; end
			g_scene:add_layer(ZORDER_LAYER_CHATPOP, layer_chatpop:create(info));
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.chat_cheight, self.chat_cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local data = self.data_cell;
			local width = self.chat_cwidth;
			local height = self.chat_cheight;
			local info = self.list[idx + 1];
			local channel = self:channel_name(info.channel);
			local eid = info.eid;
			local alias = info.alias;
			local msg = info.msg;
			local time = info.time;
			local is_vip = info.is_vip;
			local sprite, data2, path, str, pos, size;

			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'line', GUI_CHAT, ANCHOR_DOWN);

			if true == DEBUG_MODE then
				str = string.format('[%s][(%d)%s][%s]:',channel,eid, alias, time);
			else
				str = string.format('[%s][%s][%s]:',channel, alias, time);
			end
			sprite, data2 = gui_add_label_on_cell(cell, data, str, 20, 't_name', GUI_CHAT, ANCHOR_DOWN);
			if info.channel == C_PRIVATE then
				sprite:setTextColor(cc.c4b(50, 213, 242, 255));
			elseif info.channel == C_GUILD then
				sprite:setTextColor(cc.c4b(247, 177, 9, 255));
			end
			if is_vip == 1 then
				sprite:setPositionX(data2.x+wfix(50));
				path = util.get_path('pic_59.png');
				pos = ccp(data2.x, data2.y);
				util.add_sprite(cell, path, pos, ANCHOR_LEFT_DOWN);
			end

			str = string.format('%s', msg);
			sprite, data2 = gui_add_label_on_cell(cell, data, str, 20, 't_detail', GUI_CHAT, ANCHOR_DOWN);
			return cell;
		end
	end, -- tableview_handler end }

	tableview_channel_handler = function(...)  -- { start
		local self = layer_chat;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.lchannel or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_arrows(self.clarrow, self.crarrow, #self.lchannel, self.channel_cwidth, self.channel_twidth, view:getContentOffset());
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			play_tap_1();
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.lchannel[idx + 1];
			local tag = info.tag;
			local x, y = view:getContentOffset();
			self:change_channel(tag);
			view:setContentOffset(cc.p(x, y), false);
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.channel_cheight, self.channel_cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local data = self.data_tab;
			local width = self.channel_cwidth;
			local height = self.channel_cheight;
			local info = self.lchannel[idx + 1];
			local tag = info.tag;
			local name = t_lang(info.name);
			--local data = gui_get_data('btn_chat_all', GUI_MAIN);
			local path, filename, pos, sprite, size;
			sprite = gui_add_cell_bg(cell, data);
			pos = cc.p(width/2, height/2);
			local findex = idx + 1;
			if findex == C_LOG then
				findex = 99;
			end
			if self.current_tab == tag then
				--filename = string.format("btn_1_s.png");
				--filename = data.fname2;
				path = util.get_path(data.fname2);
				local tc = cc.Director:getInstance():getTextureCache();
				local texture = tc:addImage(path);
				if nil == texture then return; end
				sprite:setTexture(texture);
			--else
				--filename = string.format("btn_1.png");
				--filename = data.fname1;
			end
			util.add_text_to_sprite_by_data(sprite, data, name, 25);
			--path = util.get_path(filename);
			--sprite = util.add_sprite(cell, path, pos, ANCHOR_CENTER_CENTER, 1);

			--[[
			pos = cc.p(width/2, height/2);
			size = cc.size(width, height);
			local color = cc.c4b(data.r, data.g, data.b, 255);
			local scolor = cc.c4b(data.sr, data.sg, data.sb, 255);
			--util.add_label(sprite, name, 25, pos, util.c_white, ANCHOR_LEFT_DOWN, nil, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
			util.add_labeloutline(cell, name, nil, 25, pos, color, scolor, 2, ANCHOR_CENTER_CENTER, 5);
			]]--
			return cell;
		end
	end, -- tableview_channel_handler end }

	handle_channel_btn = function(self, channel)
		local item = self.channel_btn;
		self.channel_speak = channel;
		local name = self:channel_name(channel);
		if nil == item then
			return;
		end
		local label = item:getChildByTag(TAG_SPRITE_LABEL);
		if nil ~= label then
			label:setString(name);
		end
		--util.add_text_outline_to_sprite(item, name, 25, cc.c4b(255, 208, 1, 255), cc.c4b(30, 24, 60, 255), 1);
		if nil == self.editbox then
			return;
		end
		local ph = t_lang("CHAT_TIP_ENTER");
		if channel == C_PRIVATE and nil ~= self.chat_target then
			ph = string.format("(%s)%s", self.chat_target.alias, ph);
		end
		self.editbox:setPlaceHolder(ph);
		self.editlabel:setString(ph);
	end,

	callback_channel = function()
		play_tap_1();
		local self = layer_chat;
		local channel = self.channel_speak or (C_WORLD - 1);
		channel = channel + 1;
		if g_euser.st < ST_ROOM and channel == C_ROOM then
			channel = channel + 1;
		end
		if channel == C_GUILD and (g_euser.gid <= 0 or g_euser.gpos == GUILD_POS_APPLY) then
			channel = channel + 1;
		end
		if channel == C_LOG then
			channel = channel + 1;
		end
		if channel >= C_LOG + 1 then -- no need to be C_LOG
			channel = C_WORLD;
		end
		self:handle_channel_btn(channel);
	end,

	channel_name = function(self, tag)
		local str = '';
		if tag == C_ALL then
			str = str .. t_lang("C_ALL");
		elseif tag == C_WORLD then
			str = str .. t_lang("C_WORLD");
		elseif tag == C_ROOM then
			str = str .. t_lang("C_ROOM");
		elseif tag == C_GUILD then
			str = str .. t_lang("C_GUILD");
		elseif tag == C_PRIVATE then
			str = str .. t_lang("C_PRIVATE");
		elseif tag == C_LOG then
			str = str .. t_lang("C_LOG");
		else
			str = str .. '???';
		end

		return str;
	end,

	callback_channeltag = function(...)
		local self = layer_chat;
		local args = {...};
		local index = args[2]:getTag();
		self:change_channel(index);
	end,

	refresh_list = function(self)
		local table_view = self.chat_view;
		if nil == table_view then
			return;
		end
		table_view:reloadData();
		if self.chat_cheight * #self.list <= self.chat_view_height then
			return;
		end
		local offsetx, offsety = table_view:getContentOffset();
		offsety = table_view:getContentSize().height-self.chat_cheight*#self.list;
		local offset = cc.p(offsetx, offsety);
		local animated = false;
		table_view:setContentOffset(offset, animated);
	end,

	change_channel = function(self, tag)
		self.current_tab = tag;
		self.tchannel:reloadData();
		self.list = g_chat_list[self.current_tab];
		self:refresh_list();
	end,

	refresh = function(self)
		if nil == self.layer then
			return;
		end
		self.current_tab = self.current_tab or C_WORLD;
		self.list = g_chat_list[self.current_tab];
		self:refresh_list();
	end,

	add_msg = function(self, msg)
		local channel = self.channel_speak or C_WORLD;
		if nil == msg or '' == msg then
			return;
		end
		msg = util.replace_sensitive_data(msg);
		local cmd = '';
		--msg = msg or '???';
		if C_WORLD == channel then
			cmd = 'wchat ' .. msg;	
		elseif C_ROOM == channel then
			if 'show_local_version' == msg then
				-- for debug
				add_chat_msg(C_LOG, -1, '本地', string.format('seed [%s], logic_version [%s]', g_seed, LOGIC_VERSION), get_time());
				--
			elseif 'savebug' == msg then
				-- for debug
				save_bug();
				--
			end
			cmd = 'rchat ' .. msg;
		elseif C_GUILD == channel then
			local gid = g_euser.gid or 0;
			local gpos = g_euser.gpos or GUILD_POS_NONE;
			if 0 >= gid or gpos == GUILD_POS_APPLY then
				add_chat_msg(C_GUILD, -1, '本地', string.format('未加入公会，不能发言'), get_time());
				return;
			end
			cmd = 'gchat ' .. msg;
		elseif C_PRIVATE == channel then
			if nil == self.chat_target then
				return;
			end
			local eid = self.chat_target.eid;
			--local alias = self.chat_target.alias;
			cmd = string.format("fchat %d %s", eid, msg);
		elseif C_LOG == channel then
			cmd = msg;
		end
		if true == g_scene:is_online() then
			net_send(cmd);
		end
	end,

	is_legal = function(self, str)
		-- trim white space
		str = string.gsub(str, "%s", "");
		if 0 == string.len(str) then
			return false;
		end
		return true;
	end,

	edit_box_handler = function(eventname, psender)
		local self = layer_chat;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
			local str = edit:getText();
			str = util.string_cut_by_size(str, 60);
			if true == self:is_legal(str) then
				self:add_msg(str);	
			end
			edit:setText('');
			edit:setVisible(false);
			self.editlabel:setVisible(true);
		elseif eventname == "changed" then
		end

	end,

	send_chat = function()
		local self = layer_chat;
	end,

	handler = function(event, x, y)
		local self = layer_chat;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		self.tpoint = ccp(x, y);
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
		if nil == self.tpoint then
			return;
		end
		x = self.tpoint.x;
		y = self.tpoint.y;
		self.tpoint = nil;
		local t = self.editrect;
		if nil ~= t and x > t.x1 and x < t.x2 and y > t.y1 and y < t.y2 then
			play_tap_3();
			self.editlabel:setVisible(false);
			self.editbox:setVisible(true);
			self.editbox:sendActionsForControlEvents(CCControlEventTouchUpInside);
		end
		local r = self.rect_info;
		if nil == r then
			return;
		end
		if x > r.x1 and x < r.x2 and y > r.y1 and y < r.y2 then
			play_tap_1();
			--[[
			if 0 == is_wait_for_battle() then
				print('is_wait_for_battle');
				g_scene:add_layer(ZORDER_LAYER_INFO, layer_info:create(g_euser));
				return;
			end
			local zorder = ZORDER_LAYER_OTHERINFO;
			g_scene:add_layer(zorder, layer_info:create(g_euser, zorder));
			]]--
			g_scene:add_layer(ZORDER_LAYER_INFO, layer_info:create(g_euser));
			return;
		end
	end,

} -- layer_chat end

layer_debug = {

	create = function(self)



		return self.layer, self.name;
	end,

	clean_texture = function()
		local self = layer_debug;
		local cache = cc.Director:getInstance():getTextureCache();
		cache:removeUnusedTextures();
		string = cache:getCachedTextureInfo();
		local sp = string.find(string, "TextureCache dumpDebugInfo", 1);
		string = string.sub(string, sp, string.len(string));
		self.label_texture:setString(string);
	end,

	test_tutor_intro = function()
		tutor_first_intro();
	end,

	test_tutor_deck = function()
		tutor_tap_mydeck();
	end,

	test_tutor_piece = function()
		tutor_show_piece();
	end,

	debug_function = function()
		g_scene:testlua();
	end,

	debug_card = function()
		local self = layer_debug;
		LOCAL_TEST = true;
		--self.cb_debug_card();
		g_scene:preload(self.cb_debug_card, layer_preload.START, STAGE_PVE);
		--[[
		local c = util.check_file('res_eff.plist');
		if c == true then
			path = "yes";
		else
			path = "no";
		end
		local layer, name = layer_text:create("path", path);
		g_scene:add_layer(ZORDER_LAYER_TEXT, layer, name);
		util.add_particle(layer, path, cc.p(HALF_WIDTH, HALF_HEIGHT), 10);
		]]--
	end,

	cb_debug_card = function()
		g_scene:pve(2);
	end,

	debug_local = function()
		--data_handler:cleanup();
		local self = layer_debug;
		LOCAL_TEST = false;
		-- TODO double time do game will crash
		--self.cb_debug_local()
		g_scene:preload(self.cb_debug_local, layer_preload.START, STAGE_PVE);
	end,

	cb_debug_local = function()
		local deck1_array, deck2_array;
		deck1_array = get_standard_deck_array(15);
		deck2_array = get_standard_deck_array(1);
		g_scene:pve(2, 200, deck1_array, deck2_array, false, 2);
	end,

	debug_c_function = function()
		--g_scene:cdebug();
	end,

	debug_replay = function()
		--g_scene:add_layer(ZORDER_LAYER_REPLAY, layer_replay:create());
	end,

	delete_res = function()
		--[[
		if nil == delete_download_resource then
			CLIENT_PATCH = CLIENT_PATCH_CONSTANT;
			util.save_rms(KEY_PATCH_INDEX, tonumber(CLIENT_PATCH), 'integer');
			local path = cc.FileUtils:getInstance():getWritablePath() .. 'res/';
			local list = KUtils:dfsFolder(path, 0);
			for i = 1, #list do
				local fname = list[i];
				local p = path .. fname;
				KUtils:deleteDownloadDir(p);
			end
			return;
		end
		]]--
		delete_download_resource();
		util.relaunch_game();
	end,

	reload_res = function()
		CLIENT_PATCH = CLIENT_PATCH_CONSTANT or 1;
		util.save_rms(KEY_PATCH_INDEX, tonumber(CLIENT_PATCH), 'integer');
		util.relaunch_game();
	end,

	local_push = function()
		util.set_local_push(os.time()+60, "倒数60秒");
	end,

	clean_iap_record = function()
		local args = { };
		local luaoc = require "luaoc";
		local class_name = "IAPView";
		local ok, ret = luaoc.callStaticMethod(class_name, "cleanIAPrecord",args);
	end,

	test_iap = function()
		local args = { 
		};
		local luaoc = require "luaoc";
		local class_name = "IAPView";
		local ok, ret = luaoc.callStaticMethod(class_name, "testSend",args);
	end,


	win_ai = function()
		local self = layer_debug;
		self:remove();
		net_send("@win");
	end,


	show_pay = function()
		local self = layer_debug;
		self:remove();
		net_send('lpay 1');
	end,

	show_guild = function()
		local self = layer_debug;
		self:remove();
		if true == g_euser:has_guild() then
			net_send('guild');
		else
			g_scene:lguild();
		end
	end,



	test_dres = function()
		--local self = layer_debug;
		--send_dres('card1.png');
	end,


} -- layer_debug

layer_testlua = { -- layer_testlua start
	name = 'layer_testlua',
	layer = nil,
	list = {
		'1 label', '2 card', '3 result', '4 anim', '5 tutorial', '6 horse lamp',
		'7 luajit', '8 richlabel', '9 iap test error receipt', '10 draw',
	},
	cwidth = nil,
	cheight = nil,

	cleanup = function(self)
		self.layer = nil;
		self.cwidth = nil;
		self.cheight = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();
		self.layer = cc.Layer:create();

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 200))

		util.reg_handler(self.layer, -ZORDER_LAYER_TESTLUA, self.handler, true);

		local items = {};
		local item, pos;
		local size = cc.size(172, 52);

		pos = cc.p(0, FULL_HEIGHT);
		item = add_item_1(items, '返回', nil, 20, self.back, ANCHOR_LEFT_UP, pos, size);

		util.add_menu(self.layer, items);

		pos = cc.p(0, 0);
		size = cc.size(FULL_WIDTH, FULL_HEIGHT-100);
		self.cwidth = size.width;
		self.cheight = 100;
		util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, 1);

		return self.layer, self.name;
	end,

	back = function()
		g_scene:login();
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_testlua;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			self:callback_case(idx+1);
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local name = self.list[idx+1];
			local pos = cc.p(0, self.cheight/2);
			util.add_label(cell, name, 40, pos, util.c_white, ANCHOR_LEFT_CENTER, 0, cc.size(self.cwidth, self.cheight), cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
			return cell;
		end
	end, -- tableview_handler end }

	callback_case = function(self, index)
		local input_list, name, num;
		name = self.list[index];
		--num = string.sub(name, 1, 1);
		input_list = split_num(name);
		num = input_list[1];
		local function_name = 'test' .. num;
		local fun_ptr = nil;
		fun_ptr = self[function_name];
		if nil == fun_ptr then
			print('ERROR function is nil: ', function_name);
			return;
		end

		-- implicit:  fun_ptr is non-nil
    	local layer_test = cc.Layer:create()
		util.add_layer_color(layer_test, ccc4(200, 200, 200, 255))
		fun_ptr(layer_test); 

		local items = {};
		local item;
		local size = cc.size(172, 52);
		local pos = cc.p(FULL_WIDTH, FULL_HEIGHT);
		item = add_item_1(items, '关闭', nil, 20, self.callback_close_test, ANCHOR_RIGHT_UP, pos, size);
		util.add_menu(layer_test, items);

		pos = ccp(0, FULL_HEIGHT);
		util.add_label(layer_test, name, 35, pos, util.c_black, ANCHOR_LEFT_UP, 1);
		g_scene:add_layer(ZORDER_LAYER_TESTLUA+20, layer_test);
	end,

	-- this is a generic close!
	callback_close_test = function(...)
		local arg = {...};
		local menu = arg[2];
		local layer = menu:getParent():getParent();  
		layer:removeFromParentAndCleanup(true);
	end,

	handler = function(event, x, y)
		local self = layer_testlua;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
	end,

	test1 = function(layer)
		show_test1(layer);
	end,

	test2 = function(layer)
		show_test2(layer);
	end,

	test3 = function(layer)
		show_test3(layer);
	end,

	test4 = function(layer)
		show_test4(layer);
	end,

	test5 = function(layer)
		show_test5(layer);
	end,

	test6 = function(layer)
		show_test6(layer);
	end,

	test7 = function(layer)
		show_test7(layer);
	end,

	test8 = function(layer)
		show_test8(layer);
	end,

	test9 = function(layer)
		show_test9(layer);
	end,

	test10 = function(layer)
		show_test10(layer);
	end,
} -- layer_testlua end

layer_mystery = {  -- layer_mystery start
	name = 'layer_mystery',
	layer = nil,
	offsetheight = nil,
	label_time = nil,
	time_1 = nil,
	time = nil,
	rgold = nil,
	menu = nil,
	list = nil,

	cleanup = function(self)
		self.layer = nil;
		self.offsetheight = nil;
		self.label_time = nil;
		self.time_1 = nil;
		self.time = nil;
		self.rgold = nil;
		self.menu = nil;
		self.list = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_MYSTERY, self.handler, true);

		local offsetheight = init_bg_full(self.layer, GUI_MYSTERY, self.back);
		self.offsetheight = offsetheight;
		local sprite, data;
		sprite,data = gui_add_sprite(self.layer,'outframe',GUI_MYSTERY,ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));

		gui_add_sprite(self.layer,'bg_refresh',GUI_MYSTERY,ANCHOR_DOWN);

		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn_show', GUI_MYSTERY, self.show, ANCHOR_DOWN);

		util.add_menu(self.layer, items, data.zorder);

		path = util.get_path(FT_8);
		self.label_time = gui_add_labelbmf(self.layer, '', path, 'refresh_time', GUI_MYSTERY, ANCHOR_DOWN, cc.TEXT_ALIGNMENT_RIGHT);
		self.label_time:setScale(0.6);

		self.time_1 = os.time();
		self.time = 0;--60*60; -- 60 sec
		self.layer:scheduleUpdateWithPriorityLua(self.update_time, 1);

		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		--g_scene:go(GUI_MAIN, "map");
		g_scene:map();
	end,

	update_time = function(dt)
		local self = layer_mystery;
		local t = os.time() - self.time_1;
		local time = self.time - t;
		if 0 > time then
			time = 0;
		end
		local str = string.format("%02d:%02d:%02d", math.floor(time/60/60), math.floor(time/60), time%60);
		self.label_time:setString(str);
	end,

	set_data = function(self, data)
		if nil ~= self.menu then
			self.menu:removeFromParent(true);
			self.menu = nil;
		end
		local offsetheight = self.offsetheight;
		self.time_1 = os.time();
		self.time = data.remain_time;
		self.rgold = data.refresh_gold;

		local lhas = {};
		local lnot = {}; -- not open
		self.list = lhas;
		for i = 1, #data.list do
			local info = data.list[i];
			info.slot_pos = i;
			if info.gold == 0 and info.crystal == 0 then
				table.insert(lnot, info);
			else
				table.insert(lhas, info);
			end
		end
		--print('#lnot , #lhas: ', #lnot, #lhas);
		local items = {};
		local item;

		local index = 0;
		for i = 1, #lhas do
			index = index + 1;
			if index == 3 and #lhas < 5 then index = 4; end
			if index == 6 and #lhas < 6 then break; end
			local info = lhas[i];
			local key = 'frame' .. index;
			item, data = gui_add_item(items, key, GUI_MYSTERY, self.tap, ANCHOR_DOWN);
			item:setTag(i);
			info.item = item;
			local x, y;
			x = data.x+data.width/2;
			y = data.y+data.height/2+offsetheight/2;
			if index < 4 then
				y = y + offsetheight/2;
			end
			item:setPosition(cc.p(x, y));
			item:setAnchorPoint(ANCHOR_CENTER_CENTER);
			local size = item:getContentSize();
			local scale = item:getScale();
			local hs = (data.height+offsetheight/2)/size.height;
			if hs < scale then
				item:setScale(hs);
			end
			local cid = info.piece_id;
			local rc = g_card_list[cid];
			if nil == rc then
				rc = hero_list[cid];
			end
			local card = clone(rc);
			local name = card.name;
			local fname = 'card' .. cid .. '.png';
			local path = util.get_path(fname, 'card0.png');
			local mask_path = util.get_path('bg_164.png');
			local pic = util.add_mask_sprite(item, path, mask_path, cc.p(size.width/2, size.height), ANCHOR_CENTER_UP, -1);
			pic:setScale((size.height-30)/pic:getContentSize().height);
			
			data = gui_get_data(key, GUI_MYSTERY, ANCHOR_DOWN);
			key = 'cname' .. index;
			sprite = gui_add_label_on_cell(item, data, name, 22, key, GUI_MYSTERY, ANCHOR_DOWN);
			sprite:setAlignment(cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);
			local price = "";
			local crystal = info.crystal;
			local gold = info.gold;
			if crystal > 0 then
				key = 'crystal' .. index;
				sprite, data2 = gui_add_sprite_on_cell(item, data, key, GUI_MYSTERY, ANCHOR_DOWN);
				price = crystal .. '';
			elseif gold > 0 then
				key = 'gold' .. index;
				sprite, data2 = gui_add_sprite_on_cell(item, data, key, GUI_MYSTERY, ANCHOR_DOWN);
				price = gold .. '';
			end
			path = util.get_path(FT_8);
			key = 'price' .. index;
			sprite = gui_add_labelbmf_on_cell(item,data,price,path,key,GUI_MYSTERY,ANCHOR_DOWN, cc.TEXT_ALIGNMENT_RIGHT);
			sprite:setScale(0.7);

			local pcount = info.piece_count or 0;
			if pcount > 0 then
				path = util.get_path(FT_8);
				str = "*" .. pcount;
				util.add_labelbmf(item, str, path, cc.p(size.width, data2.y+data2.height+50), ANCHOR_RIGHT_DOWN, 100, cc.TEXT_ALIGNMENT_RIGHT);
			elseif pcount < 0 then
				enable_btn(item, false);
			end
		end

		index = 6;
		for i = 1, #lnot do
			index = index + 1;
			if index > 8 then break; end
			local info = lnot[i];
			local cid = info.piece_id;
			local key = 'frame' .. index;
			--sprite,data = gui_add_sprite(self.layer,key,GUI_MYSTERY,ANCHOR_DOWN);
			item,data = gui_add_item(items,key,GUI_MYSTERY,self.tap2,ANCHOR_DOWN);
			item:setTag(cid);
			local x, y;
			x = data.x+data.width/2;
			y = data.y+data.height/2+offsetheight/2;
			if index < 8 then
				y = y + offsetheight/2;
			end
			item:setPosition(cc.p(x, y));
			item:setAnchorPoint(ANCHOR_CENTER_CENTER);
			local size = item:getContentSize();
			local scale = item:getScale();
			local hs = (data.height+offsetheight/2)/size.height;
			if hs < scale then
				item:setScale(hs);
			end
			local fname = 'card' .. cid .. '.png';
			local path = util.get_path(fname, 'card0.png');
			local mask_path = util.get_path('bg_164.png');
			local pic = util.add_mask_sprite(item, path, mask_path, cc.p(size.width/2, size.height), ANCHOR_CENTER_UP, -1);
			pic:setScale((size.height-30)/pic:getContentSize().height);

			data = gui_get_data(key, GUI_MYSTERY, ANCHOR_DOWN);
			local its = {};
			local it;
			key = 'btn' .. index;
			it, data2 = gui_add_item_on_cell(its, data, key, GUI_MYSTERY, self.openvip, ANCHOR_DOWN);
			util.add_menu(item, its, data.zorder);
		end

		item, data = gui_add_item(items, 'btn_refresh', GUI_MYSTERY, self.refresh, ANCHOR_DOWN);
		gui_add_sprite_on_cell(item, data, 'rgold', GUI_MYSTERY, ANCHOR_DOWN);
		--gui_add_sprite_on_cell(item, data, 'rcrystal', GUI_MYSTERY,ANCHOR_DOWN);
		local path = util.get_path(FT_5);
		str = self.rgold .. '';
		gui_add_labelbmf_on_cell(item,data,str,path,'rprice',GUI_MYSTERY,ANCHOR_DOWN, cc.TEXT_ALIGNMENT_RIGHT);

		self.menu = util.add_menu(self.layer, items, data.zorder);
	end,

	show = function()
		net_send('lpshop');
	end,

	tap2 = function(...)
		local args = {...};
		local self = layer_mystery;
		local cid = args[1];
		local rc = g_card_list[cid];
		if nil == rc then
			rc = hero_list[cid];
		end
		local card = clone(rc);
		local layer, name = layer_mispop:create(card, true);
		g_scene:add_layer(ZORDER_LAYER_MISPOP, layer, name);
	end,

	refresh = function()
		local self = layer_mystery;
		if self.rgold > g_euser.gold then
			show_err(t_lang("TIP_NOT_ENOUGH_GOLD"));
			return;
		end
		net_send('rpshop');
	end,

	-- tag 1->confirm 0->cancel
	open_it = function(tag)
		if tag ~= 1 then return; end
		go_pay();
	end,

	openvip = function()
		local self = layer_mystery;
		local tip = "VIP可以额外开启神秘商店的2个空格";
		g_scene:add_layer(ZORDER_LAYER_TIP, layer_tip:create(tip, self.open_it));
	end,

	cb_buy = function(self, pos)
		for i = 1, #(self.list or {}) do
			local info = self.list[i];
			local p = info.slot_pos;
			if p == pos then
				--info.piece_count = -1;
				enable_btn(info.item, false);
				break;
			end
		end
	end,

	buy = function(...)
		local self = layer_mystery;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		if nil == info then return; end
		local cid = info.piece_id;
		local gold = info.gold;
		local crystal = info.crystal;
		if gold > 0 and gold > g_euser.gold then
			show_err(t_lang("TIP_NOT_ENOUGH_GOLD"));
			return;
		end
		if crystal > 0 and crystal > g_euser.crystal then
			show_err(t_lang("TIP_NOT_ENOUGH_CRYSTAL"));
			return;
		end
		local pos = info.slot_pos;
		local cmd = string.format("pbuy %d", pos);
		net_send(cmd);
	end,

	tap = function(...)
		local self = layer_mystery;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		if nil == info then return; end
		local cid = info.piece_id;
		local gold = info.gold;
		local crystal = info.crystal;
		local rc = g_card_list[cid];
		if nil == rc then
			rc = hero_list[cid];
		end
		local card = clone(rc);
		local layer, name = layer_mispop:create(card, true);

		local pcount = info.piece_count or 0;
		if pcount > 0 then
			local path = util.get_path(FT_8);
			local str = "*" .. pcount;
			local l = util.add_labelbmf(layer, str, path, cc.p(FULL_WIDTH-50, HALF_HEIGHT), ANCHOR_RIGHT_CENTER, 100, cc.TEXT_ALIGNMENT_RIGHT);
			l:setScale(2);
		end

		local items = {};
		local item, data;
		item, data = gui_add_item(items, 'btn_buy', GUI_PMYSTERY, self.buy, ANCHOR_DOWN);
		item:setTag(index);
		item:setPositionY(hfix(100));
		local price = nil;
		if crystal > 0 then
			gui_add_sprite_on_cell(item, data, 'crystal', GUI_PMYSTERY,ANCHOR_DOWN);
			price = crystal .. '';
		else
			gui_add_sprite_on_cell(item, data, 'gold', GUI_PMYSTERY, ANCHOR_DOWN);
			price = gold .. '';
		end
		local path = util.get_path(FT_5);
		gui_add_labelbmf_on_cell(item,data,price,path,'price',GUI_PMYSTERY,ANCHOR_DOWN, cc.TEXT_ALIGNMENT_RIGHT);

		util.add_menu(layer, items, data.zorder);

		g_scene:add_layer(ZORDER_LAYER_MISPOP, layer, name);
	end,
	
	handler = function(event, x, y)
		local self = layer_mystery;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
}  -- layer_mystery end

layer_hero = {  -- layer_hero start
	name = 'layer_hero',
	-- mark_cmd
	-- will set when send hero_mlist ...
	-- will clean when ret hero_mlist error or 
	-- back from hero_mlist view or
	-- finish battle and back to hero mlist view
	mark_cmd = nil, 
	mark_hero_name = nil,
	mark_hero_index = nil, -- for sort card, use in layer_picec and deck
	mark_type_index = nil, -- for sort card, use in layer_picec and deck
	layer = nil,
	TYPE_NORMAL = 1,
	TYPE_MYDECK = 2,
	TYPE_SORT  = 3,
	sort_cb = nil, -- e.g xx:change_hero(hero_index, hero_name, type_index);
	type_kind = nil,
	list = nil,
	tableview = nil,
	twidth = nil,
	tx = nil,
	side = nil,
	bar = nil,
	tap = nil,
	do_cell_anim = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.twidth = nil;
		self.tx = nil;
		self.side = nil;
		self.bar = nil;
		self.tap = nil;
		self.do_cell_anim = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, type_kind, sort_cb)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_HERO, self.handler, true);

		self.type_kind = type_kind;
		self.sort_cb = sort_cb;
		local offsetheight = init_bg_full(self.layer, GUI_HERO, self.back);

		self.list = {};
		local bg_data, t_data;
		bg_data = gui_get_data('bg_have', GUI_HERO, ANCHOR_UP);
		if self.type_kind ~= self.TYPE_SORT then
			table.insert(self.list, 
				{ flag = 1, bg = 'bg_have', t = 't_have',
				  size = cc.size(bg_data.width, bg_data.height),
				  text = '已拥有',
				}
			);
			bg_data = gui_get_data('bg_not_have', GUI_HERO, ANCHOR_UP);
			table.insert(self.list, 
				{ flag = 2, bg = 'bg_not_have', t = 't_not_have',
				  size = cc.size(bg_data.width, bg_data.height),
				  text = '未拥有',
				}
			);
		end

		local sprite, data, pos, size;
		--[[
		data = gui_get_data('cell', GUI_HERO, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		]]--
		self.do_cell_anim = true;
		data = gui_get_data('table', GUI_HERO, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		self.twidth = size.width;
		self.tx = pos.x;
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		local self = layer_hero;
		if self.type_kind == self.TYPE_MYDECK then
			--g_scene:go(GUI_MYDECK, "mydeck");
			g_scene:mydeck();
			return;
		end
		if self.type_kind == self.TYPE_SORT then
			self:back_to_sort();
			return;
		end
		--g_scene:go(GUI_MAIN, "map");
		g_scene:map();
	end,
	
	back_to_sort = function(self, hero_index, hero_name, type_index)
		hero_index = hero_index or self.mark_hero_index;
		type_index = type_index or self.mark_type_index;
		hero_name = hero_name or self.mark_hero_name;
		--[[
		g_scene:piece();
		layer_piece:change_hero(hero_index, hero_name, type_index);
		]]--
		self:remove();
		if nil ~= self.sort_cb then
			self.sort_cb(hero_index, hero_name, type_index);
		end
		self.mark_hero_index = nil;
		self.mark_type_index = nil;
		self.mark_hero_name = nil;
	end,

	add_detail = function(self, flag, index, size, list, to_list)
		for i = 1, #list, 3 do
			local ll = {};
			local l = {};
			local last = i+2;
			if last > #list then last = #list; end
			for j = i, last do
				local info = list[j];
				table.insert(ll, info);
			end
			l.list = ll;
			l.flag = flag;
			l.size = size;
			index = index + 1;
			table.insert(to_list, index, l);
		end
	end,

	add_list = function(self, list_has, list_not)
		local width = self.twidth;
		if self.type_kind == self.TYPE_SORT then
			local list = {};
			table.insert(list, { hid = 0, name = "所有英雄" });
			for i = 1, #(list_has) do
				local info = list_has[i];
				table.insert(list, info);
			end
			for i = 1, #(list_not) do
				local info = list_not[i];
				table.insert(list, info);
			end
			local data = gui_get_data('cframe', GUI_HERO, ANCHOR_UP);
			local size = cc.size(width, data.height+50);
			self:add_detail(3, 0, size, list, self.list);
			self:reload();
			return;
		end
		local data = gui_get_data('cframe', GUI_HERO, ANCHOR_UP);
		local size = cc.size(width, data.height+50);
		local index = 1;
		for i = 1, #self.list do
			local info = self.list[i];
			if 1 == info.flag then
				index = i;
				break;
			end
		end
		self:add_detail(3, index, size, list_has, self.list);
		index = 1;
		for i = 1, #self.list do
			local info = self.list[i];
			if 2 == info.flag then
				index = i;
				break;
			end
		end
		self:add_detail(4, index, size, list_not, self.list);
		self:reload();
	end,

	reload = function(self)
		self.do_cell_anim = true;
		self.tableview:reloadData();
	end,

	show_hero_mlist = function(self, hero_id)
		local cmd = string.format("hero_mlist %d", hero_id);
		layer_hero.mark_cmd = cmd;
		net_send(cmd);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_hero;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.list[idx+1];
			local flag = info.flag;
			if 1 == flag or 2 == flag or nil == self.side then
				return;
			end
			local list = info.list or {};
			local ddd = list[self.side]; 
			if self.type_kind == self.TYPE_SORT then
				self:back_to_sort(ddd.hid, ddd.name, self.mark_type_index);
				return;
			end
			if 4 == flag then
				local layer, name = layer_alert:create(ALERT_HERO_MISS, ddd);
				g_scene:add_layer(ZORDER_LAYER_ALERT, layer, name, true);
				return;
			end
			-- 3==flag
			local hid = ddd.hid;
			if self.type_kind == self.TYPE_MYDECK then
				g_euser.hero_id = hid;
				g_euser.slot_id = nil;
				g_scene:pickdeck();
				return;
			end
			self:show_hero_mlist(hid);
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			local info = self.list[idx+1];
			local size = info.size;
			return size.height, size.width;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new();
			local sprite, data;
			local info = self.list[idx+1];
			local size = info.size;
			local hh = size.height/2;
			local flag = info.flag;
			if 1 == flag or 2 == flag then
				sprite, data = gui_add_sprite(cell, info.bg, GUI_HERO, ANCHOR_UP);
				sprite:setPosition(cc.p(0, hh));
				sprite:setAnchorPoint(ANCHOR_LEFT_CENTER);
				gui_add_label_on_cell(sprite, data, info.text, 28, info.t, GUI_HERO, ANCHOR_UP);
				return cell;
			end
			local gapx = size.width/3;
			local x = gapx/2;
			local list = info.list or {};
			--local items = {};

			for i = 1, #list do
				local is_has = true;
				local cb = self.choose;
				if 4 == flag then
					is_has = false;
					cb = self.show_get_tip;
				end
				local ddd = list[i];
				local hid = ddd.hid or 0;
				--sprite, data = gui_add_item(items, 'cframe', GUI_HERO, cb, ANCHOR_UP);
				--sprite:setTag(hid);
				sprite,data = gui_add_sprite(cell,'cframe',GUI_HERO,ANCHOR_UP);
				local bsize = sprite:getContentSize();
				sprite:setPosition(cc.p(x+(i-1)*gapx, hh+20));
				sprite:setAnchorPoint(ANCHOR_CENTER_CENTER);
				local fname = 'card' .. hid .. '.png';
				if hid == 0 then
					fname = 'pic_94.png';
				end
				local path = util.get_path(fname, 'card0.png');
				local pic = util.add_sprite(sprite, path, cc.p(bsize.width/2, bsize.height/2), ANCHOR_CENTER_CENTER, -1);
				pic:setScaleX((bsize.width-8)/pic:getContentSize().width);
				pic:setScaleY((bsize.height-8)/pic:getContentSize().height);
				local balias;
				-- balias png height is 36, cframe is 130
				balias,data = gui_add_sprite(cell,'cbg_alias',GUI_HERO,ANCHOR_UP);
				balias:setPosition(cc.p(x+(i-1)*gapx, hh-67));
				balias:setAnchorPoint(ANCHOR_CENTER_CENTER);
				local basize = balias:getContentSize();
				local name = ddd.name or "";
				util.add_labelttf(balias, name, nil, 22, cc.p(basize.width/2, basize.height/2), util.c4b_black, ANCHOR_CENTER_CENTER, 10, basize, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
				if false == is_has then
					util.set_gray(sprite);
					util.set_gray(pic);
					util.set_gray(balias);
				end
				--if ddd.show_eff_mark == nil then
				if true == self.do_cell_anim then
					local delay = (idx%10)*0.1;
					keff_showup_1(sprite, delay);
					--keff_showup_1(pic, delay);
					--keff_showup_1(balias, delay);
					--ddd.show_eff_mark = TAG_SHOW_CELL_MARK;
				end
			end
			--[[
			if #items > 0 then
				util.add_menu(cell, items, data.zorder);
			end
			]]--
			return cell;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_hero;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function(self, x, y)
		self.side = nil;
		local tx = self.tx;
		local gap = self.twidth/3;
		if x > tx and x < tx + gap then
			self.side = 1;
		elseif x > tx + gap and x < tx + gap*2 then
			self.side = 2;
		elseif x > tx + gap*2 and x < tx + gap*3 then
			self.side = 3;
		end
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		self.do_cell_anim = false;

	end,
}  -- layer_hero end

layer_heromiss = {  -- layer_heromiss start
	name = 'layer_heromiss',
	layer = nil,
	list = nil,
	tableview = nil,
	cwidth = nil,
	cheight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,
	do_cell_anim = nil,
	hid = nil,
	lhp = nil,
	lenergy = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
		self.do_cell_anim = nil;
		self.hid = nil;
		self.lhp = nil;
		self.lenergy = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, hinfo)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_HEROMISS, self.handler, true);

		local offsetheight = init_bg_full(self.layer, GUI_HMISS, self.back);

		local sprite, data, pos, size;
		sprite, data = gui_add_sprite(self.layer, 'bg_hero',GUI_HMISS,ANCHOR_UP);
		size = sprite:getContentSize();
		local hid = hinfo.hid;
		self.hid = hid;
		local hp = hinfo.hp or 0;
		local energy = hinfo.energy or 0;
		local name = hero_list[hid].name or "";
		local desc = hero_list[hid].skill_desc or "";
		local fname = 'card' .. hid .. '.png';
		local path = util.get_path(fname, 'card0.png');
		local pt = util.get_path(FT_2);
		local pic = util.add_sprite(sprite, path, cc.p(size.width/2, size.height/2), ANCHOR_CENTER_CENTER, -1);
		pic:setScaleX((size.width-8)/pic:getContentSize().width);
		pic:setScaleY((size.height-8)/pic:getContentSize().height);
		sprite = gui_add_sprite(self.layer, 'bg_hero_alias',GUI_HMISS,ANCHOR_UP);
		size = sprite:getContentSize();
		--gui_add_label(self.layer, name, 20,'hero_alias',GUI_HMISS,ANCHOR_UP);
		util.add_labelttf(sprite, name, nil, 22, cc.p(size.width/2, size.height/2), util.c4b_black, ANCHOR_CENTER_CENTER, 10, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
		gui_add_sprite(self.layer, 'bg_hp',GUI_HMISS,ANCHOR_UP);
		--gui_add_label(self.layer, hp, 22, 'num_hp',GUI_HMISS,ANCHOR_UP);
		self.lhp = gui_add_labelbmf(self.layer,hp,pt,'num_hp',GUI_HMISS,ANCHOR_UP);
		gui_add_sprite(self.layer, 'bg_power',GUI_HMISS,ANCHOR_UP);
		self.lenergy = gui_add_labelbmf(self.layer,energy,pt,'num_power',GUI_HMISS,ANCHOR_UP);
		gui_add_sprite(self.layer, 'bg_desc',GUI_HMISS,ANCHOR_UP);
		sprite = gui_add_label(self.layer, desc, 22, 'desc',GUI_HMISS,ANCHOR_UP);
		sprite:setAlignment(cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_TOP);
		gui_add_sprite(self.layer, 'bg_board',GUI_HMISS,ANCHOR_UP);
		gui_add_label(self.layer, '成长任务', 26, 't_board',GUI_HMISS,ANCHOR_UP);
		sprite,data = gui_add_sprite(self.layer,'outframe',GUI_HMISS,ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));
		gui_add_sprite(self.layer, 'fbottom',GUI_HMISS,ANCHOR_DOWN);

		self.do_cell_anim = true;
		self.list = hinfo.mlist or {};
		data = gui_get_data('cell', GUI_HMISS, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		data = gui_get_data('table', GUI_HMISS, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		--self:add_list();

		return self.layer, self.name;
	end,

	back = function()
		layer_hero.mark_cmd = nil;
		layer_heromiss:remove();
	end,

	add_list = function(self)
		for i = 1, 4 do
			local info = { mid = 1, status = 2, reward_type = 1, reward_count = 3, desc = "使用XX挑战关卡XXX" };
			table.insert(self.list, info);
		end
		self:reload();
	end,

	reload = function(self)
		self.do_cell_anim = true;
		self.tableview:reloadData();
	end,

	go_miss = function(...)
		local self = layer_heromiss;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		local p1 = info.p1;
		if nil == p1 then return; end
		p1 = tonumber(p1);
		local chapter_id = math.floor(p1/100);
		local stage_id = p1%100;
		--local cmd = string.format("chapter %d %d", chapter_id, stage_id);
		--net_send(cmd);
		layer_chapter.set_stage_id_for_mission = stage_id;
		layer_chapter.last_chapter_id = chapter_id;
		g_scene:chapter();
	end,

	go_done = function(...)
		local self = layer_heromiss;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		local mid = info.mid;
		local hid = self.hid;
		if nil == mid or nil == hid then return; end
		local cmd = string.format("shero_mis %d %d", hid, mid);
		net_send(cmd);
	end,

	update_mission = function(self, hero_id, mission_id, hp, energy)
		if self.hid ~= hero_id then return; end
		for i = 1, #(self.list or {}) do
			local info = self.list[i];
			local mid = info.mid;
			if mid == mission_id then
				info.status = 3;
				break;
			end
		end
		hp = hp or 0;
		energy = energy or 0;
		self.lhp:setString(hp);
		self.lenergy:setString(energy);
		self:reload();
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_heromiss;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			--local cell = args[3];
			--local idx = cell:getIdx();
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new();
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local data2, sprite, path, pos, size, str;
			local info = self.list[idx + 1];
			local mid = info.mid;
			local status = info.status;
			local reward_type = info.reward_type;
			local reward_count = info.reward_count;

			str = info.desc;
			--print('str: ', str);
			--gui_add_label_on_cell(cell,data,str,24,'tip',GUI_HMISS,ANCHOR_DOWN);
			gui_add_rlabel_on_cell(cell,data,str,24,'tip',GUI_HMISS,ANCHOR_DOWN);

			if reward_type == 1 then
				gui_add_sprite_on_cell(cell, data, 'tip_hp', GUI_HMISS, ANCHOR_DOWN);
			elseif reward_type == 2 then
				gui_add_sprite_on_cell(cell, data, 'tip_power', GUI_HMISS, ANCHOR_DOWN);
			end

			path = util.get_path(FT_2);
			str = "+" .. reward_count;
			gui_add_labelbmf_on_cell(cell,data,str,path,'tip_change',GUI_HMISS,ANCHOR_DOWN);
			if 3 == status then
				sprite, data2 = gui_add_sprite_on_cell(cell, data, 'missdone', GUI_HMISS, ANCHOR_DOWN);
				return cell;
			end

			local items = {};
			local item;

			if 2 == status then
				item, data2 = gui_add_item_on_cell(items, data, 'btn_done', GUI_HMISS, self.go_done, ANCHOR_DOWN);
			else
				item, data2 = gui_add_item_on_cell(items, data, 'btn_go', GUI_HMISS, self.go_miss, ANCHOR_DOWN);
			end
			item:setTag(idx+1);

			util.add_menu(cell, items, data2.zorder);

			--if info.show_eff_mark == nil then
			if true == self.do_cell_anim then
				local delay = (idx%10)*0.1;
				keff_show_fromright(cell, delay);
				--keff_showup_1(balias, delay);
				--info.show_eff_mark = TAG_SHOW_CELL_MARK;
			end
			return cell;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_heromiss;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		self.do_cell_anim = false;

	end,
}  -- layer_heromiss end

layer_mydeck = {  -- layer_mydeck start
	name = 'layer_mydeck',
	layer = nil,
	list = nil,
	tableview = nil,
	cwidth = nil,
	cheight = nil,
	data_cell = nil,
	pic_sprite = nil,
	lname = nil,
	lenergy = nil,
	lhp = nil,
	ldesc = nil,
	ldeck = nil,
	hinfo = nil,
	clarrow = nil,
	crarrow = nil,
	twidth = nil,
	btn_pick_deck = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.data_cell = nil;
		self.pic_sprite = nil;
		self.lname = nil;
		self.lenergy = nil;
		self.lhp = nil;
		self.ldesc = nil;
		self.ldeck = nil;
		self.hinfo = nil;
		self.clarrow = nil;
		self.crarrow = nil;
		self.twidth = nil;
		self.btn_pick_deck = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, hinfo)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_MYDECK, self.handler, true);

		local offsetheight = init_bg_full(self.layer, GUI_MYDECK, self.back);

		local sprite, data, pos, size;
		sprite, data = gui_add_sprite(self.layer, 'bg_hero',GUI_MYDECK,ANCHOR_UP);
		size = sprite:getContentSize();
		local path = util.get_path('card0.png');
		local pt = util.get_path(FT_2);
		local pic = util.add_sprite(sprite, path, cc.p(size.width/2, size.height/2), ANCHOR_CENTER_CENTER, -1);
		self.pic_sprite = pic;
		pic:setScaleX((size.width-8)/pic:getContentSize().width);
		pic:setScaleY((size.height-8)/pic:getContentSize().height);
		sprite = gui_add_sprite(self.layer, 'bg_hero_alias',GUI_MYDECK,ANCHOR_UP);
		size = sprite:getContentSize();
		self.lname = util.add_labelttf(sprite, "", nil, 22, cc.p(size.width/2, size.height/2), util.c4b_black, ANCHOR_CENTER_CENTER, 10, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
		gui_add_sprite(self.layer, 'bg_hp',GUI_HMISS,ANCHOR_UP);
		self.lhp=gui_add_labelbmf(self.layer,"",pt,'num_hp',GUI_MYDECK,ANCHOR_UP);
		gui_add_sprite(self.layer, 'bg_power',GUI_HMISS,ANCHOR_UP);
		self.lenergy=gui_add_labelbmf(self.layer,"",pt,'num_power',GUI_MYDECK,ANCHOR_UP);
		gui_add_sprite(self.layer, 'bg_desc',GUI_MYDECK,ANCHOR_UP);
		self.ldesc=gui_add_label(self.layer,"", 22, 'desc',GUI_MYDECK,ANCHOR_UP);
		self.ldesc:setAlignment(cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_TOP);
		sprite,data=gui_add_sprite(self.layer, 'bg_deck_name',GUI_MYDECK,ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));
		self.ldeck=gui_add_label(self.layer, '', 26,'deck_name',GUI_MYDECK,ANCHOR_UP);
		sprite,data=gui_add_sprite(self.layer,'outframe',GUI_MYDECK,ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));

		local items = {};
		local data, item;

		item,data = gui_add_item(items, 'btn_hero', GUI_MYDECK, self.cb_hero, ANCHOR_UP);
		item,data = gui_add_item(items, 'btn_deck', GUI_MYDECK, self.cb_deck, ANCHOR_UP);
		self.btn_pick_deck = item;

		util.add_menu(self.layer, items, data.zorder);

		self.list = {};
		data = gui_get_data('cell', GUI_MYDECK, ANCHOR_DOWN);
		local nheight = data.height + offsetheight;
		local sh = nheight/data.height;
		self.data_cell = data;
		self.cwidth = data.width*sh;
		self.cheight = data.height*sh;
		data = gui_get_data('table', GUI_MYDECK, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		self.twidth = size.width;
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_handler,pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);
		self.clarrow, self.crarrow = util.add_arrows(self.layer, pos, size, self.cwidth, 0, cc.p(0, 0));

		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		--g_scene:go(GUI_MAIN, "map");
		g_scene:map();
	end,

	update_info = function(self, hinfo)
		self.hinfo = hinfo;
		local hid = hinfo.hero_id;
		local hp = hinfo.hp or 0;
		local energy = hinfo.energy or 0;
		local name = hero_list[hid].name or "";
		local desc = hero_list[hid].skill_desc or "";
		local sname = string.format("上场牌堆: 自组牌堆%d", hinfo.slot_id or 0);
		local fname = 'card' .. hid .. '.png';
		local path = util.get_path(fname, 'card0.png');
		if nil ~= self.pic_sprite then
			local tc = cc.Director:getInstance():getTextureCache();
			local texture = tc:addImage(path);
			if nil == texture then return; end
			self.pic_sprite:setTexture(texture);
		end
		if nil ~= self.lname then
			self.lname:setString(name);
		end
		if nil ~= self.lenergy then
			self.lenergy:setString(energy);
		end
		if nil ~= self.lhp then
			self.lhp:setString(hp);
		end
		if nil ~= self.ldesc then
			self.ldesc:setString(desc);
		end
		if nil ~= self.ldeck then
			self.ldeck:setString(sname);
		end
		--self.list = hinfo.deck_array or {};
		self.list = {};
		for i = 1, #(hinfo.deck_array or {}) do
			local info = hinfo.deck_array[i];
			local card = info.card;
			if card.ctype ~= HERO then
				table.insert(self.list, info);
			end
		end
		self:reload();
	end,

	cb_hero = function()
		play_tap_1();
		--g_scene:go(GUI_HERO, "hero", {special_type=layer_hero.TYPE_MYDECK});
		g_scene:hero({special_type=layer_hero.TYPE_MYDECK});
	end,

	cb_deck = function()
		play_tap_1();
		local self = layer_mydeck;
		if nil == self.hinfo then return; end
		--local hid = self.hinfo.hero_id;
		--local sid = self.hinfo.slot_id;
		--g_scene:pickdeck(hid, sid);
		--g_scene:go(GUI_PICKDECK, "pickdeck");
		g_scene:pickdeck();
	end,

	reload = function(self)
		self.tableview:reloadData();
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_mydeck;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			local len = math.ceil(#self.list / 2);
			local offset = view:getContentOffset();
			util.handle_arrows(self.clarrow, self.crarrow, len, self.cwidth, self.twidth, offset);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.list[idx + 1];
			local card = clone(info.card);
			g_scene:add_layer(ZORDER_LAYER_MISPOP, layer_mispop:create(card));
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new();
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			local data2, sprite, path, pos, size, str;
			local info = self.list[idx + 1];
			local card = clone(info.card);
			local count = info.count;
			data2 = gui_get_data('cframe', GUI_MYDECK, ANCHOR_DOWN);
			pos = cc.p(data2.x-data.x+width/2, data2.y-data.y+height/2);
			local cinfo = object_card:new(cell, card, nil, nil, pos, 0, 1, STYPE_VER_1);
			sprite = cinfo:get_front();
			local s = sprite:getContentSize();
			local ws = (width-30)/s.width;
			local wh = (height-30)/s.height;
			if ws < wh then
				sprite:setScale(ws);
			else
				sprite:setScale(wh);
			end
			sprite:setTag(TAG_CELL_CARD_SPRITE);
			path = util.get_path(FT_8);
			count = '*' .. count;
			util.add_labelbmf(cell, count, path, cc.p(width-10, height/2), ANCHOR_RIGHT_CENTER, 100);
			
			--[[
			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'cframe', GUI_MYDECK, ANCHOR_DOWN);
			sprite:setPosition(cc.p(width/2, height/2));
			sprite:setAnchorPoint(ANCHOR_CENTER_CENTER);
			local s = sprite:getContentSize();
			local ws = (width-(data.width-data2.width))/s.width;
			local wh = (height-(data.height-data2.height))/s.height;
			if ws < wh then
				sprite:setScale(ws);
			else
				sprite:setScale(wh);
			end
			local fname = 'card' .. card.id .. '.png';
			path = util.get_path(fname, 'card0.png');
			local mask_path = util.get_path('bg_155.png');
			pos = ccp(s.width/2, s.height/2);
			local pic = util.add_mask_sprite(sprite, path, mask_path, pos, ANCHOR_CENTER_CENTER, -1);
			pic:setScale(s.height/pic:getContentSize().height);

			local l = nil;
			local scale = 0.7;
			local fontpath = util.get_path(FNT_CARD);
			if card.ctype ~= HERO then
				path = util.get_path('icon_54.png');
				pos = ccp(0, s.height);
				l = util.add_sprite(sprite, path, pos, ANCHOR_LEFT_UP);
				l:setScale(scale);
				pos = ccp(25, s.height-28);
				str = card.cost;
				l=util.add_labelbmf(sprite,str,fontpath,pos,ANCHOR_CENTER_CENTER);
				l:setScale(scale);
			end
			if ABILITY == card.ctype or ATTACH == card.ctype 
					or SUPPORT == card.ctype or ARTIFACT == card.ctype
					or TRAP == card.ctype then
				return cell;
			end
			if ARMOR == card.ctype then
				fname = 'icon_59.png';
			elseif HERO == card.ctype then
				fname = 'icon_57.png';
			else
				fname = 'icon_55.png';
			end
			pos = cc.p(0, 0);
			path = util.get_path(fname);
			l = util.add_sprite(sprite, path, pos, ANCHOR_LEFT_DOWN);
			l:setScale(scale);
			if card.ctype == HERO then
				str = card.energy;
			else
				str = card.power;
			end
			if ARMOR == card.ctype then
				pos = ccp(26, 32);
			elseif HERO == card.ctype then
				pos = ccp(26, 32);
			else
				pos = ccp(46, 32);
			end
			l=util.add_labelbmf(sprite,str,fontpath,pos,ANCHOR_CENTER_CENTER);
			l:setScale(scale);
			if ARMOR == card.ctype or WEAPON == card.ctype then
				fname = 'icon_58.png';
			else
				fname = 'icon_56.png';
			end
			path = util.get_path(fname);
			pos = ccp(s.width, 0);
			l = util.add_sprite(sprite, path, pos, ANCHOR_RIGHT_DOWN);
			l:setScale(scale);

			if ARMOR == card.ctype or WEAPON == card.ctype then
				pos = ccp(s.width-26, 32);
			else
				pos = ccp(s.width-26, 32);
			end
			str = card.hp;
			l=util.add_labelbmf(sprite,str,fontpath,pos,ANCHOR_CENTER_CENTER);
			l:setScale(scale);

			local path = util.get_path(FT_8);
			count = '*' .. count;
			util.add_labelbmf(cell, count, path, cc.p(width-10, height/2), ANCHOR_RIGHT_CENTER, 100);
			]]--
			return cell;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_mydeck;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
}  -- layer_mydeck end

layer_pickdeck = {  -- layer_pickdeck start
	name = 'layer_pickdeck',
	layer = nil,
	list = nil,
	tableview = nil,
	theight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,
	do_cell_anim = nil,
	data_cell_first = nil,
	data_cell_last = nil,
	hero_id = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.theight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
		self.do_cell_anim = nil;
		self.data_cell_first = nil;
		self.data_cell_last = nil;
		self.hero_id = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_PICKDECK, self.handler, true);

		local offsetheight = init_bg_full(self.layer, GUI_PICKDECK, self.back);

		local sprite, data, pos, size;
		sprite,data = gui_add_sprite(self.layer,'outframe',GUI_PICKDECK,ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));
		gui_add_sprite(self.layer, 'fbottom',GUI_PICKDECK,ANCHOR_DOWN);

		self.do_cell_anim = true;
		self.list = {};
		data = gui_get_data('cell1', GUI_PICKDECK, ANCHOR_DOWN);
		self.data_cell_first = data;
		data = gui_get_data('cell3', GUI_PICKDECK, ANCHOR_DOWN);
		self.data_cell_last = data;
		data = gui_get_data('cell2', GUI_PICKDECK, ANCHOR_DOWN);
		self.data_cell = data;
		data = gui_get_data('table', GUI_PICKDECK, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		self.theight = size.height;
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		--g_scene:go(GUI_MYDECK, "mydeck");
		g_scene:mydeck();
	end,

	add_list = function(self, hero_id, slot_percent, list_deck)
		self.hero_id = hero_id;
		self.list = {};
		local l = {};
		l.flag = 1;
		l.hero_id = hero_id;
		l.slot_id = 99;
		l.slot_percent = slot_percent;
		table.insert(self.list, l);
		for i = 1, #(list_deck or {}) do
			local info = list_deck[i];
			info.flag = 2;
			table.insert(self.list, info);
		end
		l = {};
		l.flag = 3;
		l.price = 0;
		table.insert(self.list, l);
		self:reload();
	end,

	reload = function(self)
		self.do_cell_anim = true;
		self.tableview:reloadData();
	end,

	check = function(...)
		local self = layer_pickdeck;
		--local args = {...};
		--local index = args[2]:getTag();
		--[[
		local function cb()
			local cmd = string.format("get_hero_slot %d %d", self.hero_id, 99);
			net_send(cmd);
		end
		g_scene:go(GUI_SGDECK, "sgdeck", { callback=cb });
		]]--
		g_scene:sgdeck();
		local cmd = string.format("get_hero_slot %d %d", self.hero_id, 99);
		net_send(cmd);
	end,

	edit = function(...)
		local self = layer_pickdeck;
		if nil == self.hero_id then return; end
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		if nil == info then return; end
		local sid = info.slot_id;
		if nil == sid then return; end
		--[[
		local function cb()
			local cmd = string.format("get_hero_slot %d %d", self.hero_id, sid);
			net_send(cmd);
		end
		g_scene:go(GUI_DECK, "deck", { callback=cb });
		]]--
		g_scene:deck();
		local cmd = string.format("get_hero_slot %d %d", self.hero_id, sid);
		net_send(cmd, true);
	end,

	add = function(...)
		local self = layer_pickdeck;
		--local args = {...};
		--local index = args[2]:getTag();
		if nil == self.hero_id then return; end
		local cmd = "insert_hero_slot " .. self.hero_id;
		net_send(cmd);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_pickdeck;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.list[idx+1];
			if nil == info then return; end
			local sid = info.slot_id;
			if nil == sid then return; end
			if sid == g_euser.slot_id then return; end
			if 99 == sid then
				if 100 ~= info.slot_percent then
					show_msg("集齐卡牌才能使用");
					return;
				end
			end
			local cmd = string.format("choose_hero_slot %d %d", self.hero_id,sid);
			net_send(cmd);
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			local info = self.list[idx + 1];
			local data = nil;
			if info.flag == 1 then
				data = self.data_cell_first;
			elseif info.flag == 3 then
				data = self.data_cell_last;
			else
				data = self.data_cell;
			end
			return data.height, data.width;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new();
			local info = self.list[idx + 1];
			local data = nil;
			if info.flag == 1 then
				data = self.data_cell_first;
			elseif info.flag == 3 then
				data = self.data_cell_last;
			else
				data = self.data_cell;
			end
			local width = data.width;
			local height = data.height;
			gui_add_cell_bg(cell, data);
			local data2, sprite, path, pos, size, str;
			if 1 == info.flag then
				str = "推荐牌组";
				gui_add_label_on_cell(cell, data, str, 24, 'cell1_t', GUI_PICKDECK, ANCHOR_DOWN);
				str = "完成度:";
				gui_add_label_on_cell(cell, data, str, 20, 'cell1_tf', GUI_PICKDECK, ANCHOR_DOWN);
				local pec = info.slot_percent or 0;
				str = pec .. "%";
				gui_add_label_on_cell(cell, data, str, 22, 'cell1_tn', GUI_PICKDECK, ANCHOR_DOWN);

				sprite, data2 = gui_add_sprite_on_cell(cell, data, 'cell1_progress', GUI_PICKDECK, ANCHOR_DOWN);
				path = util.get_path("bg_158.png");
				sprite = util.add_progress_bar(sprite, util.create_sprite(path), cc.p(0, 0), cc.PROGRESS_TIMER_TYPE_BAR, cc.p(0, 1), cc.p(1, 0), pec, 10);
				sprite:setAnchorPoint(ANCHOR_LEFT_DOWN);

				if g_euser.slot_id == info.slot_id then
					local d = self.data_cell;
					gui_add_sprite_on_cell(cell, d, 'cell2_take', GUI_PICKDECK, ANCHOR_DOWN);
				end

				local items = {};
				local item;

				item, data2 = gui_add_item_on_cell(items, data, 'cell1_check', GUI_PICKDECK, self.check, ANCHOR_DOWN);
				item:setTag(idx+1);

				util.add_menu(cell, items, data2.zorder);
			elseif 3 == info.flag then
				local items = {};
				local item;

				item, data2 = gui_add_item_on_cell(items, data, 'cell3_btn', GUI_PICKDECK, self.add, ANCHOR_DOWN);
				item:setTag(idx+1);
				data2 = gui_get_data('cell3_btn', GUI_PICKDECK, ANCHOR_DOWN);
				--[[
				gui_add_sprite_on_cell(item, data2, 'gold', GUI_PICKDECK, ANCHOR_DOWN);
				gui_add_sprite_on_cell(item, data2, 'crystal', GUI_PICKDECK, ANCHOR_DOWN);
				path = util.get_path(FT_5);
				str = "222";
				gui_add_labelbmf_on_cell(item,data2,str,path,'price',GUI_PICKDECK,ANCHOR_DOWN);
				]]--

				util.add_menu(cell, items, data2.zorder);
			elseif 2 == info.flag then
				str = "自建牌组" .. (info.slot_id or 0);
				gui_add_label_on_cell(cell, data, str, 24, 'cell2_t', GUI_PICKDECK, ANCHOR_DOWN);
				str = "牌数:";
				gui_add_label_on_cell(cell, data, str, 20, 'cell2_tf', GUI_PICKDECK, ANCHOR_DOWN);
				str = (info.card_count or 0) .. "";
				gui_add_label_on_cell(cell, data, str, 22, 'cell2_tn', GUI_PICKDECK, ANCHOR_DOWN);

				if g_euser.slot_id == info.slot_id then
					gui_add_sprite_on_cell(cell, data, 'cell2_take', GUI_PICKDECK, ANCHOR_DOWN);
				end

				local items = {};
				local item;

				item, data2 = gui_add_item_on_cell(items, data, 'cell2_edit', GUI_PICKDECK, self.edit, ANCHOR_DOWN);
				item:setTag(idx+1);

				util.add_menu(cell, items, data2.zorder);
			end
			if true == self.do_cell_anim then
				local delay = (idx%10)*0.1;
				keff_show_fromright(cell, delay);
			end
			return cell;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_pickdeck;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		self.do_cell_anim = false;

	end,
}  -- layer_pickdeck end

layer_sgdeck = { -- start    
	name = 'layer_sgdeck',
	layer = nil,
	list = nil,
	tableview = nil,
	clarrow = nil,
	crarrow = nil,
	cwidth = nil,
	cheight = nil,
	data_cell = nil,
	twidth = nil,
	line = nil,
	side = nil,
	percent = nil,
	lpercent = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.clarrow = nil;
		self.crarrow = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.data_cell = nil;
		self.twidth = nil;
		self.line = nil;
		self.side = nil;
		self.percent = nil;
		self.lpercent = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_SGDECK, self.handler, true);

		self.list = {};
		local offsetheight = init_bg_full(self.layer, GUI_SGDECK, self.back);

		local sprite, data, pos, size, path;
		sprite,data = gui_add_sprite(self.layer,'outframe',GUI_SGDECK,ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));

		gui_add_sprite(self.layer,'bg_subt',GUI_SGDECK,ANCHOR_UP);
		gui_add_label(self.layer, "上场牌堆", 24, 'subt', GUI_SGDECK, ANCHOR_UP);
		gui_add_sprite(self.layer,'tab_collect',GUI_SGDECK,ANCHOR_DOWN);
		sprite, data = gui_add_sprite(self.layer,'bar',GUI_SGDECK,ANCHOR_DOWN);
		path = util.get_path(FT_5);
		pos = cc.p(data.width/2, 0);
		self.lpercent = util.add_labelbmf(sprite,"",path,pos,ANCHOR_CENTER_DOWN,20);
		path = util.get_path("bg_158.png");
		sprite = util.add_progress_bar(sprite, util.create_sprite(path), cc.p(0, 0), cc.PROGRESS_TIMER_TYPE_BAR, cc.p(0, 1), cc.p(1, 0), 0, 10);
		sprite:setAnchorPoint(ANCHOR_LEFT_DOWN);
		self.percent = sprite;

		data = gui_get_data('cell', GUI_SGDECK, ANCHOR_DOWN);
		local nheight = data.height + offsetheight;
		local sh = nheight/data.height;
		data.width = data.width * sh;
		data.height = data.height * sh;
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height;
		data = gui_get_data('table', GUI_SGDECK, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		self.twidth = size.width;
		self.line = pos.y + size.height/2;
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		self.clarrow, self.crarrow = util.add_arrows(self.layer, pos, size, self.cwidth, 0, cc.p(0, 0));

		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		--g_scene:go(GUI_PICKDECK, "pickdeck");
		g_scene:pickdeck();
	end,

	reload = function(self)
		self.tableview:reloadData();
	end,

	set_list = function(self, list, percent)
		self.list = list or {};
		self:reload();
		percent = percent or 0;
		self.lpercent:setString(string.format("%d%%", percent));
		self.percent:setPercentage(percent);
	end,

	set_card_own = function(self, card_list)
		for i = 1, #(self.list or {}) do
			local info = self.list[i];
			local card = info.card;
			local cid = card.id;
			local count = info.count;
			for j = 1, #(card_list or {}) do
				local d = card_list[j];
				local cid2 = d.card.id;
				if cid2 == cid then
					local count2 = d.count;
					if count2 > count then count2 = count; end
					info.has = count2;
					break;
				end
			end
		end
		self:reload();
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_sgdeck;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return math.ceil(#(self.list or {})/2);
		elseif "scrollViewDidScroll" == event then
			local len = math.ceil(#self.list / 2);
			local offset = view:getContentOffset();
			util.handle_arrows(self.clarrow, self.crarrow, len, self.cwidth, self.twidth, offset);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local index = idx*2 + 1;
			if 2 == self.side then -- down
				index = index + 1;
			elseif 1 == self.side then -- up
			else
				return;
			end
			local info = self.list[index];
			if nil == info then return; end
			local card = info.card;
			if nil == card then return; end
			local has = info.has or 0;
			local total = info.count;
			if has < total then
				local layer, name = layer_alert:create(ALERT_GET_PIECE, info);
				g_scene:add_layer(ZORDER_LAYER_ALERT, layer, name, true);
				local cmd = 'piece_chapter ' .. info.card.id;
				net_send(cmd);
				return;
			end
			g_scene:add_layer(ZORDER_LAYER_MISPOP, layer_mispop:create(card));
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local index = idx*2 + 1;
			local data = self.data_cell;
			local data2 = gui_get_data('cframe', GUI_SGDECK, ANCHOR_DOWN);
			local hh = height/2;
			local size;
			local len = index+1;
			if len > #self.list then len = #self.list; end
			for i = index, len do
				local info = self.list[i];
				local card = clone(info.card);
				local count = info.count;
				local has = info.has or 0;
				local basey = 0;
				if i % 2 ~= 0 then
					basey = hh;
				end
				local pos = cc.p(data2.x-data.x+width/2, basey+hh/2);
				local cinfo = object_card:new(cell, card, nil, nil, pos, 0, 1, STYPE_VER_1);
				local sprite = cinfo:get_front();
				local s = sprite:getContentSize();
				local ws = (width-30)/s.width;
				local wh = (hh-30)/s.height;
				if ws < wh then
					sprite:setScale(ws);
				else
					sprite:setScale(wh);
				end
				local path = util.get_path(FT_8);
				local str = has .. '/' .. count;
				util.add_labelbmf(cell, str, path, cc.p(width-10, basey+hh/2), ANCHOR_RIGHT_CENTER, 100);

				--[[
				local s, d; -- sprite, data
				r = self.r_table;
				local offsety = r.offsety;
				local offset = -r.y-basey+offsety/2;
				local scale = (d.height + offsety/2) / CARD_SIZE.height;
				local pos = cc.p(width/2, d.y+offset+CARD_SIZE.height*scale/2);
				local cinfo = object_card:new(cell, card, nil, nil, pos, 0, scale, STYPE_VER_1);
				local sprite = cinfo:get_front();
				self.list[i].info = cinfo;
				self.list[i].sprite = sprite;

				local gold, crystal, path;
				if self.kind == self.KIND_BUY then
					gold = math.abs(info.c_buygold);
					crystal = math.abs(info.c_buycrystal);
				else -- self.KIND_SELL
					gold = info.c_sellgold;
					crystal = info.c_sellcrystal;
				end
				self.list[i].gold = gold;
				self.list[i].crystal = crystal;
				path = util.get_path(FNT_1);
				local gapy = 10 * sprite:getScale();
				scale = 0;
				if gold > 0 then
					s, d = gui_add_sprite(cell, 'bg_gold', GUI_SHOP, ANCHOR_DOWN);
					s:setPosition(cc.p(d.x-r.x, d.y+offset));
					local w = width/s:getContentSize().width;
					local h = d.height/s:getContentSize().height;
					if w > h then
						scale = h;
					else
						scale = w;
					end
					s:setScale(scale);
					s, d = gui_add_sprite(cell, 'icon_gold',GUI_SHOP,ANCHOR_DOWN);
					s:setPosition(cc.p(d.x-r.x, d.y+offset));
					s:setScale(scale);

					s, d = gui_add_labelbmf(cell, gold, path,'num_gold',GUI_SHOP,ANCHOR_DOWN);
					s:setPosition(cc.p(d.x-r.x, d.y+offset));
					s:setScale(scale);
				end
				if crystal > 0 then
					s, d = gui_add_sprite(cell,'bg_crystal',GUI_SHOP,ANCHOR_DOWN);
					s:setPosition(cc.p(d.x-r.x, d.y+offset));
					if 0 == scale then
						local w = width/s:getContentSize().width;
						local h = d.height/s:getContentSize().height;
						if w > h then
							scale = h;
						else
							scale = w;
						end
					end
					s:setScale(scale);
					s,d=gui_add_sprite(cell,'icon_crystal',GUI_SHOP,ANCHOR_DOWN);
					s:setPosition(cc.p(d.x-r.x, d.y+offset));
					s:setScale(scale);
				
					s, d = gui_add_labelbmf(cell, crystal, path,'num_crystal',GUI_SHOP,ANCHOR_DOWN);
					s:setPosition(cc.p(d.x-r.x, d.y+offset));
					s:setScale(scale);
				end

				local count = self:is_has_card(cinfo.card.id);
				self.list[i].count = count;
				path = util.get_path('font_deck_num.fnt');
				pos = cc.p(width/4*3, height/4*3-basey+10);
				count = '*' .. count;
				s=util.add_labelbmf(cell,count,path,pos,ANCHOR_CENTER_CENTER,100);
				s:setScale(scale);
				]]--
			end
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_sgdeck;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function (self, x, y)
		if y > self.line then
			self.side = 1; -- up
		else
			self.side = 2; -- down
		end
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
	end,
	
	onTouchEnded = function(self, x, y)
	end,

} -- layer_sgdeck end

layer_alert = {
	name = 'layer_alert',
	layer = nil,
	bg = nil,
	bgdata = nil,
	card_id = nil,
	list_get = nil,

	cleanup = function(self)
		self.layer = nil;
		self.bg = nil;
		self.bgdata = nil;
		self.card_id = nil;
		self.list_get = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	-- see in ALERT TYPE
	create = function(self, alert_type, data)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_ALERT, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));

		if alert_type == ALERT_HERO_MISS then
			self:for_hero_miss_tip(data);
		elseif alert_type == ALERT_GET_PIECE then
			self:for_get_piece(data);
		else
			local path = util.get_path('bg_121.png');
			local frect = cc.rect(0, 0, 404, 260); -- fullrect
			local irect = cc.rect(198, 125, 8, 10); -- insetrect
			local size = cc.size(wfix(505), hfix(302));--realsize
			local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
			local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, size, 10); 

			local items = {};
			local item;

			pos = cc.p(size.width - 35, size.height - 40);
			item = add_item_2(items, 'btn_16.png', 'btn_16_s.png', self.back, ANCHOR_CENTER_CENTER, pos);

			util.add_menu(bg, items, 50);
		end

		return self.layer, self.name;
	end,

	back = function()
		local self = layer_alert;
		self:remove();
	end,

	for_hero_miss_tip = function(self, cdata)
		local bg, data, sprite, data2;
		bg, data = gui_add_sprite(self.layer, 'bg_tip', GUI_HERO, ANCHOR_UP);
		bg:setAnchorPoint(ANCHOR_LEFT_CENTER);
		bg:setPositionY(HALF_HEIGHT);
		
		sprite, data2 = gui_add_sprite_on_cell(bg, data, 'tip_hframe', GUI_HERO, ANCHOR_UP);
		local s = sprite:getContentSize();
		local hid = cdata.hid;
		local name = cdata.name;
		local fname = 'card' .. hid .. '.png';
		path = util.get_path(fname, 'card0.png');
		local pic = util.add_sprite(sprite, path, cc.p(s.width/2, s.height/2), ANCHOR_CENTER_CENTER, -1);
		pic:setScaleX((s.width-8)/pic:getContentSize().width);
		pic:setScaleY((s.height-8)/pic:getContentSize().height);

		sprite, data2 = gui_add_sprite_on_cell(bg, data, 'tip_hnframe', GUI_HERO, ANCHOR_UP);
		s = sprite:getContentSize();
		util.add_labelttf(sprite, name, nil, 22, cc.p(s.width/2, s.height/2), util.c4b_black, ANCHOR_CENTER_CENTER, 10, s, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);

		sprite, data2 = gui_add_sprite_on_cell(bg, data, 'tip_get', GUI_HERO, ANCHOR_UP);
		sprite, data2 = gui_add_sprite_on_cell(bg, data, 'tip_desc_bg', GUI_HERO, ANCHOR_UP);
		local str = "我都唔知讲咩好了";
		sprite = gui_add_label_on_cell(bg, data, str, 22, 'tip_desc', GUI_HERO, ANCHOR_UP);
		sprite:setAlignment(cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_TOP);
		--util.add_labelttf(bg, str, nil, 22, cc.p(200, size.height/2), util.c4b_white, ANCHOR_LEFT_CENTER, 10, cc.size(size.width-220, size.height-60), cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
		local items = {};
		local item;

		item, data2 = gui_add_item_on_cell(items, data, 'btn_back_tip', GUI_HERO, self.back, ANCHOR_UP);

		util.add_menu(bg, items, data2.zorder);
	end,

	for_get_piece = function(self, cdata)
		local bg, data, sprite, data2;
		bg, data = gui_add_sprite(self.layer, 'pbg', GUI_SGDECK, ANCHOR_UP);
		self.bg = bg;
		self.bgdata = data;
		bg:setAnchorPoint(ANCHOR_LEFT_CENTER);
		bg:setPositionY(HALF_HEIGHT);
		
		sprite, data2 = gui_add_sprite_on_cell(bg, data, 'ptip', GUI_SGDECK, ANCHOR_UP);
		local card = clone(cdata.card);
		self.card_id = card.id;
		local has = cdata.has or 0;
		local count = cdata.count;
		local current_piece_count = cdata.current_piece_count;
		local merge_count = cdata.merge_count;
		if nil ~= current_piece_count and nil ~= merge_count then
			-- layer_piece
			has = current_piece_count;
			count = merge_count;
		end

		data2 = gui_get_data('pframe', GUI_SGDECK, ANCHOR_UP);
		local pos = cc.p(data2.x-data.x+data2.width/2, data2.y-data.y+data2.height/2);
		local cinfo = object_card:new(bg, card, nil, nil, pos, 0, 1, STYPE_VER_1);
		sprite = cinfo:get_front();
		local s = sprite:getContentSize();
		local ws = data2.width/s.width;
		local wh = data2.height/s.height;
		if ws < wh then
			sprite:setScale(ws);
		else
			sprite:setScale(wh);
		end
		local path = util.get_path(FT_8);
		local str = has .. '/' .. count;
		pos.x = pos.x+data2.width/2;
		util.add_labelbmf(bg, str, path, pos, ANCHOR_RIGHT_CENTER, 100);
		path = util.get_path('pic_88.png');
		util.add_sprite(sprite, path, cc.p(50, 380), ANCHOR_LEFT_DOWN, 10);

		local items = {};
		local item;

		item, data2 = gui_add_item_on_cell(items, data, 'pback', GUI_SGDECK, self.back, ANCHOR_UP);

		util.add_menu(bg, items, data2.zorder);
	end,

	set_get_piece_tip = function(self, card_id, list)
		if nil == self.bg or self.card_id ~= card_id then return; end
		list = list or {};
		self.list_get = list;
		local items = {};
		local item, data2;

		local bg = self.bg;
		local data = self.bgdata;
		local path = util.get_path(FT_7);
		local len = #list;
		if len > 3 then len = 3; end
		for i = 1, len do
			local info = list[i];
			local key = 'pline' .. i;
			item, data2 = gui_add_item_on_cell(items, data, key, GUI_SGDECK, self.cb_get_piece, ANCHOR_UP);
			data2 = gui_get_data(key, GUI_SGDECK, ANCHOR_UP);
			item:setTag(i);
			key = 'pchapter' .. i;
			str = info.chapter_name;
			gui_add_label_on_cell(item, data2, str, 22, key, GUI_SGDECK, ANCHOR_UP);
			key = 'pnum' .. i;
			str = info.chapter_id .. '-' .. info.stage_id;
			gui_add_labelbmf_on_cell(item,data2,str,path,key,GUI_SGDECK,ANCHOR_UP);
		end
		util.add_menu(bg, items, data2.zorder);
	end,

	cb_get_piece = function(...)
		local self = layer_alert;
		if 0 == #(self.list_get or {}) then return; end
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list_get[index];
		if nil == info then return; end
		--local cmd = string.format("chapter %d %d", info.chapter_id,info.stage_id);
		--net_send(cmd);
		layer_chapter.set_stage_id_for_mission = info.stage_id;
		layer_chapter.last_chapter_id = info.chapter_id;
		g_scene:chapter();
	end,

	handler = function(event, x, y)
		local self = layer_alert;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,

} -- layer_alert end

layer_table = {  -- layer_table start
	name = 'layer_table',
	layer = nil,
	btn_chat = nil,
	btn_name_up = nil,
	btn_name_down = nil,
	phase = nil,
	round = nil,
	gr = nil,
	gate_tip = nil,
	gate_msg = nil,
	chapter_reward_msg = nil,

	cleanup = function(self)
		self.layer = nil;
		self.btn_chat = nil;
		self.btn_name_up = nil;
		self.btn_name_down = nil;
		self.phase = nil;
		self.round = nil;
		self.gr = nil;
		self.gate_tip = nil;
		self.gate_msg = nil;
		self.chapter_reward_msg = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_TABLE, self.handler, true);

		local sprite, data, side;
    	-- add desk background
		sprite = gui_add_sprite(self.layer, 'bg', GUI_MATCH);
		--gui_add_sprite(self.layer, 'left_up_leaf', GUI_MATCH, ANCHOR_UP);
		gui_add_sprite(self.layer, 'bg_btn_left', GUI_MATCH);
		gui_add_sprite(self.layer, 'bg_btn_right', GUI_MATCH);
		sprite = gui_add_sprite(self.layer, 'bg_btn_auto', GUI_MATCH);
		sprite:setPositionY(0);
		gui_add_sprite(self.layer, 'ally_up_t', GUI_MATCH);
		gui_add_sprite(self.layer, 'ally_down_t', GUI_MATCH);
		gui_add_sprite(self.layer, 'sup_up_t', GUI_MATCH);
		gui_add_sprite(self.layer, 'sup_down_t', GUI_MATCH);
		gui_add_sprite(self.layer, 'bg_hero_up', GUI_MATCH);
		gui_add_sprite(self.layer, 'bg_hero_down', GUI_MATCH);
		--[[
		gui_add_sprite(self.layer, 'board', GUI_MATCH);
		gui_add_sprite(self.layer, 'arc_up', GUI_MATCH, ANCHOR_UP);
		gui_add_sprite(self.layer, 'arc_down', GUI_MATCH, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 'bg_right_up', GUI_MATCH, ANCHOR_UP);
		sprite, data = gui_add_sprite(self.layer, 'res_up', GUI_MATCH);
		sprite, data = self:adjust_res(sprite, data);
		sprite:setRotation(180);
		sprite, data = gui_add_sprite(self.layer, 'res_down', GUI_MATCH);
		sprite, data = self:adjust_res(sprite, data);
		gui_add_sprite(self.layer, 'bg_btn_left', GUI_MATCH);
		gui_add_sprite(self.layer, 'bg_btn_right', GUI_MATCH);
		gui_add_sprite(self.layer, 'bg_hero_up', GUI_MATCH);
		gui_add_sprite(self.layer, 'bg_hero_down', GUI_MATCH);
		]]--

        -- ===down side start===
		side = SIDE_DOWN;
        -- grave
		data = self:set_table('grave_down', side, T_GRAVE);
        -- deck
		data = self:set_table('deck_down', side, T_DECK);
        -- resource
		data = self:set_table('res_down', side, T_RES);
        -- support
		data = self:set_table('sup_down', side, T_SUPPORT);
        -- hand
		data = self:set_table('hand_down', side, T_HAND);
        -- ally
		data = self:set_table('ally_down', side, T_ALLY);
        -- hero
		data = self:set_table('hero_down', side, T_HERO);
		self.name_down = util.add_labeloutline(self.layer, '', nil, 25, cc.p(data.x, data.y+data.height/2), util.c4b_white, util.c4b_black, 1, ANCHOR_LEFT_DOWN, data.zorder - 2);
        -- ===down side end===
        
		-- ===up side start===
		side = SIDE_UP;
        -- grave
		data = self:set_table('grave_up', side, T_GRAVE);
        -- deck
		data = self:set_table('deck_up', side, T_DECK);
        -- resource
		data = self:set_table('res_up', side, T_RES);
        -- support
		data = self:set_table('sup_up', side, T_SUPPORT);
        -- hand
		data = self:set_table('hand_up', side, T_HAND);
        -- ally
		data = self:set_table('ally_up', side, T_ALLY);
        -- hero
		data = self:set_table('hero_up', side, T_HERO);
		self.name_up = util.add_labeloutline(self.layer, '', nil, 25, cc.p(data.x, data.y+data.height/2), util.c4b_white, util.c4b_black, 1, ANCHOR_LEFT_DOWN, data.zorder - 2);
		-- ===up side end  ===

		local items = {};
		local item;

		--[[
		item, data = gui_add_item(items, 'btn_left', GUI_MATCH, self.chat, ANCHOR_NULL);
		util.add_text_outline_to_sprite(item, '聊天', 25, util.c4b_gold, util.c4b_black, 1);
		self.btn_chat = item;
		]]--

		--[[ xxx
		item, data = gui_add_item(items, 'btn_left', GUI_MATCH, self.tip, ANCHOR_NULL);
		--util.add_text_outline_to_sprite(item, '提示', 25, util.c4b_gold, util.c4b_black, 1);
		util.add_text_to_sprite(item, '提示', 28, util.c4b_text);
		]]--

		if true == is_show_tip_btn() then
			--[[
			item, data = gui_add_item(items, 'btn_tip', GUI_MATCH, self.tip, ANCHOR_NULL);
			util.add_text_outline_to_sprite(item, '提示', 25, cc.c4b(data.r, data.g, data.b, 255), cc.c4b(data.sr, data.sg, data.sb, 255), 1);
			self:btn_tip_anim(item);
			]]--

			--[[ xxx
			item, data = gui_add_item(items, 'btn_tip', GUI_MATCH, self.chat, ANCHOR_NULL);
			util.add_text_outline_to_sprite(item, '聊天', 25, cc.c4b(data.r, data.g, data.b, 255), cc.c4b(data.sr, data.sg, data.sb, 255), 1);
			self.btn_chat = item;
			]]--
		end

		util.add_menu(self.layer, items, 100);

		self:set_name_btn();
		self:add_phase_tip();

		return self.layer, self.name;
	end,

	add_gate_msg = function(self, gate_msg_list)
		if nil == self.layer then return; end
		self.gate_msg = gate_msg_list or {};
	end,

	check_svg_tutorial = function()
		local flag = false;
		if false == flag then
			flag = util.trigger_tutor(TUTOR_FIRST_SAC);
		end
		if false == flag then
			flag = util.trigger_tutor(TUTOR_SECOND_SAC);
		end
	end,

	show_gate_msg = function(self, round)
		if 0 == round%2 then return; end
		local rr = math.floor(round/2) + round%2;
		for i = 1, #(self.gate_msg or {}) do
			local data = self.gate_msg[i];
			local gate_round = data.round;
			local r = math.floor(gate_round/2) + gate_round%2;
			--if round == data.round then
			if rr == r then
				local cid = data.card_id;
				local rc = g_card_list[cid];
				if nil == rc then
					rc = hero_list[cid];
				end
				if nil ~= rc then
					local card = clone(rc);	
					g_scene:add_layer(ZORDER_LAYER_GATEPOP, layer_gatepop:create(card, data.msg, layer_table.check_svg_tutorial));
				end
				--[[
				local actor = { name = rc.name, icon = 1, use_card_pic = true };
				local list_tip = { data.msg, };
				local layer, name = layer_story:create(actor, list_tip, nil);
				g_scene:add_layer(ZORDER_LAYER_STORY, layer, name);
				]]--
				return;
			end
		end
	end,

	add_gate_tip = function(self, gr)
		self.gr = gr;
		local data = gui_get_data('bg_time', GUI_MATCH, ANCHOR_UP);
		local pos = cc.p(data.x+data.width, data.y);
		local text = "第1回合\n";
		for i = 1, #gr do
			local r = gr[i];
			--print('r: ', r);
			r = math.floor(r/2) + r%2;
			if i == 1 then
				text = text .. r;
			else
				text = text .. '-' .. r;
			end
		end
		--local label = util.add_labeloutline(self.layer, text, nil, 24, pos, util.c4b_gold, util.c4b_black, 2, ANCHOR_CENTER_CENTER, 10, cc.size(width, height), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
		self.gate_tip = util.add_labeloutline(self.layer, text, nil, 24, pos, util.c4b_gold, util.c4b_black, 2, ANCHOR_CENTER_CENTER, 90);
	end,

	update_gate_tip = function(self, round)
		self:show_gate_msg(round);
		if nil == self.gate_tip or nil == self.gr then return; end
		local rr = math.floor(round/2) + round%2;
		local text = "第" .. rr .. "回合\n";
		local offset = nil;
		for i = 1, #self.gr do
			local r = self.gr[i];
			r = math.floor(r/2) + r%2;
			text = text .. '-' .. r;
			if nil == offset and r >= rr then
				offset = r - rr;
			end
		end
		self.gate_tip:setString(text);
		if round%2 == 0 then return; end
		if nil == offset then return; end
		local msg;
		if 0 == offset then
			msg = "敌人即将出现";
		else
			msg = string.format("第%d回合\n离下一轮敌方出现还有%d个回合", rr, offset);
		end
		pop_gate_count(msg);

	end,

	add_phase_tip = function(self)
		local fname;
		if g_phase == PHASE_SACRIFICE then
			fname = "text_3.png";
		else
			fname = "text_4.png";
		end
		local data, scale = gui_get_data("phase_pic", GUI_MATCH);
		local path = util.get_path(fname);
		--local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local pos = cc.p(data.x+data.width/2, data.y+data.height/2);
		self.phase = util.add_sprite(self.layer,path,pos,ANCHOR_CENTER_CENTER,10);
		local tr = 'T' .. g_round;
		--self.round = gui_add_label(self.layer, tr, 24, 'num_round', GUI_MATCH);
		path = util.get_path(FT_4);
		print(' - 1');
		self.round = gui_add_labelbmf(self.layer,tr,path,'num_round',GUI_MATCH);
		print(' - 2');

		--[[
		local size = cc.size(wfix(200), hfix(64));--realsize
		if size.height < 64 then size.height = 64; end
		local path = util.get_path('pop_up.png');
		local frect = cc.rect(0, 0, 64, 64); -- fullrect
		local irect = cc.rect(30, 30, 4, 4); -- insetrect
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, size, 10); 
		self.phase = bg;
		bg:setOpacity(200);
		local str;
		if phase == PHASE_SACRIFICE then
			str = '弃牌阶段';
		else
			str = '出牌阶段';
		end
		local label = util.add_labeloutline(bg, str, nil, 25, cc.p(size.width/2, size.height/2), util.c4b_gold, util.c4b_black, 2, ANCHOR_CENTER_CENTER, 10, cc.size(size.width-40, size.height-30), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
		label:setTag(333);

		--util.add_labeloutline(self.layer, str, nil, 28, cc.p(HALF_WIDTH, HALF_HEIGHT), util.c4b_black, util.c4b_white, 2, ANCHOR_CENTER_CENTER, 10, cc.size(size.width-40, size.height-30), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
		]]--
	end,

	update_phase = function(self, side, phase)
		if nil == self.layer then return; end
		if nil == self.phase or nil == self.round then return; end
		local tr = 'T' .. g_round;
		self.round:setString(tr);
		if side == g_euser.side then return; end -- my side only show phase
		local tag = 123;
		self.phase:stopActionByTag(tag);
		local function change()
			local fname;
			if phase == -1 then
				fname = "text_5.png";
				if g_euser.side == SIDE_GUEST then
					if side == SIDE_UP then
						fname = "text_6.png";
					else
						fname = "text_7.png";
					end
				end
			elseif phase == PHASE_SACRIFICE then
				fname = "text_3.png";
			else
				fname = "text_4.png";
			end
			local path = util.get_path(fname);
			local tc = cc.Director:getInstance():getTextureCache();
			local texture = tc:addImage(path);
			if nil == texture then return; end
			self.phase:setTexture(texture);
		
			--[[
			local str;
			if phase == -1 then
				str = '对方回合';
				if g_euser.side == SIDE_GUEST then
					if side == SIDE_UP then
						str = '上方回合';
					else
						str = '下方回合';
					end
				end
			elseif phase == PHASE_SACRIFICE then
				str = '弃牌阶段';
			else
				str = '出牌阶段';
			end
			local label = self.phase:getChildByTag(333);
			if nil == label then return; end
			label:setString(str);
			]]--
		end
		local orbit_time = 0.3;
		local anims_array = {};
		local orbit1 = cc.OrbitCamera:create(orbit_time, 1, 0, 0, -90, 90, 0);
		local orbit2 = cc.OrbitCamera:create(orbit_time, 1, 0, 90, -90, 90, 0);
		table.insert(anims_array, orbit1);
		table.insert(anims_array, cc.CallFunc:create(change));
		table.insert(anims_array, orbit2);
		local action = cc.Sequence:create(anims_array);

		action:setTag(tag);
		self.phase:runAction(action);
	end,

	-- deprecated
	adjust_res = function(self, sprite, data)
		local x = data.x+data.width/2;
		local y = data.y+data.height/2;
		sprite:setPosition(cc.p(x, y));
		sprite:setAnchorPoint(ANCHOR_CENTER_CENTER);
		local scale = data.width/data.rwidth;
		if data.height/data.rheight < scale then
			scale = data.height/data.rheight;
		end
		sprite:setScale(scale);
		data.scale = scale;
		data.x = x;
		data.y = y;
		data.width = data.owidth * data.scale;
		data.height = data.oheight * data.scale;
		local path = util.get_path('res_eff.plist');
		util.add_particle(sprite, path, cc.p(data.rwidth/2, data.rheight/3*2),10);
		return sprite, data;
	end,

	btn_tip_anim = function(self, btn)
		--local sprite = btn:getNormalImage();
		local c = btn:getColor();
		local action, array;
		array = {};
		action = cc.TintTo:create(1, 150, 150, 100);
		table.insert(array, action);
		action = cc.TintTo:create(1, c.r, c.g, c.b);
		table.insert(array, action);
		action = cc.Sequence:create(array);
		action = cc.RepeatForever:create(action);
		btn:runAction(action);
	end,

	hide_name_btn = function(self, side)
		local label = nil;
		local tag = TAG_SPRITE_LABEL;
		if side == SIDE_UP then
			label = self.btn_name_up:getChildByTag(tag);
		else
			label = self.btn_name_down:getChildByTag(tag);
		end
		if nil == label then return; end
		label:setVisible(false);
	end,

	set_name_btn = function(self)
		if nil == g_euser.room_data then
			return;
		end
		local list = g_euser.room_data.guest_list or {};
		if 2 > #list then
			return;
		end
		local name_up = nil;
		local name_down = nil;
		local eid_up, eid_down;
		local is_guest = true;
		for i = 1, 2 do
			local info = list[i];
			if info.eid == g_euser.eid then
				is_guest = false;
				break;
			end
		end
		if true == is_guest then
			for i = 1, 2 do
				local info = list[i];
				if i == SIDE_DOWN then
					name_down = info.alias;
					eid_down = info.eid;
				else
					name_up = info.alias;
					eid_up = info.eid;
				end
			end
		else
			for i = 1, 2 do
				local info = list[i];
				if info.eid == g_euser.eid then
					name_down = info.alias;
					eid_down = info.eid;
				else
					name_up = info.alias;
					eid_up = info.eid;
				end
			end
		end
		if nil == name_down or nil == name_up then
			return;
		end

		local function cb(...)
			local args = {...};
			local tag = args[2]:getTag();
			if tag == g_euser.eid then return; end
			if tag < 500 then return; end
			local info = nil;
			for i = 1, 2 do
				local d = list[i];
				if d.eid == tag then
					info = d;
					break;
				end
			end
			g_scene:add_layer(ZORDER_LAYER_CHATPOP, layer_chatpop:create(info));
		end

		local items = {};
		local data, item, label;

		item,data = gui_add_item(items, 'bg_alias_up', GUI_MATCH, cb);
		label = gui_add_text_outline_on_sprite(item, name_up, 'alias_up', GUI_MATCH, nil, 23);
		item:setTag(eid_up);
		self.btn_name_up = item;

		item,data = gui_add_item(items, 'bg_alias_down', GUI_MATCH, cb);
		label = gui_add_text_outline_on_sprite(item, name_down, 'alias_down', GUI_MATCH, nil, 23);
		item:setTag(eid_down);
		self.btn_name_down = item;

		util.add_menu(self.layer, items, ZORDER_SHOWING+11);
	end,

	change_side = function(self, side)
		if nil == self.btn_name_up or nil == self.btn_name_down then return; end
		local s1, s2;
		local tag = TAG_SPRITE_LABEL;
		if side == SIDE_DOWN then
			s1 = self.btn_name_down:getChildByTag(tag);
			s2 = self.btn_name_up:getChildByTag(tag);
		elseif side == SIDE_UP then
			s1 = self.btn_name_up:getChildByTag(tag);
			s2 = self.btn_name_down:getChildByTag(tag);
		else
			return;
		end
		if nil ~= s1 then
			--s1:setColor(cc.c3b(94, 253, 199));
			s1:setColor(cc.c3b(252, 190, 3));
		end
		if nil ~= s2 then
			s2:setColor(cc.c3b(255, 255, 255));
		end
		--pop_turn(g_euser.side, side);
		layer_table:update_phase(side, -1);
		if g_scene:is_stage(STAGE_PVG) then
			layer_table:update_gate_tip(g_round);
		end
	end,

	fix_size_ally_support = function(self, data, cwidth, cheight)
		local x, y, width, height, scale;
		local offsetx = 0;--5;--10;--20;
		local offsety = 0;--3;--13;
		y = data.y + data.height / 2;
		scale = (data.height-hfix(offsety*2))/cheight;
		x = data.x + wfix(offsetx) + cwidth * scale / 2;
		width = data.width - offsetx * 2;
		height = data.height - offsety * 2;
		return x, y, width, height, scale;
	end,

	set_table = function(self, key, side, _table)
		if key ~= 'hand_up' and key ~= 'hand_down' and
		   key ~= 'hero_up' and key ~= 'hero_down' then
			gui_add_sprite(self.layer, key, GUI_MATCH);
		end
		local cwidth = CARD_SIZE_2.width;
		local cheight = CARD_SIZE_2.height;
		local data = gui_get_data(key, GUI_MATCH);
		local x, y, width, height, scale;
		if _table == T_HAND then
			local gapy = hfix(60);
			width = data.width;
			height = data.height + gapy;
			x = data.x + cwidth / 2;
			if key == 'hand_down' then
				y = data.y + data.height - height/2;
			else
				y = data.y + height/2;
			end
			scale = height / cheight;
		elseif _table == T_ALLY or _table == T_SUPPORT then
			x, y, width, height, scale = self:fix_size_ally_support(data, cwidth, cheight);
		else
			x = data.x + data.width / 2;
			y = data.y + data.height / 2;
			width = data.width;
			height = data.height;
			scale = data.height / cheight;
		end
		if _table == T_HERO then
			local wscale = data.width / data.rwidth;
			local hscale = data.height / data.rheight;
			if wscale < hscale then
				scale = wscale;
			else
				scale = hscale;
			end
		end
		--[[
		if _table == T_DECK then
			scale = 1;
		end
		]]--
		local ui_table = g_ui_table[side][_table];
		local b = false;
		if _table == T_GRAVE then
			b = true;
		end
		if _table == T_DECK then
			scale = width/CARD_SIZE_2.width;
			y = y + scale*20;
		end
		self:set_frame(ui_table, x, y, width, height, scale, cwidth, cheight, b);
		return data;
	end,

	set_frame = function(self, frame, x, y, width, height, cscale, cwidth, cheight, is_grave)
		frame.x = x;
		frame.y = y;
		frame.width = width;
		frame.height = height;
		frame.cscale = cscale;
		frame.cwidth = cwidth * cscale;
		frame.cheight = cheight * cscale;
		if true == is_grave then
			--frame.pic_width = nil;
			--frame.pic_height = nil;
			frame.pic_x = frame.x;
			frame.pic_y = frame.y+frame.cscale*20;
			frame.pic_scale = frame.cscale;--GRAVE_SIZE.height/PIC_SIZE.height;
			--frame.origin_y = y;
			--frame.y = math.floor(y + height/2 - pheight/2);
			--frame.cscale = pscale;
			--frame.cwidth = cwidth * pscale;
			--frame.cheight = cheight * pscale;
			frame.pic_len = 1;
			--[[
			local psize = PIC_SIZE;
			local pscale = width/psize.width;
			local pwidth = width;
			local pheight = math.floor(height * pscale);
			local gapy = pheight + hfix(6);
			frame.pic_width = pwidth;
			frame.pic_height = pheight;
			frame.pic_scale = pscale;
			frame.origin_y = y;
			frame.y = math.floor(y + height/2 - pheight/2);
			frame.cscale = pscale;
			frame.cwidth = cwidth * pscale;
			frame.cheight = cheight * pscale;
			frame.pic_len = math.floor(height/gapy) - 1;
			]]--
		else
			frame.pic_width = nil;
			frame.pic_height = nil;
			frame.pic_scale = nil;
			frame.origin_y = nil;
			frame.pic_len = nil;
		end
	end,

	chat = function()
		play_tap_1();
		g_scene:add_layer(ZORDER_LAYER_CHAT, layer_chat:create(true));
	end,

	tip = function()
		play_tap_1();
--		if true == g_scene:is_stage(STAGE_PVP) then
--			tutor_pvp_attack();
--			return;
--		end
		if true == LOCAL_TEST then
			do_ai();
			return;
		end
		if true ~= g_scene:is_online() then
			return;
		end
		if g_euser.side ~= g_current_side then
			show_msg(t_lang("TIP_WAIT_OPPONENT"));
			return;
		end
		if false == is_touchable() then
			return;
		end
		if PHASE_SACRIFICE == g_phase then
--			util.set_tutor(TUTOR_RES, false, false);
--			util.set_tutor(TUTOR_SAC_TAP, false, false);
			util.trigger_tutor(TUTOR_RES);
		else
			local list = g_ui_table[g_euser.side][T_HAND];
			local info = nil;
			info = check_hl_in_list(list);
			if nil ~= info then
				-- can use card in hand
--				util.set_tutor(TUTOR_PLAY, false, false);
--				util.set_tutor(TUTOR_HL, false, false);
--				util.set_tutor(TUTOR_NEED_RES, false, false);
--				util.set_tutor(TUTOR_USE, false, false);
				util.trigger_tutor(TUTOR_PLAY);
				return;
			end
			list = g_ui_table[g_euser.side][T_ALLY];
			info = check_hl_in_list(list);
			if nil ~= info then
				-- can use card in ally
--				util.set_tutor(TUTOR_HL_ALLY, false, false);
--				util.set_tutor(TUTOR_TAP_ATTACK, false, false);
--				util.set_tutor(TUTOR_HL_ATTARGET, false, false);
--				util.set_tutor(TUTOR_TAP_ATTARGET, false, false);
				util.trigger_tutor(TUTOR_HL_ALLY);
				return;
			end
			if nil ~= g_src_index and g_src_index > 0 
				                  and g_action_type == TYPE_ATTACK then
				-- choose target to attack
--				util.set_tutor(TUTOR_HL_ATTARGET, false, false);
--				util.set_tutor(TUTOR_TAP_ATTARGET, false, false);
				util.trigger_tutor(TUTOR_HL_ATTARGET);
				return;
			end
			info = g_ui_table[g_euser.side][T_HERO][1];
			if nil ~= info then
				--[[
				local s = info:get_sprite();
				local h = s:getChildByTag(TAG_HIGHLIGHT);
				local index = cindex(info.card);
				local indexs = list_ability_target(index, g_logic_table, g_current_side, {}, 1);
				if nil ~= h and #indexs > 0 then
					util.set_tutor(TUTOR_HL_HERO, false, false);
					util.set_tutor(TUTOR_TAP_ABHERO, false, false);
					util.trigger_tutor(TUTOR_HL_HERO);
					return;
				end
				]]--
				local kind = check_kind(info.card, g_logic_table, g_current_side, g_phase);
				if kind == AKIND_ABILITY or kind == AKIND_BOTH then
--					util.set_tutor(TUTOR_HL_HERO, false, false);
--					util.set_tutor(TUTOR_TAP_ABHERO, false, false);
					util.trigger_tutor(TUTOR_HL_HERO);
					return;
				end
			end
--			util.set_tutor(TUTOR_NEXT, false, false);
			util.trigger_tutor(TUTOR_NEXT);
		end
	end,

	handler = function(event, x, y)
		local self = layer_table;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
}  -- layer_table end

layer_card = {
	name = 'layer_card',
	layer = nil,   -- @see init()
	FORCE_AUTO = 0, -- set in net_game
	touch_point = nil,
	btn_next = nil,
	btn_confirm = nil,
	btn_skip = nil,
	btn_cancel = nil,
	btn_auto = nil,
	-- action target list ,such as ability target list
	-- @see callback_cancel()  : reset to empty (write)
	ability_target_list = {},
	touch_card = {ltype = 0, index = 0},
	target_card = nil, -- will init in onTouchMove
	p_drag = nil, -- particle drag
	p_pointer = nil, 
	p_hand = nil,
	label_count_deck = {},
	time_start = nil,
	next_timeout = nil,
	list_grave = { [SIDE_UP] = nil, [SIDE_DOWN] = nil, },
	count_label = nil,
	--round_label = nil,
	list_player = { [SIDE_UP] = nil, [SIDE_DOWN] = nil, },
	touch_func = nil,
	should_start_next_after_result = nil,
	time_touch_down = nil,
	--touch_y = nil,
	tip_help = nil,
	is_auto = nil,

	cleanup = function(self)
		self.layer = nil;
		self.touch_point = nil;
		self.btn_next = nil;
		self.btn_confirm = nil;
		self.btn_skip = nil;
		self.btn_cancel = nil;
		self.btn_auto = nil;
		self.ability_target_list = {};
		self.touch_card = {ltype = 0, index = 0};
		self.target_card = nil; -- will init in onTouchMove
		self.p_drag = nil;
		self.p_pointer = nil;
		self.p_hand = nil;
		self.label_count_deck = {};
		self.time_start = nil;
		self.next_timeout = nil;
		self.list_grave = { [SIDE_UP] = nil, [SIDE_DOWN] = nil, };
		self.count_label = nil;
		--self.round_label = nil;
		self.list_player = { [SIDE_UP] = nil, [SIDE_DOWN] = nil, };
		self.touch_func = nil;
		self.should_start_next_after_result = nil;
		self.time_touch_down = nil;
		--self.touch_y = nil;
		self.tip_help = nil;
		self.is_auto = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();
		
		self.layer = cc.Layer:create();
        
		util.reg_handler(self.layer, -ZORDER_LAYER_CARD, self.handler, false);

		self:init_cards();
		--self:add_table_alias();

		-- resource label
		self:init_res_label(g_logic_table, g_ui_table);

		gui_add_sprite(self.layer, 'left_up_leaf', GUI_MATCH, ANCHOR_UP);

		local items = {};
		local item, data;

		item, data = gui_add_item(items, 'btn_auto', GUI_MATCH, self.callback_auto, ANCHOR_NULL);
		self.btn_auto = item;
		if 1 == self.FORCE_AUTO then
			item:setSelectedIndex(1);
		end
		if g_euser.side ~= SIDE_DOWN then
			enable_btn(self.btn_auto, false);
		end

		item, data = gui_add_item(items, 'btn_finish', GUI_MATCH, self.callback_next_side, ANCHOR_NULL);
		--util.add_text_outline_to_sprite(item, '结束', 25, util.c4b_gold, util.c4b_black, 1);
		--util.add_text_to_sprite(item, '结束', 28, util.c4b_text);
		self.btn_next = item;
		item:setVisible(false);
		
		item, data = gui_add_item(items, 'btn_confirm', GUI_MATCH, self.callback_confirm, ANCHOR_NULL);
		--util.add_text_outline_to_sprite(item, '确定', 25, util.c4b_gold, util.c4b_black, 1);
		--util.add_text_to_sprite(item, '确定', 28, util.c4b_text);
		self.btn_confirm = item;
		item:setVisible(false);

		item, data = gui_add_item(items, 'btn_skip', GUI_MATCH, self.callback_skip_sac, ANCHOR_NULL);
		--util.add_text_outline_to_sprite(item, '跳过', 25, util.c4b_gold, util.c4b_black, 1);
		--util.add_text_to_sprite(item, '跳过', 28, util.c4b_text);
		self.btn_skip = item;
		item:setVisible(false);

		item, data = gui_add_item(items, 'btn_cancel', GUI_MATCH, self.callback_cancel, ANCHOR_NULL);
		--util.add_text_outline_to_sprite(item, '取消', 25, util.c4b_gold, util.c4b_black, 1);
		--util.add_text_to_sprite(item, '取消', 28, util.c4b_text);
		self.btn_cancel = item;
		item:setVisible(false);

		--util.add_menu(self.layer, items, ZORDER_MENU);
		util.add_menu(self.layer, items, ZORDER_CARD+10);

		--[[
		local path, pos, info, count, lup, ldown, data;
		path = util.get_path('font3_30.fnt');
		data = gui_get_data('deck_up_num', GUI_MATCH);
		info = g_ui_table[SIDE_UP][T_DECK];
		count = #(g_logic_table[SIDE_UP][T_DECK]);
		--pos = ccp(info.x, info.y);
		pos = ccp(data.x, data.y);
		--lup=util.add_labelbmf(self.layer,count,fullpath,pos,ANCHOR_CENTER_CENTER,ZORDER_COUNT_DECK);
		lup=util.add_labelbmf(self.layer,count,path,pos,ANCHOR_LEFT_DOWN,data.zorder);
		lup:setScale(0.8);
		info = g_ui_table[SIDE_DOWN][T_DECK];
		data = gui_get_data('deck_down_num', GUI_MATCH);
		count = #(g_logic_table[SIDE_DOWN][T_DECK]);
		--pos = ccp(info.x, info.y);
		pos = ccp(data.x, data.y);
		--ldown=util.add_labelbmf(self.layer,count,fullpath,pos,ANCHOR_CENTER_CENTER,ZORDER_COUNT_DECK);
		ldown=util.add_labelbmf(self.layer,count,path,pos,ANCHOR_LEFT_DOWN,data.zorder);
		ldown:setScale(0.8);
		self.label_count_deck = { [SIDE_UP] = lup, [SIDE_DOWN] = ldown };
		]]--

		self:init_deck_num(g_logic_table);
		
		--self:set_name_btn();
		
		return self.layer, self.name;
	end,

	set_wait_result = function(self)
		self.should_start_next_after_result = true;
	end,

	show_tip_help = function(self, tips)
		self:remove_tip_help();

		tips = tips or '';

--		local size = cc.size(wfix(200), hfix(64));--realsize
		local size = cc.size(FULL_WIDTH/4*3, HALF_HEIGHT/4);
		if size.height < 64 then size.height = 64; end
		local path = util.get_path('pop_up.png');
		local frect = cc.rect(0, 0, 64, 64); -- fullrect
		local irect = cc.rect(30, 30, 4, 4); -- insetrect
		local pos = cc.p(HALF_WIDTH, FULL_HEIGHT - 30);
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_UP, frect, irect, size, 100); 
		self.tip_help = bg;
		local label = util.add_labeloutline(bg, tips, nil, 25, cc.p(size.width/2, size.height/2), util.c4b_gold, util.c4b_black, 2, ANCHOR_CENTER_CENTER, 10, cc.size(size.width-40, size.height-30), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
	end,

	remove_tip_help = function(self)
		if nil ~= self.tip_help then
			self.tip_help:removeFromParent(true);
			self.tip_help = nil;
		end
	end,

	init_deck_num = function(self, logic_table)
		local path = util.get_path(FT_4);
		local scale = 0.8;

		local function set_label(side, key)
			local data = gui_get_data(key, GUI_MATCH);
			local count = #(g_logic_table[side][T_DECK]);
			--pos = ccp(data.x, data.y);
			--label=util.add_labelbmf(self.layer,count,path,pos,ANCHOR_LEFT_DOWN,data.zorder);
			pos = cc.p(data.x+data.width/2, data.y);
			--[[
			if key == "deck_down_num" then
				pos.y = pos.y + data.height;
			end
			]]--
			label=util.add_labelbmf(self.layer,count,path,pos,ANCHOR_CENTER_DOWN,data.zorder);
			label:setScale(scale);
			return label;
		end
		local lup = set_label(SIDE_UP, 'deck_up_num');
		local ldown = set_label(SIDE_DOWN, 'deck_down_num');
		self.label_count_deck = { [SIDE_UP] = lup, [SIDE_DOWN] = ldown };
	end,

	add_table_alias = function(self, data, title)
		gui_add_sprite(self.layer, 'l_ally_down', GUI_MATCH);
		gui_add_sprite(self.layer, 'l_ally_up', GUI_MATCH);
		gui_add_sprite(self.layer, 'l_supp_down', GUI_MATCH);
		gui_add_sprite(self.layer, 'l_supp_up', GUI_MATCH);
	end,

	add_clock = function(self, layer)
		local sprite, data, pos;
		-- 回合倒计时
		--sprite, data = gui_add_sprite(layer,'time',GUI_MATCH,ANCHOR_LEFT_UP);
		gui_add_sprite(layer,'bg_time', GUI_MATCH, ANCHOR_UP);
		local data, scale = gui_get_data('t_time', GUI_MATCH, ANCHOR_UP);
		--pos = ccp(data.x+80, data.height/2);
		--pos = ccp(data.x+60, data.height/2);
		local pos = cc.p(data.x, data.y);
		--local fontpath = util.get_fullpath(F_FONT, FNT_TIME);
		local path = util.get_path(FT_4);
		self.count_label = util.add_labelbmf(layer,'--',path, pos, ANCHOR_LEFT_DOWN, data.zorder);
		self.count_label:setScale(scale);

		--pos = ccp(data.x+120, data.height/2);
		--self.round_label = util.add_labelbmf(sprite,'',fontpath, pos, ANCHOR_LEFT_CENTER);
	end,

	update_player_info = function(self, data)
		local channel = data.channel;
		local room_id = data.room_id;
		local st = data.st;
		local texture_cache = CCTextureCache:sharedTextureCache();
		local texture_cache = cc.Director:getInstance():getTextureCache();
		local guest_list = data.guest_list;
		for i = 1, #guest_list do
			local info = guest_list[i];
			local icon = info.icon;
			local uinfo = self.list_player[i];
			if nil ~= uinfo then
				local avatar = uinfo.icon;
				local size = uinfo.size;
				local fullpath = get_icon_path(icon);
				local texture = texture_cache:addImage(fullpath);
				avatar:setTexture(texture);
				local s = avatar:getContentSize();
				avatar:setScaleX(size.width/s.width);
				avatar:setScaleY(size.height/s.height);
			end
		end
	end,

	init_res_label = function(self, logic_table, ui_table)
		local path = util.get_path(FT_1);
		local scale = 0.8;

		local function set_label(side, key)
			local label, pos, str;
			local t = logic_table[side];
			local data = gui_get_data(key, GUI_MATCH);
			pos = cc.p(data.x+34, data.y);
			str = string.format("%d", t.resource); 
			--label = util.add_labelbmf(self.layer,str,path,pos,ANCHOR_RIGHT_DOWN,data.zorder,cc.TEXT_ALIGNMENT_RIGHT,cc.size(data.width, data.height));
			label = util.add_labelbmf(self.layer,str,path,pos,ANCHOR_RIGHT_DOWN,data.zorder,cc.TEXT_ALIGNMENT_RIGHT);
			label:setScale(scale);
			ui_table.label_res[side] = label;

			pos = cc.p(data.x+35, data.y);
			label = util.add_labelbmf(self.layer,"/",path,pos,ANCHOR_LEFT_DOWN,data.zorder,cc.TEXT_ALIGNMENT_CENTER);
			label:setScale(scale);

			pos = cc.p(data.x+44, data.y);
			str = string.format("%d", t.resource_max); 
			label = util.add_labelbmf(self.layer,str,path,pos,ANCHOR_LEFT_DOWN,data.zorder,cc.TEXT_ALIGNMENT_LEFT);
			label:setScale(scale);
			ui_table.label_res_max[side] = label;
		end

		set_label(SIDE_UP, 'res_num_up');
		set_label(SIDE_DOWN, 'res_num_down');
	end,

	--[[
	init_res_label = function(self, logic_table, ui_table, side)
		local fullpath, label, str, data, pos, size;
		fullpath = util.get_fullpath(F_FONT, FNT_CARD);
		-- res value
		local t = logic_table[side];
		data = ui_table[side][T_RES];
		local hhh, y;
		if side == SIDE_UP then
			hhh = ANCHOR_DOWN;
			y = data.y+data.height/2+hfix(15);
		else
			hhh = ANCHOR_UP;
			y = data.y-data.height/2-hfix(15);
		end

		pos = cc.p(data.x - data.width/2 - wfix(16), y);
		str = string.format("%d", t.resource); 
		label = util.add_labelbmf(self.layer,str,fullpath,pos,cc.p(ANCHOR_RIGHT, hhh), data.zorder, cc.TEXT_ALIGNMENT_RIGHT, 0);
		ui_table.label_res[side] = label;

		pos = cc.p(data.x - data.width/2 - wfix(8), y);
		label = util.add_labelbmf(self.layer,"/",fullpath,pos,cc.p(ANCHOR_CENTER, hhh), data.zorder, cc.TEXT_ALIGNMENT_CENTER, 0);

		pos = cc.p(data.x - data.width/2, y);
		str = string.format("%d", t.resource_max); 
		label = util.add_labelbmf(self.layer,str,fullpath,pos,cc.p(ANCHOR_LEFT, hhh), data.zorder, cc.TEXT_ALIGNMENT_LEFT, 0);
		ui_table.label_res_max[side] = label;
	end,
	]]--

	update_res_label = function(self, logic_table, ui_table, side)
		if g_scene:is_stage(STAGE_PVG) then
			if side == SIDE_UP then
				return;
			end
		end
		local label_res, label_res_max;
		local t = logic_table[side];
		label_res = ui_table.label_res[side];
		label_res:setString(t.resource);
		label_res_max = ui_table.label_res_max[side];
		label_res_max:setString(t.resource_max);
	end,

	update_count_label = function(self, logic_table)
		local list = self.label_count_deck;
		local slist = { SIDE_UP, SIDE_DOWN };
		for i = 1, #slist do
			local side = slist[i];
			local label = list[side];
			if nil ~= label then
				local count = #(logic_table[side][T_DECK]);
				label:setString(count);
			end
		end
	end,

	hide_all_btn = function(self)
		if g_scene:is_stage(STAGE_REPLAY) then
			return;
		end
		if g_euser.side == SIDE_GUEST then
			return;
		end
		if true == self.btn_skip:isVisible() then
			enable_btn(self.btn_skip, false);
			--self.btn_next:setVisible(false);
			self.btn_next:setVisible(true);
			enable_btn(self.btn_next, false);
			self.btn_confirm:setVisible(false);
			self.btn_cancel:setVisible(false);
		elseif true == self.btn_confirm:isVisible() and true == self.btn_cancel:isVisible() then
			enable_btn(self.btn_confirm, false);
			enable_btn(self.btn_cancel, false);
			self.btn_next:setVisible(false);
			self.btn_skip:setVisible(false);
		else
			self.btn_next:setVisible(true);
			enable_btn(self.btn_next, false);
			self.btn_confirm:setVisible(false);
			self.btn_skip:setVisible(false);
			self.btn_cancel:setVisible(false);
		end
	end,

	set_to_table = function(self, side, _table)
		local logic_table = g_logic_table[side][_table];
		local ui_table = g_ui_table[side][_table];
		local cwidth = CARD_SIZE_2.width;
		local cheight = CARD_SIZE_2.height;
		local cscale = ui_table.cscale;
		local gap;
		if ui_table.ltype == UP_GRAVE or ui_table.ltype == DOWN_GRAVE or 
		   ui_table.ltype == UP_DECK or ui_table.ltype == DOWN_DECK then
			gap = 0;
		else
			gap = calculate_gap(#logic_table, cwidth * cscale, ui_table.width, ui_table.ltype);
		end
		
		for i = 1, #logic_table do
			local card = logic_table[i]; 
			local pos;
			local rotation = 0;
			pos, rotation = get_card_pos_rotation(ui_table, gap, i, #logic_table);
			add_ui_card(self.layer, ui_table, pos, rotation, card);
		end
	end,

	init_cards = function(self)
        -- ===down side start===
		local side = SIDE_DOWN;
		-- deck
		self:set_to_table(side, T_DECK);
		-- grave
		self:set_to_table(side, T_GRAVE);
		-- hero
		self:set_to_table(side, T_HERO);
		-- hand
		self:set_to_table(side, T_HAND);
		-- support
		self:set_to_table(side, T_SUPPORT);
		-- ally
		self:set_to_table(side, T_ALLY);
        -- ===down side end===
        -- ===up side start===
		side = SIDE_UP;
		-- deck
		self:set_to_table(side, T_DECK);
		-- grave
		self:set_to_table(side, T_GRAVE);
		-- hero
		self:set_to_table(side, T_HERO);
		-- hand
		self:set_to_table(side, T_HAND);
		-- support
		self:set_to_table(side, T_SUPPORT);
		-- ally
		self:set_to_table(side, T_ALLY);
        -- ===up side end===
	end,
	
	clean_menu = function(self)
		self:change_btn(self.btn_next);
	end,

	update_next_count = function(dt)
		local self = layer_card;
		local t = os.time() - self.time_start;
		--print('os.time: ', t);
		local str = self.next_timeout - t;
		if t > self.next_timeout then
			self:stop_timeout();
			if PHASE_SACRIFICE ~= g_phase or g_euser.side ~= g_current_side then
				enable_btn(self.btn_next, true);
			end
			str = '--';
		end
		local label = self.count_label;
		if nil == label then return; end
		label:setString(str);
	end,

	stop_timeout = function(self)
		self.next_timeout = nil;
		self.time_start = nil;
		self.count_label:setString('--');
		self.layer:unscheduleUpdate();
	end,

	check_timeout = function(self)
		if g_euser.side ~= g_current_side then
			if nil == self.next_timeout then
				enable_btn(self.btn_next, true);
			end
		end
	end,

	show_timeout = function(self, timeout)
		--print("---- show_timeout");
		self:stop_timeout();
		timeout = timeout or 30;
		self.count_label:setString(timeout);
		self.next_timeout = timeout;
		self.time_start = os.time();
		self.layer:scheduleUpdateWithPriorityLua(self.update_next_count, 1);
	end,

	handle_next_timeout = function(self, timeout)
		--self.round_label:setString(g_round or '');
		--print("---- handle_next_timeout");
		if g_scene:is_stage(STAGE_PVG) then
			return;
		end
		if g_scene:is_stage(STAGE_REPLAY) then
			return;
		end
		local dtimeout = tonumber(g_constant.max_timeout) or 60;
		timeout = tonumber(timeout or dtimeout);
		--print('timeout: ', timeout);
		if true == LOCAL_TEST or true ~= g_scene:is_online() then
			if PHASE_SACRIFICE ~= g_phase then
				self:change_btn(self.btn_next);
			end
			enable_btn(self.btn_next, true);
			return;
		end
		local s1 = g_euser.side;
		local s2 = g_current_side;
		self:show_timeout(timeout);
		if g_euser.side == SIDE_GUEST then
			return;
		end
		if nil ~= timeout and g_euser.side ~= g_current_side then
			self:change_btn(self.btn_next);
			self:hide_all_btn();
		end
	end,

	-- a, b, n
	visible_btn_by_cmd = function(self, cmd_type, is_show)
		if 'n' == cmd_type then
			self:change_btn(self.btn_next);
			self:hide_all_btn();
		end
	end,

	refresh_virtual = function(self, sprite, card)
		--[[
		local s = sprite:getChildByTag(TAG_STATUS_SPRITE);
		if nil ~= s then
			local e = s:getActionByTag(TAG_STATUS_EFF);
			print('e: ', e);
		end

		local action = sprite:getActionByTag(TAG_VIRTUAL_ACTION);
		if nil ~= action then
			local is_done = action:isDone();
		end
		local particle = sprite:getChildByTag(TAG_VIRTUAL_PARTICLE);
		if nil ~= particle then
			particle:removeFromParentAndCleanup(true);
		end
		local vtype = card.vtype or 0;
		create_virtual_particle(sprite, vtype);
		]]--
		update_attachment_timer(sprite, card);
		return sprite;
	end,

	refresh_card_attach = function(self, sprite, card)
		local new_alist = { cscale = 1 }; -- new attach_list
		local alist = card.attach_list or {};
		local a_index = 1;
		local v_index = 1;
		for i=1, #alist do
			local ac = alist[i];
			local ac_sprite = g_sprite_cache[ac];
			local size = sprite:getContentSize();
			local pos = ccp(size.width / 2, size.height / 2);
			if ac.id > 1000 then -- virtual card
				local ainfo;
				if nil ~= ac_sprite then
					ac_sprite = self:refresh_virtual(ac_sprite, ac);
					ainfo = add_ui_card(sprite, new_alist, pos, 0, ac, ac_sprite);
					ainfo:reset_zorder(v_index);
				else
					local ainfo = add_ui_card(sprite, new_alist, pos, 0, ac);
					ainfo:reset_zorder(v_index);
				end
				v_index = v_index + 1;
			else  -- not virtual card
				pos.y = pos.y + a_index * math.floor(size.height / 7);
				if nil ~= ac_sprite then
					ac_sprite:removeFromParentAndCleanup(true);
					g_sprite_cache[ac] = nil;
				end
				local ainfo = add_ui_card(sprite, new_alist, pos, 0, ac);
				ainfo:reset_zorder(ZORDER_CARD_ATTACH-a_index);
				a_index = a_index + 1;
			end
		end
		return new_alist;
	end,

	refresh_hero_attach = function(self, sprite, card)
		local new_alist = { cscale = 1 }; -- new attach_list
		local alist = card.attach_list or {};
		local a_index = 1;
		local v_index = 1;
		local total_v = 0;
		for i=1, #alist do
			local ac = alist[i];
			if ac.id > 1000 then
				total_v = total_v + 1;
			end
		end
		local hcw = nil;
		local hch = nil;
		for i=1, #alist do
			local ac = alist[i];
			local ac_sprite = g_sprite_cache[ac];
			local size = sprite:getContentSize();
			local pos = ccp(size.width / 2, size.height / 2);
			if ac.id > 1000 then -- virtual card
				local ainfo;
				if nil ~= ac_sprite then
					ac_sprite = self:refresh_virtual(ac_sprite, ac);
					ainfo = add_ui_card(sprite, new_alist, pos, 0, ac, ac_sprite);
					ainfo:reset_zorder(v_index);
				else
					local ainfo = add_ui_card(sprite, new_alist, pos, 0, ac);
					ainfo:reset_zorder(v_index);
				end
				v_index = v_index + 1;
			else  -- not virtual card
				if nil == ch then
					hcw = 45 / 2; -- bg_102.png; 
					hch = 42 / 2; -- bg_102.png;
				end
				pos.x = hcw + 10;
				pos.y = size.height - hch - 5 - (a_index-1) * hch;
				if nil ~= ac_sprite then
					ac_sprite:removeFromParentAndCleanup(true);
					g_sprite_cache[ac] = nil;
				end
				local ainfo = add_ui_card(sprite, new_alist, pos, 0, ac);
				ainfo:reset_zorder(total_v+a_index);
				a_index = a_index + 1;
			end
		end
		return new_alist;
	end,

	refresh_card = function(self, sprite, card, pos, rotation, scale)
		local new_alist = { cscale = 1 }; -- new attach_list
		if nil == card then
			kerror("refresh_card card is nil");
			return sprite, new_alist;
		end
		if nil == sprite then
			kerror("refresh_card sprite is nil");
			return sprite, new_alist;
		end

		sprite:setRotation(rotation or 0);
		local width = sprite:getContentSize().width;
		local height = sprite:getContentSize().height;
		sprite:setAnchorPoint(ANCHOR_CENTER_CENTER);
		sprite:setPosition(ccp(pos.x, pos.y));
		sprite:setScale(scale);
		if card.ctype == HERO then
			new_alist = self:refresh_hero_attach(sprite, card);
		else
			new_alist = self:refresh_card_attach(sprite, card);
		end

		-- refresh card info label
		local label;
		label = sprite:getChildByTag(TAG_COST);
		tolua.cast(label, "cc.Label");
		if nil ~= label then -- T_DECK, sprite is cover.png has no label on it
			label:setString(card.cost);
		end
		
		label = sprite:getChildByTag(TAG_HP);
		tolua.cast(label, "cc.Label");
		if nil ~= label then -- T_DECK, sprite is cover.png has no label on it
			label:setString(card.hp);
		end

		label = sprite:getChildByTag(TAG_POWER);
		tolua.cast(label, "cc.Label");
		if nil ~= label then -- T_DECK, sprite is cover.png has no label on it
			local ppp;
			if card.ctype == HERO then
				ppp = card.energy;
			else
				ppp = card.power;
			end
			label:setString(ppp);
		end

		refresh_card_status(sprite, card, width, height);

		return sprite, new_alist;
	end,

	-- refresh sprite in table list 
	--  such as hp, cost, power (CCLabelBMFont)
	--  if do not have the sprite, create a new one
	-- TODO create a method to check which sprite is deprecated and remove it
	refresh_table_list = function(self, logic_table, ui_table)
		local cwidth = CARD_SIZE_2.width;
		local cheight = CARD_SIZE_2.height;
		local cscale = ui_table.cscale;
		local gap;
		if ui_table.ltype == UP_GRAVE or ui_table.ltype == DOWN_GRAVE or 
		   ui_table.ltype == UP_DECK or ui_table.ltype == DOWN_DECK then
			gap = 0;
		else
			gap = calculate_gap(#logic_table, cwidth*cscale, ui_table.width, ui_table.ltype);
		end

		local newlist = object_uitable:new(ui_table.ltype);
		newlist.cscale = cscale;

		for i = 1, #logic_table do
			local card = logic_table[i];
			local sprite = g_sprite_cache[card];
			local attach_list, pos;
			local rotation = 0;
			local ci = cindex(card);
			local table_index = index_table_num(ci);
			local side_index = index_side(ci);
			local ni, ns; -- new info, new sprite
			if nil ~= sprite then
				pos,rotation = get_card_pos_rotation(ui_table,gap,i,#logic_table);
				sprite,attach_list = self:refresh_card(sprite,card,pos,rotation,cscale);
				ni, ns = add_ui_card(self.layer,newlist,pos,rotation,card,sprite,attach_list);
			else
				pos,rotation = get_card_pos_rotation(ui_table,gap,i,#logic_table);
				ni, ns = add_ui_card(self.layer, newlist, pos, rotation, card);
			end
			--print('card.name: ', ni.card.name, ci, table_index, T_DECK);
			if nil ~= ns then
				if true == USE_ANIM then
					if table_index == T_DECK then
						ni:flip_to_cover();
					elseif table_index == T_HAND then
						if true == data_handler.show_all_card or 
						   true == SHOW_ALL or
						   (side_index == SIDE_DOWN and g_euser.side == SIDE_DOWN) then
							ni:flip_to_front();
						else
							ni:flip_to_cover();
						end
					end
				else
					if true == LOCAL_TEST and table_index ~= T_HERO and 
					   table_index ~= T_GRAVE then
						ni:flip_to_front();
					elseif table_index == T_DECK or 
						(side_index == SIDE_UP and table_index == T_HAND) then
						ni:flip_to_cover();
					elseif table_index == T_SUPPORT then
						if TRAP == card.ctype then
							ni:flip_to_cover();
						else
							ni:flip_to_front();
						end
					elseif table_index == T_ALLY or
						   (side_index == SIDE_DOWN and table_index == T_HAND) then
						ni:flip_to_front();
					end
				end
			end
		end
		local total;
		total = #ui_table;
		for i = 1, total do
			table.remove(ui_table, 1);
		end
		total = #newlist;
		for i = 1, total do
			table.insert(ui_table, newlist[i]);
		end
		return newlist;
	end,

	-- refresh one card_list' zorder e.g. g_ui_table[SIDE_DOWN][T_HAND]
	refresh_clist_zorder = function(self, clist, new_zorder)
		clist = clist or {};
		local start_idx = 1;
		local end_idx = #clist;
		local inc = 1;
		if clist.ltype == UP_DECK or clist.ltype == DOWN_DECK then
			start_idx = #clist;
			end_idx = 1;
			inc = -1;
		end
		for i=start_idx, end_idx, inc do
			local obj = clist[i];
			local zorder;
			local sprite;
			sprite = obj:get_sprite(true);	
			if nil ~= new_zorder then
				zorder = new_zorder;
			else
				zorder = obj.frame.zorder;
			end
			if nil ~= sprite then
				-- TODO maybe bug if use the same zorder
				self.layer:reorderChild(sprite, zorder);
			end
		end
	end,

	refresh_table = function(self, side, _table)
		local logic_table = g_logic_table[side][_table];
		local ui_table = g_ui_table[side][_table];
		self:refresh_table_list(logic_table, ui_table);
		self:refresh_clist_zorder(ui_table, ZORDER_CARD);
	end,

	-- refresh card sprite's attribute(hp, cost, power, attach_list)
	-- and create new card if need
	refresh_layer = function(self)
		self.touch_point = nil;
		g_src_index = 0;  -- this is global
		self:change_btn(self.btn_next);
		self:hide_all_btn();
		
		remove_hl();
		local lside = { SIDE_DOWN, SIDE_UP };
		local ltable = { T_DECK, T_GRAVE, T_HERO, T_HAND, T_SUPPORT, T_ALLY };
		for i = 1, #lside do
			for j = 1, #ltable do
				self:refresh_table(lside[i], ltable[j]);
			end
		end
		if g_euser.side == SIDE_DOWN then
			local ui_deck_table = g_ui_table[SIDE_DOWN][T_DECK];
			if is_view_top() and #ui_deck_table > 0
			and ui_deck_table[1].status == CARD_COVER then
				ui_deck_table[1]:flip_to_front();
			end

			local ui_oppo_hand_table = g_ui_table[SIDE_UP][T_HAND];
			if is_view_oppo() then
				local hidx;
				for hidx = 1, #ui_oppo_hand_table do
					if ui_oppo_hand_table[hidx].status == CARD_COVER then
						ui_oppo_hand_table[hidx]:flip_to_front();
					end
				end
			end
		end

		self:update_res_label(g_logic_table, g_ui_table, SIDE_DOWN);
		self:update_res_label(g_logic_table, g_ui_table, SIDE_UP);
		self:update_count_label(g_logic_table);
		self:refresh_grave();
		clean_sprite_cache();

		if true == LOCAL_TEST or g_euser.side == g_current_side then
			if true == self.is_auto then
				local cmd = ai_cmd_global();
				play_game_cmd(cmd, index);
				self:hide_all_btn();
			else
				self:init_wait_action(g_phase);
			end
		end
		self:check_timeout();
	end,

	refresh_card_list = function(self)
		if nil == self.layer then
			return;
		end
		-- refresh all card list in order to remove g_showing_card
		for i=1, #g_all_card_list do
			local list = g_all_card_list[i];
			self:refresh_clist_zorder(list, ZORDER_CARD);
		end
	end,

	change_btn = function(self, btn)
		if g_scene:is_stage(STAGE_REPLAY) then
			return;
		end
		if g_euser.side == SIDE_GUEST then
			return;
		end
		if btn == self.btn_skip then
			self.btn_skip:setVisible(true);
			enable_btn(self.btn_skip, true);
			--self.btn_next:setVisible(false);
			self.btn_next:setVisible(true);
			enable_btn(self.btn_next, false);
			self.btn_confirm:setVisible(false);
			self.btn_cancel:setVisible(false);
		elseif btn == self.btn_confirm then
			self.btn_cancel:setVisible(true);
			enable_btn(self.btn_cancel, true);
			self.btn_confirm:setVisible(true);
			enable_btn(self.btn_confirm, true);
			self.btn_skip:setVisible(false);
			self.btn_next:setVisible(false);
		elseif btn == self.btn_cancel then
			self.btn_cancel:setVisible(true);
			enable_btn(self.btn_cancel, true);
			self.btn_confirm:setVisible(false);
			enable_btn(self.btn_confirm, false);
			self.btn_skip:setVisible(false);
			self.btn_next:setVisible(false);
		else
			self.btn_next:setVisible(true);
			enable_btn(self.btn_next, true);
			self.btn_skip:setVisible(false);
			self.btn_confirm:setVisible(false);
			self.btn_cancel:setVisible(false);
		end
	end,

	callback_cancel = function(...)
		play_tap_1();
		local self = layer_card;
		local args = {...};
		local item = args[2];
		item:setVisible(false);

		self.ability_target_list = {} 	-- global
		g_src_index = 0				-- global
		g_action_type = TYPE_NONE	-- global
		
		self:refresh_layer();
	end,

	callback_confirm = function(...)
		play_tap_1();
		local self = layer_card;
		local args = {...};
		local item = args[2];
		item:setVisible(false);

		local cmd = 'b ' .. g_src_index ;
		for i=1, #self.ability_target_list do
			cmd = cmd .. ' ' .. self.ability_target_list[i];
		end
		play_game_cmd(cmd);

		self.ability_target_list = {};  -- reset it
		return;
	end,

	callback_skip_sac = function(...)
		play_tap_1();
		local args = {...};
		local item = args[2];
		item:setVisible(false);
		local sprite = item:getChildByTag(TAG_BTN_NEXT_EFF_1);
		if nil ~= sprite then
			sprite:removeFromParent(true);
		end
		sprite = item:getChildByTag(TAG_BTN_NEXT_EFF_2);
		if nil ~= sprite then
			sprite:removeFromParent(true);
		end
		sprite = item:getChildByTag(TAG_BTN_NEXT_EFF_3);
		if nil ~= sprite then
			sprite:removeFromParent(true);
		end
		local cmd = 's ' .. 0;
		play_game_cmd(cmd);
		return;
	end,

	callback_auto = function(tag, sender)
		play_tap_1();
		local self = layer_card;
		if true == data_handler.is_check_for_teach then
			show_msg("请按提示进行操作");
			return;
		end
		if 1 == self.FORCE_AUTO then
			show_msg("竞技场前100名对战中只能自动进行，请留意自动出牌的规则和调整好牌堆来获得更高名次！");
			sender = tolua.cast(sender, "cc.MenuItemToggle");
			sender:setSelectedIndex(1);
			return;
		end
		sender = tolua.cast(sender, "cc.MenuItemToggle");
		local t = sender:getSelectedIndex();  --0 : off     1 : on
		if 0 == t then
			self.is_auto = false;
		else
			self.is_auto = true;
		end
		if true == self.is_auto and g_euser.side == g_current_side then
			local cmd = ai_cmd_global();
			play_game_cmd(cmd, index);
		end
		--local cmd = ai_cmd_global();
	end,

	callback_next_side = function(...)
		play_tap_1();
		local self = layer_card;
		local args = {...};
		local item = args[2];
		item:setVisible(false);
		local sprite = item:getChildByTag(TAG_BTN_NEXT_EFF_1);
		if nil ~= sprite then
			sprite:removeFromParent(true);
		end
		sprite = item:getChildByTag(TAG_BTN_NEXT_EFF_2);
		if nil ~= sprite then
			sprite:removeFromParent(true);
		end
		sprite = item:getChildByTag(TAG_BTN_NEXT_EFF_3);
		if nil ~= sprite then
			sprite:removeFromParent(true);
		end

		local cmd;
		if true == LOCAL_TEST or g_euser.side == g_current_side then
			cmd = 'n';
		else
			-- @see in play_game_cmd
			cmd = 'f';
		end
		play_game_cmd(cmd);
		util.upload_tutor();
		return;
	end,

	check_touch_grave = function(self, x, y)
		if nil == g_ui_table then return 0; end
		local list = { SIDE_UP, SIDE_DOWN };
		for i = 1, #list do
			local side = list[i];
			if nil ~= g_ui_table[side] then 
				local grave = g_ui_table[side][T_GRAVE];
				local sx = grave.x;
				local sy = grave.y;
				if nil ~= grave.origin_y then
					sy = grave.origin_y;
				end
				local h_dwidth = grave.width/2;
				local h_dheight = grave.height/2;
				local sx1 = sx-h_dwidth;
				local sx2 = sx+h_dwidth;
				local sy1 = sy-h_dheight;
				local sy2 = sy+h_dheight;
				if x > sx1 and x < sx2 and y > sy1 and y < sy2 then
					return side;
				end
			end
		end
		return 0;
	end,

	remove_p_hand = function(self, is_reset)
		if nil == self.p_hand then
			return;
		end
		local info = self.p_hand;
		self.p_hand = nil;
		if true == is_reset then
			self:touch_small(info);
		end
	end,

	remove_drag_line = function(self)
		if nil == self.p_drag then
			return;
		end
		--self.p_drag.batch:removeFromParentAndCleanup(true);
		self.p_drag:removeFromParent(true);
		self.p_drag = nil;
		if nil ~= self.p_pointer then
			--self.p_pointer.batch:removeFromParentAndCleanup(true);
			self.p_pointer:removeFromParent(true);
			self.p_pointer = nil;
		end
	end,

	is_drag_card = function(self, touch_card)
		local list = get_card_list(self.touch_card.ltype); 
		local info = get_ui_card(touch_card.index);
		if nil == info then
			kdebug("DEBUG is_drag_card nil info index[%d]", touch_card.index);
			return false;
		end
		local card = info.card;
		local kind = check_kind(card, g_logic_table, g_current_side, g_phase);
		if kind == AKIND_SAC or kind == AKIND_TALLY or kind == AKIND_TSUPPORT then
			return true;
		end
		return false;
	end,

	is_my_card = function(self, touch_card, side)
		local list = get_card_list(self.touch_card.ltype); 
		--local info = list[self.touch_card.index];
		local info = get_ui_card(self.touch_card.index);
		if nil == info then
			return false;
		end
		local card = info.card;
		local index = cindex(card);
		local cside = index_side(index);
		if cside == side then
			return true;
		else
			return false;
		end
	end,

	switch_action = function(self, touch_card, x, y)
		if true ~= LOCAL_TEST and g_euser.side ~= g_current_side then
			return;
		end
		if nil == touch_card or 0 == touch_card.index then
			return;
		end
		if nil == self.touch_point then return; end
		local list = get_card_list(touch_card.ltype); 
		local tcard = get_ui_card(touch_card.index); -- the selected card
		local ff = tcard.frame;
		local cpos = cc.p(ff.x, ff.y); -- center point of selected card
		--local offsety = math.abs(y - cpos.y);
		--local offsetx = math.abs(x - cpos.x);
		--local fingerx = wfix(60);
		local fingery = hfix(15);
		--if offsetx < fingerx and offsety < fingery then
		--local offsety = y - cpos.y;
		local offsety = y - self.touch_point.y;
		if offsety < fingery then
			return true;
		end
		return false;
	end,

	drag_action = function(self, touch_card, x, y)
		if true ~= LOCAL_TEST and g_euser.side ~= g_current_side then
			return;
		end
		if nil == touch_card or 0 == touch_card.index then
			return;
		end
		local list = get_card_list(touch_card.ltype); 
		local tcard = get_ui_card(touch_card.index); -- the selected card
		--local ff = tcard.frame;
		local ff = self.touch_point;
		local cpos = ccp(ff.x, ff.y); -- center point of selected card
		local offsety = math.abs(y - cpos.y);
		local offsetx = math.abs(x - cpos.x);
		local fingerx = calculate_gap(#list, list.cscale*CARD_SIZE_2.width, list.width, list.ltype);
		--local fingerx = wfix(30);
		local fingery = hfix(15);
		if nil == self.p_drag then
			if offsetx < fingerx and offsety < fingery then
				return;
			end
			if nil ~= layer_action.layer then
				return;
			end
			local card = tcard.card;
			local index = cindex(card);
			local kind = check_kind(card, g_logic_table, g_current_side, g_phase);
			
			if kind == AKIND_NONE or 0 ~= g_src_index then
				return;
			end
			if kind == AKIND_ABILITY then
				local num, err = total_target(index,g_logic_table,g_current_side);
				if 0 == num then
					return;
				end
				if 0 == target_num(index,g_logic_table,g_current_side) then
					return;
				end
			end

			-- implicit: offsetx > fingerx or offsety > fingery (drag far enough)
			-- implicit: kind ~= 0,  g_src_index == 0 
			-- note: g_src_index = selected card index
			--[[
			local path;
			path = util.get_path('dragline.plist');	
			self.p_drag = util.add_particle(self.layer, path, cpos,ZORDER_EFFECT);
			self.p_drag.pos = cpos;
			]]--
			local verts = {
				cc.p(cpos.x, cpos.y),
				cc.p(x, y),
			};
			local ret_verts = nil;
			self.p_drag, ret_verts = util.draw_line(self.layer, verts, cc.c4f(1, 1, 1, 1), 28, 12, 2, ZORDER_EFFECT, 4);
			self.p_drag.ret_verts = ret_verts;
			self.p_drag.pos = cpos;
			--[[
			path = util.get_path('drag_pointer.plist');	
			self.p_pointer = util.add_particle(self.layer, path, ccp(cpos.x+40, cpos.y+40), ZORDER_EFFECT);
			]]--
			local verts = {
				cc.p(-50, 0),
				cc.p(50, 0),
				cc.p(0, 50),
				cc.p(-50, 0),
			};
			self.p_pointer = util.draw_line(self.layer, verts, cc.c4f(1, 1, 1, 1), 28, 12, 2, ZORDER_EFFECT, 4);
			self.p_pointer:setPosition(cpos);
			local csprite = tcard.sprite;
			csprite:setRotation(0);
			self.layer:reorderChild(csprite, ZORDER_SHOWING);
			if true == is_target_grave(index, g_logic_table, g_current_side) then
				g_src_index = index;
				hl_table(self.layer, AKIND_TGRAVE, g_ui_table, g_current_side);
			elseif kind == AKIND_ATTACK then
				hl_at_target(index, 'move');
			elseif kind == AKIND_ABILITY then
				hl_ab_target(index, 'move');
			elseif kind == AKIND_BOTH then
				hl_both_target(index);
			else
				hl_table(self.layer, kind, g_ui_table, g_current_side);
			end
			return;
		else
			if offsetx < fingerx and offsety < fingery then
				disable_touch();
				remove_hl();
				self:remove_drag_line();
				self.ability_target_list = {} 	-- global
				g_src_index = 0				-- global
				g_action_type = TYPE_NONE	-- global

				self:init_wait_action(g_phase);
				enable_touch();
				return;
			end
			local ret_verts = self.p_drag.ret_verts;
			if #(ret_verts or {}) > 1 then
				ret_verts[2].x = x;
				ret_verts[2].y = y;
			end
			local ttt = self.p_drag.pos;
			local pp = cc.p(x-ttt.x, y-ttt.y);
			local r = math.atan2(pp.y, pp.x);
			local r1 = r * 360 / ( 2 * 3.14 );
			local r2 = 90 - r1;
			local offset = math.sqrt(math.pow(pp.x, 2) + math.pow(pp.y, 2));
			--local spos = self.p_drag.emitter:getPosVar();
			--spos.y = offset*0.5;
			--self.p_drag.emitter:setPosVar(spos);
			local pos = cc.p(pp.x/2+ttt.x, pp.y/2+ttt.y);
			--self.p_drag.batch:setPosition(pos);
			--self.p_drag.batch:setRotation(r2);

			pos.x = x + math.cos(r) * 80;
			pos.y = y + math.sin(r) * 80;
			self.p_pointer:setPosition(pos);
			self.p_pointer:setRotation(r2);
			--self.p_pointer.batch:setPosition(pos);
			--self.p_pointer.batch:setRotation(r2);

			local target_card=self:check_target(g_all_card_list,ccp(pos.x,pos.y));
			local tinfo = get_ui_card(target_card.index);
			return target_card;
		end
		return;
	end,

	hand_action = function(self, touch_card, x, y)
		if true ~= LOCAL_TEST and g_euser.side ~= g_current_side then
			return;
		end
		if nil == touch_card or 0 == touch_card.index then
			return;
		end
		local list = get_card_list(touch_card.ltype); 
		--local tcard = list[touch_card.index]; -- the selected card
		local tcard = get_ui_card(touch_card.index); -- the selected card
		--local ff = tcard.frame;
		local ff = self.touch_point;
		local cpos = ccp(ff.x, ff.y); -- center point of selected card
		local offsety = math.abs(y - cpos.y);
		local offsetx = math.abs(x - cpos.x);
		local fingerx = calculate_gap(#list, list.cscale*CARD_SIZE_2.width, list.width, list.ltype);
		--local fingerx = wfix(60);
		local fingery = hfix(60);
		if nil == self.p_hand then
			if offsetx < fingerx and offsety < fingery then
				return;
			end
			local kind = check_kind(tcard.card, g_logic_table, g_current_side, g_phase);
			if (kind ~= AKIND_TSUPPORT and kind ~= AKIND_TALLY and kind ~= AKIND_SAC) or 0 ~= g_src_index then
				return;
			end
			local csprite = tcard.sprite;
			self.p_hand = tcard;
			csprite:setRotation(0);
			self:touch_big(tcard);
			self.layer:reorderChild(csprite, ZORDER_SHOWING);
			hl_table(self.layer, kind, g_ui_table, g_current_side);
		else
			if offsetx < fingerx and offsety < fingery then
				disable_touch();
				remove_hl();
				self:remove_p_hand(true);
				self.ability_target_list = {} 	-- global
				g_src_index = 0				-- global
				g_action_type = TYPE_NONE	-- global

				self:init_wait_action(g_phase);
				enable_touch();
				return;
			end
			local info = self.p_hand;
			local sprite = info.sprite;
			local pos = cc.p(x, y+hfix(40));
			sprite:setPosition(pos);
			local scale = sprite:getScale();
			local s = sprite:getContentSize();
			local size = cc.size(s.width*scale, s.height*scale);
			pos = cc.p(x, y);
			local target_card=self:check_target(g_all_card_list,pos,size);
			return target_card;
		end
	end,

	-- beg_card is card in touch begin
	-- end_card is move to new one
	handle_touch_move = function(self, beg_card, end_card, x, y)
		if 0 == end_card.ltype or 0 == end_card.index then
			-- move to outside
			if 0 ~= beg_card.index then
				local list = get_card_list(beg_card.ltype); 
				self:refresh_clist_zorder(list, ZORDER_CARD);
				self:touch_small(list[beg_card.index]);
			end
			beg_card.ltype = 0;
			beg_card.index = 0;
			return true;
		end
		if 0 == beg_card.ltype or 0 == beg_card.index then
			-- move into card list from outside
			local list = get_card_list(end_card.ltype); 
			self:refresh_clist_zorder(list, ZORDER_CARD_TOUCH);
			self:touch_big(list[end_card.index]);

			beg_card.ltype = end_card.ltype;
			beg_card.index = end_card.index;
			return true;
		end
		if beg_card.ltype==end_card.ltype and beg_card.index == end_card.index then
			return true;
		end
		-- change card
		local blist = get_card_list(beg_card.ltype);
		self:refresh_clist_zorder(blist, ZORDER_CARD);
		self:touch_small(blist[beg_card.index]);

		local elist = get_card_list(end_card.ltype);
		self:refresh_clist_zorder(elist, ZORDER_CARD_TOUCH);
		self:touch_big(elist[end_card.index]);

		return false;
	end,

	check_touch = function(self, all_card_list, x, y)
		for i = 1, #all_card_list do
			local list = all_card_list[i] or {};
			if list.ltype == UP_GRAVE or list.ltype == DOWN_GRAVE then
				list = {}; -- use as break;
			end
			for j = #list, 1, -1 do
				local is_touched = check_in_card(list[j], x, y);
				if true ~= LOCAL_TEST and true ~= data_handler.show_all_card and 
				   ((list.ltype == DOWN_HAND and g_euser.side ~= SIDE_DOWN) or 
				   (list.ltype == UP_HAND and g_euser.side ~= SIDE_UP)) then

				   is_touched = false;
				end
				if true == is_touched then
					local index = cindex(list[j].card);
					return { ltype = list.ltype, index = index };
				end
			end
		end
		return { ltype = 0, index = 0 };
	end,

	check_target = function(self, all_card_list, cpos, csize)
		cpos = cpos or cc.p(0, 0);
		csize = csize or cc.size(0, 0);
		-- check table
		local sprite = self.layer:getChildByTag(TAG_HIGHLIGHT);
		if nil ~= sprite then
			local lll = {};
			local list, d, pos, size, rect, x1, x2, y1, y2;
			list = g_ui_table[g_euser.side][T_ALLY];
			d = gui_get_data('ally_down', GUI_MATCH);
			table.insert(lll, { data = d });
			--list = g_ui_table[g_euser.side][T_ALLY];
			--d = gui_get_data('sup_down', GUI_MATCH);
			--table.insert(lll, { data = d });
			for i = 1, #lll do
				local data = lll[i].data;
				pos = cc.p(data.x+data.width/2, data.y+data.height/2);
				size = cc.size(data.width, data.height);
				--rect = { x1 = pos.x-size.width/2, x2 = pos.x+size.width/2,
			--		   y1 = pos.y-size.height/2,y2 = pos.y+size.height/2};
				rect = { x1 = pos.x-size.width/2, x2 = pos.x+size.width/2,
					   y1 = pos.y+size.height/4,y2 = pos.y+size.height/2};
				x1 = cpos.x-csize.width/2;
				x2 = cpos.x+csize.width/2;
				y1 = cpos.y-csize.height/2;
				y2 = cpos.y+csize.height/2;
				if x2 > rect.x1 and x1 < rect.x2 and y2 > rect.y1 and y1<rect.y2 then
					return { ltype = 'table' , index = 0 };
				end
			end

			sprite:setScale(1);
		end

		for i = 1, #all_card_list do
			local list = all_card_list[i] or {};
			if list.ltype == UP_GRAVE or list.ltype == DOWN_GRAVE then
				list = {}; -- use as break;
			end
			for j = #list, 1, -1 do
				local l = list[j];
				if nil ~= g_sprite_cache[l.card] then
					local sprite = l.sprite;
					local hl = sprite:getChildByTag(TAG_HIGHLIGHT);
					local is_touched = check_in_card(l, cpos.x, cpos.y);
					if nil ~= hl then
						if true == is_touched then
							--return { ltype = list.ltype, index = j };
							local index = cindex(l.card);
							return { ltype = list.ltype, index = index };
						end
					end
					local la = l.card_attach_list or {};
					if true ~= is_touched then
						la = {};
					end
					local count = 0;
					local aindex = 0;
					for k = 1, #la do
						local a = la[k];
						if nil ~= g_sprite_cache[a.card] then
							local sprite = a.sprite;
							local hl = sprite:getChildByTag(TAG_HIGHLIGHT);
							if nil ~= hl then
								count = count + 1;
								aindex = cindex(a.card);
							end
						end
					end
					if 1 == count then
						return { ltype = list.ltype, index = aindex };
					elseif count > 1 then
						-- has more than 1 attach card hl, show the main card
						local index = cindex(l.card);
						return { ltype = list.ltype, index = index };
					end
				end
			end
		end
		return { ltype = 0, index = 0 };
	end,

	touch_big = function(self, cinfo)
		if nil == cinfo then
			return;
		end
		local card = cinfo.card;
		local tindex = index_table_num(cindex(card));
		local sprite = cinfo.sprite;
		local frame = cinfo.frame;
		local sscale = frame.scale;
		local sx = frame.x;
		local sy = frame.y;

		-- scale to 1.2
		if true ~= DRAG_MODE then
			if T_HERO ~= tindex then
				sprite:setScale(sscale * 1.5);
			else
				sprite:setScale(sscale * 1.1);
			end
		end

		-- move up 
		local pos;
		local pos = cc.p(sx, sy);
		sprite:setPosition(pos);
	end,

	touch_small = function(self, cinfo)
		if nil == cinfo then
			return;
		end
		local c = cinfo.card;
		local sprite = cinfo.sprite;
		local frame = cinfo.frame;
		local sscale = frame.scale;
		local sx = frame.x;
		local sy = frame.y;

		if true ~= DRAG_MODE then
			sprite:setScale(sscale);
		end
		sprite:setPosition(ccp(sx, sy));

	end,

	touch_up = function(self, tinfo, callback_list)
		if nil == tinfo then
			return false;
		end
		local list = get_card_list(tinfo.ltype); 
		if nil == list then
			return false;
		end
		callback_list = callback_list or {};
		self:refresh_clist_zorder(list, ZORDER_CARD);
		local cinfo = list[tinfo.index];
		if nil == cinfo then
			return false;
		end
		disable_touch();
		local c = cinfo.card;
		local sprite = cinfo.card_sprite;
		local finfo = cinfo.frame_info;
		local npos = cc.p(finfo.posx, finfo.posy);
		local animation = {};
		local action = cc.MoveTo:create(0.1, npos);
		table.insert(animation, cc.EaseIn:create(action, 0.1));
		table.insert(animation, cc.RotateTo:create(0.1, finfo.rotation));
		table.insert(animation, cc.ScaleTo:create(0.1, finfo.scale));
		local action_final = {};
		table.insert(action_final, cc.Sequence:create(animation));
		for i = 1, #callback_list do
			local cb = callback_list[i];
			table.insert(action_final, cc.CallFunc:create(cb));
		end
		table.insert(action_final, cc.CallFunc:create(enable_touch));
		sprite:runAction( cc.Sequence:create( action_final ) );
		return true;
	end,

	remove_preview = function(self)
		if nil == layer_preview.layer then return; end
		layer_preview:remove();
	end,

	handler = function(event, x, y)
		local self = layer_card;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			if true == g_scene:is_online() then
				if nil == layer_result.layer then
					layer_menu.ask_fold();
				else
					g_scene:login();
				end
			end
		end
	end,

	onTouchBegan = function (self, x, y)
		self.time_touch_down = nil;
		--self.touch_y = nil;
		if true == g_is_in_tutor then
			self.touch_point = nil;
			return true;
		end
		if false == is_touchable() then
			self.touch_point = nil;
			return true;
		end
		-- no need to check and return, just go ahead is ok
		if nil ~= self.touch_point then
			print('DBEUG layer_card onTouchBegan touch_point not nil');
			self:reset_touch_data();
			self:remove_p_hand(true);
			self:remove_drag_line();
			self.touch_point = nil;
			refresh_layer_card();
			return false;
		end
		self:reset_touch_data();
		self.touch_point = {x = x, y = y};

		if 0 ~= self:check_touch_grave(x, y) then
			return true;
		end
		self.cinfo = nil;
		self.target_card = { ltype = 0, index = 0 };
		self.touch_card = self:check_touch(g_all_card_list, x, y);
		if 0 == self.touch_card.index then
			self.touch_point = nil;
			return false;
		end

		local list = get_card_list(self.touch_card.ltype); 
		self:refresh_clist_zorder(list, ZORDER_CARD_TOUCH);
		local tt = get_ui_card(self.touch_card.index);
		self:touch_big(tt);
		self.touch_func = nil;
		local s = index_side(self.touch_card.index);
		local tn = index_table_num(self.touch_card.index);
		if s == SIDE_DOWN and g_euser.side == SIDE_DOWN and tn == T_HAND then
			--self.touch_y = y;
			self.time_touch_down = os.time();
			--print("------- t1: ", self.time_touch_down);
			g_scene:add_layer(ZORDER_LAYER_PREVIEW, layer_preview:create(tt));
		end
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		if nil == self.touch_point then
			return;
		end

		if true ~= LOCAL_TEST then
			if false == self:is_my_card(self.touch_card, g_current_side) then
				return;
			end
		end

		--[[
		if nil == self.p_drag and 0 ~= self:check_touch_grave(x, y) then
			if 0 ~= self.touch_card.index then
				local list = get_card_list(self.touch_card.ltype); 
				self:refresh_clist_zorder(list, ZORDER_CARD);
				self:touch_small(get_ui_card(self.touch_card.index));
			end
			self.touch_card.ltype = 0;
			self.touch_card.index = 0;
			return;
		end
		]]--

		local s = index_side(self.touch_card.index);
		local tn = index_table_num(self.touch_card.index);
		if s == SIDE_DOWN and g_euser.side == SIDE_DOWN and tn == T_HAND then
			if true == self:switch_action(self.touch_card, x, y) then
				local touch_card = self:check_touch(g_all_card_list, x, y);
				if 0 < touch_card.index and touch_card.index ~= self.touch_card.index then
					self:reset_touch_data();
					self.touch_point = {x = x, y = y};
					self.touch_card = touch_card;
					local list = get_card_list(self.touch_card.ltype); 
					self:refresh_clist_zorder(list, ZORDER_CARD_TOUCH);
					local tt = get_ui_card(self.touch_card.index);
					self:touch_big(tt);
					self.touch_func = nil;
					--self.time_touch_down = os.time();
					--print("------- t1: ", self.time_touch_down);
					g_scene:add_layer(ZORDER_LAYER_PREVIEW, layer_preview:create(tt));
					return;
				end
			end
		end

		local target_card = nil;
		if true == self:is_drag_card(self.touch_card) then
			target_card = self:hand_action(self.touch_card, x, y);
		else
			target_card = self:drag_action(self.touch_card, x, y);
		end

		--local target_card = self:drag_action(self.touch_card, x, y);
		if nil == target_card then
			return;
		end
		self:remove_preview();
		local nltype = target_card.ltype;
		local nindex = target_card.index;
		local oltype = self.target_card.ltype;
		local oindex = self.target_card.index;
		if nltype == oltype and nindex == oindex then
			return;
		end
		self.target_card = target_card;
		if 'table' == nltype then	
			return;
		end
		if 0 ~= oltype and 0 ~= oindex then
			local list = get_card_list(oltype); 
			self:refresh_clist_zorder(list, ZORDER_CARD_TOUCH);
			self:touch_small(get_ui_card(oindex));
		end
		if 0 ~= nltype and 0 ~= nindex then
			local list = get_card_list(nltype); 
			self:refresh_clist_zorder(list, ZORDER_CARD_TOUCH);
			self:touch_big(get_ui_card(nindex));
		end

	end,

	onTouchEnded = function(self, x, y)
		if nil == self.touch_point then
			return;
		end
		--self.touch_y = nil;
		self.touch_point = nil;

		self:remove_preview();
		if true == self:handle_touch_end() then
			return;
		end

		-- move to handle_touch_end, need test
		--self:refresh_layer();
		--

		local flag_grave = self:check_touch_grave(x, y);
		if 0 ~= flag_grave then
			if flag_grave == SIDE_UP or flag_grave == SIDE_DOWN then
				local list = g_ui_table[flag_grave][T_GRAVE];
				if nil ~= list and 0 < #list then
					play_tap_2();
					open_grave(flag_grave);
				end
				return;
			end
		end

	end,

	reset_touch_card = function(self, tinfo)
		if nil == tinfo then
			return false;
		end
		local ltype = tinfo.ltype;
		if nil == tonumber(ltype) then
			return;
		end
		local list = get_card_list(tinfo.ltype); 
		if nil == list then
			return false;
		end
		callback_list = callback_list or {};
		self:refresh_clist_zorder(list, ZORDER_CARD);
		local cinfo = get_ui_card(tinfo.index);
		if nil == cinfo then
			return false;
		end
		cinfo:reset();
	end,

	reset_touch_data = function(self)
		self:reset_touch_card(self.touch_card);
		self:reset_touch_card(self.target_card);
		self.touch_card = { ltype = 0, index = 0 };
		self.target_card = { ltype = 0, index = 0 };
	end,

	handle_touch_target = function(self, sinfo, tinfo, target_ltype)
		local scard, tcard, src_index, target_index;
		if sinfo then scard = sinfo.card end;
		if tinfo then tcard = tinfo.card end;
		if scard then src_index = cindex(scard) end;
		if tcard then target_index = cindex(tcard) end;

		local kind = check_kind(scard, g_logic_table, g_current_side, g_phase);
		if 'table' == target_ltype then
			local index = cindex(scard);
			local f, s = is_target_grave(index,g_logic_table,g_current_side);
			if kind == AKIND_SAC then -- sac
				action_sac(src_index);	
				return true;
			elseif kind == AKIND_TALLY or kind == AKIND_TSUPPORT then --table ally
				hl_ab_target(src_index, 'action');	
				return true;
			elseif true == f then
				open_grave(s);
				return true;
			end
		elseif 0 ~= target_ltype and nil ~= tcard then
			local ret = false;
			local sprite = tinfo.sprite;
			local hl = sprite:getChildByTag(TAG_HIGHLIGHT);
			if nil ~= hl then
				ret = action_target(layer_card, g_action_type, g_src_index, target_index);
				--print('ret: ', ret);
			else
				local count = 0;
				local ainfo = nil;
				local alist = tinfo.card_attach_list or {};
				for i = 1, #alist do
					ainfo = alist[i];
					local sprite = ainfo.sprite;
					local hl = sprite:getChildByTag(TAG_HIGHLIGHT);
					count = count + 1;
				end
				if 1 == count then
					ret = self:handle_touch_target(sinfo, ainfo);
				elseif count > 1 then
					create_btn_cancel();
					local layer = layer_action:create(tinfo);
					g_scene:add_layer(ZORDER_LAYER_ACTION, layer);
					ret = true;
				end
			end
			--print('ret:     ', ret);
			if true == ret then
				self:reset_touch_data();
				return true;
			end
		end
		return false;
	end,

	handle_touch_end = function(self, x, y)
		local touch_info = get_ui_card(self.touch_card.index);
		local target_info = get_ui_card(self.target_card.index);
		local target_ltype = nil;
		local need_pop = true;
		if nil ~= self.p_hand then
			self:remove_p_hand(false);
			need_pop = false;
		end
		if nil ~= self.p_drag then
			self:remove_drag_line();
			need_pop = false;
		end
		if self.target_card then target_ltype = self.target_card.ltype end;
		local scard, tcard;
		if touch_info then scard = touch_info.card end;
		if target_info then tcard = target_info.card end;
		local ret = false;
		ret = self:handle_touch_target(touch_info, target_info, target_ltype);
		if true == ret then
			return true;
		end

		if false == need_pop then
			if nil ~= touch_info and nil == target_info then
				show_msg("无效目标");
			end
			refresh_layer_card();
			return false;
		end

		self:reset_touch_data();

		if nil ~= touch_info then
			if nil ~= self.time_touch_down then
				local t = os.time() - self.time_touch_down;
				if t > 1 then
					return true;
				end
			end
			local sss = touch_info.sprite;
			local layer, name = layer_action:create(touch_info);
			g_scene:add_layer(ZORDER_LAYER_ACTION, layer, name);
			return true;
		end
		-- need??
		--self.ability_target_list = {} 	-- global
		--g_src_index = 0				-- global
		--g_action_type = TYPE_NONE	-- global
		return false;
	end,

	-- use in play_to_anim
	clean_for_touch_end = function(self)
		if nil ~= self.p_hand then
			self:remove_p_hand(false);
		end
		if nil ~= self.p_drag then
			self:remove_drag_line();
		end
		remove_hl();
		self.ability_target_list = {} 	-- global
		g_src_index = 0				-- global
		g_action_type = TYPE_NONE	-- global
		if nil ~= self.touch_point then
			self:reset_touch_data();
		end
		self.touch_point = nil;
	end,
	
    -- init wait to action
	init_wait_action = function(self, phase)
		self:refresh_grave();
		if true ~= LOCAL_TEST and g_euser.side ~= g_current_side then
			return;
		end
		if nil ~= g_net_win_data then
			return;
		end
		local t = g_ui_table[g_current_side];
		local list = {};
		table.insert(list, t[T_HAND]);
		table.insert(list, t[T_ALLY]);
		table.insert(list, t[T_SUPPORT]);
		table.insert(list, t[T_HERO]);

		local has_hl = false;
		for i = 1, #list do
			local l = list[i];
			for k, info in ipairs(l) do
				local card = info.card;
				if nil ~= card then
					local kind = nil;
					kind = check_kind(card,g_logic_table,g_current_side, g_phase);
					local index = cindex(card);
					if kind == AKIND_SAC then
						hl_card(index, HL_SAC);
						has_hl = true;
					elseif kind == AKIND_BOTH then
						hl_card(index, HL_BOTH);
						has_hl = true;
					elseif kind == AKIND_ATTACK then
						hl_card(index, HL_ATTACK);
						has_hl = true;
					elseif kind == AKIND_ABILITY then
						hl_card(index, HL_ABILITY);
						has_hl = true;
					elseif kind == AKIND_TALLY then
						hl_card(index, HL_ABILITY);
						has_hl = true;
					elseif kind == AKIND_TSUPPORT then
						hl_card(index, HL_ABILITY);
						has_hl = true;
					end
				end
			end
		end
		local list_move_hand = {};
		for i=1, #g_ui_table[g_current_side][T_HAND] do
			local info = g_ui_table[g_current_side][T_HAND][i];
			local cs = info.sprite;
			local hl = cs:getChildByTag(TAG_HIGHLIGHT);
			if nil == hl then
				table.insert(list_move_hand, info);
			end
		end
		if #list_move_hand ~= #g_ui_table[g_current_side][T_HAND] then
			for i = 1, #list_move_hand do
				local info = list_move_hand[i];
				local cs = info.sprite;
				local y = cs:getPositionY();
				y = y - 20;
				cs:setPositionY(y);
				info.frame.y = y;
			end
		end

		if g_last_phase ~= phase then
			g_last_phase = phase
			layer_table:update_phase(-1, phase);
			--pop_phase(phase);
		end
		if PHASE_SACRIFICE == phase then
			self:change_btn(self.btn_skip);	

			if g_euser.side == g_current_side then
				local flag = false;

				if false == OLD_TUTOR then
					flag = true;
				end

				if false == flag then
					flag = util.trigger_tutor(TUTOR_INTRO);
				end

				if false == flag then
					flag = util.trigger_tutor(TUTOR_SECOND_SAC);
				end

				if false == flag and g_euser.level < 5 then
					layer_card:show_tip_help("继续弃除手牌获得更多可用资源")
				end

			end

			--[[
			if g_euser.side == g_current_side then
				local flag = false;
				if false == flag then
					flag = util.trigger_tutor(TUTOR_RES);
				end
				if false == flag then
					flag = util.trigger_tutor(TUTOR_TAP_SKIP);
				end
			end
			]]--
		else
			self:change_btn(self.btn_next);	

			if g_euser.side == g_current_side then
				local flag = false;

				layer_card:remove_tip_help();
				if layer_dragtutorial ~= nil then
					layer_dragtutorial:remove();
				end

				if false == OLD_TUTOR then
					flag = true;
				end

				if nil ~= g_net_win_data then
					flag = true;
				end

				if false == flag then
					flag = util.trigger_tutor(TUTOR_HIGHLIGHT_CARD);
				end

				if false == flag then
					flag = util.trigger_tutor(TUTOR_ATTACK);
				end

				if false == flag then
					flag = util.trigger_tutor(TUTOR_WYLD_SKILL);
				end

				if false == flag then
					flag = util.trigger_tutor(TUTOR_REST);
				end

				if false == flag then
					flag = util.trigger_tutor(TUTOR_WAIT_NEXT_SAC);
				end

				if false == flag then
					flag = util.trigger_tutor(TUTOR_PVP_CAN_ATTACK);
				end

				if false == flag then
					flag = show_svg_help();
				end

				if false == flag and false == has_hl then
					tip_tap_next();
				end

--				if false == flag then
--					flag = util.trigger_tutor(TUTOR_WAIT_NEXT);
--				end

				
			end
			--[[
			if g_euser.side == g_current_side then
				local flag = false;
				if false == flag then
					flag = util.trigger_tutor(TUTOR_PLAY);
				end
				if false == flag then
					flag = util.trigger_tutor(TUTOR_HL_ALLY);
				end
				if false == flag then
					flag = util.trigger_tutor(TUTOR_HL_HERO);
				end
				if false == flag then
					flag = util.trigger_tutor(TUTOR_NEXT);
				end
			end
			]]--
		end
		change_step(STEP_CHOOSE);
		if OLD_TUTOR == false and true == data_handler.is_check_for_teach then
			check_for_teach();
		end
	end,

	refresh_grave_by_side = function(self, side)
		local zorder = 8;
		local ui_table = g_ui_table[side][T_GRAVE];
		if nil == ui_table then
			return;
		end
		local scale = ui_table.pic_scale;
		for i = #ui_table, 1, -1 do
			local info = ui_table[i];
			if i < #ui_table then
				info:remove_sprite();
			else
				local pos = info:get_grave_pos(ui_table, index);
				if nil ~= pos then
					info:change_grave(pos, scale);
				end
			end
		end

		--[[
		local height = ui_table.pic_height;
		if nil == height then
			return;
		end
		local len = ui_table.pic_len;
		local scale = ui_table.pic_scale;
		local index = 1;
		for i = #ui_table, 1, -1 do
			local info = ui_table[i];
			local pos = info:get_grave_pos(ui_table, index);
			print('pos ', pos.x, pos.y, scale);
			if nil ~= pos then
				info:change_grave(pos, scale);
			end
			index = index + 1;
			if index > len then
				break;
			end
		end
		for i = #ui_table - len, 1, -1 do
			local info = ui_table[i];
			info:remove_sprite();
		end
		]]--
	end,

	refresh_grave = function(self)
		self:refresh_grave_by_side(SIDE_UP);
		self:refresh_grave_by_side(SIDE_DOWN);
	end,

} -- layer_card end 

layer_action = {
	name = 'layer_action',
	layer = nil, -- @see init
	obj = nil,	
	list = nil,
	menu = nil,
	tcount = 0,

	cleanup = function(self)
		self.layer = nil;
		self.obj = nil;
		self.list = nil;
		self.menu = nil;
		self.tcount = 0;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, obj)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_ACTION, self.handler, true);

		self.tcount = 0;
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 120));

		if nil == obj then
			kerror("layer_action:create  obj=nil");
			return self.layer, self.name;
		end

		self.obj = obj;

		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local rotation = 0;
		local cwidth = FULL_WIDTH - wfix(50);
		local cheight = FULL_HEIGHT - hfix(300);
		local scale = get_card_scale(cwidth, cheight, CARD_SIZE);
		local sprite = obj:get_action_sprite(self.layer, pos, rotation, scale);
		self.layer:reorderChild(sprite, ZORDER_SHOWING);
		local size = sprite:getContentSize();

		self.list = {};
		table.insert(self.list, { obj = obj, sprite = sprite });
		for i = 1, #obj.attach_list do
			local o = obj.attach_list[i];
			local c = o.card;
			if c.id < 1000 then
				table.insert(self.list, { obj = o, sprite = nil });
			end
		end
		local callback_list = { self.show_menu };
		
		if #self.list > 1 then

			for i = 2, #self.list do
				local o = self.list[i].obj;
				local p = cc.p(pos.x, pos.y+(i-1)*50+hfix(80));
				if i == 1 then
				elseif i == #self.list then
				elseif 0 == i%2 then
					p.x = p.x + i * 10;
				else -- 0 ~= i%2
					p.x = p.x - i * 10;
				end
				local rotation = 0; 
				local scale = sprite:getScale();
				local s = o:get_action_sprite(self.layer, p, rotation, scale);
				self.layer:reorderChild(s, ZORDER_SHOWING-i);
				self.list[i].sprite = s;
			end

			local items = {};
			local item;

			pos = cc.p(HALF_WIDTH, 0);
			item = add_item_1(items, '下一张', nil, 30, self.show_next, ANCHOR_CENTER_DOWN, pos);
			
			util.add_menu(self.layer, items);
		end

		local pos_to = cc.p(HALF_WIDTH, HALF_HEIGHT+hfix(80));
		self.tdisable();
		local farray = {};
		local action;
		action = cc.EaseIn:create(cc.MoveTo:create(0.2, pos_to), 0.2);
		table.insert(farray, action);

		for i=1, #callback_list do
			local callback = callback_list[i];
			table.insert(farray, cc.CallFunc:create(callback));
		end
		table.insert(farray, cc.CallFunc:create(self.tenable));
		--table.insert(farray, cc.CallFunc:create(self.for_tutor));

		action = cc.Sequence:create(farray);
		sprite:runAction( cc.Sequence:create(farray));

		local items = {};
		local item;

		--[[ xxxx
		if true == is_show_tip_btn() then
			item, data = gui_add_item(items, 'btn_tip', GUI_MATCH, self.tip, ANCHOR_NULL);
			util.add_text_outline_to_sprite(item, '提示', 25, cc.c4b(data.r, data.g, data.b, 255), cc.c4b(data.sr, data.sg, data.sb, 255), 1);
		end
		]]--

		util.add_menu(self.layer, items, 100);
		
		return self.layer, self.name;
	end, 

	for_tutor = function(...)
		if g_euser.side == SIDE_GUEST then
			return;
		end
		local args = {...};
		local sprite = args[1];
		local self = layer_action;
		local ctype = self.obj.card.ctype;
		if true == g_is_in_tutor then
			story_2();
			return;
		end
		local step = nil;
		local flag = util.trigger_tutor(TUTOR_USE);
		if true == flag then return; end
		--if ctype == ALLY then
		if index_table_num(cindex(self.obj.card)) == T_ALLY then
			flag = util.trigger_tutor(TUTOR_TAP_ATTACK);
			if true == flag then return; end
		end
		if nil ~= g_src_index and g_src_index > 0 then
			if g_action_type == TYPE_ATTACK then
				flag = util.trigger_tutor(TUTOR_TAP_ATTARGET);
				if true == flag then return; end
			end
		end
		if ctype == HERO then
			flag = util.trigger_tutor(TUTOR_TAP_ABHERO);
			if true == flag then return; end
		end
		if ctype == HERO then
			step = TUTOR_HERO_POWER;
		elseif ctype == ALLY then
			step = TUTOR_ALLY_ATTACK;
		elseif ctype == WEAPON then
			step = TUTOR_WEAPON_ATK;
		elseif ctype == ARMOR then
			step = TUTOR_ARMOR_DEF;
		else
			step = TUTOR_COST;
		end
		flag = util.trigger_tutor(step);
		if false == flag then
			util.trigger_tutor(TUTOR_SAC_TAP);
		end
	end,

	tip = function()
		play_tap_1();
		local self = layer_action;
		if false == is_touchable() then
			return;
		end
		if true ~= g_scene:is_online() then
			return;
		end
		if g_euser.side ~= g_current_side then
			show_msg(t_lang("TIP_WAIT_OPPONENT"));
			return;
		end
		local ctype = self.obj.card.ctype;
		if ctype == HERO then
			step = TUTOR_HERO_POWER;
		elseif ctype == ALLY then
			step = TUTOR_ALLY_ATTACK;
--			util.set_tutor(TUTOR_COST, false, false);
		elseif ctype == WEAPON then
			step = TUTOR_WEAPON_ATK;
--			util.set_tutor(TUTOR_COST, false, false);
		elseif ctype == ARMOR then
			step = TUTOR_ARMOR_DEF;
--			util.set_tutor(TUTOR_COST, false, false);
		else
			step = TUTOR_COST;
		end
--		util.set_tutor(step, false, false);
--		util.set_tutor(TUTOR_DESC, false, false);
		util.trigger_tutor(step);
	end,

	tdisable = function()
		local self = layer_action;
		self.tcount = self.tcount + 1;
	end,

	tenable = function()
		local self = layer_action;
		self.tcount = self.tcount - 1;
		if 0 > self.tcount then
			self.tcount = 0;
		end
	end,

	is_enable = function()
		local self = layer_action;
		if 0 == self.tcount then
			return true;
		end
		return false;
	end,

	show_next = function(...)
		if false == is_touchable() then
			return;
		end
		local self = layer_action;
		local args = {...};
		local index = args[2]:getTag();
		local next_index = index + 1;

		if 0 == #(self.list or {}) then
			return;
		end
		if next_index > #self.list then
			next_index = 1;
		end
		local last_object = self.list[#self.list];
		table.remove(self.list, #self.list);
		table.insert(self.list, 1, last_object);

		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		for i = 1, #self.list do
			local obj = self.list[i].obj;
			local sprite = self.list[i].sprite;

			self.layer:reorderChild(sprite, ZORDER_SHOWING-i);

			local p = cc.p(pos.x, pos.y+(i-1)*50+hfix(80));
			if i == 1 then
			elseif i == #self.list then
			elseif 0 == i%2 then
				p.x = p.x + i * 10;
			else -- 0 ~= i%2
				p.x = p.x - i * 10;
			end
			local animation = {};
			table.insert(animation, cc.MoveTo:create(0.3, p));

			local actions_final = {};
			table.insert(actions_final, cc.Spawn:create(animation));

			self.tdisable();
			table.insert(actions_final, cc.CallFunc:create(self.tenable));
			sprite:runAction( cc.Sequence:create( actions_final ) );
		end

		self:show_menu();
	end,

	show_menu = function()
		local self = layer_action; --now we put attack/ability/sac on layer_action

		if nil ~= self.menu then
			self.menu:removeFromParentAndCleanup(true);
			self.menu = nil;
		end

		local btn_height = hfix(120);
		
		--local obj = get_ui_card(index);  -- like index_card(index, logic_table)
		local obj = self.list[1].obj;
		if nil == obj then
			kdebug("======= show_btn obj is nil");
			return;
		end
		--print('DEBUG handle_scale_max: index, obj = ', index, obj);
		local f_info = obj.frame; --list_object[1]
		local card = obj.card;  -- logic card data
		local index = cindex(card);
		local temp_sprite = obj.sprite;
		--local a_list = obj.attach_list or {};

		if nil == temp_sprite:getChildByTag(TAG_HIGHLIGHT) then
			-- this is normal because some card is not selectable
			-- e.g. cannot attack and cannot use ability
			return ;
		end

		kdebug("handle_scale_max:g_phase[%d]g_src_index[%d]",g_phase,g_src_index);

		local list_btn = {};
		if g_src_index > 0 then
			
			if g_action_type == TYPE_ATTACK then
				local l = { title = '目标', cb = callback_target };
				table.insert(list_btn, l);
			elseif g_action_type == TYPE_ABILITY then
				local l = { title = '目标', cb = callback_target };
				table.insert(list_btn, l);
			else

				local target_indexs, in_list;
				target_indexs = list_attack_target(g_src_index, g_logic_table, g_current_side);
				if nil ~= table_find(target_indexs or {}, index) then
					local l = { title = '攻击目标', cb = callback_target_t };
					table.insert(list_btn, l);
				end

				target_indexs = list_ability_target(g_src_index, g_logic_table, g_current_side, layer_card.ability_target_list, #layer_card.ability_target_list + 1);
				if nil ~= table_find(target_indexs or {}, index) then
					local l = { title = '技能目标', cb = callback_target_b };
					table.insert(list_btn, l);
				end
			end

		else --  implicit: g_src_index <= 0 

			local card = index_card(index, g_logic_table);
			local kind = nil;
			if nil ~= card then
				kind = check_kind(card, g_logic_table,g_current_side, g_phase);
			end
			local l = nil;
			if kind == AKIND_SAC then
				l = { title = '弃牌', cb = callback_sac };
				table.insert(list_btn, l);
			end
			if kind == AKIND_ATTACK or kind == AKIND_BOTH then
				l = { title = '攻击', cb = callback_attack };
				table.insert(list_btn, l);
			end
			if kind == AKIND_ABILITY or kind == AKIND_BOTH then
				l = { title = '技能', cb = callback_ability };
				table.insert(list_btn, l);
			end
			if kind == AKIND_TALLY or kind == AKIND_TSUPPORT then
				l = { title = '出牌', cb = callback_ability };
				table.insert(list_btn, l);
			end
		end
		if 0 == #list_btn then
			return;
		end
		local items = {};
		local item;

		local offsetx = FULL_WIDTH/(#list_btn+1);
		for i = 1, #list_btn do
			local l = list_btn[i];
			local title = l.title;
			local cb = l.cb;
			local pos = cc.p(offsetx * i, btn_height);
			item = add_item_1(items, title, nil, 30, cb, ANCHOR_CENTER_DOWN, pos);
			item:setTag(index);
		end
		if #(items or {}) > 0 then
			local menu = util.add_menu(self.layer, items, 1);
			menu:setTag(index);
			self.menu = menu;
		end
	end,

	close = function(self, callback_list)
		if nil == self.layer then
			layer_card:refresh_card_list();
			return;
		end
		self:remove();
		if true == is_step(STEP_CHOOSE) then
			g_src_index = 0;
		end
		for i = 1, #(callback_list or {}) do
			local cb = callback_list[i];
			cb();
		end
		if g_euser.side == SIDE_GUEST then
			return;
		end
		--[[
		if PHASE_SACRIFICE == g_phase then
			util.trigger_tutor(TUTOR_SAC);
		end
		]]--
	end,

	handler = function(event, x, y)
		local self = layer_action;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
		if false == self.is_enable() then
			return;
		end
		self:close();
	end,

} -- layer_action end

layer_preview = {
	name = 'layer_preview',
	layer = nil,

	cleanup = function(self)
		self.layer = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, obj)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_ACTION, self.handler, false, nil, true);

		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local rotation = 0;
		local cwidth = FULL_WIDTH - wfix(50);
		local cheight = FULL_HEIGHT - hfix(300);
		local scale = get_card_scale(cwidth, cheight, CARD_SIZE);
		local sprite = obj:get_action_sprite(self.layer, pos, rotation, scale);
		self.layer:reorderChild(sprite, ZORDER_SHOWING);

		--[[
		local pos_to = cc.p(HALF_WIDTH, HALF_HEIGHT+hfix(80));
		self.tdisable();
		local farray = {};
		local action;
		action = cc.EaseIn:create(cc.MoveTo:create(0.2, pos_to), 0.2);
		table.insert(farray, action);

		for i=1, #callback_list do
			local callback = callback_list[i];
			table.insert(farray, cc.CallFunc:create(callback));
		end
		table.insert(farray, cc.CallFunc:create(self.tenable));
		--table.insert(farray, cc.CallFunc:create(self.for_tutor));

		action = cc.Sequence:create(farray);
		sprite:runAction( cc.Sequence:create(farray));

		]]--
		
		return self.layer, self.name;
	end, 

	handler = function(event, x, y)
		local self = layer_preview;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
	end,

} -- layer_preview end

layer_menu = {
	name = 'layer_menu',
	layer = nil,
	btn1 = nil,
	btn2 = nil,
	btn3 = nil,
	btn4 = nil,
	bg_btn = nil,
	is_replay = nil,

	cleanup = function(self)
		self.layer = nil;
		self.btn1 = nil;
		self.btn2 = nil;
		self.btn3 = nil;
		self.btn4 = nil;
		self.bg_btn = nil;
		self.is_replay = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, stage)
		self:remove();
		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_MENU, self.handler, false);

		local items = {};
		local item, pos, data;

		local zorder = 65;
		if stage == STAGE_PVE or stage == STAGE_PVP or stage == STAGE_PVG then
			-- count time for per round
			layer_card:add_clock(self.layer);

			item, data = gui_add_item(items,'btn_more',GUI_MATCH,self.cb_match_more, ANCHOR_UP);
			zorder = data.zorder;
			if true == g_is_in_tutor then
				enable_btn(item, false);
			end
			self:create_match_more(stage, data);

		elseif stage == STAGE_REPLAY then
			self.is_replay = true;
			item, data = gui_add_item(items,'btn_more',GUI_MATCH, self.cb_match_more, ANCHOR_UP);
			zorder = data.zorder;
			self:create_match_more(stage, data);

		elseif stage == STAGE_BLANK then
			local size = cc.size(172, 52);
			pos = ccp(FULL_WIDTH, FULL_HEIGHT);
			item = add_item_1(items, '退出', nil, 20, self.blank_back, ANCHOR_RIGHT_UP, pos, size);
			table.insert(items, item);
		end

		util.add_menu(self.layer, items, zorder);

		return self.layer, self.name;
	end,

	create_match_more = function(self, stage, data)
		local items = {};
		local item, data, pos, cb;

		item, data = gui_add_item(items, 'more3', GUI_MATCH, self.menu_chat, ANCHOR_UP);
		item:setPosition(cc.p(data.x, FULL_HEIGHT));
		self.btn1 = item;

		local is_back = false;
		if 1 == layer_card.FORCE_AUTO then
			cb = self.to_pclg;
		elseif stage == STAGE_PVP or stage == STAGE_PVG then
			if g_euser.side == SIDE_GUEST then
				is_back = true;
			end
			cb = self.ask_fold;
		elseif stage == STAGE_REPLAY then
			is_back = true;
			cb = self.to_playerinfo;
		elseif stage == STAGE_PVE and g_scene:is_online() then
			cb = self.to_map;
		else
			cb = self.to_login;
		end
		item, data = gui_add_item(items, 'more2', GUI_MATCH, cb, ANCHOR_UP);
		item:setPosition(cc.p(data.x, FULL_HEIGHT));
		self.btn2 = item;

		item, data = gui_add_item(items, 'more1', GUI_MATCH,self.rgame,ANCHOR_UP);
		item:setPosition(cc.p(data.x, FULL_HEIGHT));
		self.btn3 = item;
		
		if nil ~= g_euser.room_data and nil ~= g_euser.room_data.target_list then
			item, data = gui_add_item(items, 'more4', GUI_MATCH,self.show_target_list,ANCHOR_UP);
			item:setPosition(cc.p(data.x, FULL_HEIGHT));
			self.btn4 = item;
			self.bg_btn = gui_add_sprite(self.layer, 'bg_more2', GUI_MATCH, ANCHOR_UP);
		else
			self.btn4 = nil;
			self.bg_btn = gui_add_sprite(self.layer, 'bg_more', GUI_MATCH, ANCHOR_UP);
		end

		self.bg_btn:setVisible(false);

		util.add_menu(self.layer, items, data.zorder);
	end,

	menu_chat = function()
		play_tap_1();
		if true == data_handler.is_check_for_teach then
			show_msg("请按提示进行操作");
			return;
		end
		show_chat(true);
		--g_scene:add_layer(ZORDER_LAYER_CHAT, layer_chat:create(true));
	end,

	cb_match_more = function(tag, sender)
		play_tap_3();
		-- sindex 0: off, 1: on
		local sindex = tolua.cast(sender, "cc.MenuItemToggle"):getSelectedIndex();
		local self = layer_menu;
		if 0 == sindex then
			self.bg_btn:setVisible(false);
			y = FULL_HEIGHT;
		else
			self.bg_btn:setVisible(true);
			local data = gui_get_data('more1', GUI_MATCH, ANCHOR_UP);
			y = data.y;
		end
		local list = { self.btn1, self.btn2, self.btn3, self.btn4 };
		local delay = 0;
		for i = 1, #list do
			local btn = list[i];
			if nil ~= btn then
				delay = delay + 0.1;
				btn:stopAllActions();
				local array = {};
				table.insert(array, cc.DelayTime:create(delay));
				local action = cc.MoveTo:create(0.1, cc.p(btn:getPositionX(), y));
				table.insert(array, action);
				btn:runAction(cc.Sequence:create(array));
			end
		end
	end,

	blank_back = function()
		play_tap_1();
		g_scene:debug();
	end,

	to_login = function()
		play_tap_1();
		g_scene:login();
	end,

	to_playerinfo = function()
		play_tap_1();
		clean_for_replay();
		--[[
		cc.Director:getInstance():getScheduler():setTimeScale(1);
		layer_anim:remove();
		layer_card:remove();
		data_handler:cleanup();
		g_euser.side = nil;
		g_euser.room_data = nil;
		g_scene:map();
		g_scene:add_layer(ZORDER_LAYER_INFO, layer_info:create(g_euser));
		local eid = layer_video.eid or '';
		local cmd = 'lreplay ' .. eid;
		net_send(cmd);
		]]--
	end,

	to_pclg = function()
		play_tap_1();
		show_pclg();
	end,

	to_map = function()
		play_tap_1();
		g_scene:map();
	end,

	show_target_list = function()
		local l = g_euser.room_data.target_list or {};
		g_scene:add_layer(ZORDER_LAYER_LTARGET, layer_ltarget:create(l));
	end,

	rgame = function()
		play_tap_1();
		if 1 == layer_card.FORCE_AUTO then
			return;
		end
		if nil ~= g_net_win_data then
			-- already get net_win, don't send leave or fold
			-- otherwise will get st not_enough and jump to login
			return;
		end
		local cmd = 'ginfo';
		net_send(cmd);
	end,

	ask_fold = function()
		play_tap_1();
		local self = layer_menu;
		local is_npc = false;
		local is_my = false;
		local list = g_euser.room_data.guest_list or {};
		if #list >= 2 then
			for i = 1, 2 do
				local info = list[i];
				if info.eid < 500 then
					is_npc = true;
				end
				if info.eid == g_euser.eid then
					is_my = true;
				end
			end
		end
		local hp = g_logic_table[SIDE_DOWN][T_HERO][1].hp or 0;
		local str;
		if true == is_my and hp > 5
		and nil ~= g_euser.room_data
		and nil ~= g_euser.room_data.game_type
		and (g_euser.room_data.game_type == GAME_SOLO_GOLD
		or g_euser.room_data.game_type == GAME_VS_GOLD
		or g_euser.room_data.game_type == GAME_VS_CRYSTAL
		or g_euser.room_data.game_type == GAME_VS_FREE
		or g_euser.room_data.game_type == GAME_SOLO_PLUS) then
--			print('game_type:', g_euser.room_data.game_type, ' stage: ', stage);
			str = "你的英雄血量高于5点，投降将不能获得奖励，是否退出？";
		else
			str = "是否退出？";
		end
		g_scene:add_layer(ZORDER_LAYER_TIP, layer_tip:create(str, self.fold));
	end,

	-- tag 1->confirm 0->cancel
	fold = function(tag)
		local self = layer_menu;
		if true == self.is_replay then
			self.to_playerinfo();
			return;
		end
		if nil ~= g_net_win_data then
			-- already get net_win, don't send leave or fold
			-- otherwise will get st not_enough and jump to login
			return;
		end
		if g_euser.side == SIDE_GUEST then
			local cmd = 'leave';
			net_send(cmd);
			return;
		end
		local cmd = 'fold';
		net_send(cmd);
	end,

	handler = function(event, x, y)
		local self = layer_menu;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_menu end

layer_result = {
	name = 'layer_result',
	layer = nil,
	TAG_BG = 56,
	TAG_WIN = 1,
	TAG_LOSE = 2,
	TAG_DRAW = 3,
	TAG_GUEST = 4,
	result = nil,
	info = nil,
	step = nil,
	is_done = false,
	cid = nil,
	list_box = nil,
	select_box = nil,
	list_box_card = nil,

	cleanup = function(self)
		self.layer = nil;
		self.result = nil;
		self.info = nil;
		self.step = nil;
		self.is_done = false;
		self.cid = nil;
		self.list_box = nil;
		self.select_box = nil;
		self.list_box_card = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	-- if result == guest , offset_rating will be the winner's name
	--create = function(self, result, offset_rating, offset_gold, offset_exp, level, exp_next)
	create = function(self, result, info)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_RESULT, self.handler, true);

		self.result = result;
		self.info = info;
		self.step = 1;
		self.is_done = false;
		self.cid = info.card_id;
		self.list_box = {};
		
		local sprite = gui_add_sprite(self.layer, 'bg', GUI_RESULT);
		sprite:setTag(self.TAG_BG);

		local btn_key, str;
		local path = util.get_path(FT_4);
		if result == self.TAG_WIN then
			gui_add_sprite(self.layer, 'light', GUI_RESULT, ANCHOR_UP);
			gui_add_sprite(self.layer, 'bar', GUI_RESULT, ANCHOR_UP);
			gui_add_sprite(self.layer, 'l_win', GUI_RESULT, ANCHOR_UP);
			if info.exp > 0 then
				gui_add_sprite(self.layer, 'l_exp', GUI_RESULT, ANCHOR_UP);
				str = "+" .. info.exp;
				gui_add_labelbmf(self.layer,str,path,'n_exp',GUI_RESULT,ANCHOR_UP);
			end
			local cinfo = info.chapter_info;
			if info.game_type == GAME_CHAPTER and nil ~= cinfo then
				gui_add_sprite(self.layer, 'bg_target', GUI_RESULT, ANCHOR_UP);
				local p = util.get_path(FT_2);
				for i = 1, #(cinfo.list_target or {}) do
					local tg = cinfo.list_target[i];
					local key = 'tg_' .. i;
					local t=string.format("%s",layer_stage:get_target_msg(tg,true));
					gui_add_rlabel(self.layer, t, 24, key, GUI_RESULT, ANCHOR_UP);
					key = 'tg_' .. i .. '_n';
					t= i .. '';
					gui_add_labelbmf(self.layer,t,p,key,GUI_RESULT,ANCHOR_UP);
					key = 'star_' .. i;
					local s=gui_add_sprite(self.layer,key,GUI_RESULT, ANCHOR_UP);
					if 1 == tg.done then
						key = 'tg_' .. i .. '_done';
					else
						util.set_gray(s);
						key = 'tg_' .. i .. '_not';
					end
					gui_add_sprite(self.layer, key, GUI_RESULT, ANCHOR_UP);
				end
			else
				if info.gold > 0 then
					gui_add_sprite(self.layer, 'l_gold', GUI_RESULT, ANCHOR_UP);
					str = "+" .. info.gold;
					gui_add_labelbmf(self.layer,str,path,'n_gold',GUI_RESULT,ANCHOR_UP);
				end
				if info.rating > 0 then
					gui_add_sprite(self.layer, 'l_rate', GUI_RESULT, ANCHOR_UP);
					str = "+" .. info.rating;
					gui_add_labelbmf(self.layer,str,path,'n_rate',GUI_RESULT,ANCHOR_UP);
				end
			end
			btn_key = 'btn_next';
		elseif result == self.TAG_LOSE then
			gui_add_sprite(self.layer, 'light_lose', GUI_RESULT, ANCHOR_UP);
			gui_add_sprite(self.layer, 'pic_grave', GUI_RESULT, ANCHOR_UP);
			gui_add_sprite(self.layer, 'bar_lose', GUI_RESULT, ANCHOR_UP);
			gui_add_sprite(self.layer, 'l_lose', GUI_RESULT, ANCHOR_UP);
			--[[
			gui_add_sprite(self.layer, 'bg_improve', GUI_RESULT, ANCHOR_UP);
			gui_add_sprite(self.layer, 't_improve', GUI_RESULT, ANCHOR_UP);
			gui_add_sprite(self.layer, 'arrow_improve', GUI_RESULT, ANCHOR_UP);
			]]--
			btn_key = 'btn_next_lose';
		elseif result == self.TAG_DRAW then
			gui_add_sprite(self.layer, 'light_draw', GUI_RESULT, ANCHOR_UP);
			gui_add_sprite(self.layer, 'bar_draw', GUI_RESULT, ANCHOR_UP);
			gui_add_sprite(self.layer, 'l_draw', GUI_RESULT, ANCHOR_UP);
			btn_key = 'btn_next_draw';
		else -- TAG_GUEST
			local s, d = gui_add_sprite(self.layer, 'bar', GUI_RESULT, ANCHOR_UP);
			str = info.winnername .. '  胜出';
			util.add_labeloutline(self.layer, str, nil, 30, cc.p(d.x+d.width/2, d.y+d.height), util.c4b_white, util.c4b_black, 2, ANCHOR_CENTER_DOWN, 10, cc.size(FULL_HEIGHT, FULL_HEIGHT-d.y-d.height), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);
			btn_key = 'btn_next';
		end

		local items = {};
		local item;

		if result == self.TAG_LOSE then
			item, data = gui_add_item(items, 'bg_improve', GUI_RESULT, self.cb_improve, ANCHOR_UP);
			gui_add_sprite_on_cell(item, data, 't_improve', GUI_RESULT,ANCHOR_UP);
			gui_add_sprite_on_cell(item, data, 'arrow_improve', GUI_RESULT,ANCHOR_UP);
		end

		item, data = gui_add_item(items, btn_key, GUI_RESULT, self.cb_step_1, ANCHOR_UP);

		util.add_menu(self.layer, items, data.zorder);

		util.stop_bgmusic();
		local fname = nil;
		if result == self.TAG_WIN then
			fname = 'eff_win.mp3';
		elseif result == self.TAG_LOSE then
			fname = 'eff_lose.mp3';
		else
			fname = 'eff_draw.mp3';
		end
		-- do preload in layer_preload loadres
		--util.preload_effect(path)
		local path = util.get_path(fname);
		--print('result music path: ', path);
		--util.preload_effect(path);
		util.play_effect(path);
		--[[

		local fullpath = util.get_fullpath(F_IMAGE, 'res_result.plist');
		util.add_frames(fullpath);
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 210));

		local delay = 0.2;
		delay = self:show_popup(delay);

		if result == self.TAG_WIN then
			delay = self:show_light(delay);
		end

		delay = self:show_mark(delay, result);

		if nil ~= info.exp and g_euser.side ~= SIDE_GUEST then
			delay = self:show_exp(delay, info);
			g_euser.level = info.level;
		end

		delay = self:show_info(delay, result, info);

		delay = self:show_next(delay);

		util.stop_bgmusic();
		local fname = nil;
		if result == self.TAG_WIN then
			fname = 'eff_win.mp3';
		elseif result == self.TAG_LOSE then
			fname = 'eff_lose.mp3';
		else
			fname = 'eff_draw.mp3';
		end
		-- do preload in layer_preload loadres
		--util.preload_effect(path)
		local path = util.get_path(fname);
		--print('result music path: ', path);
		--util.preload_effect(path);
		util.play_effect(path);

		local cmsg = "";
		if nil ~= layer_table.chapter_reward_msg then
			self.is_set_chapter_msg = true;
			cmsg = layer_table.chapter_reward_msg;
			self.need_open_chapter = true;
		end
		local pos = cc.p(0, FULL_HEIGHT);
		local size = cc.size(FULL_WIDTH, FULL_HEIGHT);
		self.label_crm = util.add_labelttf(self.layer, cmsg, nil, 25, pos, util.c4b_white, ANCHOR_LEFT_UP, 50, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_TOP); 
		]]--

		return self.layer, self.name;
	end,

	cb_step_1 = function()
		local self = layer_result;
		if g_scene:is_stage(STAGE_REPLAY) then
			--clean_for_replay();
			self.close();
			return;
		end
		if layer_result.TAG_GUEST==self.result then
			--[[
			if true==g_scene:is_online() then 
				g_scene:map();
			else
				self:remove();
			end
			]]--
			self.close();
			return;
		end
		self:check_card();
	end,

	check_card = function(self)
		self.step = 2;
		local cid = self.info.card_id;
		local card = clone_card_by_id(cid);
		if nil == card then
			self:check_box();
			return;
		end
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local cinfo = object_card:new(self.layer, card, nil, nil, pos, 0, 0);
		local sprite = cinfo:get_front();
		
		local scale = wfix(1);
		if hfix(1) < scale then
			scale = hfix(1);
		end
		local function do_next()
			if true == layer_card.should_start_next_after_result then
				net_send('ginfo');
				return;
			end
			self.step = 3;
		end
		scale = scale * 1.2;
		local array, action;
		array = {};
		table.insert(array, cc.ScaleTo:create(1, scale));
		table.insert(array, cc.RotateBy:create(1, 360 * 3));
		action = cc.Spawn:create(array);
		array = {};
		table.insert(array, action);
		table.insert(array, cc.CallFunc:create(do_next));
		action = cc.Sequence:create(array);
		sprite:runAction(action);
	end,

	check_box = function(self)
		self.step = 4;
		local rpos = nil;
		local rinfo = self.info.rinfo;
		if nil ~= rinfo then
			rpos = rinfo.reward_pos;
		elseif self.info.game_type == GAME_CHAPTER and nil ~= self.info.chapter_info then
			rinfo = self.info.chapter_info;
			rpos = rinfo.reward_pos;
		end
		if nil == rpos or rpos < 1 then
			self.step = 5;
			self:close();
			return;
		end
		-- do something
		local list = self.layer:getChildren();
		for i = 1, #list do
			local s = list[i];
			if self.TAG_BG ~= s:getTag() then
				local list = {};
				table.insert(list, cc.FadeOut:create(0.2));
				table.insert(list, cc.CallFunc:create(self.cb_set_unvisible));
				s:runAction(cc.Sequence:create(list));
			else
				local list = {};
				table.insert(list, cc.DelayTime:create(0.2));
				table.insert(list, cc.CallFunc:create(self.show_box_anim));
				s:runAction(cc.Sequence:create(list));
			end
		end
	end,

	show_box_anim = function()
		local self = layer_result;
		self.list_box_card = {};
		gui_add_sprite(self.layer, 'bg_title', GUI_RESULT, ANCHOR_UP);
		gui_add_label_ali(self.layer, '请选择宝箱', 28, 'title', GUI_RESULT, ANCHOR_UP, cc.TEXT_ALIGNMENT_CENTER);
		local items = {};
		local item, data, key, list;

		self.list_box = {};
		for i = 1, 4 do
			key = 'box' .. i;
			item, data = gui_add_item(items, key, GUI_RESULT, self.choose_box, ANCHOR_UP);
			item:setPosition(cc.p(data.x+data.width/2, data.y+data.height/2));
			item:setAnchorPoint(ANCHOR_CENTER_CENTER);
			item:setTag(i);
			table.insert(self.list_box, item);
			list = {};
			local dtime = math.random(0, 20) / 100;
			table.insert(list, cc.DelayTime:create(dtime));
			table.insert(list, cc.RotateTo:create(0.05, -20));
			table.insert(list, cc.RotateTo:create(0.1, 20));
			table.insert(list, cc.RotateTo:create(0.05, 0));
			table.insert(list, cc.DelayTime:create(0.2));
			item:runAction(cc.RepeatForever:create(cc.Sequence:create(list)));
		end

		util.add_menu(self.layer, items, data.zorder);
		self.step = 5;
	end,

	choose_box = function(...)
		local self = layer_result;
		local args = {...};
		local tag = args[2]:getTag();
		self.select_box = tag;
		for i = 1, #self.list_box do
			local s = self.list_box[i];
			local list = {};
			table.insert(list, cc.DelayTime:create(math.abs(i-tag)/10));
			table.insert(list, cc.CallFunc:create(self.open_box));
			s:runAction(cc.Sequence:create(list));
		end
		local items = {};
		local item, data;
		item, data = gui_add_item(items, 'btn_next', GUI_RESULT, self.close, ANCHOR_UP);
		item:setPositionY(hfix(100));
		item:setOpacity(0);
		local list = {};
		table.insert(list, cc.FadeIn:create(0.2));
		item:runAction(cc.Sequence:create(list));
		util.add_menu(self.layer, items, data.zorder);
	end,

	open_box = function(...)
		local self = layer_result;
		local args = {...};
		local tag = args[1]:getTag();
		local item = self.list_box[tag];
		if nil == item then return; end
		item:removeFromParent(true);
		local key = 'box' .. tag;
		local sprite;
		sprite = gui_add_sprite(self.layer, key, GUI_RESULT, ANCHOR_UP);
		local path = util.get_path('pic_87.png');
		local tc = cc.Director:getInstance():getTextureCache();
		local texture = tc:addImage(path);
		if nil ~= texture then
			sprite:setTexture(texture);
		end
		local scale = sprite:getScale();
		local list = {};
		table.insert(list, cc.EaseOut:create(cc.ScaleTo:create(0.1, scale*1.2), 0.1));
		table.insert(list, cc.EaseIn:create(cc.ScaleTo:create(0.1, scale), 0.1));
		sprite:runAction(cc.Sequence:create(list));
		local key = 'box' .. tag .. '_light';
		local light = gui_add_sprite(self.layer, key, GUI_RESULT, ANCHOR_UP);
		key = 'box' .. tag .. '_laser';
		local laser = gui_add_sprite(self.layer, key, GUI_RESULT, ANCHOR_UP);
		local rinfo = nil;
		if nil ~= self.info.rinfo then
			rinfo = self.info.rinfo;
		else
			rinfo = self.info.chapter_info;
		end
		local rpos = rinfo.reward_pos;
		local ttt = rpos;
		if tag ~= self.select_box then
			path = util.get_path('bg_148.png');
			texture = tc:addImage(path);
			if nil ~= texture then
				light:setTexture(texture);
			end
			path = util.get_path('bg_147.png');
			texture = tc:addImage(path);
			if nil ~= texture then
				laser:setTexture(texture);
			end
			if tag == rpos then
				rpos = self.select_box;
			else
				rpos = tag;
			end
		else
			rpos = ttt;
		end
		local ll = rinfo.list_reward[rpos];
		local rtype = ll.reward_type;
		local rnum = ll.reward_num;
		if nil == ll then return; end
		key = 'item' .. tag .. '_pic';
		local frame = gui_add_sprite(self.layer, key, GUI_RESULT, ANCHOR_UP);

		local label_path;
		if rtype == CHAPTER_REWARD_GOLD then
			path = util.get_path('icon_49.png');
			label_path = util.get_path('text_16.png');
		elseif rtype == CHAPTER_REWARD_CRYSTAL then
			path = util.get_path('icon_50.png');
			label_path = util.get_path('text_17.png');
		elseif rtype == CHAPTER_REWARD_PIECE then
			path = util.get_path('icon_52.png');
			label_path = util.get_path('text_19.png');
		elseif rtype == CHAPTER_REWARD_CARD then
			path = util.get_path('icon_53.png');
			label_path = util.get_path('text_20.png');
		elseif rtype == CHAPTER_REWARD_EXP then
			path = util.get_path('icon_60.png');
			label_path = util.get_path('text_21.png');
		elseif rtype == CHAPTER_REWARD_POWER then
			path = util.get_path('icon_51.png');
			label_path = util.get_path('text_18.png');
		else
			return;
		end
		texture = tc:addImage(path);
		if nil ~= texture then
			frame:setTexture(texture);
		end
		local mask_path = nil;
		if rtype == CHAPTER_REWARD_PIECE then
			local rc = g_card_list[rnum];
			if nil == rc then
				rc = hero_list[rnum];
			end
			local card = clone(rc);
			table.insert(self.list_box_card, {s = frame, c = card, p = true});
			path = util.get_path(string.format('card%d.png', rnum), 'card0.png');
			mask_path = util.get_path('bg_146.png');
		elseif rtype == CHAPTER_REWARD_CARD then
			local rc = g_card_list[rnum];
			if nil == rc then
				rc = hero_list[rnum];
			end
			local card = clone(rc);
			table.insert(self.list_box_card, {s = frame, c = card, p = false});
			path = util.get_path(string.format('card%d.png', rnum), 'card0.png');
			mask_path = util.get_path('bg_145.png');
		end
		if nil ~= mask_path then
			local size = frame:getContentSize();
			local pos = cc.p(size.width/2, size.height/2);
			local pic = util.add_mask_sprite(frame, path, mask_path, pos, ANCHOR_CENTER_CENTER, -1);
			pic:setScale(size.height/pic:getContentSize().height);
		end
		key = 'item' .. tag .. '_t';
		local label = gui_add_sprite(self.layer, key, GUI_RESULT, ANCHOR_UP);
		texture = tc:addImage(label_path);
		if nil ~= texture then
			label:setTexture(texture);
		end
		path = util.get_path(FT_4);
		key = 'item' .. tag .. '_n';
		local str = '*' .. rnum;
		if rtype == CHAPTER_REWARD_PIECE then
			str = '*1';
		elseif rtype == CHAPTER_REWARD_CARD then
			str = '*1';
		end
		gui_add_labelbmf(self.layer, str, path, key, GUI_RESULT, ANCHOR_UP); 
	end,

	cb_set_unvisible = function(...)
		local args = {...};
		args[1]:setVisible(false);
	end,

	cb_improve = function()
		local self = layer_result;
	end,

	check_touch_box_card = function(self, tx, ty)
		local list = self.list_box_card or {};
		if 0 == #list then
			return false;
		end
		for i = 1, #list do
			local info = list[i];
			local s = info.s;
			local c = info.c;
			local p = info.p;
			local x, y = s:getPosition();
			local size = s:getContentSize();
			local scale = s:getScale();
			local width = size.width*scale;
			local height = size.height*scale;
			if nil~=c and tx>x and tx < x+width and ty > y and ty < y+height then
				g_scene:add_layer(ZORDER_LAYER_MISPOP, layer_mispop:create(c,p));
				return true;
			end
		end
		return false;
	end,

	show_popup = function(self, delay)
		local fname, pos, sprite, array;
		fname = 'result_center.png';
		pos = cc.p(HALF_WIDTH, HALF_HEIGHT + 100);
		sprite=util.add_sprite_frame(self.layer,fname,pos,ANCHOR_CENTER_CENTER,5);
		sprite:setVisible(false);
		sprite:setScale(1.5);
		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		table.insert(array, cc.EaseOut:create(cc.ScaleTo:create(0.2, 1), 0.2));
		sprite:runAction(cc.Sequence:create(array));

		delay = delay + 0.2;

		local p1 = cc.p(HALF_WIDTH, HALF_HEIGHT + 100 + 70);
		local p2 = cc.p(HALF_WIDTH, HALF_HEIGHT + 100 - 20);
		fname = 'result_left.png';
		sprite = util.add_sprite_frame(self.layer,fname,p1,ANCHOR_CENTER_DOWN,3);
		sprite:setVisible(false);
		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		table.insert(array, cc.EaseOut:create(cc.MoveTo:create(0.1, p2), 0.1));
		table.insert(array, cc.EaseOut:create(cc.RotateTo:create(0.2, -45), 0.2));
		sprite:runAction(cc.Sequence:create(array));

		fname = 'result_right.png';
		sprite = util.add_sprite_frame(self.layer,fname,p1,ANCHOR_CENTER_DOWN,3);
		sprite:setVisible(false);
		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		table.insert(array, cc.EaseOut:create(cc.MoveTo:create(0.1, p2), 0.1));
		table.insert(array, cc.EaseOut:create(cc.RotateTo:create(0.2, 45), 0.2));
		sprite:runAction(cc.Sequence:create(array));

		delay = delay + 0.2;

		return delay;
	end,

	show_light = function(self, delay)
		local fname, pos, sprite, array;
		fname = 'result_light.png';
		pos = cc.p(HALF_WIDTH, HALF_HEIGHT + 100);
		sprite=util.add_sprite_frame(self.layer,fname,pos,ANCHOR_CENTER_CENTER,1);
		sprite:setVisible(false);
		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		sprite:runAction(cc.Sequence:create(array));
		sprite:runAction(cc.RepeatForever:create(cc.RotateBy:create(7, 360)));

		return delay;
	end,

	show_mark = function(self, delay, result)
		local fname, pos, sprite, array;
		if result == self.TAG_WIN then
			fname = 'result_win_1.png';
		elseif result == self.TAG_GUEST then
			return delay;
		else
			fname = 'result_lose_1.png';
		end
		pos = cc.p(HALF_WIDTH, HALF_HEIGHT + 100 - 40);
		sprite=util.add_sprite_frame(self.layer,fname,pos,ANCHOR_CENTER_UP,7);
		sprite:setVisible(false);
		sprite:setScaleX(0);
		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		table.insert(array, cc.ScaleTo:create(0.2, 1.2));
		table.insert(array, cc.ScaleTo:create(0.2, 1));
		sprite:runAction(cc.Sequence:create(array));

		delay = delay + 0.1;

		if result == self.TAG_WIN then
			fname = 'result_win_2.png';
		elseif result == self.TAG_DRAW then
			fname = 'result_draw_2.png';
		else
			fname = 'result_lose_2.png';
		end
		pos = cc.p(HALF_WIDTH, HALF_HEIGHT + 100 - 60);
		sprite=util.add_sprite_frame(self.layer,fname,pos,ANCHOR_CENTER_CENTER,9);
		sprite:setVisible(false);
		sprite:setScale(1.5);
		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		table.insert(array, cc.EaseOut:create(cc.ScaleTo:create(0.2, 1), 0.2));
		sprite:runAction(cc.Sequence:create(array));

		delay = delay + 0.1;

		return delay;
	end,

	show_info = function(self, delay, result, info)
		local fname, pos, sprite, array;
		if result == self.TAG_GUEST then
			local name = info.winnername;
			if nil ~= name then
				pos = cc.p(HALF_WIDTH, HALF_HEIGHT + 100 + 40);
				name = '胜利者：' .. name;
				sprite = util.add_labeloutline(self.layer, name, nil, 25, pos, util.c4b_white, util.c4b_black, 1, ANCHOR_CENTER_CENTER, 9);
				sprite:setVisible(false);
				array = {};
				table.insert(array, cc.DelayTime:create(delay));
				table.insert(array, cc.Show:create());
				sprite:runAction(cc.Sequence:create(array));
			end
			return delay;
		end
		local fontpath = util.get_fullpath(F_FONT, 'font_result.fnt');
		local rating = info.rating or '0';
		local gold = info.gold or '0';
		local crystal = info.crystal or '0';
		local show_rating = true;
		if 0 == tonumber(rating) then
			show_rating = false;
		end
		--[[
		local grd = g_euser.room_data;
		if nil ~= grd then
			local list = grd.guest_list or {};
			if #list > 1 then
				for i = 1, 2 do
					local info = list[i];
					if info.eid < 500 then
						show_rating = false;
						break;
					end
				end
			end
		end
		]]--
		if true == show_rating then
			fname = 'result_evil.png';
			pos = cc.p(HALF_WIDTH-84, HALF_HEIGHT + 100 + 70);
			sprite=util.add_sprite_frame(self.layer,fname,pos,ANCHOR_LEFT_UP,9);
			sprite:setVisible(false);
			array = {};
			table.insert(array, cc.DelayTime:create(delay));
			table.insert(array, cc.Show:create());
			sprite:runAction(cc.Sequence:create(array));

			pos.x = HALF_WIDTH;
			if rating >= 0 then
				rating = '+' .. rating;
			end
			sprite = util.add_labelbmf(self.layer, rating, fontpath, pos, ANCHOR_LEFT_UP, 9);
			sprite:setVisible(false);
			array = {};
			table.insert(array, cc.DelayTime:create(delay));
			table.insert(array, cc.Show:create());
			sprite:runAction(cc.Sequence:create(array));
			local len = sprite:getStringLength();
			for i = 0, len - 1 do
				local t = sprite:getLetter(i);
				local x, y = t:getPosition();
				array = {};
				table.insert(array, cc.DelayTime:create(delay + i * 0.1));
				table.insert(array, cc.JumpTo:create(0.15, cc.p(x, y), 15, 1));
				t:runAction(cc.Sequence:create(array));
			end
		end

		pos = cc.p(HALF_WIDTH-84, HALF_HEIGHT + 100 + 30);
		if crystal > 0 then
			fname = 'crystal.png';
			sprite = util.add_sprite(self.layer, fname, pos, ANCHOR_LEFT_UP, 9);
		else
			fname = 'result_coin.png';
			sprite=util.add_sprite_frame(self.layer,fname,pos,ANCHOR_LEFT_UP,9);
		end
		sprite:setVisible(false);
		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		sprite:runAction(cc.Sequence:create(array));

		pos.x = HALF_WIDTH;
		if crystal > 0 then
			crystal = '+' .. crystal;
			sprite = util.add_labelbmf(self.layer, crystal, fontpath, pos, ANCHOR_LEFT_UP, 9);
		else
			if gold >= 0 then
				gold = '+' .. gold;
			end
			sprite = util.add_labelbmf(self.layer, gold, fontpath, pos, ANCHOR_LEFT_UP, 9);
		end
		sprite:setVisible(false);
		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		sprite:runAction(cc.Sequence:create(array));
		len = sprite:getStringLength();
		for i = 0, len - 1 do
			local t = sprite:getLetter(i);
			local x, y = t:getPosition();
			array = {};
			table.insert(array, cc.DelayTime:create(delay + i * 0.09));
			table.insert(array, cc.JumpTo:create(0.15, cc.p(x, y), 15, 1));
			t:runAction(cc.Sequence:create(array));
		end

		return delay;
	end,

	show_exp = function(self, delay, info)
		local exp_offset = info.exp or 0;
		local exp_next = info.exp_next or 0;
		local level = info.level or 0;
		local exp_player = info.exp_player or 0;

		local fullpath, pos, sprite, array;
		--fullpath = util.get_fullpath(F_IMAGE, 'label_exp.png');
		pos = cc.p(HALF_WIDTH - 140, HALF_HEIGHT - 200);
		--sprite=util.add_sprite(self.layer,fullpath,pos,ANCHOR_CENTER_CENTER,5);
		sprite = util.add_labeloutline(self.layer, "EXP", nil, 25, pos, util.c4b_white, util.c4b_black, 2, ANCHOR_CENTER_CENTER, 5);
		sprite:setVisible(false);
		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		sprite:runAction(cc.Sequence:create(array));

		pos = cc.p(HALF_WIDTH, HALF_HEIGHT - 200);
		fullpath = util.get_fullpath(F_IMAGE, 'bar_exp_1.png');
		sprite=util.add_sprite(self.layer,fullpath,pos,ANCHOR_CENTER_CENTER,1);
		sprite:setVisible(false);
		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		sprite:runAction(cc.Sequence:create(array));

		fullpath = util.get_fullpath(F_IMAGE, 'bar_exp_3.png');
		sprite=util.add_sprite(self.layer,fullpath,pos,ANCHOR_CENTER_CENTER,5);
		sprite:setVisible(false);
		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		sprite:runAction(cc.Sequence:create(array));

		fullpath = util.get_fullpath(F_IMAGE, 'bar_exp_2.png');
		sprite = util.add_progress_bar(self.layer, util.create_sprite(fullpath), pos, cc.PROGRESS_TIMER_TYPE_BAR, ccp(0, 1), ccp(1, 0), 0, 3);
		sprite:setVisible(false);
		local exp_bar = sprite;

		local fontpath = util.get_fullpath(F_FONT, 'font_exp.fnt');
		local num_add = 0;
		pos.x = pos.x + 200;
		sprite = util.add_labelbmf(self.layer, '+0', fontpath, pos, ANCHOR_LEFT_CENTER, 9);
		sprite:setVisible(false);
		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		sprite:runAction(cc.Sequence:create(array));
		local exp_label = sprite;

		-- set current exp bar
		local exp_total = g_euser.exp_next;
		local exp = g_euser.exp;
		local level_offset = level - g_euser.level;
		local percent = 0;
		if exp < 0 then exp = 0; end
		if 0 == exp_total or exp >= exp_total then
			percent = 100;
		else
			percent = exp / exp_total * 100;
		end
		exp_bar:setPercentage(percent);

		local function level_up()
			local fname = 'result_level_up.png';
			local pos = cc.p(HALF_WIDTH, HALF_HEIGHT + 100 + 200);
			local sprite=util.add_sprite_frame(self.layer,fname,pos,ANCHOR_CENTER_CENTER,10);
			local array = {};
			pos.y = pos.y + 40;
			table.insert(array, cc.MoveTo:create(0.6, pos));
			table.insert(array, cc.CallFunc:create(callback_remove_sprite));
			sprite:runAction(cc.Sequence:create(array));
		end

		local num_exp = 0;
		local speed = 5;
		local line = exp_player / exp_next * 100;
		local function update_exp()
			percent = percent + speed;
			num_exp = num_exp + 1;
			if level_offset > 0 then
				if percent > 100 then 
					level_up();
					percent = 100; 
					level_offset = level_offset - 1;
					percent = 0;
					speed = 5;

					if is_ver(VER_LJSDK) then
						ljsdk_submit_data("levelUp");
					end

				end
			else
				if percent >= line then
					percent = line;
					self.layer:unscheduleUpdate();
					num_exp = exp_offset;
				end
			end
			exp_bar:setPercentage(percent);
			local t_exp = '+' .. num_exp;
			exp_label:setString(t_exp);

			speed = speed + 0.4;
		end

		local function start_update()
			self.layer:scheduleUpdateWithPriorityLua(update_exp, 1);
		end

		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		table.insert(array, cc.CallFunc:create(start_update));
		exp_bar:runAction(cc.Sequence:create(array));

		return delay;
	end,

	show_next = function(self, delay)
		local pos = cc.p(HALF_WIDTH, hfix(100));
		local str = '点击屏幕继续';
		--local label = util.add_labelglow(self.layer, str, nil, 35, pos, util.c4b_white, util.c4b_red, ANCHOR_CENTER_CENTER, 100, cc.size(FULL_WIDTH, hfix(200)), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
		local label = util.add_labelttf(self.layer, str, nil, 35, pos, util.c4b_white, ANCHOR_CENTER_CENTER, 100, cc.size(FULL_WIDTH, hfix(200)), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
		label:setVisible(false);

		local function do_next()
			self.is_done = true;
			if true == layer_card.should_start_next_after_result then
				net_send('ginfo');
				return;
			end
		end

		local action, array;
		array = {};
		table.insert(array, cc.DelayTime:create(delay));
		table.insert(array, cc.Show:create());
		table.insert(array, cc.CallFunc:create(do_next));
		label:runAction(cc.Sequence:create(array));
		
		array = {};
		action = cc.FadeIn:create(1);
		table.insert(array, action);
		action:setReverseAction(action);
		table.insert(array, action);
		action = cc.Sequence:create(array);
		action = cc.RepeatForever:create(action);
		label:runAction(action);
	end,

	show_card = function(self)
		local card = clone_card_by_id(self.cid);
		if nil == card then
			self:show_next(0);
			return;
		end
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local cinfo = object_card:new(self.layer, card, nil, nil, pos, 0, 0);
		local sprite = cinfo:get_front();
		
		local scale = wfix(1);
		if hfix(1) < scale then
			scale = hfix(1);
		end
		local function do_next()
			self.is_done = true;
			self.cid = nil;
			if true == layer_card.should_start_next_after_result then
				net_send('ginfo');
				return;
			end
		end
		scale = scale * 1.2;
		local array, action;
		array = {};
		table.insert(array, cc.ScaleTo:create(1, scale));
		table.insert(array, cc.RotateBy:create(1, 360 * 3));
		action = cc.Spawn:create(array);
		array = {};
		table.insert(array, action);
		table.insert(array, cc.CallFunc:create(do_next));
		action = cc.Sequence:create(array);
		sprite:runAction(action);
	end,

	close = function()
		local self = layer_result;
		local game_type = self.info.game_type;
		local game_result = self.info.result;
		data_handler:cleanup();
		g_euser.side = nil;
		g_euser.room_data = nil;
		if true == g_scene:is_online() then
			if g_scene:is_stage(STAGE_REPLAY) then
				--[[
				cc.Director:getInstance():getScheduler():setTimeScale(1);
				g_scene:map();
				g_scene:add_layer(ZORDER_LAYER_INFO, layer_info:create(g_euser));
				local eid = layer_video.eid or '';
				local cmd = 'lreplay ' .. eid;
				net_send(cmd);
				]]--
				clean_for_replay();
				return;
			end
			if game_type == GAME_CHAPTER then
				if game_result ~= self.TAG_WIN then
					layer_chapter.is_in_last_stage = false;
				end
				if nil ~= layer_hero.mark_cmd then
					g_scene:hero();
					net_send(layer_hero.mark_cmd);
					net_send('sta', true);
					layer_hero.mark_cmd = nil;
					return;
				end
				--print('-- mark 2: ', layer_chapter.is_in_last_stage, game_result);
				g_scene:chapter();
				net_send('sta', true);
				return;
			end
			g_scene:map();
		else
			self:remove();
		end
	end,

	handler = function(event, x, y)
		local self = layer_result;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		if 3 == self.step then
			self:check_box();
		end
		if 5 ~= self.step then
			return;
		end
		if true == self:check_touch_box_card(x, y) then
			return;
		end
		
		--self:close();
	end,
} -- layer_result end

layer_loadres = {
	name = 'layer_loadres',
	layer = nil,
	list = nil,
	callback = nil,
	args = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.callback = nil;
		self.args = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, gui_key, callback, args)
		self:remove();
		
		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_PRELOAD, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 255));
		util.add_labelttf(self.layer, "加载中...", nil, 30, cc.p(FULL_WIDTH, 0), util.c4b_white, ANCHOR_RIGHT_DOWN, 10);

		self.callback = callback;
		self.list = {};
		self:set_list(gui_key, self.list);

		self.layer:scheduleUpdateWithPriorityLua(self.load_res, 1);
			
		return self.layer, self.name;
	end,

	finish = function(self)
		g_scene[self.callback](g_scene, self.args);
	end,

	set_list = function(self, gui_key, list)
		local res_list = gui_get_list(gui_key);
		for k, v in pairs(res_list) do
			if nil ~= v then
				if nil ~= v.filename1 and "0" ~= v.filename1 then
					local path = util.get_path(v.filename1);
					table.insert(list, path);
				end
				if nil ~= v.filename2 and "0" ~= v.filename2 then
					local path = util.get_path(v.filename2);
					table.insert(list, path);
				end
			end
		end
	end,

	load_res = function(dt)
		local self = layer_loadres;
		local list = self.list or {};
		local count = 0;
		local total = #list;
		kdebug("load_res total[%d]", total);
		if 0 == total then
			self.layer:unscheduleUpdate();
			self:finish();
			return;
		end
		local function cb_load(texture)
			count = count + 1;
			if count >= total then
				self:finish();
			end
			return;
		end
		local cache = cc.Director:getInstance():getTextureCache();
		for i = 1, #list do
			local path = list[i];
			cache:addImageAsync(path, cb_load);
		end
		self.layer:unscheduleUpdate();
	end,

	handler = function(event, x, y)
		local self = layer_loadres;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_loadres end

layer_solo = {
	name = 'layer_solo',
	layer = nil,
	tableview = nil,
	list = nil,
	cwidth = nil,
	cheight = nil,
	theight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.theight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_SOLO, self.handler, true);

		self.list = {};
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		local sprite, data;
		local offsetheight = init_bg_for_view(self.layer, GUI_PRACTICE, '练习', self.back);

		data = gui_get_data('cell', GUI_PRACTICE, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		data = gui_get_data('table', GUI_PRACTICE, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		self.theight = size.height;
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	reload = function(self)
		self.tableview:reloadData();
	end,

	add_list = function(self, list)
		self.list = list or {};
		self:reload();
	end,

	challenge = function(...)
		local args = {...};
		local sid = args[2]:getTag();
		local cmd = 'solo ' .. sid;
		net_send(cmd);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_solo;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			--local cell = args[3];
			--local idx = cell:getIdx();
			--local info = self.list[idx + 1];
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell();
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new();
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local info = self.list[idx + 1];
			local icon = info.icon;
			local eid = info.eid;
			local alias = info.alias;
			local level = info.level;
			local gold = info.gold;
			local data2, sprite, path, pos, size, str;

			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'icon', GUI_PRACTICE, ANCHOR_DOWN);
			path = get_icon_path(icon);
			sprite = util.add_sprite(sprite, path,cc.p(0,0),ANCHOR_LEFT_DOWN,-1);
			sprite:setScale(data2.width/sprite:getContentSize().width);

			gui_add_sprite_on_cell(cell,data,'bg_alias',GUI_PRACTICE,ANCHOR_DOWN);
			str = alias;
			gui_add_label_on_cell(cell,data,str,28,'c_alias',GUI_PRACTICE,ANCHOR_DOWN);

			gui_add_sprite_on_cell(cell, data, 'bg_lv', GUI_PRACTICE,ANCHOR_DOWN);

			path = util.get_path('font_lv.fnt');
			str = 'LV.' .. level;
			gui_add_labelbmf_on_cell(cell,data,str,path,'lv',GUI_PRACTICE,ANCHOR_DOWN);

			str = '奖励:';
			gui_add_label_on_cell(cell,data,str,24,'t_reward',GUI_PRACTICE,ANCHOR_DOWN);
			gui_add_sprite_on_cell(cell, data, 'icon_gold', GUI_PRACTICE,ANCHOR_DOWN);
			path = util.get_path(FNT_1);
			str = gold;
			gui_add_labelbmf_on_cell(cell,data,str,path,'num_gold',GUI_PRACTICE,ANCHOR_DOWN);

			local items = {};
			local item;

			item, data2 = gui_add_item_on_cell(items, data, 'btn_play', GUI_PRACTICE, self.challenge, ANCHOR_DOWN);
			item:setTag(eid);
			gui_add_text_on_sprite(item,'挑战','t_play',GUI_PRACTICE,ANCHOR_DOWN,30);

			util.add_menu(cell, items, data2.zorder);
			return cell;
		end
	end, -- tableview_handler end }

	back = function()
		local self = layer_solo;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_solo;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_solo end

layer_stage = {
	name = 'layer_stage',
	layer = nil,
	list_reward = nil,
	list_tool = nil,
	data_cell_reward = nil,
	tv_reward = nil,
	cwidth_reward = nil,
	cheight_reward = nil,
	data_cell_tool = nil,
	tv_tool = nil,
	cwidth_tool = nil,
	cheight_tool = nil,
	chapter_id = nil,
	stage_id = nil,
	star1 = nil,
	star2 = nil,
	star3 = nil,
	btn_go = nil,
	btn_pay = nil,
	need_power = nil,
	dialog = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list_reward = nil;
		self.list_tool = nil;
		self.data_cell_reward = nil;
		self.tv_reward = nil;
		self.cwidth_reward = nil;
		self.cheight_reward = nil;
		self.data_cell_tool = nil;
		self.tv_tool = nil;
		self.cwidth_tool = nil;
		self.cheight_tool = nil;
		self.chapter_id = nil;
		self.stage_id = nil;
		self.star1 = nil;
		self.star2 = nil;
		self.star3 = nil;
		self.btn_go = nil;
		self.btn_pay = nil;
		self.need_power = nil;
		self.dialog = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, sinfo, dialog)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_STAGE, self.handler, true);

		self.list_reward = {};
		self.dialog = {};
		for i = 1, #(dialog or {}) do
			table.insert(self.dialog, dialog[i]);
		end
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));

		local map, title, data;
		map, title = init_chapter_bg_full(self.layer, GUI_STAGE, self.back, "");
		self.map = map;
		str = layer_chapter:get_title_string() or "";
		title:setString(str);
		self.chapter_id = sinfo.chapter_id;
		self.stage_id = sinfo.stage_id;

		local map_data = gui_get_data('map', GUI_STAGE, ANCHOR_DOWN);
		str = string.format("第%d关 %s", sinfo.stage_id, sinfo.stage_name);
		gui_add_label_on_cell(map,map_data,str,28,'name',GUI_STAGE,ANCHOR_DOWN);
		str = sinfo.stage_msg;
		gui_add_stroke_on_cell(map,map_data,str,22,'slogan',GUI_STAGE,ANCHOR_DOWN);
		gui_add_sprite_on_cell(map, map_data, 'bg_desc', GUI_STAGE, ANCHOR_DOWN);
		--self.star1 = gui_add_sprite_on_cell(map, map_data, 'star1', GUI_STAGE,ANCHOR_DOWN);
		--self.star2 = gui_add_sprite_on_cell(map, map_data, 'star2', GUI_STAGE,ANCHOR_DOWN);
		--self.star3 =gui_add_sprite_on_cell(map, map_data, 'star3', GUI_STAGE,ANCHOR_DOWN);
		local s;
		s = gui_add_sprite_on_cell(map, map_data, 'star1', GUI_STAGE,ANCHOR_DOWN);
		util.set_gray(s);
		s = gui_add_sprite_on_cell(map, map_data, 'star2', GUI_STAGE,ANCHOR_DOWN);
		util.set_gray(s);
		s = gui_add_sprite_on_cell(map, map_data, 'star3', GUI_STAGE,ANCHOR_DOWN);
		util.set_gray(s);
		self:set_target_sta(map, map_data);
		gui_add_sprite_on_cell(map, map_data, 'bg_power', GUI_STAGE, ANCHOR_DOWN);
		gui_add_sprite_on_cell(map, map_data, 'bg_reward', GUI_STAGE,ANCHOR_DOWN);
		gui_add_sprite_on_cell(map, map_data, 'tab_power', GUI_STAGE,ANCHOR_DOWN);
		gui_add_sprite_on_cell(map, map_data, 'tab_reward',GUI_STAGE,ANCHOR_DOWN);
		gui_add_sprite_on_cell(map, map_data, 'bg_tool', GUI_STAGE,ANCHOR_DOWN);
		gui_add_sprite_on_cell(map, map_data, 'tab_tool',GUI_STAGE,ANCHOR_DOWN);
		gui_add_sprite_on_cell(map,map_data,'icon_chicken',GUI_STAGE,ANCHOR_DOWN);
		str = sinfo.power .. '';
		self.need_power = sinfo.power;
		gui_add_label_on_cell(map,map_data,str,28,'n_power',GUI_STAGE,ANCHOR_DOWN);

		gui_add_sprite_on_cell(map,map_data,'bg_free',GUI_STAGE,ANCHOR_DOWN);
		str = "0";
		local path = util.get_path(FT_2);
		gui_add_labelbmf_on_cell(map, map_data, str, path, 'n_free', GUI_STAGE, ANCHOR_DOWN);

		for i = 1, 3 do
			local tt = sinfo.list_target[i];
			if nil == tt then break; end
			local key = 'line' .. i;
			str = self:get_target_msg(tt, true);
			gui_add_rlabel_on_cell(map,map_data,str,18,key,GUI_STAGE,ANCHOR_DOWN);
		end

		self.list_reward = sinfo.list_reward or {};
		data = gui_get_data('cell_reward', GUI_STAGE, ANCHOR_DOWN);
		self.data_cell_reward = data;
		self.cwidth_reward = data.width + 10;
		self.cheight_reward = data.height;
		data = gui_get_data('table_reward', GUI_STAGE, ANCHOR_DOWN);
		pos = cc.p(data.x-map_data.x, data.y-map_data.y);
		size = cc.size(data.width, data.height);
		self.tv_reward = util.add_tableview(map, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.reward_tv_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		self.list_tool = sinfo.list_tip or {};
		data = gui_get_data('cell_tool', GUI_STAGE, ANCHOR_DOWN);
		self.data_cell_tool = data;
		self.cwidth_tool = data.width + 10;
		self.cheight_tool = data.height;
		data = gui_get_data('table_tool', GUI_STAGE, ANCHOR_DOWN);
		pos = cc.p(data.x-map_data.x, data.y-map_data.y);
		size = cc.size(data.width, data.height);
		self.tv_tool = util.add_tableview(map, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tool_tv_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		local items = {};
		local item;
		if #self.list_tool > 0 then
			if sinfo.chapter_id == 1 and sinfo.stage_id == 9 then
				item, data = gui_add_item_on_cell(items, map_data, 'btn_charge', GUI_STAGE, self.first_charge, ANCHOR_DOWN);
				self.btn_pay = item;
			else
				item, data = gui_add_item_on_cell(items, map_data, 'btn_rob_3', GUI_STAGE, self.go_buy, ANCHOR_DOWN);
			end
		end
		item, data = gui_add_item_on_cell(items, map_data, 'btn_rob_3', GUI_STAGE, self.rob_3, ANCHOR_DOWN);
		item, data = gui_add_item_on_cell(items, map_data, 'btn_rob', GUI_STAGE, self.rob, ANCHOR_DOWN);
		if 0 < #(self.dialog or {}) then
			item, data = gui_add_item_on_cell(items, map_data, 'btn_dialog', GUI_STAGE, self.show_dialog, ANCHOR_DOWN);
		end
		item, data = gui_add_item_on_cell(items, map_data, 'btn_go', GUI_STAGE, self.go, ANCHOR_DOWN);
		self.btn_go = item;
		util.add_menu(map, items, data.zorder);

		return self.layer, self.name;
	end,

	back = function()
		layer_stage:remove();
	end,

	show_dialog = function()
		local self = layer_stage;
		local l = {};
		for i = 1, #(self.dialog or {}) do
			table.insert(l, self.dialog[i]);
		end
		tutor_show_dialog(l);
	end,

	set_target_sta = function(self, map, map_data)
		local pinfo = layer_chapter:get_select_info().data;
		if nil == pinfo then
			return;
		end
		local flag = pinfo.flag;
		-- 0,1,2,3==finish and star num, 8==not fight 9==lock
		if flag < 1 or flag > 3 then
			return;
		end
		local s, d;
		if flag >= 1 then
			s, d = gui_add_sprite_on_cell(map, map_data, 'star1', GUI_STAGE,ANCHOR_DOWN);
			keff_showup_1(s, 0);
		end
		if flag >= 2 then
			s, d = gui_add_sprite_on_cell(map, map_data, 'star2', GUI_STAGE,ANCHOR_DOWN);
			keff_showup_1(s, 0.15);
		end
		if flag == 3 then
			s, d = gui_add_sprite_on_cell(map, map_data, 'star3', GUI_STAGE,ANCHOR_DOWN);
			keff_showup_1(s, 0.3);
		end
	end,

	get_target_msg = function(self, data, is_rich_label)
		local function get_card_name(cid)
			cid = tonumber(cid);
			if nil == cid then return "[???]"; end
			local rc = g_card_list[cid];
			if nil == rc then
				rc = hero_list[cid];
			end
			if nil == rc then
				return string.format("ID[%d]", cid);
			end
			return string.format("[%s]", rc.name);
		end
		local ttype = data.target_type;
		local p1 = data.p1;
		local p2 = data.p2;
		local value = data.value;
		local p1s = '' .. p1;
		local p2s = '' .. p2;
		local values = '';
		if nil ~= value then
			values = '(' .. value .. ')';
		end
		if true == is_rich_label then
			p1s = string.format("[color=FAA003]%s[/color]", p1s);
			p2s = string.format("[color=FAA003]%s[/color]", p2s);
		end

		local str = "";
		if ttype == CHAPTER_TARGET_MY_HERO_HP then
			if p1 ~= 99 then
				str = string.format("%s <=%s", str, p1s);
			end
			if p2 ~= 99 then
				str = string.format("%s >=%s", str, p2s);
			end
			str = string.format("自己英雄血量%s", str); 
		elseif ttype == CHAPTER_TARGET_ROUND then
			if p1 ~= 99 then
				str = string.format("%s <=%s", str, p1s);
			end
			if p2 ~= 99 then
				str = string.format("%s >=%s", str, p2s);
			end
			str = string.format("回合数%s", str); 
		elseif ttype == CHAPTER_TARGET_WIN then
			str = string.format("获得胜利"); 
		elseif ttype == CHAPTER_TARGET_MY_ALLY then
			if p1 ~= 99 then
				str = string.format("%s <=%s", str, p1s);
			end
			if p2 ~= 99 then
				str = string.format("%s >=%s", str, p2s);
			end
			str = string.format("自己上场盟军数%s", str); 
		elseif ttype == CHAPTER_TARGET_MY_SUPPORT then
			if p1 ~= 99 then
				str = string.format("%s <=%s", str, p1s);
			end
			if p2 ~= 99 then
				str = string.format("%s >=%s", str, p2s);
			end
			str = string.format("自己上场支援牌数量%s", str); 
		elseif ttype == CHAPTER_TARGET_MY_ABILITY then
			if p1 ~= 99 then
				str = string.format("%s <=%s", str, p1s);
			end
			if p2 ~= 99 then
				str = string.format("%s >=%s", str, p2s);
			end
			str = string.format("自己使用技能牌数量%s", str); 
		elseif ttype == CHAPTER_TARGET_MY_CARD then
			local pp = math.floor(p2/10);
			p2s = (p2%10) .. '';
			if pp == 1 then
				str = string.format("%s <=%s", str, p2s);
			elseif pp == 2 then
				str = string.format("%s >=%s", str, p2s);
			else
				str = string.format("%s ==%s", str, p2s);
			end
			str = string.format("自己使用%s的牌%s次", get_card_name(p1), str); 
		elseif ttype == CHAPTER_TARGET_OPPO_ALLY then
			if p1 ~= 99 then
				str = string.format("%s <=%s", str, p1s);
			end
			if p2 ~= 99 then
				str = string.format("%s >=%s", str, p2s);
			end
			str = string.format("结束时敌方在场盟军数量%s", str); 
		elseif ttype == CHAPTER_TARGET_OPPO_SUPPORT then
			if p1 ~= 99 then
				str = string.format("%s <=%s", str, p1s);
			end
			if p2 ~= 99 then
				str = string.format("%s >=%s", str, p2s);
			end
			str = string.format("结束时敌方在场支援牌数量%s", str); 
		elseif ttype == CHAPTER_TARGET_OPPO_ABILITY then
			if p1 ~= 99 then
				str = string.format("%s <=%s", str, p1s);
			end
			if p2 ~= 99 then
				str = string.format("%s >=%s", str, p2s);
			end
			str = string.format("敌方使用技能数量%s", str); 
		elseif ttype == CHAPTER_TARGET_OPPO_CARD then
			local pp = math.floor(p2/10);
			p2s = (p2%10) .. '';
			if pp == 1 then
				str = string.format("%s <=%s", str, p2s);
			elseif pp == 2 then
				str = string.format("%s >=%s", str, p2s);
			else
				str = string.format("%s ==%s", str, p2s);
			end
			str = string.format("敌方使用%s的牌%s次", get_card_name(p1), str); 
		elseif ttype == CHAPTER_TARGET_MY_GRAVE then
			if p1 ~= 99 then
				str = string.format("%s <=%s", str, p1s);
			end
			if p2 ~= 99 then
				str = string.format("%s >=%s", str, p2s);
			end
			str = string.format("胜利后我方的坟墓牌数%s", str); 
		elseif ttype == CHAPTER_TARGET_OPPO_GRAVE then
			if p1 ~= 99 then
				str = string.format("%s <=%s", str, p1s);
			end
			if p2 ~= 99 then
				str = string.format("%s >=%s", str, p2s);
			end
			str = string.format("胜利后敌方的坟墓牌数%s", str); 
		elseif ttype == CHAPTER_TARGET_MY_GRAVE_ALLY then
			if p1 ~= 99 then
				str = string.format("%s <=%s", str, p1s);
			end
			if p2 ~= 99 then
				str = string.format("%s >=%s", str, p2s);
			end
			str = string.format("胜利后我方的坟墓盟军数%s", str); 
		elseif ttype == CHAPTER_TARGET_OPPO_GRAVE_ALLY then
			if p1 ~= 99 then
				str = string.format("%s <=%s", str, p1s);
			end
			if p2 ~= 99 then
				str = string.format("%s >=%s", str, p2s);
			end
			str = string.format("胜利后敌方的坟墓盟军数%s", str); 
		elseif ttype == CHAPTER_TARGET_MY_CARD_GRAVE then
			local pp = math.floor(p2/10);
			p2s = (p2%10) .. '';
			if pp == 1 then
				str = string.format("%s <=%s", str, p2s);
			elseif pp == 2 then
				str = string.format("%s >=%s", str, p2s);
			else
				str = string.format("%s ==%s", str, p2s);
			end
			str = string.format("胜利后我方坟墓有%s的牌%s张", get_card_name(p1), str); 
		elseif ttype == CHAPTER_TARGET_OPPO_CARD_GRAVE then
			local pp = math.floor(p2/10);
			p2s = (p2%10) .. '';
			if pp == 1 then
				str = string.format("%s <=%s", str, p2s);
			elseif pp == 2 then
				str = string.format("%s >=%s", str, p2s);
			else
				str = string.format("%s ==%s", str, p2s);
			end
			str = string.format("胜利后敌方坟墓有%s的牌%s张", get_card_name(p1), str); 
		elseif ttype == CHAPTER_TARGET_MY_HERO then
			local pp = math.floor(p2/10);
			p2s = (p2%10) .. '';
			if pp == 1 then
				str = string.format("%s <=%s", str, p2s);
			elseif pp == 2 then
				str = string.format("%s >=%s", str, p2s);
			else
				str = string.format("%s ==%s", str, p2s);
			end
			str = string.format("我方使用英雄%s", get_card_name(p1)); 
		elseif ttype == CHAPTER_TARGET_OPPO_HERO then
			local pp = math.floor(p2/10);
			p2s = (p2%10) .. '';
			if pp == 1 then
				str = string.format("%s <=%s", str, p2s);
			elseif pp == 2 then
				str = string.format("%s >=%s", str, p2s);
			else
				str = string.format("%s ==%s", str, p2s);
			end
			str = string.format("敌方使用英雄%s", get_card_name(p1)); 
		elseif ttype == CHAPTER_TARGET_OPPO_GRAVE_GRAVE then
			local pp = math.floor(p2/10);
			p2s = (p2%10) .. '';
			if pp == 1 then
				str = string.format("%s <=%s", str, p2s);
			elseif pp == 2 then
				str = string.format("%s >=%s", str, p2s);
			else
				str = string.format("%s ==%s", str, p2s);
			end
			str = string.format("敌方坟墓的%s%s", get_card_name(p1), str); 
		else
			str = string.format("type[%d],p1[%d],p2[%d]", ttype, p1, p2);
		end
		if p1 ~= 99 or p2 ~= 99 then
			str = string.format("%s%s", str, values); 
		end

		return str;
	end,

	first_charge = function()
		go_pay();
	end,

	go_buy = function()
	end,

	rob_3 = function()
	end,

	rob = function()
	end,

	go = function()
		play_tap_1();
		local self = layer_stage;
		if self.need_power > math.floor(g_euser.power) then
			show_err("体力不足");
			return;
		end
		local cid = self.chapter_id;
		local sid = self.stage_id;
		if nil == cid or nil == sid then return; end

		local cmd = string.format("chapter %d %d", cid, sid);
		net_send(cmd);
	end,

	reward_tv_handler = function(...)  -- { start
		local self = layer_stage;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list_reward or {});
		elseif "scrollViewDidScroll" == event then
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.list_reward[idx + 1];
			local rtype = info.reward_type;
			if rtype ~= CHAPTER_REWARD_PIECE and rtype ~= CHAPTER_REWARD_CARD then
				return;
			end
			local rnum = info.reward_num;
			local p = false;
			if rtype == CHAPTER_REWARD_PIECE then
				p = true;
			end
			local rc = g_card_list[rnum];
			if nil == rc then
				rc = hero_list[rnum];
			end
			local c = clone(rc);
			g_scene:add_layer(ZORDER_LAYER_MISPOP, layer_mispop:create(c,p));
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight_reward, self.cwidth_reward;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell();
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new();
			local width = self.cwidth_reward;
			local height = self.cheight_reward;
			local data = self.data_cell_reward;
			local bg = gui_add_cell_bg(cell, data);
			local bgsize = bg:getContentSize();
			local info = self.list_reward[idx + 1];
			local rtype = info.reward_type;
			local rnum = info.reward_num;
			local data2, sprite, path, pos, size, str;
			if rtype == CHAPTER_REWARD_CARD or rtype == CHAPTER_REWARD_PIECE then
				path=util.get_path(string.format("card%d.png", rnum),"card0.png");
			elseif rtype == CHAPTER_REWARD_GOLD then
				path = util.get_path("icon_61.png");
			elseif rtype == CHAPTER_REWARD_CRYSTAL then
				path = util.get_path("icon_62.png");
			elseif rtype == CHAPTER_REWARD_EXP then
				path = util.get_path("icon_64.png");
			elseif rtype == CHAPTER_REWARD_POWER then
				path = util.get_path("icon_63.png");
			else
				return cell;
			end
			pos = cc.p(bgsize.width/2, bgsize.height/2);
			sprite = util.add_sprite(cell, path,pos,ANCHOR_CENTER_CENTER,-2);
			sprite:setScaleX((bgsize.width-2)/sprite:getContentSize().width);
			sprite:setScaleY(bgsize.height/sprite:getContentSize().height);
			if rtype == CHAPTER_REWARD_PIECE then
				path = util.get_path("icon_66.png");
				pos = cc.p(bgsize.width/2, bgsize.height/2);
				sprite = util.add_sprite(cell, path,pos,ANCHOR_CENTER_CENTER,-1);
				sprite:setScaleX((bgsize.width-2)/sprite:getContentSize().width);
				sprite:setScaleY(bgsize.height/sprite:getContentSize().height);
				return cell;
			end
			if rtype == CHAPTER_REWARD_CARD then
				return cell;
			end
			--[[
			path = util.get_path(FT_1);
			str = '' .. rnum;
			pos = cc.p(bgsize.width, 0);
			util.add_labelbmf(cell, str, path, pos, ANCHOR_RIGHT_DOWN, 5);
			]]--
			
			return cell;
		end
	end, -- tableview_handler end }

	tool_tv_handler = function(...)  -- { start
		local self = layer_stage;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list_tool or {});
		elseif "scrollViewDidScroll" == event then
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.list_tool[idx + 1];
			local cid = info.tip_card_id;
			local rc = g_card_list[cid];
			if nil == rc then
				rc = hero_list[cid];
			end
			local c = clone(rc);
			g_scene:add_layer(ZORDER_LAYER_MISPOP, layer_mispop:create(c,p));
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight_tool, self.cwidth_tool;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell();
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new();
			local width = self.cwidth_reward;
			local height = self.cheight_reward;
			local data = self.data_cell_reward;
			local bg = gui_add_cell_bg(cell, data);
			local bgsize = bg:getContentSize();
			local info = self.list_tool[idx + 1];
			local cid = info.tip_card_id;
			local data2, sprite, path, pos, size, str;
			path=util.get_path(string.format("card%d.png", cid),"card0.png");
			pos = cc.p(bgsize.width/2, bgsize.height/2);
			sprite = util.add_sprite(cell, path,pos,ANCHOR_CENTER_CENTER,-2);
			sprite:setScaleX((bgsize.width-2)/sprite:getContentSize().width);
			sprite:setScaleY(bgsize.height/sprite:getContentSize().height);
			
			return cell;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_stage;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_stage end

layer_gate = {
	name = 'layer_gate',
	PAGE_SIZE = 15,
	layer = nil,
	tableview = nil,
	list = nil,
	cwidth = nil,
	cheight = nil,
	theight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.theight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_GATE, self.handler, true);

		self.list = {};
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		local sprite, data, rect;
		local offsetheight, sprite, rect = init_bg_for_view(self.layer, GUI_GATE, '闯关', self.back);

		self:add_tip(rect);

		data = gui_get_data('cell', GUI_GATE, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		data = gui_get_data('table', GUI_GATE, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		self.theight = size.height;
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	reload = function(self)
		self.tableview:reloadData();
	end,

	add_tip = function(self, rect)
		local size = cc.size(rect.x2-rect.x1, FULL_HEIGHT-rect.y2-20);
		if size.height > 150 then size.height = 150; end
		if size.height < 64 then size.height = 64; end
		local path = util.get_path('pop_up.png');
		local frect = cc.rect(0, 0, 64, 64); -- fullrect
		local irect = cc.rect(30, 30, 4, 4); -- insetrect
		local pos = cc.p(HALF_WIDTH, rect.y2+20);
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_DOWN, frect, irect, size, 10); 
		self.phase = bg;
		local str = "1.闯关模式下只要清除敌方所有盟军即可胜利\n2.闯关模式下我方英雄不能受到任何伤害，否则挑战失败"
		local label = util.add_labeloutline(bg, str, nil, 20, cc.p(size.width/2, size.height/2), util.c4b_gold, util.c4b_black, 2, ANCHOR_CENTER_CENTER, 10, cc.size(size.width-40, size.height-30), cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
	end,

	add_list = function(self, list, start_id, total_size, is_full)
		--self.list = list or {};
		--self:reload();
		self.list = self.list or {};
		if 1 == start_id then
			self.list = {};
		end
		local offset = nil;
		if #self.list > 0 then
			offset = self.tableview:getContentOffset();
		end
		list = list or {};
		local more_cell = { flag_more_cell = true };
		if 0 < #self.list then
			local m = self.list[#self.list];
			if true == m.flag_more_cell then
				table.remove(self.list, #self.list);
			end
		end
		for i = 1, #list do
			table.insert(self.list, list[i]);
		end
		if true ~= is_full and self.PAGE_SIZE == #list then
			table.insert(self.list, more_cell);
		end
		self:reload();
		if nil ~= offset then
			offset.y = offset.y - #list * self.cheight;
			self.tableview:setContentOffset(offset);
		end
	end,

	challenge = function(...)
		local self = layer_gate;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		if nil == info then return; end
		local cmd = 'gate ' .. info.gate_id;
		net_send(cmd);
	end,

	get_more = function()
		play_tap_1();
		local self = layer_gate;
		local len = #(self.list or {});
		if self.list[len].flag_more_cell == true then
			len = len - 1;
		end
		if len < 0 then len = 0; end
		local info = self.list[len];
		if nil == info then return; end
		local cmd = string.format("lgate %d %d", info.gate_id-1, self.PAGE_SIZE);
		net_send(cmd);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_gate;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			--local cell = args[3];
			--local idx = cell:getIdx();
			--local info = self.list[idx + 1];
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell();
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new();
			local width = self.cwidth;
			local height = self.cheight;
			local info = self.list[idx+1];
			if true == info.flag_more_cell then
				local items = {};
				local pos = cc.p(width/2, height/2);
				local size = cc.size(172, 52);
				local item = add_item_1(items, '更多', nil, 20, self.get_more, ANCHOR_CENTER_CENTER, pos, size);
				item:setTag(idx + 1);

				util.add_menu(cell, items, 1);
				return cell;
			end
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local icon = info.focus_card;
			local title = info.title;
			local exp = info.exp;
			local gold = info.gold;
			local data2, sprite, path, pos, size, str;

			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'icon', GUI_GATE, ANCHOR_DOWN);
			--path = get_icon_path(icon);
			--sprite = util.add_sprite(sprite, path,cc.p(0,0),ANCHOR_LEFT_DOWN,-1);
			--sprite:setScale(data2.width/sprite:getContentSize().width);
			local fname = string.format("card%d.png", icon);
			path = util.get_path(fname, 'picon_1_0.png');
			sprite = util.add_sprite(sprite, path,cc.p(data2.width/2,data2.height/2),ANCHOR_CENTER_CENTER,-1);
			sprite:setScaleX((data2.width-0)/sprite:getContentSize().width);
			sprite:setScaleY((data2.height-8)/sprite:getContentSize().height);

			gui_add_sprite_on_cell(cell,data,'bg_alias',GUI_GATE,ANCHOR_DOWN);
			str = title;
			gui_add_label_on_cell(cell,data,str,28,'c_alias',GUI_GATE,ANCHOR_DOWN);

			--[[
			gui_add_sprite_on_cell(cell, data, 'bg_lv', GUI_PRACTICE,ANCHOR_DOWN);

			path = util.get_path('font_lv.fnt');
			str = 'LV.' .. level;
			gui_add_labelbmf_on_cell(cell,data,str,path,'lv',GUI_GATE,ANCHOR_DOWN);
			]]--
			str = '经验:';
			gui_add_label_on_cell(cell,data,str,24,'t_exp',GUI_GATE,ANCHOR_DOWN);
			path = util.get_path(FNT_1);
			str = exp;
			gui_add_labelbmf_on_cell(cell,data,str,path,'num_exp',GUI_GATE,ANCHOR_DOWN);

			str = '奖励:';
			gui_add_label_on_cell(cell,data,str,24,'t_reward',GUI_GATE,ANCHOR_DOWN);
			gui_add_sprite_on_cell(cell, data, 'icon_gold', GUI_GATE,ANCHOR_DOWN);
			str = gold;
			gui_add_labelbmf_on_cell(cell,data,str,path,'num_gold',GUI_GATE,ANCHOR_DOWN);

			local items = {};
			local item;

			item, data2 = gui_add_item_on_cell(items, data, 'btn_play', GUI_GATE, self.challenge, ANCHOR_DOWN);
			item:setTag(idx+1);
			gui_add_text_on_sprite(item,'挑战','t_play',GUI_PRACTICE,ANCHOR_DOWN,30);

			util.add_menu(cell, items, data2.zorder);
			return cell;
		end
	end, -- tableview_handler end }

	back = function()
		local self = layer_gate;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_gate;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_gate end

layer_mail = {
	name = 'layer_mail',
	PAGE_SIZE = 10, -- server max page_size is 10
	layer = nil,
	list = nil,
	tableview = nil,
	btn_top = nil,
	rect = nil,
	theight = nil,
	cwidth = nil,
	cheight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,
	read_index = nil,
	do_cell_anim = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.btn_top = nil;
		self.rect = nil;
		self.theight = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
		self.read_index = nil;
		self.do_cell_anim = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_MAIL, self.handler, true);

		self.list = {};
		util.add_layer_color(self.layer, cc.c4b(0, 0, 0, 150));
		local data;
		local offsetheight, sprite, rect = init_bg_pop(self.layer, GUI_MAIL, '信箱', self.back, nil, true);
		self.rect = rect;

		sprite, data = gui_add_sprite(self.layer, 'frame', GUI_MAIL, ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));

		data = gui_get_data('cell', GUI_MAIL, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		data = gui_get_data('table', GUI_MAIL, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		self.theight = size.height;
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		local self = layer_mail;
		self:remove();
	end,

	reload = function(self)
		self.do_cell_anim = true;
		self.tableview:reloadData();
	end,

	add_list = function(self, list, start_pos, total)
		list = list or {};
		local more_cell = { flag_more_cell = true };
		self.list = self.list or {};
		if 0 == start_pos then
			self.list = {};
		end
		if 0 < #self.list then
			local m = self.list[#self.list];
			if true == m.flag_more_cell then
				table.remove(self.list, #self.list);
			end
		end
		for i = 1, #list do
			table.insert(self.list, list[i]);
		end
		if 0 < #list and total > #list and self.PAGE_SIZE == #list then
			table.insert(self.list, more_cell);
		end

		self:reload();
	end,

	get_more = function()
		play_tap_1();
		local self = layer_mail_box;
		local len = #(self.list or {}) - 1;
		if len < 0 then len = 0; end
		local cmd = string.format("list_message %d %d", len, self.PAGE_SIZE);
		net_send(cmd);
	end,

	check = function(...)
		local self = layer_mail;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		if nil == info then return; end
		self.read_index = index;
		local mid = info.message_id;
		local cmd = string.format("read_message %d", mid);
		net_send(cmd);
	end,

	delete_read_cell = function(self)
		if nil == self.layer then return; end
		if nil == self.read_index then return; end
		local toffset = self.tableview:getContentOffset();
		local cnum = math.floor(self.theight / self.cheight);
		if self.read_index < cnum then
			toffset.y = toffset.y + self.cheight;
		end
		table.remove(self.list, self.read_index);
		self.read_index = nil;
		self:reload();
		self.tableview:setContentOffset(toffset);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_mail;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			play_tap_3();
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.list[idx + 1];
			if nil == info.detail then
				local cmd = 'notice ' .. info.t;
				net_send(cmd);
				return;
			end
			local t = info.title or '';
			local d = info.detail or '';
			g_scene:add_layer(ZORDER_LAYER_TEXT, layer_text:create(t, d));
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local info = self.list[idx + 1];
			if true == info.flag_more_cell then
				local items = {};
				local pos = cc.p(width/2, height/2);
				local size = cc.size(172, 52);
				local item = add_item_1(items, '更多', nil, 20, self.get_more, ANCHOR_CENTER_CENTER, pos, size);
				item:setTag(idx + 1);

				util.add_menu(cell, items, 1);
				return cell;
			end
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local str = info.title;
			gui_add_sprite_on_cell(cell,data,'cell_bg_title',GUI_MAIL,ANCHOR_DOWN);
			gui_add_sprite_on_cell(cell,data,'icon',GUI_MAIL, ANCHOR_DOWN);
			gui_add_label_on_cell(cell,data,str,24,'t_title',GUI_MAIL,ANCHOR_DOWN);
			local time = info.time;
			local t = os.date("*t", time);
			str = string.format("%02d月%02d日 %02d:%02d:%02d", t.month, t.day, t.hour, t.min, t.sec);
			gui_add_label_on_cell(cell,data,str,22,'time',GUI_MAIL,ANCHOR_DOWN);

			gui_add_sprite_on_cell(cell,data,'bg_btn',GUI_MAIL, ANCHOR_DOWN);
			local items = {};
			local item;

			item, data2 = gui_add_item_on_cell(items, data, 'btn_check', GUI_MAIL, self.check, ANCHOR_DOWN);
			item:setTag(idx+1);
			--gui_add_text_on_sprite(item,'查看','t_check',GUI_MAIL,ANCHOR_DOWN,30);

			util.add_menu(cell, items, data2.zorder);
			if true == self.do_cell_anim then
				local delay = (idx%10)*0.1;
				keff_show_fromright(cell, delay);
			end
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_mail;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		self.do_cell_anim = false;
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,
} -- layer_mail end

-- deprecated
layer_mail_box = {
	name = 'layer_mail_box',
	PAGE_SIZE = 10, -- server max page_size is 10
	layer = nil,
	tableview = nil,
	list = nil,
	cwidth = nil,
	cheight = nil,
	theight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,
	read_index = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.theight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
		self.read_index = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_MAIL_BOX, self.handler, false);

		self.list = {};
		local sprite, data, pos, size;
		local d1 = gui_get_data('bg_table', GUI_MAIL, ANCHOR_UP);
		local d2 = gui_get_data('bg_table', GUI_MAIL, ANCHOR_DOWN);
		local offsety = d1.y - d2.y;

		local line_data = gui_get_data('line', GUI_MAIL, ANCHOR_DOWN);
		data = gui_get_data('cell', GUI_MAIL, ANCHOR_DOWN);
		self.cwidth = data.width;
		--self.cheight = data.height;
		self.cheight = data.y + data.height - line_data.y;
		self.data_cell = data;

		data = gui_get_data('table', GUI_MAIL, ANCHOR_DOWN);
		size = cc.size(data.width, data.height + offsety);
		self.theight = size.height;
		pos = cc.p(data.x, data.y);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, ccp(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+10);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	reload = function(self)
		self.tableview:reloadData();
	end,

	add_list = function(self, list, start_pos, total)
		list = list or {};
		local more_cell = { flag_more_cell = true };
		self.list = self.list or {};
		if 0 == start_pos then
			self.list = {};
		end
		if 0 < #self.list then
			local m = self.list[#self.list];
			if true == m.flag_more_cell then
				table.remove(self.list, #self.list);
			end
		end
		for i = 1, #list do
			table.insert(self.list, list[i]);
		end
		if 0 < #list and total > #list and self.PAGE_SIZE == #list then
			table.insert(self.list, more_cell);
		end

		self:reload();
	end,

	get_more = function()
		play_tap_1();
		local self = layer_mail_box;
		local len = #(self.list or {}) - 1;
		if len < 0 then len = 0; end
		local cmd = string.format("list_message %d %d", len, self.PAGE_SIZE);
		net_send(cmd);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_mail_box;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell();
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new();
			local width = self.cwidth;
			local height = self.cheight;
			local info = self.list[idx + 1];
			if true == info.flag_more_cell then
				local items = {};
				local pos = cc.p(width/2, height/2);
				local size = cc.size(172, 52);
				local item = add_item_1(items, '更多', nil, 20, self.get_more, ANCHOR_CENTER_CENTER, pos, size);
				item:setTag(idx + 1);

				util.add_menu(cell, items, 1);
				return cell;
			end
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local title = info.title;
			local time = info.time;
			local data2, sprite, path, pos, size, str;

			gui_add_sprite_on_cell(cell,data,'line',GUI_MAIL,ANCHOR_DOWN);
			str = title;
			gui_add_label_on_cell(cell,data,str,28,'c_title',GUI_MAIL,ANCHOR_DOWN);

			local t = os.date("*t", time);
			str = string.format("%02d月%02d日 %02d:%02d:%02d", t.month, t.day, t.hour, t.min, t.sec);
			gui_add_label_on_cell(cell,data,str,22,'c_time',GUI_MAIL,ANCHOR_DOWN);

			local items = {};
			local item;

			item, data2 = gui_add_item_on_cell(items, data, 'btn_check', GUI_MAIL, self.check, ANCHOR_DOWN);
			item:setTag(idx+1);
			gui_add_text_on_sprite(item,'查看','t_check',GUI_MAIL,ANCHOR_DOWN,30);

			util.add_menu(cell, items, data2.zorder);

			return cell;
		end
	end, -- tableview_handler end }

	check = function(...)
		local self = layer_mail_box;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		if nil == info then return; end
		self.read_index = index;
		local mid = info.message_id;
		local cmd = string.format("read_message %d", mid);
		net_send(cmd);
	end,

	delete_read_cell = function(self)
		if nil == self.layer then return; end
		if nil == self.read_index then return; end
		local toffset = self.tableview:getContentOffset();
		local cnum = math.floor(self.theight / self.cheight);
		if self.read_index < cnum then
			toffset.y = toffset.y + self.cheight;
		end
		table.remove(self.list, self.read_index);
		self.read_index = nil;
		self:reload();
		self.tableview:setContentOffset(toffset);
	end,

	back = function()
		local self = layer_mail_box;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_mail_box;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_mail_box end

layer_prank = {
	name = 'layer_prank',
	layer = nil,
	list_toggle = nil,
	ctab = nil,
	sub_layer = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list_toggle = nil;
		self.ctab = nil;
		self.sub_layer = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_PRANK, self.handler, true);

		self.list = {};
		self.list_toggle = {};
		-- btn back set in g_scene.deck
		init_bg_for_full_view(self.layer, GUI_PRANK, '竞技场');

		local sprite, data, pos, size;
		local d1 = gui_get_data('bg_table', GUI_PRANK, ANCHOR_UP);
		local d2 = gui_get_data('bg_table', GUI_PRANK, ANCHOR_DOWN);
		local offsety = d1.y - d2.y;
		gui_add_sprite(self.layer, 'bg_table', GUI_PRANK,ANCHOR_DOWN,nil,offsety);

		local items = {};
		local item;

		local list_tab = { -- tab_id, unselected data index, selected data index
			{ 1, '竞技场' }, { 2, '排行榜' }, 
		};

		for i = 1, #list_tab do
			local info = list_tab[i];
			local key = 'tag' .. i;
			item, data = gui_add_item(items, key, GUI_PRANK, self.cb_toggle, ANCHOR_UP);
			key = 'tag_text' .. i;
			gui_add_text_outline_on_sprite(item, info[2], key, GUI_PRANK, ANCHOR_UP, 30);
			item:setTag(info[1]);
			table.insert(self.list_toggle, item);

		end

		util.add_menu(self.layer, items, data.zorder);

		self:change_tab(1);

		return self.layer, self.name;
	end,

	show_challenge = function(self, list, gold, crystal, remain_time, rank, challenge_time)
		self.sub_layer = layer_prank_c;
		g_scene:add_layer(ZORDER_LAYER_PRANK_C, layer_prank_c:create(list, gold, crystal, remain_time, rank, challenge_time));
	end,

	show_rank = function(self, list, gold, crystal, remain_time, rank, challenge_time)
		self.sub_layer = layer_prank_r;
		g_scene:add_layer(ZORDER_LAYER_PRANK_R, layer_prank_r:create(list, gold, crystal, remain_time, rank, challenge_time));
	end,

	cb_toggle = function(tag, sender)
		play_tap_3();
		local self = layer_prank;
		-- self.toggle_info:getSelectedIndex()  0 : off     1 : on
		--sender = tolua.cast(sender, "cc.MenuItemToggle");
		--print('selected item:tag:%d, index:%d', tag, sender:getSelectedIndex());
		self:change_tab(tag);
	end,

	change_tab = function(self, tab)
		for i = 1, #self.list_toggle do
			local toggle = self.list_toggle[i];
			local tag = toggle:getTag();
			if tag ~= tab then
				toggle:setSelectedIndex(0);
			else
				toggle:setSelectedIndex(1);
			end
		end
		--print('tab: ', tab, self.ctab);
		if tab == self.ctab then
			return;
		end
		self.ctab = tab;
		if nil ~= self.sub_layer then
			self.sub_layer:back();
			self.sub_layer = nil;
		end
		if 1 == self.ctab then
			net_send('rtarlist');
		else
			net_send('rlist');
		end
	end,

	back = function()
		play_tap_1();
		g_scene:map();
	end,

	handler = function(event, x, y)
		local self = layer_prank;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_prank end

layer_pclg = {
	name = 'layer_pclg',
	layer = nil,
	tableview = nil,
	list = nil,
	cwidth = nil,
	cheight = nil,
	theight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,
	trank = nil,
	tleft = nil,
	treward = nil,
	lget = nil,
	ltime = nil,
	rtime = nil,
	systime = nil,
	do_cell_anim = nil,
	buy_time_count = nil,
	buy_time_crystal = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.theight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
		self.trank = nil;
		self.tleft = nil;
		self.treward = nil;
		self.lget = nil;
		self.ltime = nil;
		self.rtime = nil;
		self.systime = nil;
		self.do_cell_anim = nil;
		self.buy_time_count = nil;
		self.buy_time_crystal = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_PCLG, self.handler, false);

		self.systime = os.time();
		local offsetheight = init_prank_bg_full(self.layer, GUI_PCLG, self.back);
		local item, sprite, data, path;

		gui_add_sprite(self.layer, 'bottom_line', GUI_PCLG, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 'bgframe', GUI_PCLG, ANCHOR_UP);
		gui_add_sprite(self.layer, 'trank', GUI_PCLG, ANCHOR_UP);
		gui_add_sprite(self.layer, 'tleft', GUI_PCLG, ANCHOR_UP);
		gui_add_sprite(self.layer, 'treward', GUI_PCLG, ANCHOR_UP);
		path = util.get_path(FT_4);
		self.trank = gui_add_labelbmf(self.layer, "", path, 'nrank', GUI_PCLG, ANCHOR_UP);
		self.tleft = gui_add_labelbmf(self.layer, "", path, 'nleft', GUI_PCLG, ANCHOR_UP);
		self.treward = gui_add_labelbmf(self.layer, "", path, 'nreward', GUI_PCLG, ANCHOR_UP);

		local items = {};

		item, data = gui_add_item(items, 'btn_get', GUI_PCLG,self.get_reward,ANCHOR_UP);
		self.lget = util.add_text_to_sprite(item, "领取", 23, cc.c4b(13, 52, 24, 255));
		self.lget:setVisible(false);
		local size = item:getContentSize();
		path = util.get_path(FT_8);
		self.ltime =util.add_labelbmf(item,"00:00:00",path,cc.p(size.width/2, size.height/2),ANCHOR_CENTER_CENTER, 10);
		self.ltime:setScale(0.5);
		self.ltime:setVisible(false);

		item, data = gui_add_item(items, 'btn_rank', GUI_PCLG,self.go_rank,ANCHOR_UP);
		item, data = gui_add_item(items, 'btn_more', GUI_PCLG,self.add,ANCHOR_UP);
		item, data = gui_add_item(items, 'btn_qa', GUI_PCLG,self.intro,ANCHOR_UP);

		util.add_menu(self.layer, items, data.zorder);

		sprite, data = gui_add_sprite(self.layer, 'table', GUI_PCLG, ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));
		self.list = {};
		data = gui_get_data('cell', GUI_PCLG, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height;
		data = gui_get_data('table', GUI_PCLG, ANCHOR_DOWN);
		pos = cc.p(data.x+wfix(7), data.y+wfix(8));
		size = cc.size(data.width-wfix(14), data.height + offsetheight-wfix(16));
		self.theight = size.height;
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	update_time = function(delta)
		local self = layer_pclg;
		if nil == self.ltime then return; end

		local ntime = os.time();
		local otime = self.systime;
		local t = self.rtime - (ntime - otime);
		if t <= 0 then
			self.ltime:setString('00:00:00');
			self.ltime:setVisible(false);
			self.lget:setVisible(true);
			self.layer:unscheduleUpdate();
			return;
		end
		local sec = t % 60;
		local min = math.floor(t / 60);
		local hour = math.floor(min / 60);
		min = min % 60;
		local str = string.format("%02d:%02d:%02d", hour, min, sec);
		self.ltime:setString(str);
	end,

	reload = function(self)
		self.do_cell_anim = true;
		self.tableview:reloadData();
	end,

	set_info = function(self, info)
		self.buy_time_count = info.buy_times_count;
		self.buy_time_crystal = info.buy_times_crystal;
		local rank = info.rank;
		local gold = info.gold;
		local crystal = info.crystal;
		local has_reward = info.has_reward;
		local ctime = info.arena_time;
		self.rtime = info.remain_time;
		if 0 == has_reward and self.rtime > 0 then
			self.ltime:setVisible(true);
			self.layer:scheduleUpdateWithPriorityLua(self.update_time, 1);
		else
			self.lget:setVisible(true);
		end
		self.ctime = info.arena_time;
		self.trank:setString(rank);
		self.tleft:setString(self.ctime);
		local price, key;
		if crystal > 0 then
			key = 'crystal';
			price = crystal;
		else
			key = 'gold';
			price = gold;
		end
		gui_add_sprite(self.layer, key, GUI_PCLG, ANCHOR_UP);
		self.treward:setString(price);
		self.list = info.list;
		self:reload();
	end,

	intro = function()
		local self = layer_pclg;
	end,

	update_ctime = function(self, times)
		self.ctime = self.ctime + times;
		self.tleft:setString(self.ctime);
	end,

	cb_add = function()
		local self = layer_pclg;
		local bcrystal = self.buy_time_crystal;
		if bcrystal > g_euser.crystal then
			show_err(t_lang("TIP_NOT_ENOUGH_CRYSTAL"));
			return;
		end
		net_send("arenatimes");
	end,

	add = function()
		local self = layer_pclg;
		local bcount = self.buy_time_count;
		local bcrystal = self.buy_time_crystal;
		if nil == bcount or nil == bcrystal then return; end
		local msg = string.format("增加%d次挑战机会需要消耗", bcount);
		g_scene:add_layer(ZORDER_LAYER_MSG, layer_msg:create(msg, self.cb_add,nil, true));
		local bg = layer_msg.bg;
		if nil == bg then return; end
		local size = bg:getContentSize();
		local pos = cc.p(180, 100);
		--local path = util.get_path('icon_69.png');
		local path = util.get_path('icon_70.png');
		util.add_sprite(bg, path, pos, ANCHOR_LEFT_DOWN, 10);
		path = util.get_path(FT_4);
		pos.x = pos.x + 50;
		util.add_labelbmf(bg, bcrystal, path, pos, ANCHOR_LEFT_DOWN, 10);
	end,

	get_reward = function()
		local self = layer_pclg;
		net_send("arenareward");
	end,

	go_rank = function()
		local self = layer_pclg;
		--g_scene:go(GUI_RANK, "rank", { stab = 2 });
		local index = 0;
		for i = 1, #(layer_rank.list_tab or {}) do
			local info = layer_rank.list_tab[i];
			if info[1] == LADDER_ARENA then
				index = i;
				break;
			end
		end
		if 0 == index then return; end
		g_scene:rank({stab=index});
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_pclg;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.list[idx + 1];
			if nil == info then return; end
			local icon = info.icon;
			local eid = info.eid;
			local alias = info.alias;
			local d = { eid = eid, icon = icon,
						alias = alias };
			g_scene:add_layer(ZORDER_LAYER_CHATPOP, layer_chatpop:create(d));
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell();
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new();
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local info = self.list[idx + 1];
			local icon = info.icon;
			local eid = info.eid;
			local alias = info.alias;
			local rating = info.rating;
			local level = info.level;
			local rank = info.rank;
			local data2, sprite, path, pos, size, str;
			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'cicon', GUI_PCLG, ANCHOR_DOWN);
			path = get_icon_path(icon);
			size = sprite:getContentSize();
			sprite = util.add_sprite(sprite, path,cc.p(size.width/2,size.height/2),ANCHOR_CENTER_CENTER,-1);
			sprite:setScale((size.width-10)/sprite:getContentSize().width);

			str = alias;
			gui_add_label_on_cell(cell,data,str,25,'calias',GUI_PCLG,ANCHOR_DOWN);

			gui_add_sprite_on_cell(cell, data, 'ctrank', GUI_PCLG, ANCHOR_DOWN);
			gui_add_sprite_on_cell(cell, data, 'ctrate', GUI_PCLG, ANCHOR_DOWN);
			gui_add_sprite_on_cell(cell, data, 'ctlv', GUI_PCLG, ANCHOR_DOWN);
			local scale = 0.9;
			path = util.get_path(FT_5);
			str = rank;
			sprite = gui_add_labelbmf_on_cell(cell,data,str,path,'cnrank',GUI_PCLG,ANCHOR_DOWN);
			sprite:setScale(scale);
			str = math.floor(rating * 100) .. '%';
			sprite = gui_add_labelbmf_on_cell(cell,data,str,path,'cnrate',GUI_PCLG,ANCHOR_DOWN);
			sprite:setScale(scale);
			path = util.get_path(FT_6);
			str = level;
			sprite = gui_add_labelbmf_on_cell(cell,data,str,path,'cnlv',GUI_PCLG,ANCHOR_DOWN);
			sprite:setScale(scale);

			local items = {};
			local item;

			item, data2 = gui_add_item_on_cell(items, data, 'btn_fight', GUI_PCLG, self.challenge, ANCHOR_DOWN);
			item:setTag(idx+1);

			util.add_menu(cell, items, data2.zorder);

			if true == self.do_cell_anim then
				local delay = (idx%10)*0.1;
				keff_show_fromright(cell, delay);
			end
			return cell;
		end
	end, -- tableview_handler end }

	challenge = function(...)
		local self = layer_pclg;
		local t = self.ctime or 0;
		if 0 >= t then
			show_msg('挑战机会已用完');
			return;
		end
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		if nil == info then return; end
		local eid = info.eid;
		--local rank = info.rank;
		--local cmd = string.format("rgame %d %d", eid, rank);
		local cmd = string.format("arenagame %d", eid);
		net_send(cmd);
	end,

	back = function()
		local self = layer_pclg;
		--g_scene:go(GUI_MAIN, "map");
		g_scene:map();
	end,

	handler = function(event, x, y)
		local self = layer_pclg;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		self.do_cell_anim = false;
	end,
} -- layer_pclg end

layer_prank_r = {
	name = 'layer_prank_r',
	layer = nil,
	tableview = nil,
	list = nil,
	cwidth = nil,
	cheight = nil,
	theight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.theight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, list, gold, crystal, remain_time, rank, challenge_time)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_PRANK_R, self.handler, false);

		self.list = list or {};
		local sprite, data, pos, size;
		local d1 = gui_get_data('bg_table', GUI_PRANK, ANCHOR_UP);
		local d2 = gui_get_data('bg_table', GUI_PRANK, ANCHOR_DOWN);
		local offsety = d1.y - d2.y;

		gui_add_label(self.layer, '当前排名:', 24, 't_rank_2', GUI_PRANK, ANCHOR_UP);

		local path = util.get_path(FNT_1);
		str = rank .. '';
		gui_add_labelbmf(self.layer, str, path, 'n_rank', GUI_PRANK, ANCHOR_UP);

		gui_add_sprite(self.layer, 'line_2', GUI_PRANK, ANCHOR_UP);

		data = gui_get_data('r_cell', GUI_PRANK, ANCHOR_DOWN);
		self.cwidth = data.width;
		self.cheight = data.height;
		self.data_cell = data;

		data = gui_get_data('r_table', GUI_PRANK, ANCHOR_DOWN);
		size = cc.size(data.width, data.height + offsety);
		pos = cc.p(data.x, data.y);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, ccp(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+10);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	reload = function(self)
		self.tableview:reloadData();
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_prank_r;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell();
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new();
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local info = self.list[idx + 1];
			local icon = info.icon;
			local eid = info.eid;
			local alias = info.alias;
			local rating = info.rating;
			local level = info.level;
			local rank = info.rank;
			local data2, sprite, path, pos, size, str;

			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'r_icon', GUI_PRANK, ANCHOR_DOWN);
			path = get_icon_path(icon);
			sprite = util.add_sprite(sprite, path,cc.p(0,0),ANCHOR_LEFT_DOWN,-1);
			sprite:setScaleX(data2.width/sprite:getContentSize().width);
			sprite:setScaleY(data2.height/sprite:getContentSize().height);

			gui_add_sprite_on_cell(cell,data,'r_bg_alias',GUI_PRANK,ANCHOR_DOWN);
			str = alias;
			gui_add_label_on_cell(cell,data,str,28,'r_alias',GUI_PRANK,ANCHOR_DOWN);

			path = util.get_path(FNT_1);

			str = '胜率:';
			gui_add_label_on_cell(cell,data,str,22,'r_t_win',GUI_PRANK,ANCHOR_DOWN);
			str = math.floor(rating * 100) .. '%';
			gui_add_labelbmf_on_cell(cell,data,str,path,'r_n_win',GUI_PRANK,ANCHOR_DOWN);

			gui_add_sprite_on_cell(cell, data, 'r_bg_lv', GUI_PRANK, ANCHOR_DOWN);
			path = util.get_path('font_lv.fnt');
			str = 'LV.' .. level;
			gui_add_labelbmf_on_cell(cell,data,str,path,'r_lv',GUI_PRANK,ANCHOR_DOWN);

			local key;
			if rank < 4 then
				key = 'r_cup' .. rank;
			else
				key = 'r_cup4';
			end
			gui_add_sprite_on_cell(cell, data, key, GUI_PRANK, ANCHOR_DOWN);
			path = util.get_path('rank.fnt');
			str = rank .. '';
			if rank < 4 then
				key = 'r_n_cup';
			else
				key = 'r_n_cup4';
			end
			sprite, data2 = gui_add_labelbmf_on_cell(cell,data,str,path,key,GUI_PRANK,ANCHOR_DOWN);
			sprite:setAnchorPoint(ANCHOR_CENTER_DOWN);
			sprite:setPositionX(data2.x+data2.width/2);

			return cell;
		end
	end, -- tableview_handler end }

	back = function()
		local self = layer_prank_r;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_prank_r;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_prank_r end

layer_prank_tip = {
	name = 'layer_prank_tip',
	layer = nil,
	data = nil,
	TYPE_WAIT = 1,
	TYPE_REPLY = 2,
	count = nil,
	otime = nil,
	tleft = nil,

	cleanup = function(self)
		self.layer = nil;
		self.callback = nil;
		self.data = nil;
		self.count = nil;
		self.otime = nil;
		self.tleft = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, msg, tip_type, data)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_PRANK_TIP, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));

		self.otime = os.time();
		self.tleft = data.time_left;
		local path = util.get_path('pop_up.png');
		local frect = cc.rect(0, 0, 64, 64); -- fullrect
		local irect = cc.rect(30, 30, 4, 4); -- insetrect
		local size = cc.size(wfix(505), hfix(302));--realsize
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, size, 10); 

    	if nil ~= msg then
			pos = cc.p(size.width/2, size.height-50);
			local lsize = cc.size(size.width-40, 70);
			util.add_labeloutline(bg, msg, nil, 25, pos, util.c4b_white, util.c4b_black, 1, ANCHOR_CENTER_UP, 1, lsize, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_TOP);
    	end

		local path = util.get_path(FNT_1);
		self.count = util.add_labelbmf(bg, '10', path, cc.p(size.width/2, size.height-100), ANCHOR_CENTER_UP, 10);
		self.layer:scheduleUpdateWithPriorityLua(self.update_time, 1);

		if tip_type == self.TYPE_WAIT then
			self:init_btn_for_wait(bg, size, data);
			return self.layer, self.name;
		end
		if tip_type == self.TYPE_REPLY then
			self:init_btn_for_reply(bg, size, data);
			return self.layer, self.name;
		end

		local items = {};

		pos = cc.p(size.width/2, 28);
		add_item_1(items, '取消',nil,30,self.remove,ANCHOR_CENTER_DOWN,pos);
		
		util.add_menu(bg, items, 1);

		return self.layer, self.name;
	end,

	update_time = function(delta)
		local self = layer_prank_tip;
		local ntime = os.time();
		local c = self.tleft - (ntime - self.otime);
		local label = self.count;
		if nil == label then
			self.layer:unscheduleUpdate();
			return;
		end
		--local c = tonumber(label:getString());
		if nil == c then
			label:setString(0);
			self.layer:unscheduleUpdate();
			return;
		end
		c = c - 1;
		if c < 0 then
			self.layer:unscheduleUpdate();
			self:remove();
			return;
		end
		label:setString(c);
	end,

	cancel_wait = function()
		local self = layer_prank_tip;
		local data = self.data;
		self:remove();
		local cmd = string.format("rcancel %d", data.eid);
		net_send(cmd);
	end,

	init_btn_for_wait = function(self, bg, size, data)
		self.data = data;
		local items = {};
		local item, p1, p2, pos;

		pos = cc.p(size.width/2, 28);
		add_item_1(items, '取消',nil,30,self.cancel_wait,ANCHOR_CENTER_DOWN,pos);
		
		util.add_menu(bg, items, 1);
	end,

	accept_fight = function()
		local self = layer_prank_tip;
		local data = self.data;
		self:remove();
		local cmd = string.format("rresp %d 1", data.eid);
		net_send(cmd);
	end,

	refuse_fight = function()
		local self = layer_prank_tip;
		local data = self.data;
		self:remove();
		local cmd = string.format("rresp %d 0", data.eid);
		net_send(cmd);
	end,

	init_btn_for_reply = function(self, bg, size, data)
		self.data = data;
		local items = {};

		pos = cc.p(size.width/4*3, 28);
		add_item_1(items, '接受',nil,30,self.accept_fight,ANCHOR_CENTER_DOWN,pos);

		pos = cc.p(size.width/4, 28);
		add_item_1(items, '拒绝',nil,30,self.refuse_fight,ANCHOR_CENTER_DOWN,pos);
		
		util.add_menu(bg, items, 1);
	end,

	handler = function(event, x, y)
		local self = layer_prank_tip;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
	end,

} -- layer_prank_tip end

layer_anim = { -- start
	name = 'layer_anim',
	layer = nil, 

	cleanup = function(self)
		self.layer = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_ANIM, self.handler, false);
		
		return self.layer, self.name;
	end, 

	handler = function(event, x, y)
		local self = layer_anim;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
	end,

} -- layer_anim end

layer_deck = {
	name = 'layer_deck',
	layer = nil,
	list_pick_deck = nil,
	list_pick_slot = {
		{ tag = 1, title = '所有分类', },
		{ tag = 2, title = '附加', },
		{ tag = 3, title = '技能', },
		{ tag = 4, title = '盟军', },
		{ tag = 5, title = '武器', },
		{ tag = 6, title = '防具', },
		{ tag = 7, title = '支援', },
		{ tag = 8, title = '牌库', },
	},
	in_slot_pick = nil,
	total_deck_label = nil,
	total_slot_label = nil,
	type_rest_label = nil,
	label_deck_pick = nil,
	label_slot_pick = nil,
	eb_name = nil,
	deck_sid = nil,
	deck_name = nil,
	has_modify = nil,
	list_hero = nil,
	list_deck = nil,
	list_slot = nil,
	list_slot_total = nil,
	hero_id = nil,
	tableview_deck = nil,
	tableview_slot = nil,
	--cwidth_deck = nil,
	--cheight_deck = nil,
	twidth_deck = nil;
	--cwidth_slot = nil,
	--cheight_slot = nil,
	twidth_slot = nil,
	cscale = nil,
	clarrow_deck = nil,
	crarrow_deck = nil,
	clarrow_slot = nil,
	crarrow_slot = nil,
	touch_card = nil,
	touch_point = nil,
	line_deck = nil,
	line_slot = nil,
	is_touching = nil,
	is_should_quit = nil,
	b_slot_id = nil,
	b_slot_gold = nil,
	b_slot_crystal = nil,
	btn_back = nil, -- set in scene deck init
	data_cell_deck = nil,
	data_cell_rest = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list_pick_deck = nil;
		self.in_slot_pick = nil;
		self.total_deck_label = nil;
		self.total_slot_label = nil;
		self.type_rest_label = nil;
		self.label_deck_pick = nil;
		self.label_slot_pick = nil;
		self.eb_name = nil;
		self.has_modify = false;
		--self.deck_sid = nil; -- no need to reset
		self.deck_name = nil;
		self.list_hero = nil;
		self.list_deck = nil;
		self.list_slot = nil;
		self.list_slot_total = nil;
		self.hero_id = nil;
		self.tableview_deck = nil;
		self.tableview_slot = nil;
		--self.cwidth_deck = nil;
		--self.cheight_deck = nil;
		self.twidth_deck = nil;
		--self.cwidth_slot = nil;
		--self.cheight_slot = nil;
		self.twidth_slot = nil;
		self.cscale = nil;
		self.clarrow_deck = nil;
		self.crarrow_deck = nil;
		self.clarrow_slot = nil;
		self.crarrow_slot = nil;
		self.touch_card = nil;
		self.touch_point = nil;
		self.line_deck = nil;
		self.line_slot = nil;
		self.is_touching = nil;
		self.is_should_quit = nil;
		self.b_slot_id = nil;
		self.b_slot_gold = nil;
		self.b_slot_crystal = nil;
		self.btn_back = nil;
		self.data_cell_deck = nil;
		self.data_cell_rest = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();
		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_DECK, self.handler, true);

		self.is_should_quit = false;
		self.list_pick_deck = {};

		local offsety = init_bg_full(self.layer, GUI_DECK, self.callback_ask_return);
		-- btn back set in g_scene.deck
		--init_bg_for_full_view(self.layer, GUI_DECK, '牌堆');
		local sprite, path, pos, size, data, items, item;
		sprite, data = gui_add_sprite(self.layer, 'bg_deck', GUI_DECK, ANCHOR_UP);
		self.total_deck_label = gui_add_label(self.layer, '上阵卡数:()', 24, 't_deck', GUI_DECK, ANCHOR_UP);

		gui_add_sprite(self.layer, 'bg_rest', GUI_DECK, ANCHOR_UP, -offsety/2);
		self.total_slot_label = gui_add_label(self.layer, '闲置卡牌:()', 24, 't_rest', GUI_DECK, ANCHOR_UP, nil, -offsety/2);
		self.type_rest_label = gui_add_label(self.layer, '', 24, 'type_rest', GUI_DECK, ANCHOR_UP, nil, -offsety/2);

		sprite,data = gui_add_sprite(self.layer,'outframe',GUI_HMISS,ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsety));

		items = {};

		item, data = gui_add_item(items, 'btn_type', GUI_DECK, self.pick_slot, ANCHOR_UP, -offsety/2);

		util.add_menu(self.layer, items, data.zorder);

		data = gui_get_data('cell_deck', GUI_DECK, ANCHOR_UP);
		local nheight = data.height + offsety/2;
		local sh = nheight/data.height;
		data.width = data.width * sh;
		data.height = data.height * sh;
		self.data_cell_deck = data;
		data = gui_get_data('table_deck', GUI_DECK, ANCHOR_UP);
		pos = cc.p(data.x, data.y - offsety/2);
		size = cc.size(data.width, data.height + offsety/2);
		self.twidth_deck = size.width;
		self.line_deck = pos.y;
		self.tableview_deck = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_deck_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		self.clarrow_deck, self.crarrow_deck = util.add_arrows(self.layer, pos, size, self.data_cell_deck.width, 0, cc.p(0, 0));

		data = gui_get_data('cell_rest', GUI_DECK, ANCHOR_UP);
		nheight = data.height + offsety/2;
		sh = nheight/data.height;
		data.width = data.width * sh;
		data.height = data.height * sh;
		self.data_cell_rest = data;
		data = gui_get_data('table_rest', GUI_DECK, ANCHOR_UP);
		pos = cc.p(data.x, data.y - offsety);
		size = cc.size(data.width, data.height + offsety/2);
		self.twidth_slot = size.width;
		self.line_slot = pos.y + size.height;
		self.tableview_slot = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_slot_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		self.clarrow_slot, self.crarrow_slot = util.add_arrows(self.layer, pos, size, self.data_cell_rest.width, 0, cc.p(0, 0));
		--[[
		sprite, data = gui_add_sprite(self.layer, 'bg_slot', GUI_DECK, ANCHOR_UP);
		gui_add_label(self.layer, '上阵卡数:', 24, 't_slot', GUI_DECK, ANCHOR_UP);
		self.total_deck_label = gui_add_label(self.layer, '( )', 24, 'n_slot', GUI_DECK, ANCHOR_UP);

		items = {};
		item, data = gui_add_item(items, 'bg_cslot', GUI_DECK, self.pick_deck_check, ANCHOR_UP);
		util.add_menu(self.layer, items, data.zorder);

		self.label_deck_pick, data = gui_add_label(self.layer, '切换牌堆', 22, 't_cslot', GUI_DECK, ANCHOR_UP);
		self.eb_name = util.add_editbox_blank(self.layer, 
			cc.size(data.width, data.height), ANCHOR_LEFT_DOWN, 
			cc.p(data.x, data.y), util.f_default, 22, util.c_white, 
			cc.EDITBOX_INPUT_MODE_SINGLELINE, cc.KEYBOARD_RETURNTYPE_DONE, 
			nil, self.editbox_handler, 8, '', util.c_gray, data.zorder);
		self.eb_name:setVisible(false);

		local d1 = gui_get_data('bg_other', GUI_DECK, ANCHOR_UP);
		local d2 = gui_get_data('bg_other', GUI_DECK, ANCHOR_DOWN);
		local offsety = d1.y - d2.y;

		gui_add_sprite(self.layer, 'bg_other', GUI_DECK, ANCHOR_UP, -offsety/2);
		gui_add_label(self.layer, '闲置卡牌:', 24, 't_other', GUI_DECK, ANCHOR_UP, nil, -offsety/2);
		self.total_slot_label = gui_add_label(self.layer, '( )', 24, 'n_other', GUI_DECK, ANCHOR_UP, nil, -offsety/2);
		gui_add_sprite(self.layer, 'bg_cother', GUI_DECK, ANCHOR_UP, -offsety/2);
		self.label_slot_pick = gui_add_label(self.layer, '', 22, 't_cother', GUI_DECK, ANCHOR_UP, nil, -offsety/2);

		data = gui_get_data('table_slot', GUI_DECK, ANCHOR_UP);
		pos = cc.p(data.x, data.y - offsety/2);
		size = cc.size(data.width, data.height + offsety/2);
		self.cscale = size.height / CARD_SIZE.height * 0.9;
		self.cwidth_deck = CARD_SIZE.width * self.cscale * 1.3;
		self.cheight_deck = size.height;
		self.twidth_deck = size.width;
		self.line_deck = pos.y;
		self.tableview_deck = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_deck_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		self.clarrow_deck, self.crarrow_deck = util.add_arrows(self.layer, pos, size, self.cwidth_deck, 0, cc.p(0, 0));

		data = gui_get_data('table_other', GUI_DECK, ANCHOR_UP);
		pos = cc.p(data.x, data.y - offsety);
		size = cc.size(data.width, data.height + offsety/2);
		self.cwidth_slot = CARD_SIZE.width * self.cscale * 1.3;
		self.cheight_slot = size.height;
		self.twidth_slot = size.width;
		self.line_slot = pos.y + size.height;
		self.tableview_slot = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_slot_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		self.clarrow_slot, self.crarrow_slot = util.add_arrows(self.layer, pos, size, self.cwidth_slot, 0, cc.p(0, 0));

		items = {};

		item, data = gui_add_item(items, 'more_slot', GUI_DECK, self.pick_deck, ANCHOR_UP);

		item, data = gui_add_item(items, 'more_other', GUI_DECK, self.pick_slot, ANCHOR_UP, -offsety/2);

		item, data = gui_add_item(items, 'btn_save', GUI_DECK, self.callback_save, ANCHOR_DOWN);
		gui_add_text_on_sprite(item, "保存", 't_save', GUI_DECK, ANCHOR_DOWN, 30);

		item, data = gui_add_item(items, 'btn_clear', GUI_DECK, self.callback_clear, ANCHOR_DOWN);
		gui_add_text_on_sprite(item, "清空", 't_clear', GUI_DECK, ANCHOR_DOWN,30);

		item, data = gui_add_item(items, 'btn_chero', GUI_DECK, self.callback_hero, ANCHOR_DOWN);
		gui_add_text_on_sprite(item, "选英雄", 't_chero',GUI_DECK,ANCHOR_DOWN,30);

		util.add_menu(self.layer, items, data.zorder);
		]]--

		--[[

		self.line_deck = 0;
		self.line_slot = 0;

		data = gui_get_data('table_deck', GUI_DECK, ANCHOR_CENTER);
		pos = cc.p(data.x, data.y-tvh/2);
		size = cc.size(data.width, data.height+tvh/2);
		self.cscale = size.height / CARD_SIZE.height * 0.9;
		self.cwidth_deck = CARD_SIZE.width * self.cscale * 1.3;
		self.cheight_deck = size.height;
		self.twidth_deck = size.width;
		self.line_deck = pos.y;
		self.tableview_deck = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_deck_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		self.clarrow_deck, self.crarrow_deck = util.add_arrows(self.layer, pos, size, self.cwidth_deck, 0, cc.p(0, 0));

		data = gui_get_data('table_slot', GUI_DECK, ANCHOR_CENTER);
		pos = cc.p(data.x, data.y-tvh);
		size = cc.size(data.width, data.height+tvh/2);
		self.cwidth_slot = CARD_SIZE.width * self.cscale * 1.3;
		self.cheight_slot = size.height;
		self.twidth_slot = size.width;
		self.line_slot = pos.y + size.height;
		self.tableview_slot = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_slot_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		self.clarrow_slot, self.crarrow_slot = util.add_arrows(self.layer, pos, size, self.cwidth_slot, 0, cc.p(0, 0));
		]]--

		return self.layer, self.name;

	end,

	set_slot_list = function(self, list)
		self.list_pick_deck = {};
		for i = 1, #(list or {}) do
			table.insert(self.list_pick_deck, list[i]);
		end
		local list = self.list_pick_deck;
		local cb = self.callback_pick_deck;
		local layer, name = layer_pick:create(list, cb, 'is_deck');
		g_scene:add_layer(ZORDER_LAYER_PICK, layer, name, true);

		net_send('bslot 0 ' .. (#list + 1));
	end,

	set_buy_slot_btn = function(self, sid, gold, crystal)
		local layer = layer_pick.layer;
		if nil == layer then
			return;
		end
		self.b_slot_id = sid;
		self.b_slot_gold = gold;
		self.b_slot_crystal = crystal;

		local items = {};
		local item, pos, size;

		size = cc.size(172, 52);
		if gold > 0 then
			pos = cc.p(HALF_WIDTH/2, hfix(28));
			item = add_item_1(items, '金币开卡槽', nil, 20, self.buy_slot, ANCHOR_CENTER_DOWN, pos, size);
			item:setTag(1);
		end

		if crystal > 0 then
			pos = cc.p(FULL_WIDTH/4*3, hfix(28));
			item = add_item_1(items, '水晶开卡槽', nil, 20, self.buy_slot, ANCHOR_CENTER_DOWN, pos, size);
			item:setTag(2);
		end

		util.add_menu(layer, items, 1);
	end,

	cb_gold_buy_slot = function(tag)
		tag = tag or 0;
		if 0 == tag then return; end
		local self = layer_deck;
		local gold = self.b_slot_gold;
		if gold > g_euser.gold then
			show_err(t_lang("TIP_NOT_ENOUGH_GOLD"));
			return;
		end
		net_send('bslot 1 ' .. (#(self.list_pick_deck or {}) + 1));
	end,

	cb_crystal_buy_slot = function(tag)
		tag = tag or 0;
		if 0 == tag then return; end
		local self = layer_deck;
		local crystal = self.b_slot_crystal;
		if crystal > g_euser.crystal then
			show_err(t_lang("TIP_NOT_ENOUGH_CRYSTAL"));
			return;
		end
		net_send('bslot 2 ' .. (#(self.list_pick_deck or {}) + 1));
	end,

	buy_slot = function(...)
		local self = layer_deck;
		local sid = self.b_slot_id;
		local gold = self.b_slot_gold;
		local crystal = self.b_slot_crystal;
		local args = {...};
		-- 1 is gold, 2 is crystal
		local flag = args[2]:getTag();
		local money, cb;
		if 1 == flag then -- gold
			money = '金币(' .. gold .. ')';
			cb = self.cb_gold_buy_slot;
		elseif 2 == flag then -- crystal
			money = '水晶(' .. crystal .. ')';
			cb = self.cb_crystal_buy_slot;
		else
			return;
		end
		local tip = string.format("确定要用%s购买第%d个卡槽吗？", money, sid);
		g_scene:add_layer(ZORDER_LAYER_TIP,layer_tip:create(tip, cb));
	end,

	get_deck_str = function(self)
		local mod = string.rep('0', CARD_ARRAY_LIST);
		local len = string.len(mod);
		local list = self.list_deck;
		for i = 1, #list do
			local v = list[i];
			local id = v.card.id;
			local count = '' .. v.count;
			assert(string.len(count) == 1, 'ERROR saveslot count[' .. count .. '] id[' .. id .. ']');
			local t1 = string.sub(mod, 1, id - 1);
			local t2 = string.sub(mod, id + 1, len);
			mod = t1 .. count .. t2;
		end
		return mod;
	end,

	save_to_slot = function(self, sid, sname)
		local mod = self:get_deck_str();
		local cmd = string.format("sdeck %d %s", sid, mod);
		net_send(cmd);
	end,

	callback_save_slot = function(tag)
		tag = tag or 0;
		local self = layer_deck;
		if 1 == tag then
			self:save_to_slot(self.deck_sid, self.deck_name);
		end
	end,

	change_to_slot = function(self, list, sid, name)
		self.deck_sid = sid;
		self.deck_name = name;
		--self.label_deck_pick:setString(name);
		--self.eb_name:setText(name);
		if nil == list then
			-- set title info for selected slot
			return;
		end
		if 0 == #(list or {}) then 
			self.has_modify = true;
			return; 
		end
		self.list_hero = {};
		self.list_deck = {};
		self.list_slot = {};
		self.list_slot_total = {};

		self:set_deck_cards(list, 1, true);

		local deck_str = self:get_deck_str();
		local slot_str = c_get_slot_str(deck_str, g_euser.all_str);
		local slot_array = c_str_array(slot_str);	
		slot_array = self:add_hero_cards(slot_array, true);
		self:init_list_slot(slot_array, 1);
		self.has_modify = true;
	end,
	
	callback_pick_deck = function(index)
		local self = layer_deck;
		net_send('lslot ' .. index);
	end,

	pick_deck = function()
		local self = layer_deck;
		net_send('slotlist');
	end,

	pick_deck_check = function()
		local self = layer_deck;
		if nil == self.deck_sid or -1 == self.deck_sid then
			self.pick_deck();
			return;
		end
		self.label_deck_pick:setVisible(false);
		self.eb_name:setVisible(true);
		self.eb_name:sendActionsForControlEvents(CCControlEventTouchUpInside);
	end,

	set_eb_name = function(self, name)
		self.eb_name:setText(name);
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_deck;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
			local str = edit:getText();
			str = util.space_(str);
			if 0 == string.len(str) then
				str = self.deck_name;
			end
			edit:setText(str);
			edit:setVisible(false);
			self.label_deck_pick:setString(str);
			self.label_deck_pick:setVisible(true);
			if str == self.deck_name then return; end
			self.deck_name = str;
			net_send('rslot ' .. self.deck_sid .. ' ' .. str);
		elseif eventname == "changed" then
		end
	end,

	get_offset_in_slot_list = function(self, card_id)
		local index = 1;
		for i = 1, #self.list_slot do
			local cid = self.list_slot[i].card.id;
			if cid == card_id then
				break;
			elseif cid < card_id then
				index = i+1;
			end
		end
		if index > #self.list_slot then
			return -1;
		end
		return index;
	end,

	syn_slot_list = function(self, new_index)
		new_index = (new_index or self.in_slot_pick) or 1;
		local nlist = {};
		local list = self.list_slot_total;
		local info = self.list_pick_slot[new_index];
		local tag = info.tag;
		if 1 == tag then -- all card fit this hero
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(self.hero_id, card.id);
				if true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		elseif 2 == tag then -- attach
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(self.hero_id, card.id);
				if true == is_fit and ATTACH == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 3 == tag then -- ability
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(self.hero_id, card.id);
				if true == is_fit and ABILITY == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 4 == tag then -- ally
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(self.hero_id, card.id);
				if true == is_fit and ALLY == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 5 == tag then -- weapon
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(self.hero_id, card.id);
				if true == is_fit and WEAPON == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 6 == tag then -- armor
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(self.hero_id, card.id);
				if true == is_fit and ARMOR == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 7 == tag then -- support
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(self.hero_id, card.id);
				if true==is_fit and (SUPPORT==card.ctype or TRAP==card.ctype or ARTIFACT == card.ctype) then
					table.insert(nlist, list[i]);
				end
			end
		elseif 8 == tag then -- total card
			for i = 1, #list do
				table.insert(nlist, list[i]);
			end
		end
		self.list_slot = nlist;
		return self.list_slot;
	end,

	set_slot_name = function(self, new_index)
		return;
	end,

	change_slot = function(self, new_index)
		local titles = self.list_pick_slot or {};
		if 0 == #titles then return; end

		local info = titles[new_index];
		if nil == info then return; end
		self.in_slot_pick = new_index
		local name = info.title;
		--self.label_slot_pick:setString(name);
		self.type_rest_label:setString(name);

		--local list = self.list_slot_total or {};
		--if 0 == #list then return; end

		self:syn_slot_list(new_index);
		self:update_total();
		self.tableview_slot:reloadData();
	end,

	callback_pick_slot = function(index)
		local self = layer_deck;
		self:change_slot(index);
	end,

	pick_slot = function()
		local self = layer_deck;
		local list = self.list_pick_slot or {};
		local cb = self.callback_pick_slot;
		local layer, name = layer_pick:create(list, cb);
		g_scene:add_layer(ZORDER_LAYER_PICK, layer, name, true);
	end,

	set_deck_total = function(self, msg)
		if nil == self.layer or nil == msg then
			return;
		end
		msg = '上阵卡数:(' .. msg .. ')';
		self.total_deck_label:setString(msg);
	end,

	set_slot_total = function(self, msg)
		if nil == self.layer or nil == msg then
			return;
		end
		msg = '闲置卡牌:(' .. msg .. ')';
		self.total_slot_label:setString(msg);
	end,

	callback_return = function(tag)
		tag = tag or 0;
		local self = layer_deck;
		if 1 == tag then
			self.callback_save();
			return;
		end
		--g_scene:go(GUI_PICKDECK, "pickdeck");
		g_scene:pickdeck();
	end,

	callback_ask_return = function()
		play_tap_1();
		if nil ~= layer_book.layer then
			layer_book:remove();
			return;
		end
		local self = layer_deck;
		if true ~= self.has_modify then
			self.callback_return(0);
			return;
		end
		self.is_should_quit = true;
		local str = "是否保存？";
		g_scene:add_layer(ZORDER_LAYER_TIP, layer_tip:create(str, self.callback_return));
	end,

	callback_save = function()
		play_tap_2();
		local self = layer_deck;
		local mod = string.rep('0', CARD_ARRAY_LIST);
		local len = string.len(mod);
		local list = self.list_deck;
		for i = 1, #list do
			local v = list[i];
			local id = v.card.id;
			local count = '' .. v.count;
			assert(string.len(count) == 1, 'ERROR savedeck count[' .. count .. '] id[' .. id .. ']');
			local t1 = string.sub(mod, 1, id - 1);
			local t2 = string.sub(mod, id + 1, len);
			mod = t1 .. count .. t2;
		end
		local sid = self.deck_sid or 0;
		--local cmd = 'sdeck ' .. sid .. ' ' .. mod;
		local cmd = string.format("update_hero_slot %d %d %s", self.hero_id, self.deck_sid, mod);
		net_send(cmd);
	end,

	callback_clear = function()
		play_tap_2();
		local self = layer_deck;
		self:reset_for_pick_hero(self.hero_id);
	end,

	callback_hero = function()
		play_tap_2();
		local self = layer_deck;
		g_scene:add_layer(ZORDER_LAYER_CHERO, layer_chero:create());
		layer_chero:add_to_list(self.list_hero);
	end,

	reset_for_pick_hero = function(self, hero_id)
		--print('DEBUG reset_for_pick_hero: ', hero_id);
		local chero = hero_list[hero_id];
		if nil == chero then
			self.callback_return();
			return;
		end
		chero = clone(chero);
		local count = 1;
		local l = { card = chero, count = count };
		self.list_hero = {};
		self.list_deck = {};
		self.list_slot = {};
		self.list_slot_total = {};
		local deck_array = {};
		table.insert(deck_array, l);
		local slot_array = c_str_array(g_euser.all_str);
		slot_array = self:add_hero_cards(slot_array, true);
		self:init_list_deck(deck_array, 1);
		self:init_list_slot(slot_array, 1);
		self.has_modify = true;
	end,

	tableview_deck_handler = function(...)  -- { start
		local self = layer_deck;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list_deck or {});
		elseif "scrollViewDidScroll" == event then
			local d = self.data_cell_deck;
			util.handle_arrows(self.clarrow_deck, self.crarrow_deck, #self.list_deck, d.width, self.twidth_deck, view:getContentOffset());
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.list_deck[idx + 1];
			g_scene:add_layer(ZORDER_LAYER_DECKPOP, layer_deckpop:create(info,'deck'));
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			local d = self.data_cell_deck;
			return d.height, d.width;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local data = self.data_cell_deck;
			local width = data.width;
			local height = data.height;
			local info = self.list_deck[idx+1];
			local card = clone(info.card);
			local count = info.count;
			local sprite, data2, str, path;
			data2 = gui_get_data('frame_deck', GUI_DECK, ANCHOR_UP);
			pos = cc.p(data2.x-data.x+width/2, data2.y-data.y+height/2);
			local cinfo = object_card:new(cell, card, nil, nil, pos, 0, 1, STYPE_VER_1);
			sprite = cinfo:get_front();
			local s = sprite:getContentSize();
			local ws = (width-30)/s.width;
			local wh = (height-30)/s.height;
			if ws < wh then
				sprite:setScale(ws);
			else
				sprite:setScale(wh);
			end
			sprite:setTag(TAG_CELL_CARD_SPRITE);
			path = util.get_path(FT_8);
			count = '*' .. count;
			util.add_labelbmf(cell, count, path, cc.p(width-10, height/2), ANCHOR_RIGHT_CENTER, 100);

			--[[
			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'frame_deck', GUI_DECK, ANCHOR_DOWN);
			sprite:setTag(TAG_CELL_CARD_SPRITE);
			sprite:setPosition(cc.p(width/2, height/2));
			sprite:setAnchorPoint(ANCHOR_CENTER_CENTER);
			local s = sprite:getContentSize();
			local ws = (width-(data.width-data2.width))/s.width;
			local wh = (height-(data.height-data2.height))/s.height;
			if ws < wh then
				sprite:setScale(ws);
			else
				sprite:setScale(wh);
			end
			local fname = 'card' .. card.id .. '.png';
			path = util.get_path(fname, 'card0.png');
			local mask_path = util.get_path('bg_155.png');
			pos = ccp(s.width/2, s.height/2);
			local pic = util.add_mask_sprite(sprite, path, mask_path, pos, ANCHOR_CENTER_CENTER, -1);
			pic:setScale(s.height/pic:getContentSize().height);

			local l = nil;
			local scale = 0.7;
			local fontpath = util.get_path(FNT_CARD);
			if card.ctype ~= HERO then
				path = util.get_path('icon_54.png');
				pos = ccp(0, s.height);
				l = util.add_sprite(sprite, path, pos, ANCHOR_LEFT_UP);
				l:setScale(scale);
				pos = ccp(25, s.height-28);
				str = card.cost;
				l=util.add_labelbmf(sprite,str,fontpath,pos,ANCHOR_CENTER_CENTER);
				l:setScale(scale);
			end
			if ABILITY == card.ctype or ATTACH == card.ctype 
					or SUPPORT == card.ctype or ARTIFACT == card.ctype
					or TRAP == card.ctype then
				return cell;
			end
			if ARMOR == card.ctype then
				fname = 'icon_59.png';
			elseif HERO == card.ctype then
				fname = 'icon_57.png';
			else
				fname = 'icon_55.png';
			end
			pos = cc.p(0, 0);
			path = util.get_path(fname);
			l = util.add_sprite(sprite, path, pos, ANCHOR_LEFT_DOWN);
			l:setScale(scale);
			if card.ctype == HERO then
				str = card.energy;
			else
				str = card.power;
			end
			if ARMOR == card.ctype then
				pos = ccp(26, 32);
			elseif HERO == card.ctype then
				pos = ccp(26, 32);
			else
				pos = ccp(46, 32);
			end
			l=util.add_labelbmf(sprite,str,fontpath,pos,ANCHOR_CENTER_CENTER);
			l:setScale(scale);
			if ARMOR == card.ctype or WEAPON == card.ctype then
				fname = 'icon_58.png';
			else
				fname = 'icon_56.png';
			end
			path = util.get_path(fname);
			pos = ccp(s.width, 0);
			l = util.add_sprite(sprite, path, pos, ANCHOR_RIGHT_DOWN);
			l:setScale(scale);

			if ARMOR == card.ctype or WEAPON == card.ctype then
				pos = ccp(s.width-26, 32);
			else
				pos = ccp(s.width-26, 32);
			end
			str = card.hp;
			l=util.add_labelbmf(sprite,str,fontpath,pos,ANCHOR_CENTER_CENTER);
			l:setScale(scale);

			local path = util.get_path('font_deck_num.fnt');
			count = '*' .. count;
			util.add_labelbmf(cell, count, path, cc.p(width, height/2), ANCHOR_RIGHT_CENTER, 100);
			]]--
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			-- highlight means touch began
			local info = self.list_deck[idx+1];
			self.touch_card = {};	
			self.touch_card.table_type = 'deck';
			self.touch_card.card = info.card;
			self.touch_card.count = info.count;
			local sprite = cell:getChildByTag(TAG_CELL_CARD_SPRITE);
			self.touch_card.sprite = sprite;
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	tableview_slot_handler = function(...)  -- { start
		local self = layer_deck;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list_slot or {});
		elseif "scrollViewDidScroll" == event then
			local d = self.data_cell_rest;
			util.handle_arrows(self.clarrow_slot, self.crarrow_slot, #self.list_slot, d.width, self.twidth_slot, view:getContentOffset());
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.list_slot[idx + 1];
			g_scene:add_layer(ZORDER_LAYER_DECKPOP, layer_deckpop:create(info,'slot'));
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			local d = self.data_cell_rest;
			return d.height, d.width;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local data = self.data_cell_rest;
			local width = data.width;
			local height = data.height;
			local info = self.list_slot[idx+1];
			local card = clone(info.card);
			local count = info.count;
			local sprite, data2, str, path;
			data2 = gui_get_data('frame_rest', GUI_DECK, ANCHOR_UP);
			pos = cc.p(data2.x-data.x+width/2, data2.y-data.y+height/2);
			local cinfo = object_card:new(cell, card, nil, nil, pos, 0, 1, STYPE_VER_1);
			sprite = cinfo:get_front();
			local s = sprite:getContentSize();
			local ws = (width-30)/s.width;
			local wh = (height-30)/s.height;
			if ws < wh then
				sprite:setScale(ws);
			else
				sprite:setScale(wh);
			end
			sprite:setTag(TAG_CELL_CARD_SPRITE);
			path = util.get_path(FT_8);
			count = '*' .. count;
			util.add_labelbmf(cell, count, path, cc.p(width-10, height/2), ANCHOR_RIGHT_CENTER, 100);
			--[[
			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'frame_rest', GUI_DECK, ANCHOR_DOWN);
			sprite:setTag(TAG_CELL_CARD_SPRITE);
			sprite:setPosition(cc.p(width/2, height/2));
			sprite:setAnchorPoint(ANCHOR_CENTER_CENTER);
			local s = sprite:getContentSize();
			local ws = (width-(data.width-data2.width))/s.width;
			local wh = (height-(data.height-data2.height))/s.height;
			if ws < wh then
				sprite:setScale(ws);
			else
				sprite:setScale(wh);
			end
			local fname = 'card' .. card.id .. '.png';
			path = util.get_path(fname, 'card0.png');
			local mask_path = util.get_path('bg_155.png');
			pos = ccp(s.width/2, s.height/2);
			local pic = util.add_mask_sprite(sprite, path, mask_path, pos, ANCHOR_CENTER_CENTER, -1);
			pic:setScale(s.height/pic:getContentSize().height);

			local l = nil;
			local scale = 0.7;
			local fontpath = util.get_path(FNT_CARD);
			if card.ctype ~= HERO then
				path = util.get_path('icon_54.png');
				pos = ccp(0, s.height);
				l = util.add_sprite(sprite, path, pos, ANCHOR_LEFT_UP);
				l:setScale(scale);
				pos = ccp(25, s.height-28);
				str = card.cost;
				l=util.add_labelbmf(sprite,str,fontpath,pos,ANCHOR_CENTER_CENTER);
				l:setScale(scale);
			end
			if ABILITY == card.ctype or ATTACH == card.ctype 
					or SUPPORT == card.ctype or ARTIFACT == card.ctype
					or TRAP == card.ctype then
				return cell;
			end
			if ARMOR == card.ctype then
				fname = 'icon_59.png';
			elseif HERO == card.ctype then
				fname = 'icon_57.png';
			else
				fname = 'icon_55.png';
			end
			pos = cc.p(0, 0);
			path = util.get_path(fname);
			l = util.add_sprite(sprite, path, pos, ANCHOR_LEFT_DOWN);
			l:setScale(scale);
			if card.ctype == HERO then
				str = card.energy;
			else
				str = card.power;
			end
			if ARMOR == card.ctype then
				pos = ccp(26, 32);
			elseif HERO == card.ctype then
				pos = ccp(26, 32);
			else
				pos = ccp(46, 32);
			end
			l=util.add_labelbmf(sprite,str,fontpath,pos,ANCHOR_CENTER_CENTER);
			l:setScale(scale);
			if ARMOR == card.ctype or WEAPON == card.ctype then
				fname = 'icon_58.png';
			else
				fname = 'icon_56.png';
			end
			path = util.get_path(fname);
			pos = ccp(s.width, 0);
			l = util.add_sprite(sprite, path, pos, ANCHOR_RIGHT_DOWN);
			l:setScale(scale);

			if ARMOR == card.ctype or WEAPON == card.ctype then
				pos = ccp(s.width-26, 32);
			else
				pos = ccp(s.width-26, 32);
			end
			str = card.hp;
			l=util.add_labelbmf(sprite,str,fontpath,pos,ANCHOR_CENTER_CENTER);
			l:setScale(scale);

			local path = util.get_path('font_deck_num.fnt');
			count = '*' .. count;
			util.add_labelbmf(cell, count, path, cc.p(width, height/2), ANCHOR_RIGHT_CENTER, 100);
			]]--
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			-- highlight means touch began
			local info = self.list_slot[idx+1];
			self.touch_card = {};	
			self.touch_card.table_type = 'slot';
			self.touch_card.card = info.card;
			self.touch_card.count = info.count;
			local sprite = cell:getChildByTag(TAG_CELL_CARD_SPRITE);
			self.touch_card.sprite = sprite;
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	update_total = function(self) 
		local total = 0;
		for k, v in ipairs(self.list_deck or {}) do
			total = total + v.count;
		end
		self:set_deck_total(total);

		total = 0;
		for k, v in ipairs(self.list_slot or {}) do
			total = total + v.count;
		end
		self:set_slot_total(total);
	end,

	add_hero_cards = function(self, list, is_remove)
		list = list or {};
		local lhero = self.list_hero or {};
		local lremove = {};
		for i = 1, #list do
			local card = list[i].card;
			local count = list[i].count;
			local ctype = card.ctype;
			if ctype == HERO then
				--print('hero name: ', card.name, card.id);
				local c = clone(card);
				local l = { card = c, count = count };
				table.insert(lhero, l);
				if true == is_remove then
					table.insert(lremove, i);
				end
			end
		end
		for i = #lremove, 1, -1 do
			local index = lremove[i];
			table.remove(list, index);
		end
		self.list_hero = lhero;
		return list;
	end,

	init_list_deck = function(self, list, index)
		for i = 1, #list do
			local cid = list[i].card.id;
			local c = hero_list[i];
			if nil ~= c then
				self.hero_id = cid;
				break;
			end
		end
		self.list_deck = list;
		self:update_total();
		self.tableview_deck:reloadData();
	end,

	init_list_slot = function(self, list, index)
		self.list_slot_total = list;
		self:change_slot(1);
		--[[
		self.list_slot = list;
		self:update_total();
		self.tableview_slot:reloadData();
		]]--
	end,

	-- just call it once at begin
	set_deck_cards = function(self, list, index, not_do_lcard)
		if nil == self.layer then
			return;
		end
		-- just call it once at begin
		list = self:add_hero_cards(list);
		self:init_list_deck(list, index);
		
		if true == not_do_lcard then
			return;
		end
		local cmd = 'lcard ' .. CARD_ARRAY_LIST;
		net_send(cmd);
	end,

	-- first set deck card
	-- then load slot card(lcard), then set slot cards
	set_slot_cards = function(self, list, index)
		if nil == self.layer then
			return;
		end
		-- just call it once at begin
		list = self:add_hero_cards(list, true);
		self:init_list_slot(list, index);
	end,

	move_card = function(self, from_type, to_type, card, count)
		kdebug("from[%s] to[%s] card[%d]", from_type, to_type, card.id);
		local list_from, list_to, tableview_from, tableview_to, cwidth_to;
		if 'deck' == from_type and 'slot' == to_type then
			list_from = self.list_deck;
			--list_to = self.list_slot;
			list_to = self.list_slot_total;
			tableview_from = self.tableview_deck;
			tableview_to = self.tableview_slot;
			cwidth_to = self.data_cell_rest.width;
			--cwidth_to = self.cwidth_slot;
		elseif 'slot' == from_type and 'deck' == to_type then
			--list_from = self.list_slot;
			list_from = self.list_slot_total;
			list_to = self.list_deck;
			tableview_from = self.tableview_slot;
			tableview_to = self.tableview_deck;
			--cwidth_to = self.cwidth_deck;
			cwidth_to = self.data_cell_deck.width;
		else
			return false;
		end
		local card_id = card.id;
		if 'deck' == to_type then
			for i = 1, #list_to do
				local cid = list_to[i].card.id;
				if cid == card_id then
					local c = list_to[i].count;
					if c > 3 then
						show_msg(t_lang("TIP_DECK_MORE_THAN_FOUR"));
						return false;
					end
				end
			end
		end
		for i = 1, #list_from do
			local cid = list_from[i].card.id;
			if cid == card_id then
				local c = list_from[i].count;
				c = c - count;
				list_from[i].count = c;
				if c <= 0 then
					table.remove(list_from, i);
				end
				break;
			end
		end
		local flag = false;
		local index = 1;
		for i = 1, #list_to do
			local cid = list_to[i].card.id;
			if cid == card_id then
				local c = list_to[i].count;
				c = c + count;
				list_to[i].count = c;
				flag = true;
				break;
			elseif cid < card_id then
				index = i+1;
			end
		end
		if false == flag then
			table.insert(list_to, index, { card = clone(card), count = count });
		end
		-- syn list_slot by list_slot_total
		self:syn_slot_list(new_index);
		--
		local offset;
		offset = tableview_from:getContentOffset();
		tableview_from:reloadData();
		tableview_from:setContentOffset(offset, false);
		offset = tableview_to:getContentOffset();
		if 'slot' == to_type then
			index = self:get_offset_in_slot_list(card_id);
		end
		if -1 ~= index then -- -1 means the card donot fit the current slot list
			offset.x = - (index - 1) * cwidth_to;
		end
		tableview_to:reloadData();
		tableview_to:setContentOffset(offset, true);
		self.has_modify = true;
		self:update_total();
		return true;
	end,

	go_change_hero = function(self)
		g_scene:add_layer(ZORDER_LAYER_CHERO, layer_chero:create());
		layer_chero:add_to_list(self.list_hero);
	end,

	handler = function(event, x, y)
		local self = layer_deck;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.callback_ask_return();
		end
	end,

	onTouchBegan = function (self, x, y)
		if true == self.is_touching then
			return;
		end
		self.is_touching = true;
		self.touch_point = { x = x, y = y, sprite = nil };
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		if nil == self.touch_card then
			return;
		end
		local tx = self.touch_point.x;
		local ty = self.touch_point.y;
		if math.abs(y-ty) < hfix(60) then
			return;
		end
		local info = self.touch_card;
		local sprite = info.sprite;
		if nil == sprite then
			return;
		end
		local s = self.touch_point.sprite;
		if nil == s then
			local count = info.count;
			local card = clone(info.card);
			local pos = cc.p(tx, ty);
			local scale = sprite:getScale();
			local h = sprite:getContentSize().height;
			local cinfo = object_card:new(self.layer, card, nil, nil, pos, 0, scale, STYPE_VER_1);
			s = cinfo:get_front();
			--s:setScale(h/s:getContentSize().height);
			self.layer:reorderChild(s, ZORDER_CARD + 100);
			self.touch_point.sprite = s;
			if 1 == count then
				sprite:setVisible(false);
			end
		end
		s:setPosition(x, y);
	end,
	
	onTouchEnded = function(self, x, y)
		self.is_touching = false;
		--kdebug("layer_deck touch_end");
		local touch_point = self.touch_point;
		local touch_card = self.touch_card;
		self.touch_card = nil;	
		self.touch_point = nil;
		local s = touch_point.sprite;
		if nil == s then
			return;
		end
		--s:setPosition(tx, ty);
		s:removeFromParentAndCleanup(true);
		local tx = touch_point.x;
		local ty = touch_point.y;
		local from_type = touch_card.table_type;
		local card = touch_card.card;
		local is_fit = fit_hero_id(self.hero_id, card.id);
		local ret = false;
		if 'slot' == from_type and false == is_fit then
			show_msg(t_lang("TIP_DECK_NOT_FIT_HERO"));
		elseif 'deck' == from_type and y < self.line_slot then
			if card.ctype == HERO then
				self:go_change_hero();
			else
				ret = self:move_card(from_type, 'slot', card, 1);
			end
		elseif 'slot' == from_type and y > self.line_deck then
			ret = self:move_card(from_type, 'deck', card, 1);
		end
		if false == ret then
			if 1 == touch_card.count then
				local sprite = touch_card.sprite;
				sprite:setVisible(true);
			end
		end
	end,
} -- layer_deck end 

-- choose hero is deck
layer_chero = { -- start    
	name = 'layer_chero',
	mark_index = nil, --will set in touch_end,remove in return,use in add_to_list
	layer = nil,
	list = nil,
	touch_x = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.touch_x = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_CHERO, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 158));

		local bgsize = cc.size(FULL_WIDTH-30, FULL_HEIGHT-140);
		init_bg_for_popview(self.layer, '选择英雄', bgsize, self.callback_return);

		local items = {};
		local item;

		item = gui_add_item(items,'arrow_left',GUI_ROLE,self.callback_left,ANCHOR_DOWN);
		item:setPositionY(HALF_HEIGHT);

		item = gui_add_item(items, 'arrow_right', GUI_ROLE, self.callback_right, ANCHOR_DOWN);
		item:setPositionY(HALF_HEIGHT);

		local pos = cc.p(HALF_WIDTH, hfix(100));
		local size = cc.size(172, 52);
		add_item_1(items, '选择', nil, 25, self.callback_select, ANCHOR_CENTER_DOWN, pos, size);

		util.add_menu(self.layer, items, 30);

		return self.layer, self.name;

	end,

	callback_return = function()
		play_tap_1();
		local self = layer_chero;
		self.mark_index = nil;
		self:remove();
	end,

	callback_left = function()
		play_tap_1();
		local self = layer_chero;
		local index = self.hindex;
		if index == 1 then
			return;
		end
		self.hindex = index - 1;
		self:refresh_heros(self.hindex);
	end,

	callback_right = function()
		play_tap_1();
		local self = layer_chero;
		local index = self.hindex;
		if index == #(self.list or {}) then
			return;
		end
		self.hindex = index + 1;
		self:refresh_heros(self.hindex);
	end,

	callback_select = function()
		play_tap_1();
		local self = layer_chero;
		if 0 == #self.list then
			return;
		end
		local index = self.hindex;
		local info = self.list[index];
		local card = info.card;
		--print('index: ', index, card.id, card.name);
		self:remove();
		layer_deck:reset_for_pick_hero(card.id);
	end,

	refresh_heros = function(self, index)
		local scale_center = self.list.scale_center;
		local scale_side = self.list.scale_side;
		local lzorder = self.list.zorder;
		local lpos = ccp(self.list.x, self.list.y);
		local gapx = self.list.gapx;
		local gapy = self.list.gapy;
		for i = 1, #self.list do
			local info = self.list[i];
			local sprite = info.sprite;	
			sprite:stopAllActions();
			if math.abs(i-index) > 1 then
				sprite:setVisible(false);
			else
				sprite:setVisible(true);
			end
			local offset = i - index;
			local pos = ccp(lpos.x + gapx*offset, lpos.y + gapy*math.abs(offset));
			local zorder;
			if i ~= index then
				zorder = self.list.zorder_side;
			else
				zorder = self.list.zorder_center;
			end
			self.layer:reorderChild(sprite, zorder);
			
			local action;
			local array = {};
			action = cc.MoveTo:create(0.2, pos);
			table.insert(array, action);
			if i ~= index then
				action = cc.ScaleTo:create(0.2, scale_side);
				table.insert(array, action);
				action = cc.FadeTo:create(0.2, 200);
				table.insert(array, action);
			else
				action = cc.ScaleTo:create(0.2, scale_center);
				table.insert(array, action);
				action = cc.FadeTo:create(0.2, 255);
				table.insert(array, action);
			end
			sprite:runAction(cc.Spawn:create(array));
		end
	end,

	init_list = function(self)
		if 0 == #self.list then
			return;
		end
		local data = gui_get_data('area_center', GUI_ROLE, ANCHOR_DOWN);
		local data2 = gui_get_data('area_right', GUI_ROLE, ANCHOR_DOWN);
		local data3 = gui_get_data('area_center', GUI_ROLE, ANCHOR_UP);
		local data4 = gui_get_data('area_right', GUI_ROLE, ANCHOR_UP);
		local height_center = data3.y+data3.height-data.y;
		local height_side = data4.y+data4.height-data2.y;
		self.list.x = data.x+data.width/2;
		self.list.y = data.y+height_center/2;
		self.list.gapx = data2.x+data2.width/2-self.list.x;
		self.list.gapy = data2.y+height_side/2-self.list.y;
		self.list.y = HALF_HEIGHT; -- move card area to center of the screen
		local pos = cc.p(self.list.x, self.list.y);
		self.list.zorder_center = data.zorder;
		self.list.zorder_side = data2.zorder;
		self.hindex = 1;
		local index = 1;
		local card = nil;
		for i = 1, #self.list do
			local _card = self.list[i].card;
			if nil ~= _card then
				local offset = index - self.hindex;
				local cpos = ccp(pos.x+self.list.gapx*offset, pos.y+self.list.gapy*math.abs(offset));
				local info = object_card:new(self.layer, _card, nil, nil, cpos, 0, 1);
				local sprite = info:get_front();
				self.list[i].sprite = sprite;
				if math.abs(i-self.hindex) > 1 then
					sprite:setVisible(false);
				end
				local zorder;
				if index ~= self.hindex then
					zorder = self.list.zorder_side;
					if nil == self.list.scale_side then
						local w = data2.width/sprite:getContentSize().width;
						local h = height_side/sprite:getContentSize().height;
						local s = w;
						if h < w then
							s = h;
						end
						self.list.scale_side = s;
					end
					sprite:setScale(self.list.scale_side);
				else
					zorder = self.list.zorder_center;
					if nil == self.list.scale_center then
						local w = data.width/sprite:getContentSize().width;
						local h = height_center/sprite:getContentSize().height;
						local s = w;
						if h < w then
							s = h;
						end
						self.list.scale_center = hfix(s);
					end
					sprite:setScale(self.list.scale_center);
					card = _card;
				end
				self.layer:reorderChild(sprite, zorder);
				index = index + 1;
			end
		end
	end,

	clone_list = function(self, list)
		list = list or {};
		local nlist = {};
		for i = 1, #list do
			local card = list[i].card;
			local count = list[i].count;
			local c = clone(card);
			local l = { card = c, count = count };
			table.insert(nlist, l);
		end
		return nlist;
	end,

	add_to_list = function(self, list)
		self.list = self:clone_list(list);
		if nil ~= self.mark_index and self.mark_index > #list then
			self.mark_index = nil;
		end
		self:init_list();
	end,

	handler = function(event, x, y)
		local self = layer_chero;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		self.touch_x = x;
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
	end,
	
	onTouchEnded = function(self, x, y)
		if nil == self.touch_x then
			return;
		end
		local ox = self.touch_x;
		self.touch_x = nil;
		local offset = x - ox;
		local gap = wfix(30);
		if offset > gap then
			self.callback_left();
		elseif offset < -gap then
			self.callback_right();
		end
	end,

} -- layer_chero end

layer_deckpop = { -- start
	name = 'layer_deckpop',
	layer = nil, 
	info = nil,

	cleanup = function(self)
		self.layer = nil;
		self.info = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, info, table_type)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_DECKPOP, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));

		self.info = info;
		local card = clone(self.info.card);
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT - hfix(50));
		local cwidth = FULL_WIDTH - wfix(70);
		local cheight = FULL_HEIGHT - hfix(340);
		local scale = get_card_scale(cwidth, cheight, CARD_SIZE);
		local cinfo = object_card:new(self.layer, card, nil, nil, pos, 0, scale, STYPE_VER_1);
		local sprite = cinfo:get_front();

		pos.y = HALF_HEIGHT;
		local farray = {};
		local action;
		table.insert(farray, cc.CallFunc:create(disable_touch));
		action = cc.EaseIn:create(cc.MoveTo:create(0.2, pos), 0.2);
		table.insert(farray, action);
		table.insert(farray, cc.CallFunc:create(enable_touch));

		action = cc.Sequence:create(farray);
		sprite:runAction( cc.Sequence:create(farray));

		local cb, item, name;
		if card.ctype == HERO then
			cb = self.to_hero;
			name = '切换英雄';
		elseif 'deck' == table_type then
			cb = self.to_slot;
			name = '移出牌堆';
		else --if 'slot' == table_type then
			cb = self.to_deck;
			name = '移到牌堆';
		end
		local items = {};
		pos = cc.p(HALF_WIDTH, hfix(100));
		local size = cc.size(172, 52);
		add_item_1(items, name, nil, 28, cb, ANCHOR_CENTER_DOWN, pos, size);

		util.add_menu(self.layer, items, 1);
		
		return self.layer, self.name;
	end, 

	to_hero = function()
		play_tap_1();
		local self = layer_deckpop;
		self:remove();
		layer_deck:go_change_hero();
	end,

	to_deck = function()
		play_tap_1();
		local self = layer_deckpop;
		local info = self.info;
		layer_deck:move_card('slot', 'deck', info.card, 1);
		self:remove();
	end,

	to_slot = function()
		play_tap_1();
		local self = layer_deckpop;
		local info = self.info;
		layer_deck:move_card('deck', 'slot', info.card, 1);
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_deckpop;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
		self:remove();
	end,

} -- layer_deckpop end

layer_register = { -- start
	name = 'layer_register',
	layer = nil,
	username = '';
	password = '';
	password2 = '';

	cleanup = function(self)
		self.layer = nil;
		self.username = '';
		self.password = '';
		self.password2 = '';
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_REGISTER, self.handler, true);

		local data, pos, sprite, size;
		sprite,data = gui_add_sprite(self.layer, 'bg', GUI_LOGIN);
		if data.width/data.rwidth > data.height/data.rheight then
			sprite:setScale(data.width/data.rwidth);
		else
			sprite:setScale(data.height/data.rheight);
		end
		sprite,data = gui_add_sprite(self.layer,'building',GUI_LOGIN,ANCHOR_DOWN);
		sprite,data = gui_add_sprite(self.layer, 'logo', GUI_LOGIN, ANCHOR_UP);
		local bg, bdata = gui_add_sprite(self.layer, 'frame',GUI_LOGIN,ANCHOR_UP);
		local y = HALF_HEIGHT - wfix(44);
		bg:setPositionY(y);
		y = y+bdata.height/2+wfix(44);
		if (y+data.height+wfix(5)) > FULL_HEIGHT then
			y = FULL_HEIGHT-data.height-wfix(5);
		end
		sprite:setPositionY(y);
		bg:setAnchorPoint(ANCHOR_LEFT_CENTER);
		sprite = gui_add_stroke_ali_on_cell(bg, bdata,'注册',30,'title',GUI_LOGIN, ANCHOR_UP, cc.TEXT_ALIGNMENT_CENTER);

		str = t_lang("USERNAME");
		gui_add_stroke_on_cell(bg,bdata,str,30,'t_uname',GUI_LOGIN, ANCHOR_UP);
		gui_add_sprite_on_cell(bg,bdata, 'bg_uname', GUI_LOGIN, ANCHOR_UP);

		str = t_lang("PASSWORD");
		gui_add_stroke_on_cell(bg,bdata,str,30,'t_pw',GUI_LOGIN, ANCHOR_UP);
		gui_add_sprite_on_cell(bg,bdata, 'bg_pw', GUI_LOGIN, ANCHOR_UP);

		str = t_lang("PASSWORD");
		gui_add_stroke_on_cell(bg,bdata,str,30,'t_pw2',GUI_LOGIN, ANCHOR_UP);
		gui_add_sprite_on_cell(bg,bdata, 'bg_pw2', GUI_LOGIN, ANCHOR_UP);

		local color;
		data = gui_get_data_on_cell(bdata, 'uname', GUI_LOGIN, ANCHOR_UP);
		color = cc.c3b(data.r, data.g, data.b);
		-- editbox username
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height);
		self.username = util.add_editbox_blank(bg, size, 
			ANCHOR_LEFT_DOWN, pos, util.f_default, 20, color, 
			cc.EDITBOX_INPUT_MODE_SINGLELINE, cc.KEYBOARD_RETURNTYPE_DONE, 
			nil, self.editbox_handler, 30, t_lang("REG_TIP_REGNAME"),util.c_gray, 
			data.zorder);

		data = gui_get_data_on_cell(bdata, 'pw', GUI_LOGIN, ANCHOR_UP);
		color = cc.c3b(data.r, data.g, data.b);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height);
		self.password = util.add_editbox_blank(bg, size, ANCHOR_LEFT_DOWN,
			pos, util.f_default, 20,color,cc.EDITBOX_INPUT_MODE_SINGLELINE,
			cc.KEYBOARD_RETURNTYPE_DONE, cc.EDITBOX_INPUT_FLAG_PASSWORD, 
			self.editbox_handler,30,t_lang("REG_TIP_PW"),util.c_gray,data.zorder);

		data = gui_get_data_on_cell(bdata, 'pw2', GUI_LOGIN, ANCHOR_UP);
		color = cc.c3b(data.r, data.g, data.b);
		pos = cc.p(data.x, data.y+data.height/2);
		size = cc.size(data.width, data.height);
		self.password2 = util.add_editbox_blank(bg, size,ANCHOR_LEFT_CENTER,
			pos, util.f_default, 20,color,cc.EDITBOX_INPUT_MODE_SINGLELINE,
			cc.KEYBOARD_RETURNTYPE_DONE, cc.EDITBOX_INPUT_FLAG_PASSWORD, 
			self.editbox_handler,30,t_lang("REG_TIP_PW2"),util.c_gray,
			data.zorder);

		local items = {};
		local item;

		item,data = gui_add_item_on_cell(items,bdata,'back',GUI_LOGIN,self.close,ANCHOR_UP);
		gui_add_text_on_sprite(item, "返回", 't_back', GUI_LOGIN, ANCHOR_UP, 30);
		
		item,data = gui_add_item_on_cell(items,bdata,'reg',GUI_LOGIN,self.callback_register,ANCHOR_UP);
		gui_add_text_on_sprite(item, "注册", 't_reg', GUI_LOGIN, ANCHOR_UP, 30);

		util.add_menu(bg, items, data.zorder);

		return self.layer, self.name;

	end,

	wolf_effect = function(self, data, sprite)
		local action, array;
		array = {};
		action = CCMoveBy:create(5, ccp(0, -hfix(13)));
		table.insert(array, action);
		action = action:reverse();
		table.insert(array, action);
		action = CCSequence:create(array);
		action = CCRepeatForever:create(action);
		sprite:runAction(action);

		local fullpath = util.get_fullpath(F_PARTICLE, 'wolf_smoke.plist');
		util.add_particle(self.layer, fullpath, ccp(HALF_WIDTH, hfix(60)), data.zorder+2);
	end,

	editbox_handler = function(eventname, psender)
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
		elseif eventname == "changed" then
		end

	end,

	close = function()
		play_tap_1();
		local self = layer_register;
		self:remove();
	end,

	callback_register = function()
		play_tap_1();
		local self = layer_register;
		--print('DEBUG callback_register');
		-- self.toggle_info:getSelectedIndex()  0 : off     1 : on
		local username = self.username:getText();
		local password = self.password:getText();
		local password2 = self.password2:getText();
		if nil == username or '' == string.gsub(username, "^%s*(.-)%s*$", "%1") then
			show_msg('ERROR 用户名格式不符');
			return;
		end
		if nil == password or '' == string.gsub(password, "^%s*(.-)%s*$", "%1") then
			show_msg('ERROR 密码格式不符');
			return;
		end
		if password ~= password2 then
			show_msg('ERROR 密码不一致');
			return;
		end
		local ret;
		ret = g_scene:connect_to_net();
		if ret <= 0 then
			return;
		end
		g_euser.username = username;
		util.save_rms('username', username, 'string');
		util.save_rms('password', password, 'string');
		net_cmd_reg(username, password);
	end,
	
	handler = function(event, x, y)
		local self = layer_register;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)

	end,

} -- layer_register end

layer_role = { -- start
	name = 'layer_role',
	layer = nil,
	list_toggle = nil,
	sex = SEX_MALE,
	list = nil,
	hindex = 0,
	alias = nil,
	validate_alias = false,
	touch_x = nil,
	list_alias = nil,
	arrow_left = nil,
	arrow_right = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list_toggle = nil;
		self.sex = SEX_MALE;
		self.list = nil;
		self.hindex = 0;
		self.alias = nil;
		self.validate_alias = false;
		self.touch_x = nil;
		self.list_alias = nil;
		self.arrow_left = nil;
		self.arrow_right = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_ROLE, self.handler, true);

		self.list_toggle = {};
		self.list_hero = {};
		self.validate_alias = false;
		local sprite, data, str;
		sprite,data = gui_add_sprite(self.layer, 'bg', GUI_ROLE);
		if data.width/data.rwidth > data.height/data.rheight then
			sprite:setScale(data.width/data.rwidth);
		else
			sprite:setScale(data.height/data.rheight);
		end
		gui_add_sprite(self.layer, 'bg_title', GUI_ROLE, ANCHOR_UP);
		gui_add_sprite(self.layer, 'title', GUI_ROLE, ANCHOR_UP);
		gui_add_sprite(self.layer, 'stone', GUI_ROLE, ANCHOR_DOWN);
		local bg, bdata = gui_add_sprite(self.layer, 'frame', GUI_ROLE, ANCHOR_DOWN);
		str = "名称";
		gui_add_stroke_on_cell(bg,bdata,str,30,'t_name',GUI_ROLE, ANCHOR_DOWN);
		gui_add_sprite_on_cell(bg, bdata, 'bg_name', GUI_ROLE, ANCHOR_DOWN);

		str = '支持1~8个字符';
		gui_add_label_on_cell(bg, bdata, str, 25,'tip_name',GUI_ROLE,ANCHOR_DOWN);
		str = g_euser.alias or ( '_' .. g_euser.username );
		local first = string.sub(str, 1, 1);
		if '_' == first and 1 < string.len(str) then
			str = string.sub(str, 2);
		end
		local color;
		data = gui_get_data_on_cell(bdata, 'name', GUI_ROLE, ANCHOR_DOWN);
		color = cc.c3b(data.r, data.g, data.b);
		pos = ccp(data.x, data.y);
		size = cc.size(data.width, data.height);
		self.alias = util.add_editbox_blank(bg, size, 
			ANCHOR_LEFT_DOWN, pos, util.f_default, 22, color, 
			cc.EDITBOX_INPUT_MODE_SINGLELINE, cc.KEYBOARD_RETURNTYPE_DONE, 
			nil, self.editbox_handler, 30, t_lang("LOG_TIP_UNAME"), util.c_gray, 
			data.zorder);
		if true ~= self.callback_dice() then
			self.alias:setText(str);
		end

		gui_add_stroke_on_cell(bg,bdata,'性别',30,'t_sex',GUI_ROLE, ANCHOR_DOWN);
		gui_add_sprite_on_cell(bg, bdata, 'male', GUI_ROLE, ANCHOR_DOWN);
		gui_add_sprite_on_cell(bg, bdata, 'female', GUI_ROLE, ANCHOR_DOWN);

		local items = {};
		local item;

		-- self.toggle_info:getSelectedIndex()  0 : off     1 : on
		item, data = gui_add_item_on_cell(items, bdata, 'toggle_male', GUI_ROLE, self.cb_toggle, ANCHOR_DOWN);
		item:setTag(SEX_MALE);
		table.insert(self.list_toggle, item);
		item:setSelectedIndex(1);
		self.sex = SEX_MALE;

		item, data = gui_add_item_on_cell(items, bdata, 'toggle_female', GUI_ROLE, self.cb_toggle, ANCHOR_DOWN);
		item:setTag(SEX_FEMALE);
		table.insert(self.list_toggle, item);

		item, data = gui_add_item_on_cell(items, bdata, 'dice', GUI_ROLE, self.callback_dice, ANCHOR_DOWN);

		util.add_menu(bg, items, data.zorder);

		items = {};

		self.arrow_left = gui_add_item(items,'arrow_left',GUI_ROLE,self.callback_left,ANCHOR_UP);

		self.arrow_right = gui_add_item(items, 'arrow_right', GUI_ROLE, self.callback_right, ANCHOR_UP);


		item,data = gui_add_item(items,'btn_next',GUI_ROLE,self.callback_next,ANCHOR_DOWN);
		gui_add_text_on_sprite(item, "确认", 't_next', GUI_ROLE, ANCHOR_DOWN, 30);

		util.add_menu(self.layer, items, data.zorder);

		return self.layer, self.name;

	end,

	init_list = function(self, list)
		list = list or {};
		if #list < 2 then
			self.arrow_left:setVisible(false);
			self.arrow_right:setVisible(false);
		end
		self.list = {};
		if 0 == #list then
			return;
		end
		local data = gui_get_data('area_center', GUI_ROLE, ANCHOR_DOWN);
		local data2 = gui_get_data('area_right', GUI_ROLE, ANCHOR_DOWN);
		local data3 = gui_get_data('area_center', GUI_ROLE, ANCHOR_UP);
		local data4 = gui_get_data('area_right', GUI_ROLE, ANCHOR_UP);
		local height_center = data3.y+data3.height-data.y;
		local height_side = data4.y+data4.height-data2.y;
		self.list.x = data.x+data.width/2;
		self.list.y = data.y+height_center/2;
		local pos = cc.p(self.list.x, self.list.y);
		self.list.gapx = data2.x+data2.width/2-pos.x;
		self.list.gapy = data2.y+height_side/2-pos.y;
		self.list.zorder_center = data.zorder;
		self.list.zorder_side = data2.zorder;
		self.hindex = 1;
		local index = 1;
		local card = nil;
		for i = 1, #list do
			local ocard = hero_list[list[i]];
			if nil ~= ocard then
				local _card = clone(ocard);
				local offset = index - self.hindex;
				local cpos = ccp(pos.x+self.list.gapx*offset, pos.y+self.list.gapy*math.abs(offset));
				local info = object_card:new(self.layer, _card, nil, nil, cpos, 0, 1);
				local sprite = info:get_front();
				local l = { card = _card, sprite = sprite };
				table.insert(self.list, l);
				if math.abs(i-self.hindex) > 1 then
					sprite:setVisible(false);
				end
				local zorder;
				if index ~= self.hindex then
					zorder = self.list.zorder_side;
					if nil == self.list.scale_side then
						local w = data2.width/sprite:getContentSize().width;
						local h = height_side/sprite:getContentSize().height;
						local s = w;
						if h < w then
							s = h;
						end
						self.list.scale_side = s;
					end
					sprite:setScale(self.list.scale_side);
				else
					zorder = self.list.zorder_center;
					if nil == self.list.scale_center then
						local w = data.width/sprite:getContentSize().width;
						local h = height_center/sprite:getContentSize().height;
						local s = w;
						if h < w then
							s = h;
						end
						self.list.scale_center = hfix(s);
					end
					sprite:setScale(self.list.scale_center);
					card = _card;
				end
				self.layer:reorderChild(sprite, zorder);
				index = index + 1;
			end
		end
	end,

	refresh_heros = function(self, index)
		local scale_center = self.list.scale_center;
		local scale_side = self.list.scale_side;
		local lzorder = self.list.zorder;
		local lpos = ccp(self.list.x, self.list.y);
		local gapx = self.list.gapx;
		local gapy = self.list.gapy;
		for i = 1, #self.list do
			local info = self.list[i];
			local sprite = info.sprite;	
			sprite:stopAllActions();
			if math.abs(i-index) > 1 then
				sprite:setVisible(false);
			else
				sprite:setVisible(true);
			end
			local offset = i - index;
			local pos = ccp(lpos.x + gapx*offset, lpos.y + gapy*math.abs(offset));
			local zorder;
			if i ~= index then
				zorder = self.list.zorder_side;
			else
				zorder = self.list.zorder_center;
			end
			self.layer:reorderChild(sprite, zorder);
			
			local action;
			local array = {};
			action = cc.MoveTo:create(0.2, pos);
			table.insert(array, action);
			if i ~= index then
				action = cc.ScaleTo:create(0.2, scale_side);
				table.insert(array, action);
				action = cc.FadeTo:create(0.2, 200);
				table.insert(array, action);
			else
				action = cc.ScaleTo:create(0.2, scale_center);
				table.insert(array, action);
				action = cc.FadeTo:create(0.2, 255);
				table.insert(array, action);
			end
			sprite:runAction(cc.Spawn:create(array));
		end
	end,

	cb_toggle = function(tag, sender)
		play_tap_3();
		local self = layer_role;
		sender = tolua.cast(sender, "cc.MenuItemToggle");
		--print('selected item:tag:%d, index:%d', tag, sender:getSelectedIndex());
		self.sex = tag;
		for i = 1, #self.list_toggle do
			local toggle = self.list_toggle[i];
			local tag = toggle:getTag();
			if tag ~= self.sex then
				toggle:setSelectedIndex(0);
			else
				toggle:setSelectedIndex(1);
			end
		end
	end,

	is_legal = function(self, str)
		-- trim white space
		if 0 == string.len(str) then
			show_msg('名称不能空');
			return false;
		end

		local sp, ep;

		sp, ep = string.find(str, ' ');
		if nil ~= sp then 
			show_msg('名称不能含有 空格 ');
			return false;
		end

		sp, ep = string.find(str, '@');
		if nil ~= sp then 
			show_msg('名称不能含有 @ ');
			return false; 
		end

		return true;
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_role;
		local edit = tolua.cast(psender, "cc.EditBox");
		--local str;
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
			local str = edit:getText();
			if true ~= self:is_legal(str) then
				edit:setText('');
			end
		elseif eventname == "changed" then
			local str = edit:getText();
			local len = string.len(str);
			if len > 0 then
				local char = string.sub(str, 1, 1);	
				if '_' == char then
					edit:setText(string.sub(str, 2, len));
				end
			end
		end

	end,

	callback_left = function()
		play_tap_2();
		local self = layer_role;
		local index = self.hindex;
		if index == 1 then
			return;
		end
		self.hindex = index - 1;
		self:refresh_heros(self.hindex);
	end,
	
	callback_right = function()
		play_tap_2();
		local self = layer_role;
		local index = self.hindex;
		if index == #(self.list or {}) then
			return;
		end
		self.hindex = index + 1;
		self:refresh_heros(self.hindex);
	end,

	get_new_alias = function(self, alias)
		self.alias:setText(alias);
	end,

	callback_dice = function()
		play_tap_2();
		local self = layer_role;
		--[[
		if nil == self.list_alias then
			math.randomseed(os.time());
			local lp, lb, lg = load_alias_data();
			self.list_alias = { lp = lp, lb = lb, lg = lg };
		end
		local lp, ln;
		lp = self.list_alias.lp;
		if self.sex == SEX_MALE then
			ln = self.list_alias.lb;
		else
			ln = self.list_alias.lg;
		end
		if 0 == #(lp or {}) and 0 == #(ln or {}) then return false; end
		local index1 = math.random(1, #lp);
		local index2 = math.random(1, #ln);
		local n1 = lp[index1] or '';
		local n2 = ln[index2] or '';
		local alias = n1 .. n2;
		self.alias:setText(alias);
		]]--
		net_send(string.format("ralias %d", self.sex));
		return true;
	end,

	set_alias = function(self, alias)
		if nil == alias or '' == string.gsub(alias, "^%s*(.-)%s*$", "%1") then
			alias = alias or '';
			show_err('这个名字不太好，改个名字吧 [' .. alias .. ']');
			return false;
		end
		if util.check_has_sensitive_data(alias) then
			show_err('这个名字很敏感，改个名字吧 [' .. alias .. ']');
			return false;
		end
		if true ~= self:is_legal(alias) then
			return false;
		end
		local char = string.sub(alias, 1, 1);	
		local cmd = 'alias ' .. alias;
		net_send(cmd);
	end,

	pick_level = function(self)
		local card = self.list[self.hindex].card;
		--g_scene:add_layer(ZORDER_LAYER_GRADE, layer_grade:create(card.id));
		local hero_id = card.id or 0;
		local grade = 1;
		local cmd = 'job ' .. hero_id .. ' ' .. grade;
		net_send(cmd);
	end,
	
	callback_next = function()
		play_tap_1();
		local self = layer_role;
		local hid = self.list[self.hindex].card.id;
		local alias = self.alias:getText();
		self.sex = self.sex or SEX_MALE;
		local cmd = string.format("sprofile %s %d %s", hid, self.sex, '');  
		net_send(cmd);
		self:set_alias(alias);
	end,
	
	handler = function(event, x, y)
		local self = layer_role;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		self.touch_x = x;
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
		if nil == self.touch_x then
			return;
		end
		local ox = self.touch_x;
		self.touch_x = nil;
		local offset = x - ox;
		local gap = wfix(30);
		if offset > gap then
			self.callback_left();
		elseif offset < -gap then
			self.callback_right();
		end
	end,

} -- layer_role end

layer_grade = { -- start
	name = 'layer_grade',
	layer = nil,
	hero_id = nil,
	list_toggle = nil,
	list_grade = { 1, 2, 3 },
	grade = 0,

	cleanup = function(self)
		self.layer = nil;
		self.hero_id = nil;
		self.list_toggle = nil;
		self.grade = 0;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, hero_id)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_GRADE, self.handler, true);

		self.hero_id = hero_id;
		self.list_toggle = {};
		local sprite, fullpath, pos, data, scale, size;
		data = gui_get_data('g_bg', GUI_ROLE);
		pos = ccp(HALF_WIDTH, HALF_HEIGHT);
		fullpath = util.get_fullpath(F_IMAGE, data.fname1);
		sprite = util.add_sprite(self.layer, fullpath, pos, ANCHOR_CENTER_CENTER, data.zorder);
		if data.width / data.owidth > data.height / data.oheight then
			sprite:setScale(data.width / data.owidth);
		else
			sprite:setScale(data.height / data.oheight);
		end

		sprite = gui_add_sprite(self.layer, 'g_title', GUI_ROLE, ANCHOR_DOWN);
		sprite = gui_add_sprite(self.layer, 'g_bg_confirm', GUI_ROLE,ANCHOR_DOWN);

		local items = {};
		local item;

		-- self.toggle_info:getSelectedIndex()  0 : off     1 : on
		item, data = gui_add_item(items, 'g_toggle_1', GUI_ROLE, self.callback_switch_grade, ANCHOR_DOWN);
		item:setTag(self.list_grade[1]);
		table.insert(self.list_toggle, item);
		item:setSelectedIndex(1);
		self.grade = 1;

		item, data = gui_add_item(items, 'g_toggle_2', GUI_ROLE, self.callback_switch_grade, ANCHOR_DOWN);
		item:setTag(self.list_grade[2]);
		table.insert(self.list_toggle, item);

		item, data = gui_add_item(items, 'g_toggle_3', GUI_ROLE, self.callback_switch_grade, ANCHOR_DOWN);
		item:setTag(self.list_grade[3]);
		table.insert(self.list_toggle, item);

		item, data = gui_add_item(items, 'confirm', GUI_ROLE, self.callback_next, ANCHOR_DOWN);

		util.add_menu(self.layer, items, data.zorder);

		return self.layer, self.name;
	end,

	callback_switch_grade = function(tag, sender)
		play_tap_3();
		-- self.toggle_info:getSelectedIndex()  0 : off     1 : on
		--print('DEBUG callback_switch_grade tag: ', tag);
		local self = layer_grade;
		local toggle = tolua.cast(sender, "cc.MenuItemToggle");
		self.grade = tag;
		for i = 1, #self.list_toggle do
			local toggle = self.list_toggle[i];
			local tag = toggle:getTag();
			if tag ~= self.grade then
				toggle:setSelectedIndex(0);
			else
				toggle:setSelectedIndex(1);
			end
		end
	end,
	
	callback_next = function()
		play_tap_1();
		local self = layer_grade;
		local hero_id = self.hero_id or 0;
		local grade = self.grade or 1;
		local cmd = 'job ' .. hero_id .. ' ' .. grade;
		--print('DEBUG hero select cmd: ', cmd);
		net_send(cmd);
	end,
	
	handler = function(event, x, y)
		local self = layer_grade;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)

	end,

} -- layer_grade end

layer_info = {
	name = 'layer_info',
	layer = nil,
	user = nil,
	editbox = nil,
	icon_sprite = nil,
	icon_rect = nil,
	edit_rect = nil,
	gx_label = nil,
	bak_user = nil,
	data_cell = nil,

	cleanup = function(self, user)
		self.layer = nil;
		self.user = nil;
		self.editbox = nil;
		self.icon_sprite = nil;
		self.icon_rect = nil;
		self.edit_rect = nil;
		self.gx_label = nil;
		self.data_cell = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, user)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_INFO, self.handler, true);

		self.user = user;
		self.bak_user = self.user;

		local sprite, data, path, pos, size, str, items, item;
		local offsetheight = init_bg_full(self.layer, GUI_PLAYERINFO, self.back);
		sprite,data = gui_add_sprite(self.layer,'outframe',GUI_PLAYERINFO,ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));
		sprite,data = gui_add_sprite(self.layer,'bg_stone',GUI_PLAYERINFO,ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));
		gui_add_sprite(self.layer,'bg_player',GUI_PLAYERINFO,ANCHOR_UP);

		sprite, data = gui_add_sprite(self.layer, 'icon', GUI_PLAYERINFO, ANCHOR_UP);
		size = sprite:getContentSize();
		pos = cc.p(size.width/2, size.height/2);
		path = get_icon_path(user.icon);
		sprite = util.add_sprite(sprite, path, pos, ANCHOR_CENTER_CENTER, -1);
		sprite:setScaleX((size.width-8)/sprite:getContentSize().width);
		sprite:setScaleY((size.height-4)/sprite:getContentSize().height);
		if user.eid == g_euser.eid then
			self.icon_rect = { x1 = data.x, x2 = data.x + data.width,
							   y1 = data.y, y2 = data.y + data.height };
			self.icon_sprite = sprite;
		end

		str = user.alias or '';
		gui_add_label(self.layer,str,23,'alias',GUI_PLAYERINFO,ANCHOR_UP);

		if user.sex == SEX_FEMALE then
			gui_add_sprite(self.layer, 'female', GUI_PLAYERINFO, ANCHOR_UP);
		else
			gui_add_sprite(self.layer, 'male', GUI_PLAYERINFO, ANCHOR_UP);
		end

		gui_add_sprite(self.layer, 't_lv', GUI_PLAYERINFO, ANCHOR_UP);
		path = util.get_path(FT_6);
		str = user.level;
		gui_add_labelbmf(self.layer,str,path,'n_lv',GUI_PLAYERINFO,ANCHOR_UP);

		--local icon_vip = gui_add_sprite(self.layer, 'icon_vip', GUI_PLAYERINFO,ANCHOR_UP);
		--local tips_vip = '月卡时间: ';
		if is_vip_member(user) then
			gui_add_sprite(self.layer, 'vip1', GUI_PLAYERINFO,ANCHOR_UP);
			local end_time = os.date("*t", user.monthly_end_date);
			str = string.format("%d年%d月%d日到期"
			, end_time.year, end_time.month, end_time.day);
			gui_add_label(self.layer,str,20,'t_vip1',GUI_PLAYERINFO,ANCHOR_UP);
		else
			gui_add_sprite(self.layer, 'vip2', GUI_PLAYERINFO,ANCHOR_UP);
			str = "未开通";
			gui_add_label(self.layer,str,20,'t_vip2',GUI_PLAYERINFO,ANCHOR_UP);
			if g_euser.eid == user.eid then
			items = {};
			item, data = gui_add_item(items,'btn_vip2', GUI_PLAYERINFO, go_pay, ANCHOR_UP);
			util.add_menu(self.layer, items, data.zorder);
			end
		end

		path = util.get_path(FT_1);

		if nil ~= user.collection then
			gui_add_sprite(self.layer, 't_cardnum', GUI_PLAYERINFO, ANCHOR_UP);
			str = user.collection .. ' / ' .. '400';
			gui_add_labelbmf(self.layer,str,path,'n_cardnum',GUI_PLAYERINFO,ANCHOR_UP);
		end

		gui_add_sprite(self.layer, 't_exp', GUI_PLAYERINFO, ANCHOR_UP);
		local exp_total = user.exp_next;
		local exp = user.exp;
		if exp < 0 then exp = 0; end
		str = exp .. ' / ' .. exp_total;
		gui_add_labelbmf(self.layer,str,path,'n_exp',GUI_PLAYERINFO,ANCHOR_UP);

		gui_add_sprite(self.layer, 'bg_btn', GUI_PLAYERINFO, ANCHOR_UP);
		items = {};
		item, data = gui_add_item(items,'btn_replay', GUI_PLAYERINFO, self.video, ANCHOR_UP);
		util.add_menu(self.layer, items, data.zorder);

		gui_add_sprite(self.layer, 'bg_sign', GUI_PLAYERINFO, ANCHOR_UP);
		str = "个性签名";
		gui_add_label(self.layer, str,26,'title_sign',GUI_PLAYERINFO,ANCHOR_UP);
		str = get_signature(self.user.signature);
		self.gx_label, data = gui_add_label_ali(self.layer, str, 26, 'sign', GUI_PLAYERINFO, ANCHOR_UP, cc.TEXT_ALIGNMENT_CENTER);
		self.gx_label:setAlignment(cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
		if user.eid == g_euser.eid then
			self.edit_rect = { x1= data.x, x2 = data.x + data.width,
							   y1= data.y, y2 = data.y + data.height }; 
			local color = cc.c3b(data.r, data.g, data.b);
			pos = cc.p(data.x, data.y);
			size = cc.size(data.width, data.height);
			self.editbox = util.add_editbox_blank(self.layer, size,
				ANCHOR_LEFT_DOWN, pos, util.f_default, 25, color, 
				cc.EDITBOX_INPUT_MODE_SINGLELINE, cc.KEYBOARD_RETURNTYPE_DONE, 
				nil, self.editbox_handler, 100, '', color, data.zorder+10); 
			self.editbox:setText(str);
			self.editbox:setVisible(false);
		end

		data = gui_get_data('bg_detail', GUI_PLAYERINFO, ANCHOR_DOWN);
		self.data_cell = data;
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height+offsetheight);
		util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		--[[


		local d1 = gui_get_data('bg_sign', GUI_PLAYERINFO, ANCHOR_UP);
		local d2 = gui_get_data('bg_sign', GUI_PLAYERINFO, ANCHOR_DOWN);
		local d3 = gui_get_data('bg_detail', GUI_PLAYERINFO, ANCHOR_UP);
		local d4 = gui_get_data('bg_detail', GUI_PLAYERINFO, ANCHOR_DOWN);
		local h1 = d1.y + d1.height - d3.y;
		local h2 = d1.y + d1.height - d4.y;
		local h3 = math.floor((h2 - h1)/2);

		gui_add_sprite(self.layer, 'bg_sign', GUI_PLAYERINFO,ANCHOR_UP, -h3, h3);
		gui_add_sprite(self.layer, 'bg_title_sign', GUI_PLAYERINFO,ANCHOR_UP);
		gui_add_label(self.layer,'个性签名',30,'title_sign',GUI_PLAYERINFO,ANCHOR_UP);
		data = gui_get_data('sign', GUI_PLAYERINFO, ANCHOR_UP);
		str = get_signature(user.signature);
		pos = cc.p(data.x, data.y-h3);
		size = cc.size(data.width, data.height+h3);	
		local color = cc.c4b(data.r, data.g, data.b, 255);
		self.gx_label = util.add_labelttf(self.layer, str, nil, 25, pos, color, ANCHOR_LEFT_DOWN, data.zorder, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_TOP); 
		if user.eid == g_euser.eid then
			self.edit_rect = { x1= pos.x, x2 = pos.x + size.width,
							   y1= pos.y, y2 = pos.y + size.height }; 
			pos = cc.p(data.x, data.y-h3);
			local rs = cc.size(data.width, data.height+h3);
			self.editbox = util.add_editbox_blank(self.layer, rs,
				ANCHOR_LEFT_DOWN, pos, util.f_default, 25, color, 
				cc.EDITBOX_INPUT_MODE_SINGLELINE, cc.KEYBOARD_RETURNTYPE_DONE, 
				nil, self.editbox_handler, 100, '', color, data.zorder+10); 
			self.editbox:setText(str);
			self.editbox:setVisible(false);
		end

		gui_add_sprite(self.layer, 'bg_detail',GUI_PLAYERINFO,ANCHOR_UP,-h3*2,h3);
		gui_add_sprite(self.layer, 'bg_title_detail', GUI_PLAYERINFO,ANCHOR_UP,-h3);
		gui_add_label(self.layer,'详细资料',30,'title_detail',GUI_PLAYERINFO,ANCHOR_UP,nil,-h3);

		gui_add_label(self.layer,'ID:',22,'id',GUI_PLAYERINFO,ANCHOR_UP,nil,-h3);
		gui_add_label(self.layer,'积分:',22,'rate',GUI_PLAYERINFO,ANCHOR_UP,nil,-h3);
		gui_add_label(self.layer,'胜率:',22,'winper',GUI_PLAYERINFO,ANCHOR_UP,nil,-h3);
		gui_add_label(self.layer,'公会:',22,'guild',GUI_PLAYERINFO,ANCHOR_UP,nil,-h3);
		gui_add_label(self.layer,'对战场次:',22,'match',GUI_PLAYERINFO,ANCHOR_UP,nil,-h3);
		gui_add_label(self.layer,'胜利场次:',22,'win',GUI_PLAYERINFO,ANCHOR_UP,nil,-h3);

		str = user.eid;
		gui_add_label_ali(self.layer, str, 22, 'id_num', GUI_PLAYERINFO, ANCHOR_UP, cc.TEXT_ALIGNMENT_RIGHT, nil, -h3);
		str = math.floor(user.rating);
		gui_add_label_ali(self.layer, str, 22, 'rate_num', GUI_PLAYERINFO, ANCHOR_UP, cc.TEXT_ALIGNMENT_RIGHT, nil, -h3);
		local percent_win = 0;
		if user.game_count > 0 then
			percent_win = user.win / user.game_count * 100;
		end
		percent_win = string.format("%.2f%%", percent_win);
		str = percent_win;
		gui_add_label_ali(self.layer, str, 22, 'winper_num', GUI_PLAYERINFO, ANCHOR_UP, cc.TEXT_ALIGNMENT_RIGHT, nil, -h3);
		if user.gpos > GUILD_POS_NONE and user.gpos ~= GUILD_POS_APPLY then
			str = get_guild_name(user.gname);
		else
			str = t_lang("NO_GUILD");
		end
		gui_add_label_ali(self.layer, str, 22, 'guild_name', GUI_PLAYERINFO, ANCHOR_UP, cc.TEXT_ALIGNMENT_RIGHT, nil, -h3);
		str = user.game_count;
		gui_add_label_ali(self.layer, str, 22, 'match_num', GUI_PLAYERINFO, ANCHOR_UP, cc.TEXT_ALIGNMENT_RIGHT, nil, -h3);
		str = user.win;
		gui_add_label_ali(self.layer, str, 22, 'win_num', GUI_PLAYERINFO, ANCHOR_UP, cc.TEXT_ALIGNMENT_RIGHT, nil, -h3);
		]]--

		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		--[[
		if g_scene:is_stage(STAGE_MAP) and nil ~= layer_chat.layer then
			layer_chat.layer:setVisible(true);
		end
		]]--
		local self = layer_info;
		self:remove();
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_info;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return 1;
		elseif "scrollViewDidScroll" == event then
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			local data = self.data_cell;
			return data.height, data.width;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local str, data, d2, label;
			data = self.data_cell;
			gui_add_cell_bg(cell, data);
			str = "详细信息";
			gui_add_label_on_cell(cell,data,str,26,'title_detail',GUI_PLAYERINFO,ANCHOR_DOWN);
			local list = {};
			local u = self.user;
			table.insert(list, { key="id", str=u.eid });
			table.insert(list, { key="rate", str=math.floor(u.rating) });
			local percent_win = 0;
			if u.game_count > 0 then
				percent_win = u.win / u.game_count * 100;
			end
			percent_win = string.format("%d%%", math.floor(percent_win));
			str = percent_win;
			table.insert(list, { key="winrate", str=str });
			if u.gpos > GUILD_POS_NONE and u.gpos ~= GUILD_POS_APPLY then
				str = get_guild_name(u.gname);
			else
				str = t_lang("NO_GUILD");
			end
			table.insert(list, { key="guild", str=str , not_num=true});
			table.insert(list, { key="match", str=u.game_count });
			table.insert(list, { key="win", str=u.win });
			path = util.get_path(FT_5);
			for i = 1, #list do
				local d = list[i];
				local key = d.key;
				local str = d.str;
				if true == d.not_num then
					gui_add_label_ali_on_cell(cell, data, str, 22, key, GUI_PLAYERINFO, ANCHOR_DOWN, cc.TEXT_ALIGNMENT_RIGHT);
				else
					gui_add_labelbmf_on_cell(cell,data,str,path,key,GUI_PLAYERINFO,ANCHOR_DOWN,cc.TEXT_ALIGNMENT_RIGHT);
				end
				key = 't_' .. key;
				gui_add_sprite_on_cell(cell, data, key, GUI_PLAYERINFO, ANCHOR_DOWN);
			end

			return cell;
		end
	end, -- tableview_handler end }

	video = function()
		play_tap_1();
		local flag = is_wait_for_battle();
		if 1 == flag then
			show_msg("正在等待对战匹配");
			return;
		elseif 2 == flag then
			show_msg("正在等待房间对战");
			return;
		end
		local self = layer_info;
		local eid = self.user.eid or '';
		local alias = self.user.alias or '';
		layer_video.alias = alias;
		local cmd = 'lreplay ' .. eid;
		net_send(cmd);
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_info;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
			local str = edit:getText();
			str = util.space_(str);
			edit:setText(str);
			edit:setVisible(false);
			self.gx_label:setString(str);
			self.gx_label:setVisible(true);
			if str ~= g_euser.signature then
				self:save(nil, nil, str);
			end
		elseif eventname == "changed" then
		end
	end,

	save = function(self, icon, sex, signature)
		icon = icon or g_euser.icon;
		sex = sex or g_euser.sex;
		signature = signature or g_euser.signature;
		local cmd = string.format("sprofile %s %d %s", icon, sex, signature);
		net_send(cmd);
	end,

	friends = function()
		local self = layer_info;
	end,

	check_deck = function()
		local self = layer_info;
	end,

	callback_icon = function(index)
		local self = layer_info;
		print('index: ', index);
		if nil ~= index and index ~= tonumber(g_euser.icon) then
			self:save(index);
		end
	end,

	handler = function(event, x, y)
		local self = layer_info;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			if nil ~= layer_pickicon.layer then
				layer_pickicon.close();
				return;
			end
			if nil ~= layer_video.layer then
				layer_video.back();
				return;
			end
			self.back();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.icon_rect;
		if nil ~= r and x > r.x1 and x < r.x2 and y > r.y1 and y < r.y2 then
			play_tap_1();
			g_scene:add_layer(ZORDER_LAYER_PICKICON, layer_pickicon:create(self.callback_icon));
			return;
		end
		local t = self.edit_rect;
		if nil ~= t and x > t.x1 and x < t.x2 and y > t.y1 and y < t.y2 then
			play_tap_3();
			self.gx_label:setVisible(false);
			self.editbox:setVisible(true);
			self.editbox:sendActionsForControlEvents(CCControlEventTouchUpInside);
			return;
		end
	end,
} -- layer_info end

layer_pickicon = { -- start
	name = 'layer_pickicon',
	layer = nil,
	callback = nil,
	tag = nil,
	bg_rect = nil,

	cleanup = function(self)
		self.layer = nil;
		self.bg_rect = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, callback)
		self:remove();
		
		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_PICKICON, self.handler, true);

		self.callback = callback;
		util.add_layer_color(self.layer, cc.c4b(0, 0, 0, 158));

		local data, scale = gui_get_data('icon', GUI_PLAYERINFO, ANCHOR_UP);
		local len = #list_icon_num;

		local height = 110 + ((math.floor(len/4)+1) * (data.height + 10));
		local bgsize = cc.size(4*(data.width+10)+20, height);--realsize
		local bg, bg_rect = init_bg_for_popview(self.layer, '选择头像', bgsize, self.close);
		self.bg_rect = bg_rect;

		local items = {};
		local item;

		local fpath = util.get_path(data.fname1); -- frame_path
		for i = 1, #list_icon_num do
			local inum = list_icon_num[i];
			local fname = 'picon_1_' .. inum .. '.png';
			local cb = self.indexpicon;
			local index = (i-1)%4;
			local x = 15+data.width/2 + (i-1)%4*(data.width+10);
			local y = bgsize.height-110-(data.height+5)*math.floor((i-1)/4);
			local p = cc.p(x, y);
			item = util.create_item_image(fpath,fpath,p,ANCHOR_CENTER_UP,cb);
			item:setScale(data.width/item:getContentSize().width);
			local size = item:getContentSize();
			local path = util.get_path(fname);
			p = cc.p(size.width/2, size.height/2);
			local s = util.add_sprite(item,path,p,ANCHOR_CENTER_CENTER, -10);
			s:setScale((size.width-10)/s:getContentSize().width);
			item:setTag(inum);
			table.insert(items, item);
		end

		util.add_menu(bg, items, 20);

		return self.layer, self.name;
	end,
	
	indexpicon = function(...)
		play_tap_1();
		local self = layer_pickicon;
		local args = {...};
		self.tag = args[2]:getTag();
		--print('self.tag: ', self.tag);
		self.close();
	end,

	close = function()
		play_tap_1();
		local self = layer_pickicon;
		local tag = self.tag;
		self:remove();
		if nil ~= self.callback then
			self.callback(self.tag);
		end
	end,

	handler = function(event, x, y)
		local self = layer_pickicon;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.bg_rect;
		if nil ~= r and (x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2) then
			self.close();
		end
	end,

} -- layer_pickicon end

layer_video = {
	name = 'layer_video',
	layer = nil,
	list = nil,
	cwidth = nil,
	cheight = nil,
	tableview = nil,
	bar = nil,
	tap = nil,
	eid = nil,
	alias = nil,
	data_cell = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.tableview = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, eid, list)
		self:remove();
		
		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_VIDEO, self.handler, true);

		self.eid = eid;
		-- self.alias is set in layer_info video()
		self.list = list or {};
		local offsetheight = init_bg_full(self.layer, GUI_VIDEO, self.back);
		local sprite, data, pos, size, path;
		sprite,data = gui_add_sprite(self.layer,'outframe',GUI_VIDEO,ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));
		sprite, data = gui_add_sprite(self.layer,'fade_bottom',GUI_VIDEO,ANCHOR_DOWN);
		sprite:setScaleX(data.width/sprite:getContentSize().width);
		gui_add_sprite(self.layer,'bg_alias',GUI_VIDEO,ANCHOR_UP);
		gui_add_label_ali(self.layer, self.alias, 25, 'alias', GUI_VIDEO, ANCHOR_UP, cc.TEXT_ALIGNMENT_CENTER);

		data = gui_get_data('cell', GUI_VIDEO, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height+10;
		data = gui_get_data('table', GUI_VIDEO, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height+offsetheight);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	play_video = function(...)
		play_tap_1();
		local self = layer_video;
		local args = {...};
		local tag = args[2]:getTag();
		local info = self.list[tag];
		if nil == info then
			return;
		end
		local gameid = info.gameid;
		local cmd = 'replay ' .. gameid;
		net_send(cmd);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_video;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			--gui_add_cell_bg(cell, data, width, height);
			gui_add_cell_bg(cell, data);
			local info = self.list[idx + 1];
			local einfo = info.einfo;
			local is_win = info.is_win;
			local data2, sprite, path, pos, size, str;

			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'cicon', GUI_VIDEO, ANCHOR_DOWN);
			size = sprite:getContentSize();
			path = get_icon_path(einfo.icon);
			pos = cc.p(size.width/2, size.height/2);
			sprite = util.add_sprite(sprite, path,pos,ANCHOR_CENTER_CENTER,-1);
			sprite:setScale((size.width-10)/sprite:getContentSize().width);

			str = einfo.alias;-- .. einfo.eid;
			gui_add_label_on_cell(cell,data,str,24,'cname',GUI_VIDEO,ANCHOR_DOWN);

			gui_add_sprite_on_cell(cell, data, 'lv', GUI_VIDEO, ANCHOR_DOWN);

			path = util.get_path(FT_3);
			str = einfo.lv;
			gui_add_labelbmf_on_cell(cell,data,str,path,'n_lv',GUI_VIDEO,ANCHOR_DOWN);

			local t = info.gameid;
			str = string.format("%s/%s", string.sub(t, 3, 4),string.sub(t, 5, 6));
			path = util.get_path(FT_1);
			gui_add_labelbmf_on_cell(cell, data, str, path, 'time', GUI_VIDEO, ANCHOR_DOWN);
			str = string.format("%s:%s:%s", string.sub(t, 7, 8), string.sub(t, 9, 10), string.sub(t, 11, 12));
			sprite, data2 = gui_add_labelbmf_on_cell(cell, data, str, path, 'time', GUI_VIDEO, ANCHOR_DOWN);
			sprite:setPositionX(data2.x+100);

			if true == is_win then
				gui_add_sprite_on_cell(cell, data, 'cwin', GUI_VIDEO, ANCHOR_DOWN);
			else
				gui_add_sprite_on_cell(cell, data, 'close', GUI_VIDEO, ANCHOR_DOWN);
			end

			local ver = tonumber(info.version);
			local lver = tonumber(LOGIC_VERSION);
			local items = {};
			local item;

			item, data2 = gui_add_item_on_cell(items, data, 'btn_play', GUI_VIDEO, self.play_video, ANCHOR_DOWN);
			item:setTag(idx + 1);
			--str = "播放";
			if ver ~= lver then
				--str = "旧版本";
				--item:setEnabled(false);
				enable_btn(item, false);
			end
			--gui_add_text_on_sprite(item,str,'t_play',GUI_VIDEO,ANCHOR_UP,30);

			util.add_menu(cell, items, data2.zorder);

			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	back = function()
		play_tap_1();
		local self = layer_video;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_video;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_video end

layer_tip = {
	name = 'layer_tip',
	layer = nil,
	callback = nil,
	bg = nil,
	btn_confirm = nil,
	bbs_addr = nil,

	cleanup = function(self)
		self.layer = nil;
		self.callback = nil;
		self.bg = nil;
		self.btn_confirm = nil;
		self.bbs_addr = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, msg, cb)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_TIP, self.handler, true);

		self.callback = cb;
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));

		local path = util.get_path('bg_121.png');
		local frect = cc.rect(0, 0, 404, 260); -- fullrect
		local irect = cc.rect(200, 128, 4, 4); -- insetrect
		local size = cc.size(wfix(505), hfix(302));--realsize
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, size, 10); 
		self.bg = bg;

		if nil ~= msg then
			pos = cc.p(size.width/2, size.height-50);
			local lsize = cc.size(size.width-40, size.height - 80 - 100);
			util.add_labeloutline(bg, msg, nil, 25, pos, util.c4b_white, util.c4b_black, 1, ANCHOR_CENTER_UP, 50, lsize, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_TOP);
		end

		local items = {};
		local item, p1, p2;

		if nil ~= self.callback then
			pos = cc.p(size.width/4*3, 28);
			self.btn_confirm = add_item_1(items, '确定',nil,30,self.confirm,ANCHOR_CENTER_DOWN,pos);
		end

		if nil ~= self.callback then
			pos = cc.p(size.width/4, 28);
		else
			pos = cc.p(size.width/2, 28);
		end
		add_item_1(items, '取消', nil, 30, self.cancel, ANCHOR_CENTER_DOWN, pos);
		
		util.add_menu(bg, items, 60);

		return self.layer, self.name;
	end,

	add_button_bbs = function(self, addr)
		if nil == self.bg then
			return;
		end
		self.bbs_addr = addr;
		local items = {};
		local size = self.bg:getContentSize();

		pos = cc.p(size.width/2, 118);
		add_item_1(items, '进入论坛',nil,30,self.go_bbs,ANCHOR_CENTER_DOWN,pos, cc.size(200, 80));
		
		util.add_menu(self.bg, items, 1);
	end,

	go_bbs = function()
		local self = layer_tip;
		util.open_url('http://bbs.youxiqun.com');
	end,

	confirm = function()
		play_tap_1();
		local self = layer_tip;
		if nil ~= self.callback then
			self.callback(1);
		end
		self:remove();
	end,

	cancel = function()
		play_tap_1();
		local self = layer_tip;
		if g_scene:is_stage(STAGE_DECK) then
			if nil ~= self.callback then
				self.callback(0);
			end
		end
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_tip;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
	end,

} -- layer_tip end

layer_cbox = {
	name = 'layer_cbox',
	layer = nil,
	btn_get = nil,
	bg = nil,

	cleanup = function(self)
		self.layer = nil;
		self.btn_get = nil;
		self.bg = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, info)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_CBOX, self.handler, true);

		self.callback = cb;
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));

		local path = util.get_path('bg_121.png');
		local frect = cc.rect(0, 0, 404, 260); -- fullrect
		local irect = cc.rect(200, 128, 4, 4); -- insetrect
		local size = cc.size(wfix(560), wfix(450));--realsize
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, size, 10); 
		self.bg = bg;

		self:add_detail(info, bg);

		local items = {};
		local item;

		local mtype = info.mtype;
		pos = cc.p(size.width/2, 28);
		if 2 == info.status then
			item=add_item_1(items, '领取',nil,30,self.get,ANCHOR_CENTER_DOWN,pos);
			self.btn_get = item;
			item:setTag(info.mid);
		elseif 3 == info.status then
			item=add_item_1(items,'已领取',nil,30,self.get,ANCHOR_CENTER_DOWN,pos);
			enable_btn(item, false);
		elseif MISSION_CHAPTER_STAGE == mtype or MISSION_CHAPTER == mtype then
			item=add_item_1(items,'未完成',nil,30,self.get,ANCHOR_CENTER_DOWN,pos);
			enable_btn(item, false);
		end

		pos = cc.p(wfix(500), wfix(380));
		add_item_close(items, pos, ANCHOR_LEFT_DOWN, self.back);
		
		util.add_menu(bg, items, 60);

		return self.layer, self.name;
	end,

	get = function(...)
		local args = {...};
		local mid = args[2]:getTag();
		net_send('mreward ' .. mid);
	end,

	add_detail = function(self, info, bg)
		local m = 0;
		if info.gold > 0 or info.crystal > 0 or info.exp > 0 then
			m = m + 1;
		end
		if #info.clist > 0 then
			m = m + 1;
		end
		local key, ctype;
		if 1 == m then
			key = "cell2";
			ctype = 2;
		else
			key = "cell1";
			ctype = 1;
		end
		local bgsize = bg:getContentSize();
		local sprite, cell, data, data2, path, pos, size, str;
		cell, data = gui_add_sprite(bg, key, GUI_MISSION, ANCHOR_DOWN);
		cell:setPosition(cc.p(bgsize.width/2, bgsize.height/2+15));
		cell:setAnchorPoint(ANCHOR_CENTER_CENTER);
		local d1 = gui_get_data('cell1', GUI_MISSION, ANCHOR_DOWN);
		local d2 = gui_get_data('cell2', GUI_MISSION, ANCHOR_DOWN);
		local gold = info.gold;
		local crystal = info.crystal;
		local exp = info.exp;
		key = 'cell' .. ctype .. '_bgtitle';
		gui_add_sprite_on_cell(cell, data, key, GUI_MISSION, ANCHOR_DOWN);
		key = 'cell' .. ctype .. '_icon';
		gui_add_sprite_on_cell(cell, data, key, GUI_MISSION, ANCHOR_DOWN);
		key = 'cell' .. ctype .. '_title';
		str = info.title;
		gui_add_label_on_cell(cell,data,str,25,key,GUI_MISSION,ANCHOR_DOWN);
		key = 'cell' .. ctype .. '_desc';
		str = info.detail;
		gui_add_label_on_cell(cell,data,str,22,key,GUI_MISSION,ANCHOR_DOWN);
		path = util.get_path(FT_4);
		if gold > 0 then
			key = 'gold' .. ctype;
			gui_add_sprite_on_cell(cell, data, key, GUI_MISSION, ANCHOR_DOWN);
			key = 'n_gold' .. ctype;
			str = gold;
			sprite, data2 = gui_add_labelbmf_on_cell(cell,data,str,path,key,GUI_MISSION,ANCHOR_DOWN);
		end
		if crystal > 0 then
			local newy = 0;
			if 2 == ctype and gold == 0 then
				key = 'gold' .. ctype;
				data2 = gui_get_data(key, GUI_MISSION, ANCHOR_DOWN);
				newy = data2.y - data.y;
			end
			key = 'crystal' .. ctype;
			sprite = gui_add_sprite_on_cell(cell, data, key, GUI_MISSION, ANCHOR_DOWN);
			if newy > 0 then
				sprite:setPositionY(newy);
			end
			key = 'n_crystal' .. ctype;
			str = crystal;
			sprite, data2 = gui_add_labelbmf_on_cell(cell,data,str,path,key,GUI_MISSION,ANCHOR_DOWN);
			if newy > 0 then
				sprite:setPositionY(newy);
			end
		end
		if exp > 0 then
			key = 'exp' .. ctype;
			gui_add_sprite_on_cell(cell, data, key, GUI_MISSION, ANCHOR_DOWN);
			key = 'n_exp' .. ctype;
			str = exp;
			sprite, data2 = gui_add_labelbmf_on_cell(cell,data,str,path,key,GUI_MISSION,ANCHOR_DOWN);
		end
		key = 'pframe1';
		local ldata = gui_get_data(key, GUI_MISSION, ANCHOR_DOWN);
		key = 'cframe1_1';
		local ldata2 = gui_get_data(key, GUI_MISSION, ANCHOR_DOWN);
		key = 'cframe1_2';
		local ldata3 = gui_get_data(key, GUI_MISSION, ANCHOR_DOWN);
		x = ldata.x-d1.x;
		local gapx = ldata3.x-ldata2.x;
		for i = 1, #info.clist do
			local cinfo = info.clist[i];
			local cid = cinfo.cid;
			local is_piece = cinfo.is_piece;
			local piece_count = cinfo.piece_count or 0;
			local cb = nil;
			if true == is_piece then
				key = 'pframe1';
				cb = self.show_piece;
			else
				key = 'cframe1_1';
				cb = self.show_card;
			end
			local items = {};
			sprite, data2 = gui_add_item_on_cell(items, d1, key, GUI_MISSION, cb, ANCHOR_DOWN);
			sprite:setTag(cid);
			util.add_menu(cell, items, data2.zorder);
			if ctype == 1 and #info.clist > 3 and i <= 3 then
				sprite:setPositionY(ldata1.y - d1.y);
			else
				sprite:setPositionY(ldata2.y - d1.y);
			end
			sprite:setPositionX(x+gapx*((i-1)%3));
			local size = sprite:getContentSize();
			local pic, mask_path;
			if true == is_piece then
				mask_path = util.get_path('bg_173.png');
			else
				mask_path = util.get_path('bg_172.png');
			end
			local fname = 'card' .. cinfo.cid .. '.png';
			path = util.get_path(fname, 'card0.png');
			pic = util.add_mask_sprite(sprite, path, mask_path, cc.p(size.width/2, size.height/2), ANCHOR_CENTER_CENTER, -1);
			pic:setScaleX(size.width/pic:getContentSize().width);
			pic:setScaleY(size.height/pic:getContentSize().height);
			if piece_count > 0 then
				path = util.get_path(FT_4);
				str = piece_count .. '';
				util.add_labelbmf(sprite, str, path, cc.p(size.width, 0), ANCHOR_RIGHT_DOWN, 1);
			end
		end
	end,

	back = function()
		play_tap_1();
		local self = layer_cbox;
		self:remove();
	end,

	show_card = function(...)
		local args = {...};
		local tag = args[2]:getTag();
		local self = layer_cbox;
		local card = clone_card_by_id(tag);
		if nil == card then return; end
		g_scene:add_layer(ZORDER_LAYER_MISPOP, layer_mispop:create(card));
	end,

	show_piece = function(...)
		local args = {...};
		local tag = args[2]:getTag();
		local self = layer_cbox;
		local card = clone_card_by_id(tag);
		if nil == card then return; end
		g_scene:add_layer(ZORDER_LAYER_MISPOP, layer_mispop:create(card, true));
	end,

	handler = function(event, x, y)
		local self = layer_cbox;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
	end,

} -- layer_cbox end

layer_guildup = {
	name = 'layer_guildup',
	layer = nil,
	callback = nil,

	cleanup = function(self)
		self.layer = nil;
		self.callback = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, info, cb)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_TIP, self.handler, true);

		self.callback = cb;
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));

		local bg, data = init_bg_pop(self.layer, GUI_GUILDUP, '工会升级', self.back, true, true);
		print('-----');
		local s, d2, str;
		gui_add_sprite_on_cell(bg, data, 'frame', GUI_GUILDUP, ANCHOR_DOWN);
		gui_add_sprite_on_cell(bg, data, 'gold', GUI_GUILDUP, ANCHOR_DOWN);
		gui_add_sprite_on_cell(bg, data, 'arrow_glv',GUI_GUILDUP,ANCHOR_DOWN);
		gui_add_sprite_on_cell(bg, data, 'arrow_num',GUI_GUILDUP,ANCHOR_DOWN);
		str = "消耗";
		gui_add_label_ali_on_cell(bg, data, str, 26, 't_need', GUI_GUILDUP, ANCHOR_DOWN, cc.TEXT_ALIGNMENT_RIGHT);
		str = "公会等级";
		gui_add_label_ali_on_cell(bg, data, str, 26, 't_guildlv', GUI_GUILDUP, ANCHOR_DOWN, cc.TEXT_ALIGNMENT_RIGHT);
		str = "人数上限";
		gui_add_label_ali_on_cell(bg, data, str, 26, 't_num', GUI_GUILDUP, ANCHOR_DOWN, cc.TEXT_ALIGNMENT_RIGHT);
		local path = util.get_path(FT_1);
		str = info.levelup_gold;
		gui_add_labelbmf_on_cell(bg,data,str,path,'n_gold',GUI_GUILDUP,ANCHOR_DOWN);
		str = info.current_lv;
		gui_add_labelbmf_on_cell(bg,data,str,path,'glv_1',GUI_GUILDUP,ANCHOR_DOWN);
		str = info.next_lv;
		gui_add_labelbmf_on_cell(bg,data,str,path,'glv_2',GUI_GUILDUP,ANCHOR_DOWN);
		str = info.current_mb_max;
		gui_add_labelbmf_on_cell(bg,data,str,path,'num_1',GUI_GUILDUP,ANCHOR_DOWN);
		str = info.next_mb_max;
		gui_add_labelbmf_on_cell(bg,data,str,path,'num_2',GUI_GUILDUP,ANCHOR_DOWN);

		local items = {};
		s, d2 = gui_add_item_on_cell(items, data, 'btn_cancel', GUI_GUILDUP, self.back, ANCHOR_DOWN);
		s, d2 = gui_add_item_on_cell(items, data, 'btn_confirm', GUI_GUILDUP, self.confirm, ANCHOR_DOWN);
		util.add_menu(bg, items, d2.zorder);

		return self.layer, self.name;
	end,

	confirm = function()
		play_tap_1();
		local self = layer_guildup;
		if nil ~= self.callback then
			self.callback(1);
		end
		self:remove();
	end,

	back = function()
		play_tap_1();
		local self = layer_guildup;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_guildup;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
	end,

} -- layer_guildup end

layer_quick = { -- start    wait quick match
	name = 'layer_quick',
	layer = nil,
	is_waiting = false,
	label_time = nil,
	time_1 = nil,
	time = nil,
	label_stime = nil,

	cleanup = function(self)
		self.layer = nil;
		self.is_waiting = false;
		self.label_time = nil;
		self.time_1 = nil;
		self.time = nil;
		self.label_stime = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_QUICK, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		local bg, data = init_bg_pop(self.layer, GUI_QUICK, '决斗之城', self.callback_return, true);
		local sprite, d2;

		gui_add_sprite_on_cell(bg, data, 'bg_pic', GUI_QUICK, ANCHOR_DOWN);
		gui_add_sprite_on_cell(bg, data, 't_stime', GUI_QUICK, ANCHOR_DOWN);
		gui_add_sprite_on_cell(bg, data, 't_ctime', GUI_QUICK, ANCHOR_DOWN);
		gui_add_sprite_on_cell(bg, data, 't_reward', GUI_QUICK, ANCHOR_DOWN);
		gui_add_sprite_on_cell(bg, data, 'gold', GUI_QUICK, ANCHOR_DOWN);
		gui_add_sprite_on_cell(bg, data, 'crystal', GUI_QUICK, ANCHOR_DOWN);

		sprite, d2 = gui_add_sprite_on_cell(bg, data, 'frame', GUI_QUICK, ANCHOR_DOWN);
		sprite:setPosition(cc.p(d2.x+d2.width/2, d2.y+d2.height/2));
		sprite:setAnchorPoint(ANCHOR_CENTER_CENTER);
		self:frame_rotate(sprite, d2);

		local path = util.get_path(FT_8);
		sprite = gui_add_labelbmf_on_cell(bg, data, '', path, 'n_ctime', GUI_QUICK, ANCHOR_DOWN);
		self.label_time = sprite;
		sprite = gui_add_labelbmf_on_cell(bg, data, '', path, 'n_stime', GUI_QUICK, ANCHOR_DOWN);
		self.label_stime = sprite;

		--[[
		gui_add_sprite(self.layer, 'bg', GUI_QUICK, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 'bg_title', GUI_QUICK, ANCHOR_DOWN);
		gui_add_label_ali(self.layer,'对战',24,'title',GUI_QUICK, ANCHOR_DOWN, cc.TEXT_ALIGNMENT_CENTER);
		gui_add_sprite(self.layer, 'bg_2', GUI_QUICK, ANCHOR_DOWN);
		sprite,data = gui_add_sprite(self.layer, 'light', GUI_QUICK, ANCHOR_DOWN);
		pos = ccp(data.x+data.width/2, data.y+data.height/2);
		sprite:setPosition(pos);
		sprite:setAnchorPoint(ANCHOR_CENTER_CENTER);
		self:magic_anim(sprite);
		local sprite, data, pos, path, card_width;
		sprite,data = gui_add_sprite(self.layer, 'frame', GUI_QUICK, ANCHOR_DOWN);
		pos = cc.p(data.x+data.width/2, data.y+data.height/2);
		sprite:setPosition(pos);
		sprite:setAnchorPoint(ANCHOR_CENTER_CENTER);
		self:frame_rotate(sprite, data);
		card_width = data.width;

		path = util.get_path(FNT_1);
		sprite, data = gui_add_labelbmf(self.layer, '60', path, 't_time', GUI_QUICK, ANCHOR_DOWN);
		pos = cc.p(data.x+data.width/2+card_width/2, data.y+data.height/2);
		sprite:setPosition(pos);
		sprite:setAnchorPoint(ANCHOR_CENTER_CENTER);
		self.label_time = sprite;

		local fsize = 30;
		local tpos	= cc.p(pos.x - data.width/4, pos.y);
		local tcolor = cc.c4b(128, 255, 128, 255);
		local scolor = cc.c4b(113, 59, 18, 255);
		local outline_size = 1;
		util.add_labeloutline(self.layer, '预计匹配时间:', nil, fsize, tpos, tcolor, scolor, outline_size, ANCHOR_RIGHT_CENTER, data.zorder);
		tpos = cc.p(pos.x + data.width/4, pos.y);
		util.add_labeloutline(self.layer, '秒', nil, fsize, tpos, tcolor, scolor, outline_size, ANCHOR_LEFT_CENTER, data.zorder);


		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn_back', GUI_QUICK, self.callback_return, ANCHOR_DOWN);

		util.add_menu(self.layer, items, data.zorder);

		--eff_layer_1(self.layer);	

		self.time_1 = os.time();
		self.time = 60; -- 60 sec
--		self.time = 600; -- 600 sec
		self.layer:scheduleUpdateWithPriorityLua(self.update_time_count, 1);
		]]--

		return self.layer, self.name;

	end,

	update_time_count = function(dt)
		local self = layer_quick;
		local t = os.time() - self.time_1;
		local time = self.time - t;
		if 0 > time then
			time = 0;
		end
		local str;
		--str = string.format("%02d:%02d", math.floor(time/60), time%60);
		str = string.format("%02d:%02d", math.floor(t/60), t%60);
		self.label_time:setString(str);

		--str = get_time();
		--str = string.format("%02d:%02d", math.floor(t/60), t%60);
		--self.label_stime:setString(str);
	end,

	frame_rotate = function(self, sprite, data)
		math.randomseed(os.time());
		local fname1 = data.fname1;
		local fname2 = data.fname2;
		local function callback_front(...)
			local args = {...};
			local s = args[1];
			s:removeAllChildrenWithCleanup(true);
			local path = util.get_path(fname2);
			local tc = cc.Director:getInstance():getTextureCache();
			local texture = tc:addImage(path);
			if nil == texture then return; end
			s:setTexture(texture);
			local index = math.random(1, #list_icon_num);
			--local filename = 'picon_1_' .. list_icon_num[index] .. '.png';
			local filename = 'card' .. list_icon_num[index] .. '.png';
			path = util.get_path(filename, 'card0.png');
			local mask_path = util.get_path('bg_190.png');
			local size = s:getContentSize();
			local pic = util.add_mask_sprite(s, path, mask_path, cc.p(size.width/2, 0), ANCHOR_CENTER_DOWN, -1);
			pic:setScale((size.height-20)/pic:getContentSize().height);
		end

		local function callback_back(...)
			local args = {...};
			local s = args[1];
			s:removeAllChildrenWithCleanup(true);
			local path = util.get_path(fname1);
			local tc = cc.Director:getInstance():getTextureCache();
			local texture = tc:addImage(path);
			if nil == texture then return; end
			s:setTexture(texture);
		end

		local t = 0.6;
		local action = nil;
		local array = {};
		action = cc.OrbitCamera:create(t, 1, 0, 0, -90, 0, 0);
		table.insert(array, action);
		action = cc.CallFunc:create(callback_front);
		table.insert(array, action);
		action = cc.OrbitCamera:create(t, 1, 0, 90, -90, 0, 0);
		table.insert(array, action);
		action = cc.OrbitCamera:create(t, 1, 0, 0, -90, 0, 0);
		table.insert(array, action);
		action = cc.CallFunc:create(callback_back);
		table.insert(array, action);
		action = cc.OrbitCamera:create(t, 1, 0, 90, -90, 0, 0);
		table.insert(array, action);
		action = cc.Sequence:create(array);
		action = cc.RepeatForever:create(action);
		sprite:runAction(action);
	end,

	magic_anim = function(self, sprite)
		local c = sprite:getColor();
		local action, array;
		array = {};
		action = cc.TintTo:create(1, 150, 0, 150);
		table.insert(array, action);
		action = cc.TintTo:create(1, c.r, c.g, c.b);
		table.insert(array, action);
		action = cc.Sequence:create(array);
		array = {};
		table.insert(array, action);
		action = cc.RotateBy:create(2, 40);
		table.insert(array, action);
		action = cc.Spawn:create(array);
		action = cc.RepeatForever:create(action);
		sprite:runAction(action);
	end,

	start_waiting = function(self, time)
		if nil == self.layer then
			return
		end

		self.time_1 = os.time();
		self.time = time; -- 60 sec
--		self.time = 600; -- 600 sec
		local str = string.format("%02d:%02d", math.floor(time/60), time%60);
		self.label_stime:setString(str);
		self.layer:scheduleUpdateWithPriorityLua(self.update_time_count, 1);
		self.is_waiting = true;
	end,

	stop_waiting = function(self)
		if nil == self.layer then
			return
		end
		self.is_waiting = false;
	end,

	cancel_wait = function(self)
		local cmd = 'quick 9';
		--local cmd = 'fcancel';
		net_send(cmd, true);
	end,

	check_quit = function(self)
		if true == self.is_waiting then
			self:cancel_wait();
		end
	end,

	callback_return = function()
		play_tap_1();
		local self = layer_quick;
		self.remove_after_eff();
		--eff_layer_2(self.layer, self.remove_after_eff);	
	end,

	remove_after_eff = function()
		local self = layer_quick;
		self:check_quit();
		self:remove();
		layer_service:set_show(true);
		--layer_bottombar:set_show(true);
	end,

	handler = function(event, x, y)
		local self = layer_quick;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)

	end,
} -- layer_quick end

layer_exchange = { -- start
	name = 'layer_exchange',
	layer = nil,
	eb1 = nil,
	eb2 = nil,

	cleanup = function(self)
		self.layer = nil;
		self.eb1 = nil;
		self.eb2 = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_QUICK, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		local bg, data = init_bg_pop(self.layer, GUI_EXCHANGE, '金币兑换', self.back, true);
		local s, d2, str;

		gui_add_sprite_on_cell(bg, data, 'frame', GUI_EXCHANGE, ANCHOR_DOWN);
		gui_add_sprite_on_cell(bg, data, 't_crystal', GUI_EXCHANGE, ANCHOR_DOWN);
		gui_add_sprite_on_cell(bg, data, 'bg_n_take', GUI_EXCHANGE, ANCHOR_DOWN);
		gui_add_sprite_on_cell(bg, data, 't_gold', GUI_EXCHANGE, ANCHOR_DOWN);
		gui_add_sprite_on_cell(bg, data, 'bg_n_get', GUI_EXCHANGE, ANCHOR_DOWN);
		gui_add_sprite_on_cell(bg, data, 'note', GUI_EXCHANGE, ANCHOR_DOWN);

		str = "消耗";
		gui_add_label_on_cell(bg, data, str, 22, 't_take', GUI_EXCHANGE, ANCHOR_DOWN);
		str = "获得";
		gui_add_label_on_cell(bg, data, str, 22, 't_get', GUI_EXCHANGE, ANCHOR_DOWN);

		local color, pos, size;
		d2 = gui_get_data('n_take', GUI_EXCHANGE, ANCHOR_DOWN);
		d2.x = d2.x - data.x;
		d2.y = d2.y - data.y;
		color = cc.c3b(d2.r, d2.g, d2.b);
		pos = cc.p(d2.x, d2.y);
		size = cc.size(d2.width, d2.height);
		self.eb1 = util.add_editbox_blank(bg, size, 
			ANCHOR_LEFT_DOWN, pos, util.f_default, 22, color, 
			cc.EDITBOX_INPUT_MODE_SINGLELINE, cc.KEYBOARD_RETURNTYPE_DONE, 
			nil, self.editbox_handler, 30, "请输入水晶数", util.c_gray, 
			d2.zorder);

		d2 = gui_get_data('n_get', GUI_EXCHANGE, ANCHOR_DOWN);
		d2.x = d2.x - data.x;
		d2.y = d2.y - data.y;
		color = cc.c3b(d2.r, d2.g, d2.b);
		pos = cc.p(d2.x, d2.y);
		size = cc.size(d2.width, d2.height);
		self.eb2 = util.add_editbox_blank(bg, size, 
			ANCHOR_LEFT_DOWN, pos, util.f_default, 22, color, 
			cc.EDITBOX_INPUT_MODE_SINGLELINE, cc.KEYBOARD_RETURNTYPE_DONE, 
			nil, self.editbox_handler, 30, "请输入金币数", util.c_gray, 
			d2.zorder);
		
		local items = {};
		s, d2 = gui_add_item_on_cell(items, data, 'btn', GUI_EXCHANGE, self.exchange, ANCHOR_DOWN);
		util.add_menu(bg, items, d2.zorder);

		return self.layer, self.name;

	end,

	back = function()
		play_tap_1();
		layer_exchange:remove();
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_exchange;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
			local n = tonumber(edit:getText());
			if nil == n then
				show_msg("请输入数字");
				edit:setText("");
				return;
			end
			if edit == self.eb1 then
				n = n * 10;
				self.eb2:setText(n);
				return;
			end
			n = math.ceil(n / 10);
			self.eb1:setText(n);
			n = n * 10;
			self.eb2:setText(n);
			return;
		elseif eventname == "changed" then
		end
	end,

	exchange = function()
		local self = layer_exchange;
		local crystal = tonumber(self.eb1:getText());
		if nil == crystal or 0 == crystal then
			show_msg("请输入数字");
			return;
		end
		if crystal > g_euser.crystal then
			show_err(t_lang("TIP_NOT_ENOUGH_CRYSTAL"));
			return;
		end
		local cmd = string.format("moneyexchange %d", crystal);
		net_send(cmd);
	end,

	handler = function(event, x, y)
		local self = layer_exchange;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)

	end,
} -- layer_exchange end

layer_lwait = { -- start   list room wait 
	name = 'layer_lwait',
	layer = nil,
	channel = 9,
	room_type = 1,
	list = {},
	table_view = nil,
	editbox = nil,
	cwidth = nil,
	cheight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,
	do_cell_anim = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = {};
		self.table_view = nil;
		self.editbox = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
		self.do_cell_anim = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_LWAIT, self.handler, true);

		util.add_layer_color(self.layer, cc.c4b(0, 0, 0, 150));
		local data;
		local offsetheight, sprite, rect = init_bg_pop(self.layer, GUI_LWAIT, '自定义', self.back, nil, true);

		gui_add_sprite(self.layer, 'fade_bottom', GUI_LWAIT, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 'bg_room', GUI_LWAIT, ANCHOR_UP);

		self.editbox = gui_add_editbox(self.layer, 't_room', GUI_LWAIT, ANCHOR_UP, 22, self.editbox_handler, 20, "查找房间");

		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn_create', GUI_LWAIT, self.callback_create, ANCHOR_UP);

		item, data = gui_add_item(items, 'btn_refresh', GUI_LWAIT, self.callback_reload, ANCHOR_UP);

		item, data = gui_add_item(items, 'btn_room', GUI_LWAIT, self.callback_search, ANCHOR_UP);

		util.add_menu(self.layer, items, data.zorder);

		data = gui_get_data('cell', GUI_LWAIT, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		data = gui_get_data('table', GUI_LWAIT, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.table_view = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);


		return self.layer, self.name;
	end,

	back = function()
		local self = layer_lwait;
		self:remove();
	end,

	reload = function(self)
		self.do_cell_anim = true;
		self.table_view:reloadData();
	end,

	callback_reload = function()
		play_tap_1();
		local self = layer_lwait;
		local cmd = string.format('lroom %d %d', self.channel, self.room_type);
		net_send(cmd);
	end,

	callback_search = function()
		play_tap_1();
		local self = layer_lwait;
		local guest_name = self.editbox:getText();
		if string.len(guest_name) == 0 then
			self.callback_reload();
			return;
		end
		local list = self.list or {};
		local nlist = {};
		for i = 1, #list do
			local info = list[i];
			local title = info.title;
			if nil ~= string.find(title, guest_name) then
				table.insert(nlist, info);
			end
		end
		self.list = nlist;
		self:reload();
	end,

	-- set room list
	refresh_list = function(self, channel, list)
		if nil == self.layer then
			return;
		end
		self.list = list;
		self:reload();
	end,

	callback_room = function(lock)
		local self = layer_lwait;
		--print(string.format("lock[%s]", lock));
		-- ' 0 ' means create room
		lock = lock or '';
		--local cmd = 'room ' .. self.c_channel;
		local cmd = 'room 1';
		if 0 < string.len(lock) then
			cmd = cmd .. ' 0 ' .. lock;
		end
		net_send(cmd);
	end,

	callback_create = function()
		play_tap_1();
		local self = layer_lwait;
		local layer, name = layer_lock:create(2, self.callback_room);
		g_scene:add_layer(ZORDER_LAYER_LOCK, layer, name, true); 
	end,

	ask_lock = function(self, index, lock)
		local layer, name = layer_lock:create(1, self.callback_lock, index);
		g_scene:add_layer(ZORDER_LAYER_LOCK, layer, name, true);
	end,

	callback_lock = function(index, input)
		local self = layer_lwait;
		local info = self.list[index];
		if nil == info then
			return;
		end
		input = input or '';
		local rid = info.id;
		local rchannel = info.cid;
		local cmd = 'room ' .. rchannel .. ' ' .. rid .. ' ' .. input;
		net_send(cmd);
	end,

	cb_enter_room = function(...)
		play_tap_1();
		local self = layer_lwait;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		local rid = info.id;
		local pwd_flag = info.pwd_flag;
		-- pwd_flag 0==no password, 1==has password
		local pwd_flag = info.pwd_flag;
		if 1 == pwd_flag then
			self:ask_lock(index, lock);
			return;
		end
		self.callback_lock(index);
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_lwait;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
		elseif eventname == "changed" then
		end
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_lwait;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			--local cell = args[3];
			--local idx = cell:getIdx();
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local info = self.list[idx + 1];
			local rid = info.id;
			local num_guest = info.num_guest;
			local rtitle = info.title;
			local pwd_flag = info.pwd_flag;
			local data2, sprite, path, pos, size, str;
			local list_alias = csplit(rtitle, "~VS~");

			gui_add_sprite_on_cell(cell,data,'c_title',GUI_LWAIT,ANCHOR_DOWN);
			local str_font_size = 24;
			str = list_alias[1] or '';
			if #list_alias == 1 and string.len(str) > 5 then
				-- cut '_room'    e.g  xx_room
				local t = string.sub(str, string.len(str)-4, string.len(str));
				if '_room' == t then
					str = string.sub(str, 1, string.len(str)-5);
				end
			end
			if string.len(str) > 25 then
				str_font_size = 18;
			elseif string.len(str) > 22 then
				str_font_size = 20;
			end
			gui_add_label_on_cell(cell,data,str,str_font_size,'c_name_l',GUI_LWAIT,ANCHOR_DOWN);

			str = '房间人数: ';
			gui_add_label_on_cell(cell,data,str,24,'t_num',GUI_LWAIT,ANCHOR_DOWN);
			path = util.get_path(FT_5);
			str = '' .. num_guest;
			gui_add_labelbmf_on_cell(cell,data,str,path,'n_num',GUI_LWAIT,ANCHOR_DOWN);

			--[[
			if num_guest > 1 then
				str = '状态: 游戏中';
			else
				str = '状态: 准备中';
			end
			]]--
			str = '状态: 准备中';
			gui_add_label_on_cell(cell,data,str,24,'t_state',GUI_LWAIT,ANCHOR_DOWN);
			if 1 == pwd_flag then
				--str = str .. '(已设密码)';
				gui_add_sprite_on_cell(cell,data,'c_lock',GUI_LWAIT,ANCHOR_DOWN);
			end

			gui_add_sprite_on_cell(cell, data,'bg_btn',GUI_LWAIT,ANCHOR_DOWN);
			local items = {};
			local item;

			item, data2 = gui_add_item_on_cell(items, data, 'btn_go', GUI_LWAIT, self.cb_enter_room, ANCHOR_DOWN);
			item:setTag(idx + 1);

			util.add_menu(cell, items, data2.zorder);

			if true == self.do_cell_anim then
				local delay = (idx%10)*0.1;
				keff_showup_1(cell, delay);
			end

			return cell;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_lwait;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
		self.do_cell_anim = false;

	end,
} -- layer_lwait end

layer_lroom = { -- start   list room info 
	name = 'layer_lroom',
	layer = nil,
	lchannel = nil,
	c_channel = 0,
	list = {},
	table_view = nil,
	editbox = nil,
	cwidth = nil,
	cheight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,
	label_channel = nil,
	do_cell_anim = nil,

	cleanup = function(self)
		self.layer = nil;
		self.lchannel = nil;
		self.c_channel = 0;
		self.list = {};
		self.table_view = nil;
		self.channel = 0;
		self.editbox = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
		self.label_channel = nil;
		self.do_cell_anim = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_LROOM, self.handler, true);

		util.add_layer_color(self.layer, cc.c4b(0, 0, 0, 150));
		local data;
		local offsetheight, sprite, rect = init_bg_pop(self.layer, GUI_LROOM, '观战', self.back, nil, true);

		gui_add_sprite(self.layer, 'fade_bottom', GUI_LROOM, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 'bg_room', GUI_LROOM, ANCHOR_UP);

		self.label_channel = gui_add_label(self.layer, '', 22, 't_chn', GUI_LROOM, ANCHOR_UP);
		self.editbox = gui_add_editbox(self.layer, 't_room', GUI_LROOM, ANCHOR_UP, 22, self.editbox_handler, 20, "查找房间");

		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn_refresh', GUI_LROOM, self.callback_reload, ANCHOR_UP);

		item, data = gui_add_item(items, 'bg_chn', GUI_LROOM, self.callback_channel, ANCHOR_UP);
		item, data = gui_add_item(items, 'more_chn', GUI_LROOM, self.callback_channel, ANCHOR_UP);

		item, data = gui_add_item(items, 'btn_room', GUI_LROOM, self.callback_search, ANCHOR_UP);

		util.add_menu(self.layer, items, data.zorder);

		data = gui_get_data('cell', GUI_LROOM, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		data = gui_get_data('table', GUI_LROOM, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.table_view = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);


		return self.layer, self.name;
	end,

	back = function()
		local self = layer_lroom;
		self:remove();
	end,

	reload = function(self)
		self.do_cell_anim = true;
		self.table_view:reloadData();
	end,

	callback_channel = function()
		play_tap_1();
		local self = layer_lroom;
		self.lchannel = self.lchannel or {};
		local l = self.lchannel;
		local c = self.cb_change_channel;
		local layer, name = layer_pick:create(l, c);
		g_scene:add_layer(ZORDER_LAYER_PICK, layer, name, true);
	end,

	callback_reload = function()
		play_tap_1();
		local self = layer_lroom;
		self:change_channel(self.c_channel);
	end,

	callback_search = function()
		play_tap_1();
		local self = layer_lroom;
		local guest_name = self.editbox:getText();
		if string.len(guest_name) == 0 then
			self.callback_reload();
			return;
		end
		local list = self.list or {};
		local nlist = {};
		for i = 1, #list do
			local info = list[i];
			local title = info.title;
			if nil ~= string.find(title, guest_name) then
				table.insert(nlist, info);
			end
		end
		self.list = nlist;
		self:reload();
	end,

	-- set channel list
	set_list_channel = function(self, list)
		self.lchannel = {};
		for i = 1, #(list or {}) do
			local info = list[i];
			info.tag = i;
			table.insert(self.lchannel, info);
		end
		local channel = self.c_channel or 1;
		if 0 >= channel or channel > #list then
			channel = 1;
		end
		self.cb_change_channel(channel);
	end,

	-- set room list
	refresh_list = function(self, channel, list)
		if nil == self.layer then
			return;
		end
		local index = 1;
		for i = 1, #(self.lchannel or {}) do
			local id = self.lchannel[i].cid;
			if tonumber(id) == tonumber(channel) then
				index = i;
			end
		end
		self.c_channel = index;
		self.list = list;
		self:reload();
	end,

	cb_change_channel = function(index)
		local self = layer_lroom;
		local list = self.lchannel;
		local info = list[index];
		if nil == info then return; end
		self.c_channel = index;
		self.label_channel:setString(info.title);
		self:change_channel(index);
	end,

	change_channel = function(self, channel)
		channel = channel or 1;
		local info = self.lchannel[channel];
		if nil == info then
			return;
		end
		channel = info.cid;
		local cmd = 'lroom ' .. channel .. ' 2';
		net_send(cmd);
	end,

	set_channel_name = function(self, item, channel, name)
		local label = item:getChildByTag(TAG_SPRITE_LABEL);
		if nil == label then return; end
		label:setString(name);
	end,

	ask_lock = function(self, index, lock)
		local layer, name = layer_lock:create(1, self.callback_lock, index);
		g_scene:add_layer(ZORDER_LAYER_LOCK, layer, name, true);
	end,

	callback_lock = function(index, input)
		local self = layer_lroom;
		local info = self.list[index];
		if nil == info then
			return;
		end
		input = input or '';
		local rid = info.id;
		local rchannel = info.cid;
		local cmd = 'room ' .. rchannel .. ' ' .. rid .. ' ' .. input;
		net_send(cmd);
	end,

	cb_enter_room = function(...)
		play_tap_1();
		local self = layer_lroom;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		local rid = info.id;
		local pwd_flag = info.pwd_flag;
		-- pwd_flag 0==no password, 1==has password
		local pwd_flag = info.pwd_flag;
		if 1 == pwd_flag then
			self:ask_lock(index, lock);
			return;
		end
		self.callback_lock(index);
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_lroom;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
		elseif eventname == "changed" then
		end
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_lroom;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			--local cell = args[3];
			--local idx = cell:getIdx();
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local info = self.list[idx + 1];
			local rid = info.id;
			local num_guest = info.num_guest;
			local rtitle = info.title;
			local pwd_flag = info.pwd_flag;
			local data2, sprite, path, pos, size, str;
			local list_alias = csplit(rtitle, "~VS~");

			gui_add_sprite_on_cell(cell,data,'c_title',GUI_LROOM,ANCHOR_DOWN);
			local str_font_size = 24;
			str = list_alias[1] or '';
			if #list_alias == 1 and string.len(str) > 5 then
				-- cut '_room'    e.g  xx_room
				local t = string.sub(str, string.len(str)-4, string.len(str));
				if '_room' == t then
					str = string.sub(str, 1, string.len(str)-5);
				end
			end
			if string.len(str) > 25 then
				str_font_size = 18;
			elseif string.len(str) > 22 then
				str_font_size = 20;
			end
			gui_add_label_on_cell(cell,data,str,str_font_size,'c_name_l',GUI_LROOM,ANCHOR_DOWN);

			if nil ~= list_alias[2] then
				str = list_alias[2] or '';
				str_font_size = 24;
				if string.len(str) > 25 then
					str_font_size = 18;
				elseif string.len(str) > 22 then
					str_font_size = 20;
				end
				sprite = gui_add_label_on_cell(cell,data,str,str_font_size,'c_name_r',GUI_LROOM,ANCHOR_DOWN);
				sprite:setHorizontalAlignment(cc.TEXT_ALIGNMENT_RIGHT);

				--str = '对战';
				gui_add_sprite_on_cell(cell, data,'c_vs',GUI_LROOM,ANCHOR_DOWN);
			--else
				--str = '等待中...';
			end
			--sprite = gui_add_label_on_cell(cell,data,str,28,'c_alias',GUI_ARENA,ANCHOR_DOWN, cc.c4b(182, 28, 16, 255));
			--sprite:setHorizontalAlignment(cc.TEXT_ALIGNMENT_CENTER);

			str = '房间人数: ';
			gui_add_label_on_cell(cell,data,str,24,'t_num',GUI_LROOM,ANCHOR_DOWN);
			path = util.get_path(FT_5);
			str = '' .. num_guest;
			gui_add_labelbmf_on_cell(cell,data,str,path,'n_num',GUI_LROOM,ANCHOR_DOWN);

			if num_guest > 1 then
				str = '状态: 游戏中';
			else
				str = '状态: 准备中';
			end
			gui_add_label_on_cell(cell,data,str,24,'t_state',GUI_LROOM,ANCHOR_DOWN);
			if 1 == pwd_flag then
				--str = str .. '(已设密码)';
				gui_add_sprite_on_cell(cell,data,'c_lock',GUI_LROOM,ANCHOR_DOWN);
			end

			gui_add_sprite_on_cell(cell, data,'bg_btn',GUI_LROOM,ANCHOR_DOWN);
			local items = {};
			local item;

			item, data2 = gui_add_item_on_cell(items, data, 'btn_go', GUI_LROOM, self.cb_enter_room, ANCHOR_DOWN);
			item:setTag(idx + 1);

			util.add_menu(cell, items, data2.zorder);

			if true == self.do_cell_anim then
				local delay = (idx%10)*0.1;
				keff_showup_1(cell, delay);
			end

			return cell;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_lroom;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
		self.do_cell_anim = false;

	end,
} -- layer_lroom end

layer_lock = {
	name = 'layer_lock',
	layer = nil,
	callback = nil,
	index = nil,
	toggle = nil,
	rect = nil,

	cleanup = function(self)
		self.layer = nil;
		self.toggle = nil;
		self.rect = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	-- ltype 1 输入密码框  2 创建房间 
	create = function(self, ltype, cb, index)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_LOCK, self.handler, true);

		self.callback = cb;
		self.index = index;
		self.toggle = nil;
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 128));
		local title = '';
		if 1 == ltype then
			title = '进入房间';
		elseif 2 == ltype then
			title = '创建房间';
		else -- 3 == ltype
			title = '???';
		end
		local bgsize = cc.size(540, 390);
		local bg, rect = init_bg_for_popview(self.layer,title,bgsize,self.back,true);
		self.rect = rect;

		local path = util.get_path('bg_156.png');
		local frect = cc.rect(0, 0, 64, 64); -- fullrect
		local irect = cc.rect(30, 30, 4, 4); -- insetrect
		local size = cc.size(467, 165); -- realsize
		local pos = cc.p(35, 132);
		util.add_scale9sprite(bg, path, pos, ANCHOR_LEFT_DOWN, frect, irect, size, 15); 

		if 1 == ltype then
			self:init_asklock(bg, bgsize);
		elseif 2 == ltype then
			self:init_createroom(bg, bgsize);
		end

		return self.layer, self.name;
	end,

	init_asklock = function(self, bg, bgsize)
		local size = cc.size(286, 62);
		local pos = cc.p(127, 196);
		local tip = '请输入密码';
		self.editbox = add_editbox_2(bg, pos, size, tip, 20,self.editbox_handler);

		local items = {};

		add_item_4(items, '确定', nil, 30, self.confirm_ask, ANCHOR_CENTER_DOWN, cc.p(bgsize.width/4, 44));

		add_item_4(items, '取消', nil, 30, self.back, ANCHOR_CENTER_DOWN, cc.p(bgsize.width/4*3, 44));
		
		util.add_menu(bg, items, 50);
	end,

	init_createroom = function(self, bg, bgsize)
		local size = cc.size(286, 62);
		local pos = cc.p(160, 196);
		local tip = '请输入密码';
		self.editbox = add_editbox_2(bg, pos, size, tip, 20,self.editbox_handler);

		local items = {};

		add_item_4(items, '确定', nil, 30, self.confirm_create, ANCHOR_CENTER_DOWN, cc.p(bgsize.width/4, 44));

		add_item_4(items, '取消', nil, 30, self.back, ANCHOR_CENTER_DOWN, cc.p(bgsize.width/4*3, 44));

		local item = add_toggle_1(items, self.callback_use_lock, ANCHOR_LEFT_DOWN, cc.p(80, 200));
		self.toggle = item;
		
		util.add_menu(bg, items, 50);
	end,

	callback_use_lock = function(tag, sender)
		play_tap_3();
		--print('DEBUG callback_use_lock');
		-- self.toggle_info:getSelectedIndex()  0 : off     1 : on
		--print('selected item: tag: %d, index:%d', tag, tolua.cast(sender, "CCMenuItemToggle"):getSelectedIndex());
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_lock;
		local edit = tolua.cast(psender, "cc.EditBox");
		if nil ~= self.toggle then
			local index = self.toggle:getSelectedIndex();
			if 0 == index then
				self.toggle:setSelectedIndex(1);
			end
		end
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
			local str = edit:getText();
			if nil == str or string.len(str) == 0 then
				if nil ~= self.toggle then
					local index = self.toggle:getSelectedIndex();
					if 1 == index then
						self.toggle:setSelectedIndex(0);
					end
				end
			end
		elseif eventname == "changed" then
		end

	end,

	confirm_ask = function()
		play_tap_1();
		local self = layer_lock;
		local input = self.editbox:getText();
		self:back();
		if nil ~= self.callback then
			self.callback(self.index, input);
		end
	end,

	confirm_create = function()
		play_tap_1();
		local self = layer_lock;
		local index = 0;
		if nil ~= self.toggle then
			index = self.toggle:getSelectedIndex();
		end
		local lock = '';
		if 0 ~= index then
			lock = self.editbox:getText();
		end
		self:back();
		if nil ~= self.callback then
			self.callback(lock);
		end
	end,

	back = function()
		play_tap_1();
		local self = layer_lock;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_lock;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil ~= r and (x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2) then
			self.back();
		end
	end,
} -- layer_lock end

layer_code = {
	name = 'layer_code',
	layer = nil,
	rect = nil,

	cleanup = function(self)
		self.layer = nil;
		self.rect = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_CODE, self.handler, true);

		util.add_layer_color(self.layer, cc.c4b(0, 0, 0, 128));
		local title = '兑换码';
		local bgsize = cc.size(540, 390);
		local bg, rect = init_bg_for_popview(self.layer,title,bgsize,self.back,true);
		self.rect = rect;

		local path = util.get_path('bg_156.png');
		local frect = cc.rect(0, 0, 64, 64); -- fullrect
		local irect = cc.rect(30, 30, 4, 4); -- insetrect
		local size = cc.size(467, 165); -- realsize
		local pos = cc.p(35, 132);
		util.add_scale9sprite(bg, path, pos, ANCHOR_LEFT_DOWN, frect, irect, size, 15); 

		size = cc.size(286, 62);
		pos = cc.p(122, 196);
		local tip = '请输入兑换码';
		self.editbox = add_editbox_2(bg, pos, size, tip, 20,self.editbox_handler);

		local items = {};

		add_item_4(items, '确定', nil, 30, self.confirm, ANCHOR_CENTER_DOWN, cc.p(bgsize.width/4, 44));

		add_item_4(items, '取消', nil, 30, self.back, ANCHOR_CENTER_DOWN, cc.p(bgsize.width/4*3, 44));
		
		util.add_menu(bg, items, 50);

		return self.layer, self.name;
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_code;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
		elseif eventname == "changed" then
		end

	end,

	confirm = function()
		play_tap_1();
		local self = layer_code;
		local str = self.editbox:getText() or '';
		str = string.gsub(str, "%s", "");
		if 0 == string.len(str) then
			show_msg("请输入兑换码");
			return;
		end
		--self:back();
		local cmd = 'gift ' .. str;
		net_send(cmd);
	end,

	clean_input = function(self)
		if nil == self.layer then return; end
		if nil == self.editbox then return; end
		self.editbox:setText("");
	end,

	back = function()
		play_tap_1();
		local self = layer_code;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_code;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil ~= r and (x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2) then
			self.back();
		end
	end,
} -- layer_code end

layer_room = { -- start    has a room, wait match
	name = 'layer_room',
	layer = nil,
	list = nil,
	tableview = nil,
	cwidth = nil,
	cheight = nil,
	theight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,
	do_cell_anim = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.theight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
		self.do_cell_anim = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	-- channel, room_id, room_name
	create = function(self, channel, rid, player)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_ROOM, self.handler, true);

		self.list = list or {};
		util.add_layer_color(self.layer, cc.c4b(0, 0, 0, 50));
		local data;
		local offsetheight, sprite, rect = init_bg_pop(self.layer, GUI_ROOM, '房间', self.back, nil, true);
		gui_add_sprite(self.layer, 'fade_bottom', GUI_ROOM, ANCHOR_DOWN);

		data = gui_get_data('cell', GUI_ROOM, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		data = gui_get_data('table', GUI_ROOM, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		local items = {};
		local item, str;

		if player.eid == g_euser.eid then
			item, data = gui_add_item(items, 'btn_start', GUI_ROOM, self.callback_start, ANCHOR_DOWN);
			util.add_stroke_to_sprite_by_data(item, data, "开始", 26, 2);
			--self.btn_start = item;
			enable_btn(item, false);
		else
			str = "等待房主开始对战";
			gui_add_stroke(self.layer, str, 22, 't_wait', GUI_ROOM, ANCHOR_DOWN);
		end

		util.add_menu(self.layer, items, data.zorder);

		items = {};
		item,data=gui_add_item(items, 'chat', GUI_MAIN, self.go_chat, ANCHOR_UP);
		util.add_menu(self.layer, items, 100);

		self:insert_player(player);

		return self.layer, self.name;
	end,

	back = function()
		local self = layer_room;
		self:remove();
		local cmd = 'leave';
		net_send(cmd, true);
	end,

	reload = function(self)
		self.tableview:reloadData();
	end,

	go_chat = function()
		--show_chat(true);
		show_chat();
	end,

	insert_player = function(self, player)
		for i = 1, #self.list do
			if player.eid == self.list[i].eid then
				return;
			end
		end
		local l = {};
		l.eid = player.eid;
		l.alias = player.alias;
		l.icon = player.icon;
		table.insert(self.list, l);
		self:reload();
	end,

	remove_player = function(self, eid)
		for i = 1, #self.list do
			if eid == self.list[i].eid then
				table.remove(self.list, i);
				break;
			end
		end
		self:reload();
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_room;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new();
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local info = self.list[idx + 1];
			local icon = info.icon;
			local eid = info.eid;
			local alias = info.alias;
			local data2, sprite, path, pos, size, str;

			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'icon', GUI_ROOM, ANCHOR_DOWN);
			size = sprite:getContentSize();
			path = get_icon_path(icon);
			pos = cc.p(size.width/2, size.height/2);
			sprite = util.add_sprite(sprite, path,pos,ANCHOR_CENTER_CENTER,-1);
			sprite:setScale((size.width-6)/sprite:getContentSize().width);

			gui_add_sprite_on_cell(cell,data,'bg_alias',GUI_ROOM,ANCHOR_DOWN);
			str = alias;
			gui_add_label_on_cell(cell,data,str,28,'alias',GUI_ROOM,ANCHOR_DOWN);

			if idx + 1 == 1 then
				str = '房主';
			elseif idx + 1 == 2 then
				str = '挑战者';
			else
				str = '观战者';
			end
			gui_add_stroke_on_cell(cell,data,str,28,'pos',GUI_ROOM,ANCHOR_DOWN);

			if idx + 1 > 1 and self.list[1].eid == g_euser.eid then
				local items = {};
				local item;

				gui_add_sprite_on_cell(cell,data,'bg_kick',GUI_ROOM,ANCHOR_DOWN);
				item, data2 = gui_add_item_on_cell(items, data, 'btn_kick', GUI_ROOM, self.kick, ANCHOR_DOWN);
				item:setTag(idx + 1);

				util.add_menu(cell, items, data2.zorder);
			end
			if true == self.do_cell_anim then
				local delay = (idx%10)*0.1;
				keff_showup_1(cell, delay);
			end
			return cell;
		end
	end, -- tableview_handler end }

	kick = function(...)
		local self = layer_room;
		local args = {...};
		local index = args[2]:getTag();
		local player = self.list[index];
		local cmd = 'kick ' .. player.eid;
		net_send(cmd);
	end,

	show_start = function(self)
		if #self.list < 2 then
			return;
		end
		enable_btn(self.btn_start, true);
	end,

	hide_start = function(self, eid)
		self:remove_player(eid);
		if #self.list > 1 then
			return;
		end
		enable_btn(self.btn_start, false);
	end,

	callback_start = function()
		local self = layer_room;

		local cmd = 'game';
		net_send(cmd);
	end,

	handler = function(event, x, y)
		local self = layer_room;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
		self.do_cell_anim = false;

	end,
} -- layer_room end

layer_cchannel = { 
	name = 'layer_cchannel',
	layer = nil,
	info = nil,
	rect = nil,
	list = nil,
	callback = nil,

	cleanup = function(self)
		self.layer = nil;
		self.info = nil;
		self.rect = nil;
		self.list = nil;
		self.callback = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, list, t, callback)
		self:remove();

		self.info = info;
		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_CCHANNEL, self.handler, true);

		util.add_layer_color(self.layer, cc.c4b(0, 0, 0, 200));

		self.callback = callback;
		self.list = {};
		for i = 1, #list do
			local l = list[i];
			if t ~= i then
				table.insert(self.list, { id = l.id, title = l.title, index = i});
			end
		end
		local btn_height = 70;
		local item_list = {};
		for i = 1, #self.list do
			local l = self.list[i];
			table.insert(item_list, { title = l.title, index = l.index });
		end

		local height = 110 + (#item_list * (btn_height + 10));
		local bgsize = cc.size(400, height);--realsize
		local bg,rect=init_bg_for_popview(self.layer,'切换频道',bgsize,self.back);
		self.rect = rect;

		local items = {};

		local gap = btn_height + 5;
		for i = 1, #item_list do
			local l = item_list[i];
			local p = cc.p(bgsize.width/2, bgsize.height-150-gap*(i-1));
			local s = cc.size(bgsize.width - 70, btn_height);
			local item = add_item_1(items, l.title, nil, 30, self.change, ANCHOR_CENTER_CENTER,p,s);
			item:setTag(i);
		end

		pos = cc.p(bgsize.width-20, bgsize.height-20);
		add_item_close(items, pos, ANCHOR_CENTER_CENTER, self.back);

		util.add_menu(bg, items, 20);

		return self.layer, self.name;
	end,

	change = function(...)
		local self = layer_cchannel;
		local args = {...};
		local tag = args[2]:getTag();
		local info = self.list[tag];
		if nil == info then return; end
		if nil ~= self.callback then
			self.callback(info.index);
		end
		self.back();
	end,

	back = function()
		local self = layer_cchannel;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_cchannel;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,
} -- layer_cchannel end

layer_book = { -- start    
	name = 'layer_book',
	layer = nil,
	list_pick_type = {
		{ tag = 1, title = '所有分类' },
		{ tag = 2, title = '英雄' },
		{ tag = 3, title = '附加' },
		{ tag = 4, title = '技能' },
		{ tag = 5, title = '盟军' },
		{ tag = 6, title = '武器' },
		{ tag = 7, title = '防具' },
		{ tag = 8, title = '支援' },
	},
	in_hero = nil,
	in_type = nil,
	list = nil,
	list_phero = nil,
	list_total = nil,
	tableview = nil,
	data_cell = nil,
	clarrow = nil,
	crarrow = nil,
	twidth = nil,
	line = nil,
	side = nil,
	offset = nil,
	label_hero = nil,
	label_type = nil,
	btn_hero = nil,
	cscale = nil,
	my_cards = nil,
	lpercent = nil,
	percent = nil,

	cleanup = function(self)
		self.layer = nil;
		self.in_hero = nil;
		self.in_type = nil;
		self.list = nil;
		self.list_phero = nil;
		self.list_total = nil;
		self.tableview = nil;
		self.data_cell = nil;
		self.clarrow = nil;
		self.crarrow = nil;
		self.twidth = nil;
		self.line = nil;
		self.side = nil;
		self.offset = nil;
		self.label_hero = nil;
		self.label_type = nil;
		self.btn_hero = nil;
		self.cscale = nil;
		self.my_cards = nil;
		self.lpercent = nil;
		self.percent = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, list)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_BOOK, self.handler, true);

		local offsetheight = init_bg_full(self.layer, GUI_BOOK, self.back);

		local sprite, data, pos, size, path;
		sprite,data = gui_add_sprite(self.layer,'outframe',GUI_BOOK,ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));

		gui_add_sprite(self.layer,'subbar',GUI_PIECE,ANCHOR_UP);
		self.label_hero = gui_add_label(self.layer, '', 21, 'hero_name', GUI_BOOK, ANCHOR_UP);
		self.label_type = gui_add_label(self.layer, '', 21, 'type_name', GUI_BOOK, ANCHOR_UP);

		gui_add_sprite(self.layer,'tab_collect',GUI_BOOK,ANCHOR_DOWN);
		sprite, data = gui_add_sprite(self.layer,'bar',GUI_BOOK,ANCHOR_DOWN);
		path = util.get_path(FT_5);
		pos = cc.p(data.width/2, 0);
		self.lpercent = util.add_labelbmf(sprite,"",path,pos,ANCHOR_CENTER_DOWN,20);
		path = util.get_path("bg_158.png");
		sprite = util.add_progress_bar(sprite, util.create_sprite(path), cc.p(0, 0), cc.PROGRESS_TIMER_TYPE_BAR, cc.p(0, 1), cc.p(1, 0), 0, 10);
		sprite:setAnchorPoint(ANCHOR_LEFT_DOWN);
		self.percent = sprite;

		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn_hero', GUI_BOOK, self.pick_hero, ANCHOR_UP);
		self.btn_hero = item;
		self:add_hero_image(0);

		item, data = gui_add_item(items, 'btn_type', GUI_BOOK, self.pick_type, ANCHOR_UP);

		util.add_menu(self.layer, items, data.zorder);

		self.list = {};
		data = gui_get_data('cell', GUI_BOOK, ANCHOR_DOWN);
		local nheight = data.height + offsetheight;
		local sh = nheight/data.height;
		self.cscale = sh;
		data.width = data.width * sh;
		data.height = data.height * sh;
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height;
		data = gui_get_data('table', GUI_BOOK, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		self.twidth = size.width;
		self.line = pos.y + size.height/2;
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		self.clarrow, self.crarrow = util.add_arrows(self.layer, pos, size, self.cwidth, 0, cc.p(0, 0));

		return self.layer, self.name;
	end,

	syn_hero_list = function(self, new_index)
		-- layer_book
		new_index = (new_index or self.in_hero) or 1;
		local nlist = {};
		local list = self.list_total;
		local tag = new_index;
		if 0 == tag then -- all kind of type
			for i = 1, #list do
				table.insert(nlist, list[i]);
			end
		else
			local cid = tag;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		end
		self.list = nlist;
		self.list_phero = self.list;
		return self.list;
	end,

	syn_type_list = function(self, new_index)
		-- layer_book
		new_index = (new_index or self.in_type) or 1;
		local nlist = {};
		local list = self.list_phero or self.list;
		local info = self.list_pick_type[new_index];
		local tag = info.tag;
		print('tag: ', tag);
		if 1 == tag then -- all kind of type
			for i = 1, #list do
				table.insert(nlist, list[i]);
			end
		elseif 2 == tag then -- hero 
			for i = 1, #list do
				local card = list[i].card;
				if HERO == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 3 == tag then -- attach 
			for i = 1, #list do
				local card = list[i].card;
				if ATTACH == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 4 == tag then -- ability 
			for i = 1, #list do
				local card = list[i].card;
				if ABILITY == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 5 == tag then -- ally 
			for i = 1, #list do
				local card = list[i].card;
				if ALLY == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 6 == tag then -- weapon 
			for i = 1, #list do
				local card = list[i].card;
				if WEAPON == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 7 == tag then -- armor 
			for i = 1, #list do
				local card = list[i].card;
				if ARMOR == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 8 == tag then -- SUPPORT 
			for i = 1, #list do
				local card = list[i].card;
				if SUPPORT == card.ctype or TRAP == card.ctype or ARTIFACT == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		end
		self.list = nlist;
		return self.list;
	end,

	change_pick_type = function(self, new_index)
		-- layer_book
		new_index = new_index or 1;
		local titles = self.list_pick_type or {};
		if 0 == titles then return; end

		local info = titles[new_index];
		if nil == info then return; end
		local name = info.title;
		self.label_type:setString(name);

		if new_index ~= self.in_type then
			self.offset = nil;
		end
		self.in_type = new_index;

		self:syn_type_list(new_index);
		self:reload();
	end,

	add_hero_image = function(self, hid)
		-- layer_book
		local btn = self.btn_hero;
		local fname, path, pic, pos;
		pic = btn:getChildByTag(97);
		if nil ~= pic then
			pic:removeFromParent(true);
		end
		if hid == 0 then
			fname = 'pic_94.png';
		else
			fname = 'card' .. hid .. '.png';
		end
		path = util.get_path(fname, 'card0.png');
		local mask_path = util.get_path('bg_160.png');
		local size = btn:getContentSize();
		pos = cc.p(size.width/2, size.height/2);
		pic = util.add_mask_sprite(btn, path, mask_path, pos, ANCHOR_CENTER_CENTER, -1);
		pic:setTag(97);
		pic:setScale(size.height/pic:getContentSize().height);
	end,

	change_hero = function(self, hid, name, in_type)
		-- layer_book
		hid = hid or 0;
		self:add_hero_image(hid);
		if hid ~= self.in_hero then
			name = name or "???";
			self.label_hero:setString(name);
		end
		self.in_hero = hid;
		self:syn_hero_list(hid);
		self:reload();

		self.in_type = in_type or self.in_type;
		self:change_pick_type(self.in_type);
	end,

	cb_change_hero = function(...)
		local self = layer_book;
		self:change_hero(...);
	end,

	pick_hero = function()
		local self = layer_book;
		local t = layer_hero.TYPE_SORT;
		local cb = self.cb_change_hero;
		g_scene:add_layer(ZORDER_LAYER_HERO, layer_hero:create(t, cb));
		net_send("lhero"); 
		--g_scene:hero(layer_hero.TYPE_SORT);
		layer_hero.mark_hero_index = self.in_hero;
		layer_hero.mark_type_index = self.in_type;
		layer_hero.mark_hero_name = self.label_hero:getString();
	end,

	callback_pick_type = function(index)
		local self = layer_book;
		self:change_pick_type(index);
	end,

	pick_type = function()
		local self = layer_book;
		local cb = self.callback_pick_type;
		local list = self.list_pick_type;
		local layer, name = layer_pick:create(list, cb);
		g_scene:add_layer(ZORDER_LAYER_PICK, layer, name, true);
	end,

	reload = function(self)
		-- layer_book
		local offset = self.offset;
		self.tableview:reloadData();
		if nil ~= offset then
			self.tableview:setContentOffset(offset, false);
		end
	end,

	refresh_list = function(self, list)
		self.my_cards = c_str_array_2(g_euser.all_str);	
		local percent = #self.my_cards/(#(hero_list or {})+#(g_card_list or {}));
		percent = math.floor(percent*100);
		self.lpercent:setString(string.format("%d%%", percent));
		self.percent:setPercentage(percent);
		local list = hero_list;
		self.list_total = {};
		--for i = 1, 20 do
		for _, rc in pairs(hero_list) do
			--local rc = hero_list[i];
			if nil ~= rc and nil ~= rc.ctype and nil ~= rc.id then
				local info = { card = clone(rc) };
				table.insert(self.list_total, info);
			end
		end
		--for i = 20, 400 do
		for _, rc in pairs(g_card_list) do
			--local rc = g_card_list[i];
			if nil ~= rc and nil ~= rc.ctype and nil ~= rc.id then
				local info = { card = clone(rc) };
				table.insert(self.list_total, info);
			end
		end
		self.list = {};
		for i = 1, #self.list_total do
			local info = self.list_total[i];
			table.insert(self.list, info);
		end
		self:change_hero(0, "所有英雄");
		self:change_pick_type(self.in_type);
	end,

	back = function()
		play_tap_1();
		g_scene:map();
	end,

	is_has_card = function(self, cid)
		for i = 1, #self.my_cards do
			local info = self.my_cards[i];
			if info.cid == cid and info.count >= 0 then
				return info.count;
			end
		end
		return 0;
	end,

	sort_list = function(self)
		local list = self.list_total or {};
		local nlist = {};
		--[[
		for i = #list, 1, -1 do
			local info = list[i];
			local has = info.current_piece_count;
			if has > 0 then
				table.insert(nlist, 1, info);
			else
				table.insert(nlist, info);
			end
		end
		]]--
		self.list_total = nlist;
		self:change_hero(self.in_hero, self.label_hero:getString());
		self:change_pick_type(self.in_type);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_book;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return math.ceil(#(self.list or {})/2);
		elseif "scrollViewDidScroll" == event then
			local len = math.ceil(#self.list / 2);
			local offset = view:getContentOffset();
			self.offset = offset;
			util.handle_arrows(self.clarrow, self.crarrow, len, self.cwidth, self.twidth, offset);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local index = idx*2 + 1;
			if 2 == self.side then -- down
				index = index + 1;
			elseif 1 == self.side then -- up
				print('is_up');
			else
				return;
			end
			local info = self.list[index];
			if nil == info then
				return;
			end
			local card = clone(info.card);
			g_scene:add_layer(ZORDER_LAYER_MISPOP, layer_mispop:create(card));
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local index = idx*2 + 1;
			local data = self.data_cell;
			local hh = height/2;
			local size;
			local len = index+1;
			if len > #self.list then len = #self.list; end
			for i = index, len do
				local info = self.list[i];
				local card = info.card;
				local basey = 0;
				if i % 2 ~= 0 then
					basey = hh;
				end
				local sprite, data2, path;
				local frame, fdata;
				frame, fdata = gui_add_sprite_on_cell(cell, data, 'cframe', GUI_BOOK, ANCHOR_DOWN);
				frame:setAnchorPoint(ANCHOR_CENTER_CENTER)
				local s = frame:getContentSize();
				local ws = (width-(data.width-fdata.width))/s.width;
				local wh = (height-(data.height-fdata.height))/s.height;
				if ws < wh then
					scale = ws;
				else
					scale = wh;
				end
				frame:setScale(scale*self.cscale);
				frame:setPosition(cc.p(fdata.x+width/2, fdata.y+fdata.height*self.cscale/2+basey));
				local fname = 'card' .. card.id .. '.png';
				path = util.get_path(fname, 'card0.png');
				local mask_path = util.get_path('bg_155.png');
				pos = ccp(s.width/2, s.height/2);
				local pic = util.add_mask_sprite(frame, path, mask_path, pos, ANCHOR_CENTER_CENTER, -1);
				pic:setScale(s.height/pic:getContentSize().height);

				add_detail_for_show_frame(frame, card);

				local count = self:is_has_card(card.id);
				info.count = count;
				path = util.get_path(FT_8);
				str = '*' .. count;
				util.add_labelbmf(frame, str, path, cc.p(s.width-10, s.height/2), ANCHOR_RIGHT_CENTER, 100);
				if count == 0 then
					util.set_gray(frame);
					local list = frame:getChildren();
					for i = 1, #list do
						local s = list[i];
						if "cc.Label" ~= tolua.type(s) then
							util.set_gray(s);
						end
					end
				end
			end
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_book;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function (self, x, y)
		if y > self.line then
			self.side = 1; -- up
		else
			self.side = 2; -- down
		end
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
	end,
	
	onTouchEnded = function(self, x, y)
	end,

} -- layer_book end

layer_book2 = { -- start    
	name = 'layer_book',
	PAGE_SIZE = 12,
	layer = nil,
	list_pick_hero = {
		{ tag = 1, title = '所有英雄' },
		--[[ -- set in layer_shop add_to_list
		{ tag = 2, title = '盖伦' },
		{ tag = 3, title = '瑞雯' },
		{ tag = 4, title = '宙斯' },
		{ tag = 5, title = '莉莱' },
		{ tag = 6, title = '娑娜' },
		{ tag = 7, title = '特朗德尔' },
		{ tag = 8, title = '安妮' },
		]]--
	},
	list_pick_type = {
		{ tag = 1, title = '所有分类' },
		{ tag = 2, title = '英雄' },
		{ tag = 3, title = '附加' },
		{ tag = 4, title = '技能' },
		{ tag = 5, title = '盟军' },
		{ tag = 6, title = '武器' },
		{ tag = 7, title = '防具' },
		{ tag = 8, title = '支援' },
	},
	in_hero_buy = nil,
	in_type_buy = nil,
	in_hero_sell = nil,
	in_type_sell = nil,
	list = nil,
	list_phero = nil,
	list_shop = nil,
	tableview = nil,
	last_id = 0,
	tap_buy = nil,
	tap_sell = nil,
	kind = nil,
	KIND_BUY = 1,
	KIND_SELL = 2,
	my_cards = nil,
	clarrow = nil,
	crarrow = nil,
	twidth = nil,
	line = nil,
	side = nil,
	offset = nil,
	offset_buy = nil,
	offset_sell = nil,
	label_hero = nil,
	label_type = nil,

	cleanup = function(self)
		self.layer = nil;
		self.in_hero_buy = nil;
		self.in_type_buy = nil;
		self.in_hero_sell = nil;
		self.in_type_sell = nil;
		self.list = nil;
		self.list_phero = nil;
		self.list_shop = nil;
		self.tableview = nil;
		self.last_id = 0;
		self.tap_buy = nil;
		self.tap_sell = nil;
		self.kind = nil;
		self.my_cards = nil;
		self.clarrow = nil;
		self.crarrow = nil;
		self.twidth = nil;
		self.line = nil;
		self.side = nil;
		self.offset = nil;
		self.offset_buy = nil;
		self.offset_sell = nil;
		self.label_hero = nil;
		self.label_type = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_BOOK, self.handler, true);

		self.my_cards = c_str_array_2(g_euser.all_str);	

		local offsetheight = init_bg_full(self.layer, GUI_BOOK, self.back);

		local sprite, data, pos, size, path;
		sprite,data = gui_add_sprite(self.layer,'outframe',GUI_BOOK,ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));

		gui_add_sprite(self.layer,'subbar',GUI_BOOK,ANCHOR_UP);
		self.label_hero = gui_add_label(self.layer, '', 21, 'hero_BOOK', GUI_PMYSTERY, ANCHOR_UP);
		self.label_type = gui_add_label(self.layer, '', 21, 'type_BOOK', GUI_PMYSTERY, ANCHOR_UP);

		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn_hero', GUI_BOOK, self.pick_hero, ANCHOR_UP);
		self.btn_hero = item;
		self:add_hero_image(0);

		item, data = gui_add_item(items, 'btn_type', GUI_BOOK, self.pick_type, ANCHOR_UP);

		util.add_menu(self.layer, items, data.zorder);

		self.list = {};
		data = gui_get_data('cell', GUI_BOOK, ANCHOR_DOWN);
		local nheight = data.height + offsetheight;
		local sh = nheight/data.height;
		self.cscale = sh;
		data.width = data.width * sh;
		data.height = data.height * sh;
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height;
		data = gui_get_data('table', GUI_BOOK, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		self.twidth = size.width;
		self.line = pos.y + size.height/2;
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		self.clarrow, self.crarrow = util.add_arrows(self.layer, pos, size, self.cwidth, 0, cc.p(0, 0));
		--[[
		-- btn back set in g_scene.shop
		init_bg_for_full_view(self.layer, GUI_SHOP, '图鉴');
		local sprite, pos, size, data;
		local d1 = gui_get_data('bg_table', GUI_SHOP, ANCHOR_UP);
		local d2 = gui_get_data('bg_table', GUI_SHOP, ANCHOR_DOWN);
		local offsety = d1.y - d2.y;
		gui_add_sprite(self.layer, 'bg_table', GUI_SHOP, ANCHOR_UP, -offsety, offsety);
		gui_add_sprite(self.layer, 'bg_bottom', GUI_SHOP, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 'bg_hero', GUI_SHOP, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 'bg_kind', GUI_SHOP, ANCHOR_DOWN);
		self.label_hero = gui_add_label(self.layer, '', 23, 't_hero', GUI_SHOP, ANCHOR_DOWN);
		self.label_type = gui_add_label(self.layer, '', 23, 't_kind', GUI_SHOP, ANCHOR_DOWN);

		local items = {};
		local item;

		--item, data = gui_add_item(items, 'reload', GUI_SHOP, self.callback_reloadlist, ANCHOR_UP);

		item, data = gui_add_item(items, 'tab_buy', GUI_SHOP, self.callback_buy, ANCHOR_UP);
		gui_add_text_outline_on_sprite(item, "卡牌", 't_buy', GUI_SHOP, ANCHOR_UP, 30);
		self.tap_buy = item;

		item, data = gui_add_item(items, 'tab_sell', GUI_SHOP, self.callback_sell, ANCHOR_UP);
		gui_add_text_outline_on_sprite(item, "售卖", 't_sell', GUI_SHOP, ANCHOR_UP, 30);
		self.tap_sell = item;
		self.tap_sell:setVisible(false);

		item, data = gui_add_item(items, 'more_hero', GUI_SHOP, self.pick_hero, ANCHOR_DOWN);

		item, data = gui_add_item(items, 'more_kind', GUI_SHOP, self.pick_type, ANCHOR_DOWN);

		util.add_menu(self.layer, items, data.zorder);

		self.callback_buy(0, self.tap_buy);

		self.list = {};
		data = gui_get_data('table', GUI_SHOP, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsety);
		-----------
		self.r_table = { x = data.x, y = data.y, offsety = offsety,
						 width = data.width, height = data.height + offsety };
		-----------
		local dcard = gui_get_data('card', GUI_SHOP, ANCHOR_DOWN);
		self.cwidth = dcard.width / dcard.height * (dcard.height + offsety/2);
		self.cheight = data.height + offsety;

		self.twidth = size.width;
		self.line = pos.y + size.height/2;
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		self.clarrow, self.crarrow = util.add_arrows(self.layer, pos, size, self.cwidth, 0, cc.p(0, 0));
		]]--

		return self.layer, self.name;
	end,

	syn_hero_list = function(self, new_index)
		-- layer_book
		new_index = (new_index or self.in_hero) or 1;
		local nlist = {};
		local list = self.list_shop or {};
		local info = self.list_pick_hero[new_index];
		local tag = info.tag;
		if 1 == tag then -- all kind of type
			for i = 1, #list do
				table.insert(nlist, list[i]);
			end
		elseif 2 == tag then -- hero id 1 GaiLun
			local cid = 1;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		elseif 3 == tag then -- hero id 2 RuiWen
			local cid = 2;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		elseif 4 == tag then -- hero id 5 ZhouSi
			local cid = 5;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		elseif 5 == tag then -- hero id 6 LaiLi
			local cid = 6;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		elseif 6 == tag then -- hero id 8 SuoNa
			local cid = 8;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		elseif 7 == tag then -- hero id 11 TeLangDeEr
			local cid = 11;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		elseif 8 == tag then -- hero id 15 AnNi
			local cid = 15;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		end
		self.list = nlist;
		self.list_phero = self.list;
		return self.list;
	end,

	syn_type_list = function(self, new_index)
		new_index = (new_index or self.in_type) or 1;
		local nlist = {};
		local list = self.list_phero or self.list;
		local info = self.list_pick_type[new_index];
		local tag = info.tag;
		if 1 == tag then -- all kind of type
			for i = 1, #list do
				table.insert(nlist, list[i]);
			end
		elseif 2 == tag then -- hero 
			for i = 1, #list do
				local card = list[i].card;
				if HERO == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 3 == tag then -- attach 
			for i = 1, #list do
				local card = list[i].card;
				if ATTACH == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 4 == tag then -- ability 
			for i = 1, #list do
				local card = list[i].card;
				if ABILITY == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 5 == tag then -- ally 
			for i = 1, #list do
				local card = list[i].card;
				if ALLY == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 6 == tag then -- weapon 
			for i = 1, #list do
				local card = list[i].card;
				if WEAPON == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 7 == tag then -- armor 
			for i = 1, #list do
				local card = list[i].card;
				if ARMOR == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 8 == tag then -- SUPPORT 
			for i = 1, #list do
				local card = list[i].card;
				if SUPPORT == card.ctype or TRAP == card.ctype or ARTIFACT == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		end
		self.list = nlist;
		return self.list;
	end,

	change_hero_type = function(self, new_index)
		new_index = new_index or 1;
		local titles = self.list_pick_hero or {};
		if 0 == titles then return; end

		local info = titles[new_index];
		if nil == info then return; end
		local name = info.title;
		self.label_hero:setString(name);

		if self.kind == self.KIND_BUY then
			if new_index ~= self.in_hero_buy then
				self.offset_buy = nil;
			end
			self.in_hero_buy = new_index;
		else
			if new_index ~= self.in_hero_sell then
				self.offset_sell = nil;
			end
			self.in_hero_sell = new_index;
		end

		local list = self.list or {};
		if 0 == #list then return; end

		self:syn_hero_list(new_index);
		self:reload();
	end,

	change_pick_type = function(self, new_index)
		new_index = new_index or 1;
		local titles = self.list_pick_type or {};
		if 0 == titles then return; end

		local info = titles[new_index];
		if nil == info then return; end
		local name = info.title;
		self.label_type:setString(name);

		if self.kind == self.KIND_BUY then
			if new_index ~= self.in_type_buy then
				self.offset_buy = nil;
			end
			self.in_type_buy = new_index;
		else
			if new_index ~= self.in_type_sell then
				self.offset_sell = nil;
			end
			self.in_type_sell = new_index;
		end

		local list = self.list or {};
		if 0 == #list then return; end

		self:syn_type_list(new_index);
		self:reload();
	end,

	callback_pick_hero = function(index)
		local self = layer_book;
		self:change_hero_type(index);
		local pindex;
		if self.kind == self.KIND_BUY then
			pindex = self.in_type_buy;
		else
			pindex = self.in_type_sell;
		end
		self:change_pick_type(pindex);
	end,

	pick_hero = function()
		local self = layer_book;
		local cb = self.callback_pick_hero;
		local list = self.list_pick_hero;
		local layer, name = layer_pick:create(list, cb);
		g_scene:add_layer(ZORDER_LAYER_PICK, layer, name, true);
	end,

	callback_pick_type = function(index)
		local self = layer_book;
		self:change_pick_type(index);
	end,

	pick_type = function()
		local self = layer_book;
		local cb = self.callback_pick_type;
		local list = self.list_pick_type;
		local layer, name = layer_pick:create(list, cb);
		g_scene:add_layer(ZORDER_LAYER_PICK, layer, name, true);
	end,

	reload = function(self)
		local offset;
		if true ~= SHOP_PAGE then
			if self.kind == self.KIND_BUY then
				offset = self.offset_buy;
			else -- self.KIND_SELL
				offset = self.offset_sell;
			end
		else
			offset = self.offset;
		end
		self.tableview:reloadData();
		if nil ~= offset then
			self.tableview:setContentOffset(offset, false);
		end
	end,

	callback_reloadlist = function()
		play_tap_3();
		local self = layer_book;
		g_list_shop = {};
		if true ~= SHOP_PAGE then
			self.list_shop = {};
			self.list = {};
			self.callback_buy(0, self.tap_buy);
			self.offset_buy = nil;
			self.offset_sell = nil;
			-- total 400 cards
			-- each turn get 40 , 10 times
			local p = 40;
			local t = math.ceil(CARD_ARRAY_LIST / p);
			g_list_shop.last_id = t;
			for i = 1, t do
				local cmd = 'shop ' .. (1+p*(i-1)) .. ' ' .. p;
				net_send(cmd);
			end
		else
			self.list = {};
			self.offset = nil;
			-- each page has 4 cards (show 6);
			-- first time get 4 * 3 = 12 cards;
			local cmd = 'shop 1 ' .. layer_shop.PAGE_SIZE;
			net_send(cmd);
		end
	end,

	set_buy_list = function(self)
		self.list = {};
		for i = 1, #self.list_shop do
			local info = self.list_shop[i];
			table.insert(self.list, info);
		end
		self:change_hero_type(self.in_hero_buy);
		self:change_pick_type(self.in_type_buy);
	end,

	set_sell_list = function(self)
		self.list = {};
		for i = 1, #self.list_shop do
			local info = self.list_shop[i];
			local count = self:is_has_card(info.card.id);
			if count > 0 then
				table.insert(self.list, info);
			end
		end
		self:change_hero_type(self.in_hero_sell);
		self:change_pick_type(self.in_type_sell);
	end,

	callback_buy = function(tag, sender)
		play_tap_3();
		local self = layer_book;
		--local toggle = tolua.cast(sender, "CCMenuItemToggle");
		self.kind = self.KIND_BUY;
		local index = self.tap_sell:getSelectedIndex();
		if 0 == index then
			self.tap_buy:setSelectedIndex(1);
			return;
		end
		self.tap_buy:setSelectedIndex(1);
		self.tap_sell:setSelectedIndex(0);
		if true ~= SHOP_PAGE then
			self:set_buy_list();
		else
			self:reload();
		end
	end,

	callback_sell = function(tag, sender)
		play_tap_3();
		local self = layer_book;
		if g_euser.level < 10 then
			show_msg('10级开启');
			self.tap_sell:setSelectedIndex(0);
			return;
		end
		--local toggle = tolua.cast(sender, "CCMenuItemToggle");
		self.kind = self.KIND_SELL;
		local index = self.tap_buy:getSelectedIndex();
		if 0 == index then
			self.tap_sell:setSelectedIndex(1);
			return;
		end
		self.tap_sell:setSelectedIndex(1);
		self.tap_buy:setSelectedIndex(0);
		if true ~= SHOP_PAGE then
			self:set_sell_list();
		end
		self:reload();
	end,

	add_to_list = function(self, list, last_id)
		--print('last_id: ', last_id);
		if true ~= SHOP_PAGE then
			self.list_shop = self.list_shop or {};
			if #self.list_shop > 0 then
				return;
			end
			self.list_pick_hero = { { tag = 1, title = '所有英雄' } };
			for i = 1, #list do
				local info = list[i];
				table.insert(self.list_shop, info);
				if info.card.ctype == HERO then
					local tag = info.card.id;
					local title = info.card.name;
					table.insert(self.list_pick_hero, {tag=i+1, title=title});
				end
			end
			if self.kind == self.KIND_BUY then
				self:set_buy_list();
				--self:reload();
			else
				self.callback_buy(0, self.tap_buy);
			end
			return;
		end
		self.list = self.list or {};
		self.last_id = last_id;
		if 0 == #list then
			--self.last_id = -1; -- -1 means don't need to send requst again
			if -1 == self.last_id then
				return;
			end
			local card_id = self.last_id + 1;
			local cmd = 'shop ' .. card_id .. ' ' .. self.PAGE_SIZE;
			net_send(cmd);
			return;
		end
		if 0 < #self.list then
			local m = self.list[#self.list];
			if true == m.flag_more_cell then
				table.remove(self.list, #self.list);
			end
			m = self.list[#self.list];
			if true == m.flag_more_cell then
				table.remove(self.list, #self.list);
			end
		end
		for i = 1, #list do
			table.insert(self.list, list[i]);
		end
		if self.PAGE_SIZE == #list then
			local hlen = (#self.list)%2;
			local more_cell = { flag_more_cell = true };
			table.insert(self.list, more_cell);
			if 1 == hlen then
				more_cell = { flag_more_cell = true };
				table.insert(self.list, more_cell);
			end
		end
	end,

	back = function()
		play_tap_1();
		layer_book:remove();
	end,

	is_has_card = function(self, cid)
		for i = 1, #self.my_cards do
			local info = self.my_cards[i];
			if info.cid == cid and info.count >= 0 then
				return info.count;
			end
		end
		return 0;
	end,

	update_my_cards = function(self, cid, count)
		for i = 1, #self.my_cards do
			local info = self.my_cards[i];
			local mid = info.cid;
			if mid == cid then
				info.count = info.count + count;
				if 0 >= info.count then
					table.remove(self.my_cards, i);
				end
				if self.kind == self.KIND_BUY then
					self:set_buy_list();
				else -- self.kind == self.KIND_SELL
					self:set_sell_list();
				end
				--self:reload();
				return;
			end
		end
		table.insert(self.my_cards, { cid = cid, count = count });
		if self.kind == self.KIND_BUY then
			self:set_buy_list();
		else -- self.kind == self.KIND_SELL
			self:set_sell_list();
		end
		--self:reload();
	end,

	get_more = function()
		local self = layer_book;
		local card_id = self.last_id + 1;
		local cmd = 'shop ' .. card_id .. ' ' .. self.PAGE_SIZE;
		net_send(cmd);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_book;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return math.ceil(#(self.list or {})/2);
		elseif "scrollViewDidScroll" == event then
			local len = math.ceil(#self.list / 2);
			local offset = view:getContentOffset();
			if true ~= SHOP_PAGE then
				if self.kind == self.KIND_BUY then
					self.offset_buy = offset;
				else -- self.KIND_SELL
					self.offset_sell = offset;
				end
			else
				self.offset = offset;
			end
			util.handle_arrows(self.clarrow, self.crarrow, len, self.cwidth, self.twidth, offset);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local index = idx*2 + 1;
			if 2 == self.side then -- down
				index = index + 1;
			elseif 1 == self.side then -- up
			else
				return;
			end
			local info = self.list[index];
			if nil == info then
				return;
			end
			if true == SHOP_PAGE then
				if true == info.flag_more_cell then
					return;
				end
			end
			info.kind = self.kind;
			--g_scene:add_layer(ZORDER_LAYER_SHOPPOP, layer_shoppop:create(info));
			g_scene:add_layer(ZORDER_LAYER_MISPOP,layer_mispop:create(info.card));
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local index = idx*2 + 1;
			if true == SHOP_PAGE and true == self.list[index].flag_more_cell then
				local items = {};

				add_item_1(items, '更多', nil, 20, self.get_more,ANCHOR_CENTER_CENTER,pos);

				util.add_menu(cell, items, 1);
				return cell;
			end
			local size;
			for i = index, index+1 do
				local info = self.list[i];
				if nil == info or true == info.flag_more_cell then
					break;
				end
				local card = clone(info.card);
				local basey = 0;
				if i % 2 == 0 then
					basey = height/2;
				end
				local s, d; -- sprite, data
				local d = gui_get_data('card', GUI_SHOP, ANCHOR_DOWN);
				r = self.r_table;
				local offsety = r.offsety;
				local offset = -r.y-basey+offsety/2;
				local scale = (d.height + offsety/2) / CARD_SIZE.height;
				local pos = cc.p(width/2, d.y+offset+CARD_SIZE.height*scale/2);
				pos.y = pos.y-hfix(30);
				local cinfo = object_card:new(cell, card, nil, nil, pos, 0, scale, STYPE_VER_1);
				local sprite = cinfo:get_front();
				self.list[i].info = cinfo;
				self.list[i].sprite = sprite;

				--[[
				local gold, crystal, path;
				if self.kind == self.KIND_BUY then
					gold = math.abs(info.c_buygold);
					crystal = math.abs(info.c_buycrystal);
				else -- self.KIND_SELL
					gold = info.c_sellgold;
					crystal = info.c_sellcrystal;
				end
				self.list[i].gold = gold;
				self.list[i].crystal = crystal;
				path = util.get_path(FNT_1);
				local gapy = 10 * sprite:getScale();
				scale = 0;
				if gold > 0 then
					s, d = gui_add_sprite(cell, 'bg_gold', GUI_SHOP, ANCHOR_DOWN);
					s:setPosition(cc.p(d.x-r.x, d.y+offset));
					local w = width/s:getContentSize().width;
					local h = d.height/s:getContentSize().height;
					if w > h then
						scale = h;
					else
						scale = w;
					end
					s:setScale(scale);
					s, d = gui_add_sprite(cell, 'icon_gold',GUI_SHOP,ANCHOR_DOWN);
					s:setPosition(cc.p(d.x-r.x, d.y+offset));
					s:setScale(scale);

					s, d = gui_add_labelbmf(cell, gold, path,'num_gold',GUI_SHOP,ANCHOR_DOWN);
					s:setPosition(cc.p(d.x-r.x, d.y+offset));
					s:setScale(scale);
				end
				if crystal > 0 then
					s, d = gui_add_sprite(cell,'bg_crystal',GUI_SHOP,ANCHOR_DOWN);
					s:setPosition(cc.p(d.x-r.x, d.y+offset));
					if 0 == scale then
						local w = width/s:getContentSize().width;
						local h = d.height/s:getContentSize().height;
						if w > h then
							scale = h;
						else
							scale = w;
						end
					end
					s:setScale(scale);
					s,d=gui_add_sprite(cell,'icon_crystal',GUI_SHOP,ANCHOR_DOWN);
					s:setPosition(cc.p(d.x-r.x, d.y+offset));
					s:setScale(scale);
				
					s, d = gui_add_labelbmf(cell, crystal, path,'num_crystal',GUI_SHOP,ANCHOR_DOWN);
					s:setPosition(cc.p(d.x-r.x, d.y+offset));
					s:setScale(scale);
				end
				]]--

				local count = self:is_has_card(cinfo.card.id);
				self.list[i].count = count;
				path = util.get_path('font_deck_num.fnt');
				pos = cc.p(width/4*3, height/4*3-basey+10);
				count = '*' .. count;
				s=util.add_labelbmf(cell,count,path,pos,ANCHOR_CENTER_CENTER,100);
				if wfix(1) > hfix(1) then
					s:setScale(hfix(1));
				else
					s:setScale(wfix(1));
				end
			end
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_book;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function (self, x, y)
		if y > self.line then
			self.side = 1; -- up
		else
			self.side = 2; -- down
		end
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
	end,
	
	onTouchEnded = function(self, x, y)
		--[[
		if -1 == self.last_id then
			return;
		end
		local len = #(self.list or {});
		if 0 == len then
			return;
		end
		len = math.ceil(len / 2);
		local offset = self.tableview:getContentOffset();
		local line = math.floor(self.cwidth * (len-3) - self.twidth);
		if offset.x + line <= 0 then
			local card_id = self.last_id + 1;
			local cmd = 'shop ' .. card_id .. ' ' .. self.PAGE_SIZE;
			net_send(cmd);
		end
		]]--
	end,

} -- layer_book end

layer_shop = { -- start    
	name = 'layer_shop',
	PAGE_SIZE = 12,
	layer = nil,
	list_pick_type = {
		{ tag = 1, title = '所有分类' },
		{ tag = 2, title = '英雄' },
		{ tag = 3, title = '附加' },
		{ tag = 4, title = '技能' },
		{ tag = 5, title = '盟军' },
		{ tag = 6, title = '武器' },
		{ tag = 7, title = '防具' },
		{ tag = 8, title = '支援' },
	},
	in_hero_buy = nil,
	in_type_buy = nil,
	in_hero_sell = nil,
	in_type_sell = nil,
	in_hero = nil,
	list = nil,
	list_phero = nil,
	list_shop = nil,
	tableview = nil,
	last_id = 0,
	tap_buy = nil,
	tap_sell = nil,
	kind = nil,
	KIND_BUY = 1,
	KIND_SELL = 2,
	my_cards = nil,
	clarrow = nil,
	crarrow = nil,
	twidth = nil,
	line = nil,
	side = nil,
	offset = nil,
	offset_buy = nil,
	offset_sell = nil,
	label_hero = nil,
	label_type = nil,
	btn_hero = nil,
	data_cell = nil,
	cwidth = nil,
	cheight = nil,

	cleanup = function(self)
		self.layer = nil;
		self.in_hero_buy = nil;
		self.in_type_buy = nil;
		self.in_hero_sell = nil;
		self.in_type_sell = nil;
		self.in_hero = nil;
		self.list = nil;
		self.list_phero = nil;
		self.list_shop = nil;
		self.tableview = nil;
		self.last_id = 0;
		self.tap_buy = nil;
		self.tap_sell = nil;
		self.kind = nil;
		self.my_cards = nil;
		self.clarrow = nil;
		self.crarrow = nil;
		self.twidth = nil;
		self.line = nil;
		self.side = nil;
		self.offset = nil;
		self.offset_buy = nil;
		self.offset_sell = nil;
		self.label_hero = nil;
		self.label_type = nil;
		self.btn_hero = nil;
		self.data_cell = nil;
		self.cwidth = nil;
		self.cheight = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_SHOP, self.handler, true);


		self.kind = self.KIND_BUY;

		local offsetheight = init_bg_full(self.layer, GUI_SHOP, self.back);

		local sprite, data, pos, size, path;
		sprite,data = gui_add_sprite(self.layer,'outframe',GUI_SHOP,ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));

		gui_add_sprite(self.layer,'subbar',GUI_SHOP,ANCHOR_UP);
		self.label_hero = gui_add_label(self.layer, '', 21, 'hero_name', GUI_SHOP, ANCHOR_UP);
		self.label_type = gui_add_label(self.layer, '', 21, 'type_name', GUI_SHOP, ANCHOR_UP);

		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn_hero', GUI_SHOP, self.pick_hero, ANCHOR_UP);
		self.btn_hero = item;
		self:add_hero_image(0);

		item, data = gui_add_item(items, 'btn_type', GUI_SHOP, self.pick_type, ANCHOR_UP);

		util.add_menu(self.layer, items, data.zorder);

		self.list = {};
		data = gui_get_data('cell', GUI_SHOP, ANCHOR_DOWN);
		local nheight = data.height + offsetheight;
		local sh = nheight/data.height;
		self.cscale = sh;
		data.width = data.width * sh;
		data.height = data.height * sh;
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height;
		data = gui_get_data('table', GUI_SHOP, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		self.twidth = size.width;
		self.line = pos.y + size.height/2;
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		self.clarrow, self.crarrow = util.add_arrows(self.layer, pos, size, self.cwidth, 0, cc.p(0, 0));

		--[[
		-- btn back set in g_scene.shop
		init_bg_for_full_view(self.layer, GUI_SHOP, '商店');
		local sprite, pos, size, data;
		local d1 = gui_get_data('bg_table', GUI_SHOP, ANCHOR_UP);
		local d2 = gui_get_data('bg_table', GUI_SHOP, ANCHOR_DOWN);
		local offsety = d1.y - d2.y;
		gui_add_sprite(self.layer, 'bg_table', GUI_SHOP, ANCHOR_UP, -offsety, offsety);
		gui_add_sprite(self.layer, 'bg_bottom', GUI_SHOP, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 'bg_hero', GUI_SHOP, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 'bg_kind', GUI_SHOP, ANCHOR_DOWN);
		self.label_hero = gui_add_label(self.layer, '', 23, 't_hero', GUI_SHOP, ANCHOR_DOWN);
		self.label_type = gui_add_label(self.layer, '', 23, 't_kind', GUI_SHOP, ANCHOR_DOWN);

		local items = {};
		local item;

		item, data = gui_add_item(items, 'reload', GUI_SHOP, self.callback_reloadlist, ANCHOR_UP);

		item, data = gui_add_item(items, 'tab_buy', GUI_SHOP, self.callback_buy, ANCHOR_UP);
		gui_add_text_outline_on_sprite(item, "购买", 't_buy', GUI_SHOP, ANCHOR_UP, 30);
		self.tap_buy = item;

		item, data = gui_add_item(items, 'tab_sell', GUI_SHOP, self.callback_sell, ANCHOR_UP);
		gui_add_text_outline_on_sprite(item, "售卖", 't_sell', GUI_SHOP, ANCHOR_UP, 30);
		self.tap_sell = item;

		item, data = gui_add_item(items, 'more_hero', GUI_SHOP, self.pick_hero, ANCHOR_DOWN);

		item, data = gui_add_item(items, 'more_kind', GUI_SHOP, self.pick_type, ANCHOR_DOWN);

		util.add_menu(self.layer, items, data.zorder);

		self.callback_buy(0, self.tap_buy);

		self.list = {};
		data = gui_get_data('table', GUI_SHOP, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsety);
		-----------
		self.r_table = { x = data.x, y = data.y, offsety = offsety,
						 width = data.width, height = data.height + offsety };
		-----------
		local dcard = gui_get_data('card', GUI_SHOP, ANCHOR_DOWN);
		self.cwidth = dcard.width / dcard.height * (dcard.height + offsety/2);
		self.cheight = data.height + offsety;

		self.twidth = size.width;
		self.line = pos.y + size.height/2;
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		self.clarrow, self.crarrow = util.add_arrows(self.layer, pos, size, self.cwidth, 0, cc.p(0, 0));
		]]--

		return self.layer, self.name;
	end,

	syn_hero_list = function(self, new_index)
		-- layer_shop
		if self.kind == self.KIND_BUY then
			new_index = (new_index or self.in_hero_buy) or 1;
		else
			new_index = (new_index or self.in_hero_sell) or 1;
		end
		local nlist = {};
		local list = {};
		if self.kind == self.KIND_SELL then
			for i = 1, #self.list_shop do
				local info = self.list_shop[i];
				local count = self:is_has_card(info.card.id);
				if count > 0 then
					table.insert(list, info);
				end
			end
		else
			list = self.list_shop;
		end
		local tag = new_index;
		if 0 == tag then -- all kind of type
			for i = 1, #list do
				table.insert(nlist, list[i]);
			end
		else
			local cid = tag;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		end
		self.list = nlist;
		self.list_phero = self.list;

		--[[
		local info = self.list_pick_hero[new_index];
		local tag = info.tag;
		if 1 == tag then -- all kind of type
			for i = 1, #list do
				table.insert(nlist, list[i]);
			end
		elseif 2 == tag then -- hero id 1 GaiLun
			local cid = 1;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		elseif 3 == tag then -- hero id 2 RuiWen
			local cid = 2;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		elseif 4 == tag then -- hero id 5 ZhouSi
			local cid = 5;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		elseif 5 == tag then -- hero id 6 LaiLi
			local cid = 6;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		elseif 6 == tag then -- hero id 8 SuoNa
			local cid = 8;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		elseif 7 == tag then -- hero id 11 TeLangDeEr
			local cid = 11;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		elseif 8 == tag then -- hero id 15 AnNi
			local cid = 15;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		end
		self.list = nlist;
		self.list_phero = self.list;
		]]--
		return self.list;
	end,

	syn_type_list = function(self, new_index)
		-- layer_shop
		if self.kind == self.KIND_BUY then
			new_index = (new_index or self.in_type_buy) or 1;
		else
			new_index = (new_index or self.in_type_sell) or 1;
		end
		local nlist = {};
		local list = self.list_phero or self.list;
		local info = self.list_pick_type[new_index];
		local tag = info.tag;
		if 1 == tag then -- all kind of type
			for i = 1, #list do
				table.insert(nlist, list[i]);
			end
		elseif 2 == tag then -- hero 
			for i = 1, #list do
				local card = list[i].card;
				if HERO == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 3 == tag then -- attach 
			for i = 1, #list do
				local card = list[i].card;
				if ATTACH == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 4 == tag then -- ability 
			for i = 1, #list do
				local card = list[i].card;
				if ABILITY == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 5 == tag then -- ally 
			for i = 1, #list do
				local card = list[i].card;
				if ALLY == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 6 == tag then -- weapon 
			for i = 1, #list do
				local card = list[i].card;
				if WEAPON == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 7 == tag then -- armor 
			for i = 1, #list do
				local card = list[i].card;
				if ARMOR == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 8 == tag then -- SUPPORT 
			for i = 1, #list do
				local card = list[i].card;
				if SUPPORT == card.ctype or TRAP == card.ctype or ARTIFACT == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		end
		self.list = nlist;
		return self.list;
	end,

	--[[
	change_hero_type = function(self, new_index)
		-- layer_shop
		new_index = new_index or 1;
		local titles = self.list_pick_hero or {};
		if 0 == titles then return; end

		local info = titles[new_index];
		if nil == info then return; end
		local name = info.title;
		self.label_hero:setString(name);

		if self.kind == self.KIND_BUY then
			if new_index ~= self.in_hero_buy then
				self.offset_buy = nil;
			end
			self.in_hero_buy = new_index;
		else
			if new_index ~= self.in_hero_sell then
				self.offset_sell = nil;
			end
			self.in_hero_sell = new_index;
		end

		local list = self.list or {};
		if 0 == #list then return; end

		self:syn_hero_list(new_index);
		self:reload();
	end,
	]]--

	change_pick_type = function(self, new_index)
		new_index = new_index or 1;
		local titles = self.list_pick_type or {};
		if 0 == titles then return; end

		local info = titles[new_index];
		if nil == info then return; end
		local name = info.title;
		self.label_type:setString(name);

		if self.kind == self.KIND_BUY then
			if new_index ~= self.in_type_buy then
				self.offset_buy = nil;
			end
			self.in_type_buy = new_index;
		else
			if new_index ~= self.in_type_sell then
				self.offset_sell = nil;
			end
			self.in_type_sell = new_index;
		end

		local list = self.list or {};
		if 0 == #list then return; end

		self:syn_type_list(new_index);
		self:reload();
	end,

	--[[
	callback_pick_hero = function(index)
		local self = layer_shop;
		self:change_hero_type(index);
		local pindex;
		if self.kind == self.KIND_BUY then
			pindex = self.in_type_buy;
		else
			pindex = self.in_type_sell;
		end
		self:change_pick_type(pindex);
	end,
	]]--

	add_hero_image = function(self, hid)
		-- layer_shop
		local btn = self.btn_hero;
		local fname, path, pic, pos;
		pic = btn:getChildByTag(97);
		if nil ~= pic then
			pic:removeFromParent(true);
		end
		if hid == 0 then
			fname = 'pic_94.png';
		else
			fname = 'card' .. hid .. '.png';
		end
		path = util.get_path(fname, 'card0.png');
		local mask_path = util.get_path('bg_160.png');
		local size = btn:getContentSize();
		pos = cc.p(size.width/2, size.height/2);
		pic = util.add_mask_sprite(btn, path, mask_path, pos, ANCHOR_CENTER_CENTER, -1);
		pic:setTag(97);
		pic:setScale(size.height/pic:getContentSize().height);
	end,

	change_hero = function(self, hid, name, in_type)
		-- layer_shop
		hid = hid or 0;
		self:add_hero_image(hid);
		if hid ~= self.in_hero then
			name = name or "???";
			self.label_hero:setString(name);
		end
		self.in_hero = hid;
		self:syn_hero_list(hid);
		self:reload();

		self.in_type = in_type or self.in_type;
		self:change_pick_type(self.in_type);
	end,

	cb_change_hero = function(...)
		local self = layer_shop;
		self:change_hero(...);
	end,

	pick_hero = function()
		local self = layer_shop;
		--[[
		local cb = self.callback_pick_hero;
		local list = self.list_pick_hero;
		local layer, name = layer_pick:create(list, cb);
		g_scene:add_layer(ZORDER_LAYER_PICK, layer, name, true);
		]]--
		local t = layer_hero.TYPE_SORT;
		local cb = self.cb_change_hero;
		g_scene:add_layer(ZORDER_LAYER_HERO, layer_hero:create(t, cb));
		net_send("lhero"); 
		--g_scene:hero(layer_hero.TYPE_SORT);
		layer_hero.mark_hero_index = self.in_hero;
		layer_hero.mark_type_index = self.in_type;
		layer_hero.mark_hero_name = self.label_hero:getString();
	end,

	callback_pick_type = function(index)
		local self = layer_shop;
		self:change_pick_type(index);
	end,

	pick_type = function()
		local self = layer_shop;
		local cb = self.callback_pick_type;
		local list = self.list_pick_type;
		local layer, name = layer_pick:create(list, cb);
		g_scene:add_layer(ZORDER_LAYER_PICK, layer, name, true);
	end,

	reload = function(self)
		local offset;
		if true ~= SHOP_PAGE then
			if self.kind == self.KIND_BUY then
				offset = self.offset_buy;
			else -- self.KIND_SELL
				offset = self.offset_sell;
			end
		else
			offset = self.offset;
		end
		self.tableview:reloadData();
		if nil ~= offset then
			self.tableview:setContentOffset(offset, false);
		end
	end,

	callback_reloadlist = function()
		play_tap_3();
		local self = layer_shop;
		g_list_shop = {};
		self.list_shop = {};
		self.list = {};
		self.callback_buy(0, self.tap_buy);
		self.offset_buy = nil;
		self.offset_sell = nil;
		-- total 400 cards
		-- each turn get 40 , 10 times
		local p = 40;
		local t = math.ceil(CARD_ARRAY_LIST / p);
		g_list_shop.last_id = t;
		for i = 1, t do
			local cmd = 'shop ' .. (1+p*(i-1)) .. ' ' .. p;
			net_send(cmd);
		end
	end,

	set_buy_list = function(self)
		self.list = {};
		for i = 1, #self.list_shop do
			local info = self.list_shop[i];
			table.insert(self.list, info);
		end
		self:change_hero(0, "所有英雄");
		--self:change_hero_type(self.in_hero_buy);
		self:change_pick_type(self.in_type_buy);
	end,

	set_sell_list = function(self)
		self.list = {};
		for i = 1, #self.list_shop do
			local info = self.list_shop[i];
			local count = self:is_has_card(info.card.id);
			if count > 0 then
				table.insert(self.list, info);
			end
		end
		self:change_hero_type(self.in_hero_sell);
		self:change_pick_type(self.in_type_sell);
	end,

	callback_buy = function(tag, sender)
		play_tap_3();
		local self = layer_shop;
		--local toggle = tolua.cast(sender, "CCMenuItemToggle");
		self.kind = self.KIND_BUY;
		--[[
		local index = self.tap_sell:getSelectedIndex();
		if 0 == index then
			self.tap_buy:setSelectedIndex(1);
			return;
		end
		self.tap_buy:setSelectedIndex(1);
		self.tap_sell:setSelectedIndex(0);
		]]--
		self:set_buy_list();
	end,

	callback_sell = function(tag, sender)
		play_tap_3();
		local self = layer_shop;
		if g_euser.level < 10 then
			show_msg('10级开启');
			self.tap_sell:setSelectedIndex(0);
			return;
		end
		--local toggle = tolua.cast(sender, "CCMenuItemToggle");
		self.kind = self.KIND_SELL;
		local index = self.tap_buy:getSelectedIndex();
		if 0 == index then
			self.tap_sell:setSelectedIndex(1);
			return;
		end
		self.tap_sell:setSelectedIndex(1);
		self.tap_buy:setSelectedIndex(0);
		if true ~= SHOP_PAGE then
			self:set_sell_list();
		end
		self:reload();
	end,

	add_to_list = function(self, list, last_id)
		self.my_cards = c_str_array_2(g_euser.all_str);	
		--print('last_id: ', last_id);
		if true ~= SHOP_PAGE then
			self.list_shop = self.list_shop or {};
			if #self.list_shop > 0 then
				return;
			end
			--self.list_pick_hero = { { tag = 1, title = '所有英雄' } };
			for i = 1, #list do
				local info = list[i];
				table.insert(self.list_shop, info);
				--[[
				if info.card.ctype == HERO then
					local tag = info.card.id;
					local title = info.card.name;
					table.insert(self.list_pick_hero, {tag=i+1, title=title});
				end
				]]--
			end
			if self.kind == self.KIND_BUY then
				self:set_buy_list();
				--self:reload();
			else
				self.callback_buy(0, self.tap_buy);
			end
			return;
		end
		self.list = self.list or {};
		self.last_id = last_id;
		if 0 == #list then
			--self.last_id = -1; -- -1 means don't need to send requst again
			if -1 == self.last_id then
				return;
			end
			local card_id = self.last_id + 1;
			local cmd = 'shop ' .. card_id .. ' ' .. self.PAGE_SIZE;
			net_send(cmd);
			return;
		end
		if 0 < #self.list then
			local m = self.list[#self.list];
			if true == m.flag_more_cell then
				table.remove(self.list, #self.list);
			end
			m = self.list[#self.list];
			if true == m.flag_more_cell then
				table.remove(self.list, #self.list);
			end
		end
		for i = 1, #list do
			table.insert(self.list, list[i]);
		end
		if self.PAGE_SIZE == #list then
			local hlen = (#self.list)%2;
			local more_cell = { flag_more_cell = true };
			table.insert(self.list, more_cell);
			if 1 == hlen then
				more_cell = { flag_more_cell = true };
				table.insert(self.list, more_cell);
			end
		end
	end,

	back = function()
		play_tap_1();
		g_scene:map();
	end,

	is_has_card = function(self, cid)
		for i = 1, #self.my_cards do
			local info = self.my_cards[i];
			if info.cid == cid and info.count >= 0 then
				return info.count;
			end
		end
		return 0;
	end,

	update_my_cards = function(self, cid, count)
		for i = 1, #self.my_cards do
			local info = self.my_cards[i];
			local mid = info.cid;
			if mid == cid then
				info.count = info.count + count;
				if 0 >= info.count then
					table.remove(self.my_cards, i);
				end
				if self.kind == self.KIND_BUY then
					self:set_buy_list();
				else -- self.kind == self.KIND_SELL
					self:set_sell_list();
				end
				--self:reload();
				return;
			end
		end
		table.insert(self.my_cards, { cid = cid, count = count });
		if self.kind == self.KIND_BUY then
			self:set_buy_list();
		else -- self.kind == self.KIND_SELL
			self:set_sell_list();
		end
		--self:reload();
	end,

	update_pop_card_count = function(self, cid, buy_count)
		if nil == layer_mispop.layer then return; end
		local label = layer_mispop.layer:getChildByTag(121); -- set in touch
		if nil == label then return; end
		local count = self:is_has_card(cid);
		count = "*" .. count;
		label:setString(count);
	end,

	buy_card = function(...)
		local self = layer_shop;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		local card = info.card;
		local gold = info.gold or 0;
		local crystal = info.crystal or 0;
		local count = info.count or 0;
		local card_id = card.id;
		local action = 'buy';
		local card_type = 0; -- 0--card, 1--piece
		local money_type = nil; -- 0--gold, 1--crystal
		if count == 9 then
			show_err("最多只能拥有9张");
			return;
		end
		if crystal > 0 then
			money_type = 1;
			if crystal > g_euser.crystal then
				show_err(t_lang("TIP_NOT_ENOUGH_CRYSTAL"));
				return;
			end
		elseif gold > 0 then
			money_type = 0;
			if gold > g_euser.gold then
				show_err(t_lang("TIP_NOT_ENOUGH_GOLD"));
				return;
			end
		end
		if nil == money_type then
			return;
		end
		local count = 1;
		local cmd = string.format("%s %d %d %d %d", action, card_id, card_type, money_type, count);
		net_send(cmd);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_shop;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return math.ceil(#(self.list or {})/2);
		elseif "scrollViewDidScroll" == event then
			local len = math.ceil(#self.list / 2);
			local offset = view:getContentOffset();
			if true ~= SHOP_PAGE then
				if self.kind == self.KIND_BUY then
					self.offset_buy = offset;
				else -- self.KIND_SELL
					self.offset_sell = offset;
				end
			else
				self.offset = offset;
			end
			util.handle_arrows(self.clarrow, self.crarrow, len, self.cwidth, self.twidth, offset);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local index = idx*2 + 1;
			if 2 == self.side then -- down
				index = index + 1;
			elseif 1 == self.side then -- up
			else
				return;
			end
			local info = self.list[index];
			if nil == info then return; end
			local rc = info.card;
			--info.kind = self.kind;
			--g_scene:add_layer(ZORDER_LAYER_SHOPPOP, layer_shoppop:create(info));
			local card = clone(rc);
			local layer, name = layer_mispop:create(card);
			local count = info.count or 0;
			local gold = info.gold or 0;
			local crystal = info.crystal or 0;
			local path = util.get_path(FT_8);
			local str = "*" .. count;
			local l = util.add_labelbmf(layer, str, path, cc.p(FULL_WIDTH-50, HALF_HEIGHT), ANCHOR_RIGHT_CENTER, 100, cc.TEXT_ALIGNMENT_RIGHT);
			l:setTag(121);
			l:setScale(2);

			local items = {};
			local item, data;
			item, data = gui_add_item(items, 'btn_buy', GUI_PMYSTERY, self.buy_card, ANCHOR_DOWN);
			item:setTag(index);
			item:setPositionY(hfix(100));
			local price = nil;
			if crystal > 0 then
				gui_add_sprite_on_cell(item, data, 'crystal', GUI_PMYSTERY,ANCHOR_DOWN);
				price = crystal .. '';
			else
				gui_add_sprite_on_cell(item, data, 'gold', GUI_PMYSTERY, ANCHOR_DOWN);
				price = gold .. '';
			end
			local path = util.get_path(FT_5);
			gui_add_labelbmf_on_cell(item,data,price,path,'price',GUI_PMYSTERY,ANCHOR_DOWN, cc.TEXT_ALIGNMENT_RIGHT);

			util.add_menu(layer, items, data.zorder);

			g_scene:add_layer(ZORDER_LAYER_MISPOP, layer, name);
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local index = idx*2 + 1;
			local data = self.data_cell;
			local size;
			local hh = height/2;
			local size;
			local len = index+1;
			if len > #self.list then len = #self.list; end
			for i = index, len do
				local info = self.list[i];
				if nil == info or true == info.flag_more_cell then
					break;
				end
				local card = info.card;
				local basey = 0;
				if i % 2 ~= 0 then
					basey = hh;
				end
				local sprite, data2, path, str;
				local frame, fdata;
				frame, fdata = gui_add_sprite_on_cell(cell, data, 'cframe', GUI_SHOP, ANCHOR_DOWN);
				frame:setAnchorPoint(ANCHOR_CENTER_CENTER)
				local s = frame:getContentSize();
				local ws = (width-(data.width-fdata.width))/s.width;
				local wh = (height-(data.height-fdata.height))/s.height;
				if ws < wh then
					scale = ws;
				else
					scale = wh;
				end
				frame:setScale(scale*self.cscale);
				frame:setPosition(cc.p(fdata.x+width/2, fdata.y+fdata.height*self.cscale/2+basey));
				local fname = 'card' .. card.id .. '.png';
				path = util.get_path(fname, 'card0.png');
				local mask_path = util.get_path('bg_155.png');
				pos = ccp(s.width/2, s.height/2);
				local pic = util.add_mask_sprite(frame, path, mask_path, pos, ANCHOR_CENTER_CENTER, -1);
				pic:setScale(s.height/pic:getContentSize().height);

				add_detail_for_show_frame(frame, card);

				fdata = gui_get_data('cframe', GUI_PIECE, ANCHOR_DOWN);
				sprite, data2 = gui_add_sprite_on_cell(frame, fdata, 'bg_price', GUI_SHOP, ANCHOR_DOWN);
				sprite, data2 = gui_add_sprite_on_cell(frame, fdata, 'bg_name', GUI_SHOP, ANCHOR_DOWN);

				local gold, crystal, path;
				if self.kind == self.KIND_BUY then
					gold = math.abs(info.c_buygold);
					crystal = math.abs(info.c_buycrystal);
				else -- self.KIND_SELL
					gold = info.c_sellgold;
					crystal = info.c_sellcrystal;
				end
				info.gold = gold;
				info.crystal = crystal;
				path = util.get_path(FT_4);
				if crystal > 0 then
					sprite, data2 = gui_add_sprite_on_cell(frame, fdata, 'p_crystal', GUI_SHOP, ANCHOR_DOWN);
					str = crystal .. '';
				else ---if gold > 0 then
					sprite, data2 = gui_add_sprite_on_cell(frame, fdata, 'p_gold', GUI_SHOP, ANCHOR_DOWN);
					str = gold .. '';
				end
				sprite, data2 = gui_add_labelbmf_on_cell(frame,fdata,str,path,'price',GUI_SHOP,ANCHOR_DOWN, cc.TEXT_ALIGNMENT_RIGHT);
				sprite:setScale(0.7);
				str = card.name .. ''; 
				gui_add_label_ali_on_cell(frame, fdata, str, 22, 'name', GUI_SHOP, ANCHOR_DOWN, cc.TEXT_ALIGNMENT_CENTER);

				local count = self:is_has_card(card.id);
				info.count = count;
				path = util.get_path(FT_8);
				str = '*' .. count;
				util.add_labelbmf(frame, str, path, cc.p(s.width-10, s.height/2), ANCHOR_RIGHT_CENTER, 100);
			end
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_shop;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function (self, x, y)
		if y > self.line then
			self.side = 1; -- up
		else
			self.side = 2; -- down
		end
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
	end,
	
	onTouchEnded = function(self, x, y)
		--[[
		if -1 == self.last_id then
			return;
		end
		local len = #(self.list or {});
		if 0 == len then
			return;
		end
		len = math.ceil(len / 2);
		local offset = self.tableview:getContentOffset();
		local line = math.floor(self.cwidth * (len-3) - self.twidth);
		if offset.x + line <= 0 then
			local card_id = self.last_id + 1;
			local cmd = 'shop ' .. card_id .. ' ' .. self.PAGE_SIZE;
			net_send(cmd);
		end
		]]--
	end,

} -- layer_shop end

layer_shoppop = {
	name = 'layer_shoppop',
	layer = nil,
	list_hero = nil,
	data = nil,
	info = nil,	
	oinfo = nil,
	t_gold = nil,
	t_crystal = nil,
	rect = nil,
	label_count = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list_hero = nil;
		self.data = nil;
		self.info = nil;
		self.oinfo = nil;
		self.t_gold = nil;
		self.t_crystal = nil;
		self.rect = nil;
		self.label_count = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, data)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_SHOPPOP, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 120));
		local list_card = c_str_array_2(g_euser.all_str);	
		self.list_hero = {};
		for i = 1, #list_card do
			local cid = list_card[i].cid;
			if cid > 20 then
				break;
			end
			table.insert(self.list_hero, cid);
		end
		self.data = data;
		local info = data.info;
		self.oinfo = info;
		local f = info.frame;
		local scale = get_card_scale(f.width, f.height, CARD_SIZE);
		self.info = info:copy(self.layer, STYPE_VER_1, nil, scale, nil);

		local items = {};
		local item;

		if nil ~= layer_shop.layer then
			local sprite = self.info:get_sprite();
			local path = util.get_path('font_deck_num.fnt');
			local pos = cc.p(CARD_SIZE.width/2 + 100, CARD_SIZE.height/2 + 20);
			local label = util.add_labelbmf(sprite, '', path, pos, ANCHOR_CENTER_CENTER, 100);
			label:setScale(2);
			self.label_count = label;
			self:update_count();
		end

		util.add_menu(self.layer, items, data.zorder);

		self:show(data.count);
		
		return self.layer, self.name;
	end, 

	back = function()
		play_tap_1();
		local self = layer_shoppop;
		self:remove();
	end,

	update_count = function(self)
		if nil == self.layer then return; end
		if nil == self.label_count then return; end
		local count = layer_shop:is_has_card(self.info.card.id);
		count = '*' .. count;
		self.label_count:setString(count);
	end,

	show = function(self, count)
		local layer = self.layer;
		local info = self.data;
		local kind = info.kind;

		local d1 = gui_get_data('p_bg', GUI_SHOP, ANCHOR_DOWN);
		local d2 = gui_get_data('p_bg', GUI_SHOP, ANCHOR_UP);
		local offsetheight = d2.y-d1.y;
		local sprite, data;
		sprite, data = gui_add_sprite(self.layer,'p_bg',GUI_SHOP,ANCHOR_DOWN,nil, offsetheight);
		self.rect = {
			x1 = data.x, x2 = data.x + data.width,
			y1 = data.y, y2 = data.y + data.height,
		};
		gui_add_sprite(self.layer, 'p_bg_title', GUI_SHOP, ANCHOR_UP);
		local can_action = true;
		local str, crystal, gold;
		if kind == layer_shop.KIND_BUY then
			gold = math.abs(info.c_buygold); 
			crystal = math.abs(info.c_buycrystal); 
			str = '购买卡牌';
		else
			gold = math.abs(info.c_sellgold); 
			crystal = math.abs(info.c_sellcrystal); 
			if nil == count or 1 > count then
				can_action = false;
			end
			str = '售卖卡牌';
		end
		gui_add_label(self.layer, str, 30, 'p_t_title', GUI_SHOP, ANCHOR_UP);
		gui_add_sprite(self.layer,'p_bg_card',GUI_SHOP,ANCHOR_DOWN,nil,offsetheight);
		local scale;
		data, scale = gui_get_data('p_card', GUI_SHOP, ANCHOR_DOWN);
		data.height = data.height + offsetheight;
		local sprite = self.info.sprite;
		pos = cc.p(data.x+data.width/2, data.y+data.height/2);
		sprite:setPosition(pos);
		sprite:setScale((data.height-10*scale)/sprite:getContentSize().height);
		self.layer:reorderChild(sprite, data.zorder);

		local path = util.get_path(FNT_1);
		if gold > 0 then
			gui_add_sprite(self.layer, 'p_icon_gold', GUI_SHOP, ANCHOR_DOWN);
			gui_add_labelbmf(self.layer, gold, path, 'p_num_gold',GUI_SHOP,ANCHOR_DOWN);
		end
		if crystal > 0 then
			gui_add_sprite(self.layer, 'p_icon_crystal', GUI_SHOP, ANCHOR_DOWN);
			gui_add_labelbmf(self.layer, crystal, path,'p_num_crystal',GUI_SHOP,ANCHOR_DOWN);
		end

		local items = {};
		local item;

		if true == can_action then
			item, data = gui_add_item(items, 'p_btn_action', GUI_SHOP, self.action, ANCHOR_DOWN);
			if kind == layer_shop.KIND_BUY then
				str = '购买';
				item:setTag(2);
			else
				str = '售卖';
				item:setTag(1);
			end
			gui_add_text_on_sprite(item,str,'p_t_action',GUI_SHOP,ANCHOR_DOWN,30);

			if gold > 0 then
				item, data = gui_add_item(items, 'p_toggle_gold', GUI_SHOP, self.choose_gold, ANCHOR_DOWN);
				self.t_gold = item;
			end

			if crystal > 0 then
				item, data = gui_add_item(items, 'p_toggle_crystal', GUI_SHOP, self.choose_crystal, ANCHOR_DOWN);
				self.t_crystal = item;
			end
		end

		item,data = gui_add_item(items,'p_btn_back',GUI_SHOP,self.back,ANCHOR_UP);

		util.add_menu(self.layer, items, data.zorder);

		if true == can_action then
			if gold > 0 then
				self.choose_gold(0, self.t_gold);
			elseif crystal > 0 then
				self.choose_crystal(0, self.t_crystal);
			end
		end
	end,

	check_has_hero_fit = function(self, cid)
		if cid <= 20 then
			return true;
		end
		for i = 1, #self.list_hero do
			local hid = self.list_hero[i];
			local is_fit = fit_hero_id(hid, cid);
			if true == is_fit then
				return true;
			end
		end
		return false;
	end,

	choose_gold = function(tag, sender)
		play_tap_3();
		local self = layer_shoppop;
		--local toggle = tolua.cast(sender, "CCMenuItemToggle");
		if nil == self.t_crystal then
			self.t_gold:setSelectedIndex(1);
			return;
		end
		local index = self.t_crystal:getSelectedIndex();
		if 0 == index then
			self.t_gold:setSelectedIndex(1);
			return;
		end
		self.t_gold:setSelectedIndex(1);
		self.t_crystal:setSelectedIndex(0);
	end,

	choose_crystal = function(tag, sender)
		play_tap_3();
		local self = layer_shoppop;
		--local toggle = tolua.cast(sender, "CCMenuItemToggle");
		if nil == self.t_gold then
			self.t_crystal:setSelectedIndex(1);
			return;
		end
		local index = self.t_gold:getSelectedIndex();
		if 0 == index then
			self.t_crystal:setSelectedIndex(1);
			return;
		end
		self.t_crystal:setSelectedIndex(1);
		self.t_gold:setSelectedIndex(0);
	end,

	confirm_buy = function()
		local self = layer_shoppop;
		local card_id = self.info.card.id;
		local action = 'buy';
		local card_type = 0; -- 0--card, 1--piece
		local money_type = nil; -- 0--gold, 1--crystal
		if nil ~= self.t_gold then
			local tt = self.t_gold:getSelectedIndex();
			if 1 == tt then
				money_type = 0;
				if 'buy' == action and self.data.gold > g_euser.gold then
					show_err(t_lang("TIP_NOT_ENOUGH_GOLD"));
					return;
				end
			end
		end
		if nil ~= self.t_crystal then
			local tt = self.t_crystal:getSelectedIndex();
			if 1 == tt then
				money_type = 1;
				if 'buy' == action and self.data.crystal > g_euser.crystal then
					show_err(t_lang("TIP_NOT_ENOUGH_CRYSTAL"));
					return;
				end
			end
		end
		if nil == money_type then
			return;
		end
		local count = 1;
		local cmd = string.format("%s %d %d %d %d", action, card_id, card_type, money_type, count);
		net_send(cmd);
		--self.back();
	end,

	action = function(...)
		play_tap_1();
		local self = layer_shoppop;
		local args = {...};
		local tag = args[2]:getTag();
		local card_id = self.info.card.id;
		local card_type = 0; -- 0--card, 1--piece
		local action = nil;
		if 1 == tag then
			action = 'sell';
		elseif 2 == tag then
			if false == self:check_has_hero_fit(card_id) then
				local t = '你没有可使用该卡牌的英雄，确定购买？';
				local cb = self.confirm_buy;
				g_scene:add_layer(ZORDER_LAYER_TIP,layer_tip:create(t,cb));
				return;
			end
			if nil ~= layer_shop.layer then
				local count = layer_shop:is_has_card(card_id);
				if count >= 4 then
					local t = '最多只能放4张相同的牌到牌堆，确定购买？';
					local cb = self.confirm_buy;
					g_scene:add_layer(ZORDER_LAYER_TIP,layer_tip:create(t,cb));
					return;
				end
				if card_id <= 20 and count >= 1 then
					local t = '同款英雄牌有一张便足够了，确定购买？';
					local cb = self.confirm_buy;
					g_scene:add_layer(ZORDER_LAYER_TIP,layer_tip:create(t,cb));
					return;
				end
			end
			action = 'buy';
		else
			--print('xxxx');
			return;
		end
		local money_type = nil; -- 0--gold, 1--crystal
		if nil ~= self.t_gold then
			local tt = self.t_gold:getSelectedIndex();
			if 1 == tt then
				money_type = 0;
				if 'buy' == action and self.data.gold > g_euser.gold then
					show_err(t_lang("TIP_NOT_ENOUGH_GOLD"));
					return;
				end
			end
		end
		if nil ~= self.t_crystal then
			local tt = self.t_crystal:getSelectedIndex();
			if 1 == tt then
				money_type = 1;
				if 'buy' == action and self.data.crystal > g_euser.crystal then
					show_err(t_lang("TIP_NOT_ENOUGH_CRYSTAL"));
					return;
				end
			end
		end
		if nil == money_type then
			return;
		end
		local count = 1;
		local cmd = string.format("%s %d %d %d %d", action, card_id, card_type, money_type, count);
		net_send(cmd);
		--self.back();
	end,

	handler = function(event, x, y)
		local self = layer_shoppop;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,
} -- layer_shoppop end

layer_piece = { -- start    
	name = 'layer_piece',
	layer = nil,
	list_pick_type = {
		{ tag = 1, title = '所有分类' },
		{ tag = 2, title = '英雄' },
		{ tag = 3, title = '附加' },
		{ tag = 4, title = '技能' },
		{ tag = 5, title = '盟军' },
		{ tag = 6, title = '武器' },
		{ tag = 7, title = '防具' },
		{ tag = 8, title = '支援' },
	},
	in_hero = nil,
	in_type = nil,
	list = nil,
	list_phero = nil,
	list_piece = nil,
	tableview = nil,
	data_cell = nil,
	clarrow = nil,
	crarrow = nil,
	twidth = nil,
	line = nil,
	side = nil,
	offset = nil,
	label_hero = nil,
	label_type = nil,
	btn_hero = nil,
	cscale = nil,

	cleanup = function(self)
		self.layer = nil;
		self.in_hero = nil;
		self.in_type = nil;
		self.list = nil;
		self.list_phero = nil;
		self.list_piece = nil;
		self.tableview = nil;
		self.data_cell = nil;
		self.clarrow = nil;
		self.crarrow = nil;
		self.twidth = nil;
		self.line = nil;
		self.side = nil;
		self.offset = nil;
		self.label_hero = nil;
		self.label_type = nil;
		self.btn_hero = nil;
		self.cscale = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_PIECE, self.handler, true);

		local offsetheight = init_bg_full(self.layer, GUI_PIECE, self.back);

		local sprite, data, pos, size, path;
		sprite,data = gui_add_sprite(self.layer,'outframe',GUI_PIECE,ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));

		gui_add_sprite(self.layer,'subbar',GUI_PIECE,ANCHOR_UP);
		self.label_hero = gui_add_label(self.layer, '', 21, 'hero_name', GUI_PIECE, ANCHOR_UP);
		self.label_type = gui_add_label(self.layer, '', 21, 'type_name', GUI_PIECE, ANCHOR_UP);

		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn_hero', GUI_PIECE, self.pick_hero, ANCHOR_UP);
		self.btn_hero = item;
		self:add_hero_image(0);

		item, data = gui_add_item(items, 'btn_type', GUI_PIECE, self.pick_type, ANCHOR_UP);

		util.add_menu(self.layer, items, data.zorder);

		self.list = {};
		data = gui_get_data('cell', GUI_PIECE, ANCHOR_DOWN);
		local nheight = data.height + offsetheight;
		local sh = nheight/data.height;
		self.cscale = sh;
		data.width = data.width * sh;
		data.height = data.height * sh;
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height;
		data = gui_get_data('table', GUI_PIECE, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		self.twidth = size.width;
		self.line = pos.y + size.height/2;
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		self.clarrow, self.crarrow = util.add_arrows(self.layer, pos, size, self.cwidth, 0, cc.p(0, 0));

		return self.layer, self.name;
	end,

	syn_hero_list = function(self, new_index)
		-- layer_piece
		new_index = (new_index or self.in_hero) or 1;
		local nlist = {};
		local list = self.list_piece;
		local tag = new_index;
		if 0 == tag then -- all kind of type
			for i = 1, #list do
				table.insert(nlist, list[i]);
			end
		else
			local cid = tag;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		end
		self.list = nlist;
		self.list_phero = self.list;
		return self.list;
	end,

	syn_type_list = function(self, new_index)
		-- layer_piece
		new_index = (new_index or self.in_type) or 1;
		local nlist = {};
		local list = self.list_phero or self.list;
		local info = self.list_pick_type[new_index];
		local tag = info.tag;
		if 1 == tag then -- all kind of type
			for i = 1, #list do
				table.insert(nlist, list[i]);
			end
		elseif 2 == tag then -- hero 
			for i = 1, #list do
				local card = list[i].card;
				if HERO == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 3 == tag then -- attach 
			for i = 1, #list do
				local card = list[i].card;
				if ATTACH == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 4 == tag then -- ability 
			for i = 1, #list do
				local card = list[i].card;
				if ABILITY == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 5 == tag then -- ally 
			for i = 1, #list do
				local card = list[i].card;
				if ALLY == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 6 == tag then -- weapon 
			for i = 1, #list do
				local card = list[i].card;
				if WEAPON == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 7 == tag then -- armor 
			for i = 1, #list do
				local card = list[i].card;
				if ARMOR == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 8 == tag then -- SUPPORT 
			for i = 1, #list do
				local card = list[i].card;
				if SUPPORT == card.ctype or TRAP == card.ctype or ARTIFACT == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		end
		self.list = nlist;
		return self.list;
	end,

	change_pick_type = function(self, new_index)
		-- layer_piece
		new_index = new_index or 1;
		local titles = self.list_pick_type or {};
		if 0 == titles then return; end

		local info = titles[new_index];
		if nil == info then return; end
		local name = info.title;
		self.label_type:setString(name);

		if new_index ~= self.in_type then
			self.offset = nil;
		end
		self.in_type = new_index;

		self:syn_type_list(new_index);
		self:reload();
	end,

	add_hero_image = function(self, hid)
		local btn = self.btn_hero;
		local fname, path, pic, pos;
		pic = btn:getChildByTag(97);
		if nil ~= pic then
			pic:removeFromParent(true);
		end
		if hid == 0 then
			fname = 'pic_94.png';
		else
			fname = 'card' .. hid .. '.png';
		end
		path = util.get_path(fname, 'card0.png');
		local mask_path = util.get_path('bg_160.png');
		local size = btn:getContentSize();
		pos = cc.p(size.width/2, size.height/2);
		pic = util.add_mask_sprite(btn, path, mask_path, pos, ANCHOR_CENTER_CENTER, -1);
		pic:setTag(97);
		pic:setScale(size.height/pic:getContentSize().height);
	end,

	change_hero = function(self, hid, name, in_type)
		hid = hid or 0;
		self:add_hero_image(hid);
		if hid ~= self.in_hero then
			name = name or "???";
			self.label_hero:setString(name);
		end
		self.in_hero = hid;
		self:syn_hero_list(hid);
		self:reload();

		self.in_type = in_type or self.in_type;
		self:change_pick_type(self.in_type);
	end,

	cb_change_hero = function(...)
		local self = layer_piece;
		self:change_hero(...);
	end,

	pick_hero = function()
		local self = layer_piece;
		local t = layer_hero.TYPE_SORT;
		local cb = self.cb_change_hero;
		g_scene:add_layer(ZORDER_LAYER_HERO, layer_hero:create(t, cb));
		net_send("lhero"); 
		--g_scene:hero(layer_hero.TYPE_SORT);
		layer_hero.mark_hero_index = self.in_hero;
		layer_hero.mark_type_index = self.in_type;
		layer_hero.mark_hero_name = self.label_hero:getString();
	end,

	callback_pick_type = function(index)
		local self = layer_piece;
		self:change_pick_type(index);
	end,

	pick_type = function()
		local self = layer_piece;
		local cb = self.callback_pick_type;
		local list = self.list_pick_type;
		local layer, name = layer_pick:create(list, cb);
		g_scene:add_layer(ZORDER_LAYER_PICK, layer, name, true);
	end,

	reload = function(self)
		-- layer_piece
		local offset = self.offset;
		self.tableview:reloadData();
		if nil ~= offset then
			self.tableview:setContentOffset(offset, false);
		end
	end,

	callback_reloadlist = function()
		play_tap_3();
		local self = layer_piece;
		g_list_piece = {};
		self.list = {};
		net_send("cpiece", true);
		net_send("lpiece", true);
	end,

	add_to_list = function(self, list)
		self.list_piece = {};
		for i = 1, #list do
			local info = list[i];
			table.insert(self.list_piece, info);
			--[[
			if info.card.ctype == HERO then
				local tag = info.card.id;
				local title = info.card.name;
				table.insert(self.list_pick_hero, {tag=i+1, title=title});
			end
			]]--
		end
		self.list = {};
		for i = 1, #self.list_piece do
			local info = self.list_piece[i];
			table.insert(self.list, info);
		end
		self:change_hero(0, "所有英雄");
		self:change_pick_type(self.in_type);
	end,

	back = function()
		play_tap_1();
		--g_scene:go(GUI_MAIN, "map");
		g_scene:map();
	end,

	merge_action = function(self, index)
		local info = self.list[index];
		local current_piece_count = info.current_piece_count;
		local merge_count = info.merge_count;
		if current_piece_count < merge_count then
			show_err("碎片数量不足");
			return;
		end
		--[[
		local gold = info.gold or 0;
		local crystal = info.crystal or 0;
		if g_euser.gold < gold then
			show_err(t_lang("TIP_NOT_ENOUGH_GOLD"));
			return;
		end
		if g_euser.crystal < crystal then
			show_err(t_lang("TIP_NOT_ENOUGH_CRYSTAL"));
			return;
		end
		]]--
		local card = info.card;
		if nil == card then return; end
		local cid = card.id;
		local cmd = string.format("mpiece %d", cid);
		net_send(cmd);
	end,

	merge = function(...)
		local self = layer_piece;
		local args = {...};
		local index = args[2]:getTag();
		self:merge_action(index);
	end,

	update_piece = function(self, card_id, count)
		for i = 1, #(self.list_piece) do
			local info = self.list_piece[i];
			local card = info.card;
			if card.id == card_id then
				info.current_piece_count = info.current_piece_count + count;
				break;
			end
		end
		self:reload();
	end,

	sort_list = function(self)
		local list = self.list_piece or {};
		local nlist = {};
		for i = #list, 1, -1 do
			local info = list[i];
			local has = info.current_piece_count;
			if has > 0 then
				table.insert(nlist, 1, info);
			else
				table.insert(nlist, info);
			end
		end
		self.list_piece = nlist;
		self:change_hero(self.in_hero, self.label_hero:getString());
		self:change_pick_type(self.in_type);
	end,

	update_all_piece = function(self, list)
		for i = 1, #(self.list_piece) do
			local info = self.list_piece[i];
			local card = info.card;
			for j = 1, #(list or {}) do
				local cid = list[j].cid;
				local cpc = list[j].count;
				if cid == card.id then
					info.current_piece_count = cpc;
					break;
				end
			end
		end
		self:sort_list();
		--self:reload();
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_piece;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return math.ceil(#(self.list or {})/2);
		elseif "scrollViewDidScroll" == event then
			local len = math.ceil(#self.list / 2);
			local offset = view:getContentOffset();
			self.offset = offset;
			util.handle_arrows(self.clarrow, self.crarrow, len, self.cwidth, self.twidth, offset);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local index = idx*2 + 1;
			if 2 == self.side then -- down
				index = index + 1;
			elseif 1 == self.side then -- up
				print('is_up');
			else
				return;
			end
			local info = self.list[index];
			if nil == info then
				return;
			end
			local layer, name = layer_alert:create(ALERT_GET_PIECE, info);
			g_scene:add_layer(ZORDER_LAYER_ALERT, layer, name, true);
			local cmd = 'piece_chapter ' .. info.card.id;
			net_send(cmd);
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local index = idx*2 + 1;
			local data = self.data_cell;
			--local data2 = gui_get_data('cframe', GUI_PIECE, ANCHOR_DOWN);
			local hh = height/2;
			local size;
			local len = index+1;
			if len > #self.list then len = #self.list; end
			for i = index, len do
				local info = self.list[i];
				local current_piece_count = info.current_piece_count;
				local merge_count = info.merge_count;
				--local gold = info.gold;
				--local crystal = info.crystal;
				--local card = clone(info.card);
				local card = info.card;
				local basey = 0;
				if i % 2 ~= 0 then
					basey = hh;
				end
				local sprite, data2, path;
				local frame, fdata;
				frame, fdata = gui_add_sprite_on_cell(cell, data, 'cframe', GUI_PIECE, ANCHOR_DOWN);
				frame:setAnchorPoint(ANCHOR_CENTER_CENTER)
				local s = frame:getContentSize();
				local ws = (width-(data.width-fdata.width))/s.width;
				local wh = (height-(data.height-fdata.height))/s.height;
				if ws < wh then
					scale = ws;
				else
					scale = wh;
				end
				frame:setScale(scale*self.cscale);
				frame:setPosition(cc.p(fdata.x+width/2, fdata.y+fdata.height*self.cscale/2+basey));
				local fname = 'card' .. card.id .. '.png';
				path = util.get_path(fname, 'card0.png');
				local mask_path = util.get_path('bg_155.png');
				pos = ccp(s.width/2, s.height/2);
				local pic = util.add_mask_sprite(frame, path, mask_path, pos, ANCHOR_CENTER_CENTER, -1);
				pic:setScale(s.height/pic:getContentSize().height);

				add_detail_for_show_frame(frame, card);

				fdata = gui_get_data('cframe', GUI_PIECE, ANCHOR_DOWN);
				sprite, data2 = gui_add_sprite_on_cell(frame, fdata, 'icon_piece', GUI_PIECE, ANCHOR_DOWN);
				path = util.get_path(FT_8);
				local str = current_piece_count .. "/" .. merge_count;
				sprite, data2 = gui_add_labelbmf_on_cell(frame,fdata,str,path,'n_piece',GUI_PIECE,ANCHOR_DOWN);
				sprite:setScale(0.7);
				--[[
				path = util.get_path(FT_2);
				if crystal > 0 then
					sprite, data2 = gui_add_sprite_on_cell(frame, fdata, 'bg_price', GUI_PIECE, ANCHOR_DOWN);
					sprite, data2 = gui_add_sprite_on_cell(frame, fdata, 'p_crystal', GUI_PIECE, ANCHOR_DOWN);
					str = crystal .. '';
				elseif gold > 0 then
					sprite, data2 = gui_add_sprite_on_cell(frame, fdata, 'bg_price', GUI_PIECE, ANCHOR_DOWN);
					sprite, data2 = gui_add_sprite_on_cell(frame, fdata, 'p_gold', GUI_PIECE, ANCHOR_DOWN);
					str = gold .. '';
				else
					str = "";
				end
				sprite, data2 = gui_add_labelbmf_on_cell(frame,fdata,str,path,'price',GUI_PIECE,ANCHOR_DOWN, cc.TEXT_ALIGNMENT_RIGHT);
				sprite:setScale(0.9);
				]]--

				local items = {};
				local item;

				item, data2 = gui_add_item_on_cell(items, data, 'btn_merge', GUI_PIECE, self.merge, ANCHOR_DOWN);
				item:setPosition(cc.p(data2.x+width/2, data2.y+basey));
				item:setAnchorPoint(ANCHOR_CENTER_DOWN);
				item:setTag(i);

				util.add_menu(cell, items, data2.zorder);

				if current_piece_count == 0 then
					util.set_gray(frame);
					local list = frame:getChildren();
					for i = 1, #list do
						local s = list[i];
						--print('type: ', tolua.type(s));
						if "cc.Label" ~= tolua.type(s) then
							util.set_gray(s);
						end
					end
					enable_btn(item, false);
				end
			end
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_piece;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function (self, x, y)
		if y > self.line then
			self.side = 1; -- up
		else
			self.side = 2; -- down
		end
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
	end,
	
	onTouchEnded = function(self, x, y)
	end,

} -- layer_piece end

layer_pmystery = { -- start    
	name = 'layer_pmystery',
	layer = nil,
	list_pick_type = {
		{ tag = 1, title = '所有分类' },
		{ tag = 2, title = '英雄' },
		{ tag = 3, title = '附加' },
		{ tag = 4, title = '技能' },
		{ tag = 5, title = '盟军' },
		{ tag = 6, title = '武器' },
		{ tag = 7, title = '防具' },
		{ tag = 8, title = '支援' },
	},
	in_hero = nil,
	in_type = nil,
	list = nil,
	list_phero = nil,
	list_total = nil,
	tableview = nil,
	data_cell = nil,
	clarrow = nil,
	crarrow = nil,
	twidth = nil,
	line = nil,
	side = nil,
	offset = nil,
	label_hero = nil,
	label_type = nil,
	btn_hero = nil,
	cscale = nil,

	cleanup = function(self)
		self.layer = nil;
		self.in_hero = nil;
		self.in_type = nil;
		self.list = nil;
		self.list_phero = nil;
		self.list_total = nil;
		self.tableview = nil;
		self.data_cell = nil;
		self.clarrow = nil;
		self.crarrow = nil;
		self.twidth = nil;
		self.line = nil;
		self.side = nil;
		self.offset = nil;
		self.label_hero = nil;
		self.label_type = nil;
		self.btn_hero = nil;
		self.cscale = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, list)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_PIECE, self.handler, true);

		local offsetheight = init_bg_full(self.layer, GUI_PMYSTERY, self.back);

		local sprite, data, pos, size, path;
		sprite,data = gui_add_sprite(self.layer,'outframe',GUI_PMYSTERY,ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));

		gui_add_sprite(self.layer,'subbar',GUI_PIECE,ANCHOR_UP);
		self.label_hero = gui_add_label(self.layer, '', 21, 'hero_name', GUI_PMYSTERY, ANCHOR_UP);
		self.label_type = gui_add_label(self.layer, '', 21, 'type_name', GUI_PMYSTERY, ANCHOR_UP);

		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn_hero', GUI_PMYSTERY, self.pick_hero, ANCHOR_UP);
		self.btn_hero = item;
		self:add_hero_image(0);

		item, data = gui_add_item(items, 'btn_type', GUI_PMYSTERY, self.pick_type, ANCHOR_UP);

		util.add_menu(self.layer, items, data.zorder);

		self.list = {};
		data = gui_get_data('cell', GUI_PMYSTERY, ANCHOR_DOWN);
		local nheight = data.height + offsetheight;
		local sh = nheight/data.height;
		self.cscale = sh;
		data.width = data.width * sh;
		data.height = data.height * sh;
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height;
		data = gui_get_data('table', GUI_PMYSTERY, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		self.twidth = size.width;
		self.line = pos.y + size.height/2;
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		self.clarrow, self.crarrow = util.add_arrows(self.layer, pos, size, self.cwidth, 0, cc.p(0, 0));

		self:add_to_list(list);

		return self.layer, self.name;
	end,

	syn_hero_list = function(self, new_index)
		-- layer_pmystery
		new_index = (new_index or self.in_hero) or 1;
		local nlist = {};
		local list = self.list_total;
		local tag = new_index;
		if 0 == tag then -- all kind of type
			for i = 1, #list do
				table.insert(nlist, list[i]);
			end
		else
			local cid = tag;
			for i = 1, #list do
				local card = list[i].card;
				local is_fit = fit_hero_id(cid, card.id);
				if cid == card.id or true == is_fit then
					table.insert(nlist, list[i]);
				end
			end
		end
		self.list = nlist;
		self.list_phero = self.list;
		return self.list;
	end,

	syn_type_list = function(self, new_index)
		-- layer_pmystery
		new_index = (new_index or self.in_type) or 1;
		local nlist = {};
		local list = self.list_phero or self.list;
		local info = self.list_pick_type[new_index];
		local tag = info.tag;
		if 1 == tag then -- all kind of type
			for i = 1, #list do
				table.insert(nlist, list[i]);
			end
		elseif 2 == tag then -- hero 
			for i = 1, #list do
				local card = list[i].card;
				if HERO == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 3 == tag then -- attach 
			for i = 1, #list do
				local card = list[i].card;
				if ATTACH == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 4 == tag then -- ability 
			for i = 1, #list do
				local card = list[i].card;
				if ABILITY == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 5 == tag then -- ally 
			for i = 1, #list do
				local card = list[i].card;
				if ALLY == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 6 == tag then -- weapon 
			for i = 1, #list do
				local card = list[i].card;
				if WEAPON == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 7 == tag then -- armor 
			for i = 1, #list do
				local card = list[i].card;
				if ARMOR == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		elseif 8 == tag then -- SUPPORT 
			for i = 1, #list do
				local card = list[i].card;
				if SUPPORT == card.ctype or TRAP == card.ctype or ARTIFACT == card.ctype then
					table.insert(nlist, list[i]);
				end
			end
		end
		self.list = nlist;
		return self.list;
	end,

	change_pick_type = function(self, new_index)
		-- layer_pmystery
		new_index = new_index or 1;
		local titles = self.list_pick_type or {};
		if 0 == titles then return; end

		local info = titles[new_index];
		if nil == info then return; end
		local name = info.title;
		self.label_type:setString(name);

		if new_index ~= self.in_type then
			self.offset = nil;
		end
		self.in_type = new_index;

		self:syn_type_list(new_index);
		self:reload();
	end,

	add_hero_image = function(self, hid)
		-- layer_pmystery
		local btn = self.btn_hero;
		local fname, path, pic, pos;
		pic = btn:getChildByTag(97);
		if nil ~= pic then
			pic:removeFromParent(true);
		end
		if hid == 0 then
			fname = 'pic_94.png';
		else
			fname = 'card' .. hid .. '.png';
		end
		path = util.get_path(fname, 'card0.png');
		local mask_path = util.get_path('bg_160.png');
		local size = btn:getContentSize();
		pos = cc.p(size.width/2, size.height/2);
		pic = util.add_mask_sprite(btn, path, mask_path, pos, ANCHOR_CENTER_CENTER, -1);
		pic:setTag(97);
		pic:setScale(size.height/pic:getContentSize().height);
	end,

	change_hero = function(self, hid, name, in_type)
		hid = hid or 0;
		self:add_hero_image(hid);
		if hid ~= self.in_hero then
			name = name or "???";
			self.label_hero:setString(name);
		end
		self.in_hero = hid;
		self:syn_hero_list(hid);
		self:reload();

		self.in_type = in_type or self.in_type;
		self:change_pick_type(self.in_type);
	end,

	cb_change_hero = function(...)
		local self = layer_pmystery;
		self:change_hero(...);
	end,

	pick_hero = function()
		local self = layer_pmystery;
		local t = layer_hero.TYPE_SORT;
		local cb = self.cb_change_hero;
		g_scene:add_layer(ZORDER_LAYER_HERO, layer_hero:create(t, cb));
		net_send("lhero"); 
		--g_scene:hero(layer_hero.TYPE_SORT);
		layer_hero.mark_hero_index = self.in_hero;
		layer_hero.mark_type_index = self.in_type;
		layer_hero.mark_hero_name = self.label_hero:getString();
	end,

	callback_pick_type = function(index)
		local self = layer_pmystery;
		self:change_pick_type(index);
	end,

	pick_type = function()
		local self = layer_pmystery;
		local cb = self.callback_pick_type;
		local list = self.list_pick_type;
		local layer, name = layer_pick:create(list, cb);
		g_scene:add_layer(ZORDER_LAYER_PICK, layer, name, true);
	end,

	reload = function(self)
		-- layer_pmystery
		local offset = self.offset;
		self.tableview:reloadData();
		if nil ~= offset then
			self.tableview:setContentOffset(offset, false);
		end
	end,

	callback_reloadlist = function()
		play_tap_3();
		local self = layer_pmystery;
		self.list = {};
		net_send("cpiece", true);
		net_send("lpiece", true);
	end,

	add_to_list = function(self, list)
		self.list_total = {};
		for i = 1, #list do
			local info = list[i];
			--print('info.cid: ', info.cid);
			table.insert(self.list_total, info);
			--[[
			if info.card.ctype == HERO then
				local tag = info.card.id;
				local title = info.card.name;
				table.insert(self.list_pick_hero, {tag=i+1, title=title});
			end
			]]--
		end
		self.list = {};
		for i = 1, #self.list_total do
			local info = self.list_total[i];
			table.insert(self.list, info);
		end
		self:change_hero(0, "所有英雄");
		self:change_pick_type(self.in_type);
	end,

	back = function()
		play_tap_1();
		local self = layer_pmystery;
		self:remove();
	end,

	sort_list = function(self)
		local list = self.list_total or {};
		local nlist = {};
		for i = #list, 1, -1 do
			local info = list[i];
			local has = info.current_piece_count;
			if has > 0 then
				table.insert(nlist, 1, info);
			else
				table.insert(nlist, info);
			end
		end
		self.list_total = nlist;
		self:change_hero(self.in_hero, self.label_hero:getString());
		self:change_pick_type(self.in_type);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_pmystery;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return math.ceil(#(self.list or {})/2);
		elseif "scrollViewDidScroll" == event then
			local len = math.ceil(#self.list / 2);
			local offset = view:getContentOffset();
			self.offset = offset;
			util.handle_arrows(self.clarrow, self.crarrow, len, self.cwidth, self.twidth, offset);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local index = idx*2 + 1;
			if 2 == self.side then -- down
				index = index + 1;
			elseif 1 == self.side then -- up
				print('is_up');
			else
				return;
			end
			local info = self.list[index];
			if nil == info then
				return;
			end
			local card = clone(info.card);
			g_scene:add_layer(ZORDER_LAYER_MISPOP, layer_mispop:create(card));
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local index = idx*2 + 1;
			local data = self.data_cell;
			local hh = height/2;
			local size;
			local len = index+1;
			if len > #self.list then len = #self.list; end
			for i = index, len do
				local info = self.list[i];
				--local gold = info.gold;
				--local crystal = info.crystal;
				--local card = clone(info.card);
				local card = info.card;
				local basey = 0;
				if i % 2 ~= 0 then
					basey = hh;
				end
				local sprite, data2, path;
				local frame, fdata;
				frame, fdata = gui_add_sprite_on_cell(cell, data, 'cframe', GUI_PIECE, ANCHOR_DOWN);
				frame:setAnchorPoint(ANCHOR_CENTER_CENTER)
				local s = frame:getContentSize();
				local ws = (width-(data.width-fdata.width))/s.width;
				local wh = (height-(data.height-fdata.height))/s.height;
				if ws < wh then
					scale = ws;
				else
					scale = wh;
				end
				frame:setScale(scale*self.cscale);
				frame:setPosition(cc.p(fdata.x+width/2, fdata.y+fdata.height*self.cscale/2+basey));
				local fname = 'card' .. card.id .. '.png';
				path = util.get_path(fname, 'card0.png');
				local mask_path = util.get_path('bg_155.png');
				pos = ccp(s.width/2, s.height/2);
				local pic = util.add_mask_sprite(frame, path, mask_path, pos, ANCHOR_CENTER_CENTER, -1);
				pic:setScale(s.height/pic:getContentSize().height);

				add_detail_for_show_frame(frame, card);

				fdata = gui_get_data('cframe', GUI_PMYSTERY, ANCHOR_DOWN);
				sprite, data2 = gui_add_sprite_on_cell(frame, fdata, 'icon_piece', GUI_PIECE, ANCHOR_DOWN);
				--[[
				path = util.get_path(FT_8);
				local str = current_piece_count .. "/" .. merge_count;
				sprite, data2 = gui_add_labelbmf_on_cell(frame,fdata,str,path,'n_piece',GUI_PIECE,ANCHOR_DOWN);
				sprite:setScale(0.7);
				path = util.get_path(FT_2);
				if crystal > 0 then
					sprite, data2 = gui_add_sprite_on_cell(frame, fdata, 'bg_price', GUI_PIECE, ANCHOR_DOWN);
					sprite, data2 = gui_add_sprite_on_cell(frame, fdata, 'p_crystal', GUI_PIECE, ANCHOR_DOWN);
					str = crystal .. '';
				elseif gold > 0 then
					sprite, data2 = gui_add_sprite_on_cell(frame, fdata, 'bg_price', GUI_PIECE, ANCHOR_DOWN);
					sprite, data2 = gui_add_sprite_on_cell(frame, fdata, 'p_gold', GUI_PIECE, ANCHOR_DOWN);
					str = gold .. '';
				else
					str = "";
				end
				sprite, data2 = gui_add_labelbmf_on_cell(frame,fdata,str,path,'price',GUI_PIECE,ANCHOR_DOWN, cc.TEXT_ALIGNMENT_RIGHT);
				sprite:setScale(0.9);

				local items = {};
				local item;

				item, data2 = gui_add_item_on_cell(items, data, 'btn_merge', GUI_PIECE, self.merge, ANCHOR_DOWN);
				item:setPosition(cc.p(data2.x+width/2, data2.y+basey));
				item:setAnchorPoint(ANCHOR_CENTER_DOWN);
				item:setTag(i);

				util.add_menu(cell, items, data2.zorder);

				if current_piece_count == 0 then
					util.set_gray(frame);
					local list = frame:getChildren();
					for i = 1, #list do
						local s = list[i];
						--print('type: ', tolua.type(s));
						if "cc.Label" ~= tolua.type(s) then
							util.set_gray(s);
						end
					end
					enable_btn(item, false);
				end
				]]--
			end
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_pmystery;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function (self, x, y)
		if y > self.line then
			self.side = 1; -- up
		else
			self.side = 2; -- down
		end
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
	end,
	
	onTouchEnded = function(self, x, y)
	end,

} -- layer_pmystery end

layer_rank = {
	name = 'layer_rank',
	layer = nil,
	list_tab = { -- tab_id, unselected data index, selected data index
		{ LADDER_RATING, 'rate', '积分' }, 
		{ LADDER_CHAPTER, 'arena', '战役' },
		{ LADDER_ARENA, 'arena', '竞技场' },
		{ LADDER_LEVEL, 'level', '等级' }, 
		{ LADDER_GUILD, 'guild', '公会' }, 
		{ LADDER_COLLECT, 'collect', '搜集' }, 
		--{ LADDER_GOLD, 'gold' },
	},
	tab_index = nil,
	data_cell_tab = nil,
	tab_rarrow = nil,
	tab_larrow = nil,
	tab_tableview = nil,
	tab_twidth = nil,
	list = nil,
	tableview = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,
	my_rank = nil,
	do_cell_anim = nil,
	is_from_arena = nil,

	cleanup = function(self)
		self.layer = nil;
		self.tab_index = nil;
		self.data_cell_tab = nil;
		self.tab_rarrow = nil;
		self.tab_larrow = nil;
		self.tab_tableview = nil;
		self.tab_twidth = nil;
		self.list = nil;
		self.tableview = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
		self.my_rank = nil;
		self.do_cell_anim = nil;
		self.is_from_arena = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, stab)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_RANK, self.handler, true);

		self.list_toggle = {};
		self.list = {};

		local offsetheight = init_bg_full(self.layer, GUI_RANK, self.back);

		local sprite, data, pos, size, path;
		sprite,data = gui_add_sprite(self.layer,'outframe',GUI_RANK,ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));

		data = gui_get_data('cell_bar', GUI_RANK, ANCHOR_UP);
		self.data_cell_tab = data;
		data = gui_get_data('table_bar', GUI_RANK, ANCHOR_UP);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height);
		self.tab_twidth = size.width;
		self.tab_tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tab_tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, data.zorder);
		self.tab_larrow, self.tab_rarrow = util.add_arrows(self.layer, pos, size, self.data_cell_tab.width, #self.list_tab, cc.p(0, 0));
		self.tab_larrow:setScale(0.5);
		self.tab_rarrow:setScale(0.5);

		sprite,data = gui_add_sprite(self.layer,'bg_detail',GUI_RANK,ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));
		sprite, data = gui_add_sprite(self.layer,'fade_bottom',GUI_RANK,ANCHOR_DOWN);
		sprite:setScaleX(data.width/sprite:getContentSize().width);
		gui_add_sprite(self.layer,'bg_mine',GUI_RANK,ANCHOR_DOWN);
		path = util.get_path(FT_4);
		str = "0";
		self.my_rank = gui_add_labelbmf(self.layer, str, path, 'n_mine', GUI_RANK, ANCHOR_DOWN); 
		self.my_rank:setScale(0.9);

		data = gui_get_data('cell', GUI_RANK, ANCHOR_DOWN);
		self.data_cell = data;
		data = gui_get_data('table', GUI_RANK, ANCHOR_DOWN);
		size = cc.size(data.width, data.height + offsetheight);
		pos = cc.p(data.x, data.y);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, ccp(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+10);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		self.tab_index = nil;
		stab = stab or 1;
		if 2 == stab then
			self.is_from_arena = true;
		end
		self:change_tab(stab);

		return self.layer, self.name;
	end,

	reload = function(self)
		self.do_cell_anim = true;
		self.tableview:reloadData();
	end,

	change_tab = function(self, new_tab)
		local otab = self.tab_index;
		if new_tab == otab then
			return;
		end
		self.tab_index = new_tab;
		local toffset = self.tab_tableview:getContentOffset();
		self.tab_tableview:reloadData();
		self.tab_tableview:setContentOffset(toffset);
		local ninfo = self.list_tab[new_tab];
		if nil == ninfo then return; end
		local cmd;
		if ninfo[1] == LADDER_ARENA then
			cmd = 'arenatop';
		else
			cmd = 'ladder ' .. ninfo[1];
		end
		net_send(cmd);
	end,

	set_list = function(self, list)
		local my_info = list[#list];
		if nil ~= my_info then
			local l = my_info.rank;
			self.my_rank:setString(l);
			table.remove(list, #list);
		end
		self.list = list or {};
		self:reload();
	end,

	tab_tableview_handler = function(...)  -- { start
		local self = layer_rank;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list_tab or {});
		elseif "scrollViewDidScroll" == event then
			local offset = view:getContentOffset();
			util.handle_arrows(self.tab_larrow, self.tab_rarrow, #self.list_tab, self.data_cell_tab.width, self.tab_twidth, offset);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local index = cell:getIdx() + 1;
			self:change_tab(index);
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			local data = self.data_cell_tab;
			return data.height, data.width;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local data = self.data_cell_tab;
			local sprite = gui_add_cell_bg(cell, data);
			local path = nil;
			if idx + 1 == 1 then
				path = util.get_path("bg_185.png");
			elseif idx + 1 == #self.list_tab then
				path = util.get_path("bg_186.png");
			end
			if nil ~= path then
				local tc = cc.Director:getInstance():getTextureCache();
				local texture = tc:addImage(path);
				if nil ~= texture then 
					sprite:setTexture(texture);
				end
			end
			local width = data.width;
			local height = data.height;
			local info = self.list_tab[idx+1];
			local data2, item, str;
			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'b_btn', GUI_RANK, ANCHOR_UP);
			if self.tab_index == idx+1 then
				local path = util.get_path(data2.fname2);
				local tc = cc.Director:getInstance():getTextureCache();
				local texture = tc:addImage(path);
				if nil ~= texture then
					sprite:setTexture(texture);
				end
			end
			str = info[3] or "???";
			gui_add_text_on_sprite(sprite,str,'b_btn_t',GUI_RANK,ANCHOR_UP,30);
			return cell;
		end
	end, -- tab_tableview_handler end }

	tableview_handler = function(...)  -- { start
		local self = layer_rank;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.list[idx + 1];
			if tonumber(info.ladder_type) == LADDER_GUILD then
				local gid = info.info_id;
			else
				local d = { eid = info.info_id, icon = info.icon,
							alias = info.name };
				g_scene:add_layer(ZORDER_LAYER_CHATPOP, layer_chatpop:create(d));
			end
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			local data = self.data_cell;
			return data.height, data.width;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local width = data.width;
			local height = data.height;
			local info = self.list[idx + 1];
			local sprite, data2, str, path;
			
			str = info.name;
			sprite = gui_add_label_on_cell(cell,data,str,23,'alias',GUI_RANK,ANCHOR_DOWN);
			if tonumber(info.ladder_type) ~= LADDER_GUILD then
				sprite, data2 = gui_add_sprite_on_cell(cell, data, 'icon_player', GUI_RANK, ANCHOR_DOWN);
				path = get_icon_path(info.icon or 0);
				pos = cc.p(0, 0);
				sprite=util.add_sprite(sprite,path,pos,ANCHOR_LEFT_DOWN,-1);
				sprite:setScale((data2.width-4)/sprite:getContentSize().width);
				--sprite:setScaleY(data2.height/sprite:getContentSize().height);
			else
				data2 = gui_get_data('icon_player', GUI_RANK, ANCHOR_DOWN);
				sprite:setPositionX(data2.x-data.x);
			end
			sprite=gui_add_sprite_on_cell(cell,data,'cup',GUI_RANK,ANCHOR_DOWN);
			local fname = nil;
			if info.rank == 1 then
				fname = "icon_35.png";
			elseif info.rank == 2 then
				fname = "icon_36.png";
			elseif info.rank == 3 then
				fname = "icon_37.png";
			end
			if nil ~= fname then
				local tc = cc.Director:getInstance():getTextureCache();
				local path = util.get_path(fname);
				local texture = tc:addImage(path);
				if nil ~= texture then
					sprite:setTexture(texture);
				end
			end
			path = util.get_path(FT_12);
			str = info.rank;
			sprite, data2 = gui_add_labelbmf_on_cell(cell, data, str, path, 'n_cup', GUI_RANK, ANCHOR_DOWN, cc.TEXT_ALIGNMENT_CENTER); 
			if tonumber(info.rank) < 4 then
				sprite:setPositionY(data2.y + data2.height/3);
			end
			local key1, key2, str1, str2;
			local tab = info.ladder_type;
			if tab == LADDER_RATING then
				gui_add_sprite_on_cell(cell,data,'t_point',GUI_RANK,ANCHOR_DOWN);
				key1 = "n_point";
			elseif tab == LADDER_LEVEL then
				gui_add_sprite_on_cell(cell,data,'t_lv',GUI_RANK,ANCHOR_DOWN);
				key1 = "n_lv";
			elseif tab == LADDER_GUILD then
				gui_add_sprite_on_cell(cell,data,'t_guild_lv',GUI_RANK,ANCHOR_DOWN);
				gui_add_sprite_on_cell(cell,data,'t_guild_member',GUI_RANK,ANCHOR_DOWN);
				key1 = "n_guild_lv";
				key2 = "n_guild_member";
			elseif tab == LADDER_COLLECT then
				gui_add_sprite_on_cell(cell,data,'t_collect',GUI_RANK,ANCHOR_DOWN);
				key1 = "n_collect";
			elseif tab == LADDER_CHAPTER then
				gui_add_sprite_on_cell(cell,data,'t_chapter',GUI_RANK,ANCHOR_DOWN);
				gui_add_sprite_on_cell(cell,data,'t_star',GUI_RANK,ANCHOR_DOWN);
				key1 = "n_chapter";
				key2 = "n_star";
				str1 = info.chapter_id .. '-' .. info.stage_id;
				str2 = info.star_count;
			elseif tab == LADDER_ARENA then
				gui_add_sprite_on_cell(cell,data,'t_arena_lv',GUI_RANK,ANCHOR_DOWN);
				key1 = "n_arena_lv";
				str1 = info.level .. '';
				gui_add_sprite_on_cell(cell,data,'t_arena_win',GUI_RANK,ANCHOR_DOWN);
				key2 = "n_arena_win";
				--str2 = math.floor(info.rating*100) .. '%%';
				str2 = string.format("%2d%%", info.rating*100);
			--elseif tab == chapter sth then
			end
			if nil ~= key1 then
				if tab == LADDER_CHAPTER then
					path = util.get_path(FT_7);
				else
					path = util.get_path(FT_1);
				end
				if nil ~= str1 then
					str = str1;
				else
					str = info.point;
				end
				gui_add_labelbmf_on_cell(cell, data, str, path, key1, GUI_RANK, ANCHOR_DOWN); 
			end
			if nil ~= key2 and nil ~= str2 then
				path = util.get_path(FT_5);
				str = str2;
				sprite, data2 = gui_add_labelbmf_on_cell(cell, data, str, path, key2, GUI_RANK, ANCHOR_DOWN); 
				sprite:setPositionY(data2.y+6);
				sprite:setScale(0.8);
			end
			if true == self.do_cell_anim then
				local delay = (idx%10)*0.1;
				keff_showup_1(cell, delay);
			end
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	back = function()
		play_tap_1();
		local self = layer_rank;
		if true == self.is_from_arena then
			show_pclg();
			return;
		end
		--g_scene:go(GUI_MAP, "map");
		g_scene:map();
	end,

	handler = function(event, x, y)
		local self = layer_rank;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		self.do_cell_anim = false;

	end,
} -- layer_rank end

layer_forum = { -- start
	name = 'layer_forum',
	layer = nil, 

	cleanup = function(self)
		self.layer = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_FORUM, self.handler, true);
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 200));
		
		return self.layer, self.name;
	end, 

	callback = function(event)
		kdebug("event[%s]", event);
		local self = layer_forum;
		if nil == self.layer then
			return;
		end
		if "back" == event then
			self:remove();
		end
	end,

	handler = function(event, x, y)
		local self = layer_forum;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			play_tap_1();
			self:remove();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
	end,
} -- layer_forum end

layer_appstorepay = { -- start
	name = 'layer_appstorepay',
	layer = nil, 

	cleanup = function(self)
		self.layer = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_APPSTOREPAY,self.handler,true);
		
		return self.layer, self.name;
	end, 

	callback = function(...)
		local args = {...};
		local event = args[1];
		kdebug("event[%s]", event);
		local self = layer_appstorepay;
		if nil == self.layer then
			return;
		end
		if "back" == event then
			self:remove();
		elseif "receipt" == event then
			print('app store receipt:');	
			local r = args[2];
			print(r);	
			--[[
			show_netloading();
			local xhr = cc.XMLHttpRequest:new();
			xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_STRING;
			local r = string.format("http://%s:8899/pay_server/order?playerId=%d&serverId=%s&payCode=%s", IP_ADDR, tonumber(g_euser.eid), serverId, payCode);
			xhr:open("GET", r);
			local function callback_xhr()
				hide_netloading();
				local status = "Http Status Code:" .. xhr.statusText;
			end
			hide_netloading();
			xhr:registerScriptHandler(callback_xhr);
			xhr:send();
			]]--
		end
	end,

	handler = function(event, x, y)
		local self = layer_appstorepay;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
	end,
} -- layer_appstorepay end

layer_gm = { -- start
	name = 'layer_gm',
	layer = nil, 
	list = nil,
	cwidth = nil,
	cheight = nil,
	tableview = nil,
	bar = nil,
	tap = nil,
	eid = nil,
	alias = nil,
	data_cell = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.tableview = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_ANIM, self.handler, false);

		self.list = {
			-- tag, title, number
			{ tag = 1, t = "客服微信", n = "1918230995", },
			{ tag = 2, t = "客服QQ", n = "1918230995", },
			{ tag = 3, t = "QQ交流群1", n = "90196112", },
		};
		-- btn back set in g_scene.deck
		init_bg_for_full_view(self.layer, GUI_GM, '联系客服');
		local d1 = gui_get_data('table', GUI_GM, ANCHOR_UP);
		local d2 = gui_get_data('table', GUI_GM, ANCHOR_DOWN);
		local offsety = d1.y - d2.y;
		local sprite, data;
		data = gui_get_data('cell', GUI_GM, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height+10;
		data = gui_get_data('table', GUI_GM, ANCHOR_DOWN);
		size = cc.size(data.width, data.height+offsety);
		pos = cc.p(data.x, data.y);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		gui_add_sprite(self.layer, 'bg_intro', GUI_GM,ANCHOR_DOWN);
		local str = '客服工作时间\n周一至周五 10:00 ~ 18:00\n\n请亲们加客服微信1918230995，以便及时了解更新更快的游戏通知';
		gui_add_label(self.layer, str, 22, 'intro', GUI_GM, ANCHOR_DOWN);

		return self.layer, self.name;
	end, 

	back = function()
		play_tap_1();
		g_scene:map();
	end,

	action = function(...)
		play_tap_1();
		local self = layer_gm;
		local args = {...};
		local tag = args[2]:getTag();
		local info = self.list[tag];
		local text = info.n;
		util.text_to_pasteboard(text);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_gm;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local info = self.list[idx + 1];
			local tag = info.tag;
			local tip = info.t;
			local number = info.n;
			local data2, sprite, path, pos, size, str;

			str = tip;
			gui_add_label_on_cell(cell,data,str,28,'tip',GUI_GM,ANCHOR_DOWN);
			str = number;
			gui_add_label_on_cell(cell,data,str,28,'number',GUI_GM,ANCHOR_DOWN);

			local items = {};
			local item;

			item, data2 = gui_add_item_on_cell(items, data, 'btn_action', GUI_GM, self.action, ANCHOR_DOWN);
			item:setTag(tag);
			gui_add_text_on_sprite(item,'复制','t_action',GUI_GM,ANCHOR_UP,30);

			util.add_menu(cell, items, data2.zorder);

			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_gm;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
	end,

} -- layer_gm end

layer_service = {
	name = 'layer_service',
	layer = nil,
	list = nil,
	tableview = nil,
	rect = nil,
	cwidth = nil,
	cheight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,
	icon_up = nil,
	icon_down = nil,
	theight = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.rect = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
		self.icon_up = nil;
		self.icon_down = nil;
		self.theight = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_SERVICE, self.handler, true);

		self.list = {};
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));

		local data;
		local offsetheight, sprite, rect = init_bg_for_view(self.layer, GUI_SERVICE, '对战次数每日0点刷新', self.back);
		self.rect = rect;

		local tip = "1.金币场与钻石场生命5点以上投降视为强退\n2.强退方受1次机会额外惩罚\n3.被强退方退回入场费与次数";
		gui_add_label(self.layer, tip, 22, 'tip', GUI_SERVICE, ANCHOR_DOWN);

		data = gui_get_data('cell', GUI_SERVICE, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		data = gui_get_data('table', GUI_SERVICE, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		self.theight = size.height;
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		pos = cc.p(data.x+data.width, data.y+size.height);
		self.icon_up = add_scroll_icons(self.layer, pos, true);
		self.icon_up:setVisible(false);
		pos = cc.p(data.x+data.width, data.y);
		self.icon_down = add_scroll_icons(self.layer, pos, false);
		self.icon_down:setVisible(false);

		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		local self = layer_service;
		self:remove();
	end,

	set_show = function(self, is_show)
		if nil == layer_service.layer then return; end
		layer_service.layer:setVisible(is_show);
	end,

	reload = function(self)
		self.tableview:reloadData();
	end,

	add_info = function(self, data)
		self.list = {};
--		local open_flag = 1;
--		if open_flag == data.pve_status then
			table.insert(self.list, { bg = "bg_68.png", tag = GAME_SOLO_GOLD, 
						data = { 
							time_left = data.pve_time, 
							reward = data.pve_gold_reward, 
							reward_type = 'gold', 
							fee = data.pve_gold_cost, 
							fee_type = 'gold', 
						}, 
						flag = data.pve_status
			});
--		end
--		if open_flag == data.pvp_gold_status then
			table.insert(self.list, { bg = "bg_69.png", tag = GAME_VS_GOLD, 
						data = { 
							time_left = data.pvp_gold_time, 
							reward = data.pvp_gold_reward, 
							reward_type = 'gold', 
							fee = data.pvp_gold_cost, 
							fee_type = 'gold', 
							start_time = data.pvp_gold_start_time,
							end_time = data.pvp_gold_end_time,
						}, 
						flag = data.pvp_gold_status
			});
--		end
--		if open_flag == data.pvp_crystal_status then
			table.insert(self.list, { bg = "bg_70.png", tag = GAME_VS_CRYSTAL, 
						data = { 
							time_left = data.pvp_crystal_time, 
							reward = data.pvp_crystal_reward, 
							reward_type = 'crystal', 
							fee = data.pvp_crystal_cost, 
							fee_type = 'crystal', 
							start_time = data.pvp_crystal_start_time,
							end_time = data.pvp_crystal_end_time,
						}, 
						flag = data.pvp_crystal_status
			});
--		end
--		if open_flag == data.pvp_free_status then
			table.insert(self.list, {
						bg = "bg_71.png", tag = GAME_VS_FREE, data = {
							reward = data.pvp_free_reward, 
							reward_type = 'gold', 
							lose = data.pvp_free_lose, 
							lose_type = 'gold', 
						},
						flag = data.pvp_free_status
			});
--		end
--		if open_flag == data.pve_free_status then
			table.insert(self.list, {
						bg = "bg_72.png", tag = GAME_SOLO_FREE, data = {
							reward = data.pve_free_reward, 
							reward_type = 'gold', 
							lose = data.pve_free_lose, 
							lose_type = 'gold', 
						},
						flag = data.pve_free_status
			});
--		end
		self:reload();
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_service;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			update_scroll_icon(self.icon_up, self.icon_down, view, self.theight);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			play_tap_3();
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.list[idx + 1];
--			print('xxx: ', info.data.time_left, info.tag);
			local open_flag = 1;
			if open_flag ~= info.flag then
				show_msg("未开放");
				return;
			end
			if nil ~= info.data.time_left and info.data.time_left <= 0 then
				show_msg("今日挑战次数已经用完");
				return;
			end
			local fee_type = info.data.fee_type;
			local fee = info.data.fee or 0;
			if fee_type == 'gold' then
				if fee > g_euser.gold then
					show_msg(t_lang("TIP_NOT_ENOUGH_GOLD"));
					return;
				end
			elseif fee_type == 'crystal' then
				if fee > g_euser.crystal then
					show_money_tip(t_lang("TIP_NOT_ENOUGH_CRYSTAL"));
					return;
				end
			end
			local tag = info.tag;
			if tag==GAME_VS_GOLD or tag==GAME_VS_CRYSTAL or tag==GAME_VS_FREE then
				self:set_show(false);
				local layer, name = layer_quick:create();
				g_scene:add_layer(ZORDER_LAYER_QUICK, layer, name, true);
				layer_quick:start_waiting();
			end
			local cmd = string.format("fight %d", tag);
			net_send(cmd);
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			local info = self.list[idx + 1];
			data.fname1 = info.bg;
			gui_add_cell_bg(cell, data);
			local ttt = info.data;
			local time_left = ttt.time_left;
			local str;
			local sprite, data2;
			if nil ~= time_left then
				str = time_left;
				--path = util.get_path(FNT_1);
				local path = util.get_path('font_deck_num.fnt');
				gui_add_labelbmf_on_cell(cell,data,str,path,'num_left',GUI_SERVICE,ANCHOR_DOWN);
			end

			if nil ~= ttt.reward then
				str = '胜利奖励';
				local tip1,tips1_data = gui_add_label_on_cell(cell,data,str,25,'t_reward',GUI_SERVICE,ANCHOR_DOWN);
				path = util.get_path(FNT_1);
				str = ttt.reward or 0;
				local tip2, tips2_data = gui_add_labelbmf_on_cell(cell,data,str,path,'n_reward',GUI_SERVICE,ANCHOR_DOWN);
				sprite, data2 = gui_add_sprite_on_cell(cell, data, 'icon_reward', GUI_SERVICE, ANCHOR_DOWN);
				if 'crystal' == ttt.reward_type then
					local path = util.get_path(data2.fname2);
					local tc = cc.Director:getInstance():getTextureCache();
					local texture = tc:addImage(path);
					if nil ~= texture then 
						sprite:setTexture(texture);
					end
				end

				if info.tag == GAME_VS_FREE or info.tag == GAME_SOLO_FREE then
					tip1:setPositionY(tips1_data.y - tips1_data.height);
					tip2:setPositionY(tips2_data.y - tips2_data.height);
					sprite:setPositionY(data2.y - tips1_data.height);
				end
			end

			if nil ~= ttt.fee then
				str = '入场费';
				gui_add_label_on_cell(cell,data,str,25,'t_fee',GUI_SERVICE,ANCHOR_DOWN);
				str = ttt.fee or 0;
				gui_add_labelbmf_on_cell(cell,data,str,path,'n_fee',GUI_SERVICE,ANCHOR_DOWN);
				sprite, data2 = gui_add_sprite_on_cell(cell, data, 'icon_fee', GUI_SERVICE, ANCHOR_DOWN);
				if 'crystal' == ttt.fee_type then
					local path = util.get_path(data2.fname2);
					local tc = cc.Director:getInstance():getTextureCache();
					local texture = tc:addImage(path);
					if nil ~= texture then 
						sprite:setTexture(texture);
					end
				end
			end

			local s_time = ttt.start_time;
			local e_time = ttt.end_time;
			if nil ~= s_time and nil ~= e_time and s_time ~= e_time then
				local ts = os.date("*t", s_time);
				local te = os.date("*t", e_time);
				str = string.format("开放时间:\n%02d:%02d:%02d ~ %02d:%02d:%02d", ts.hour, ts.min, ts.sec, te.hour, te.min, te.sec);
				util.add_labeloutline(cell, str, nil, 19, cc.p(10, 10), util.c4b_black, util.c4b_white, 2, ANCHOR_LEFT_DOWN, 60);
			end
			
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_service;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,
} -- layer_service end

layer_lottery = {
	name = 'layer_lottery',
	LTYPE_ONE_GOLD = 1,
	LTYPE_TEN_GOLD = 2,
	LTYPE_ONE_CRYSTAL = 3,
	LTYPE_TEN_CRYSTAL = 4,
	layer = nil,
	rect = nil,
	list = nil,
	tableview = nil,
	cwidth = nil,
	cheight = nil,
	theight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,
	last_ltype = nil,
	last_times = nil,
	last_fee = nil,

	cleanup = function(self)
		self.layer = nil;
		self.rect = nil;
		self.list = nil;
		self.tableview = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.theight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
		self.last_ltype = nil;
		self.last_times = nil;
		self.last_fee = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, one_gold, ten_gold, one_crystal, ten_crystal)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_LOTTERY, self.handler, true);

		self.list = {};
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));

		local data;
		local offsetheight, sprite, rect = init_bg_for_view(self.layer, GUI_LOTTERY, '抽卡', self.back);
		self.rect = rect;

		data = gui_get_data('cell', GUI_LOTTERY, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		data = gui_get_data('table', GUI_LOTTERY, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		self.theight = size.height;
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		local self = layer_lottery;
		self:remove();
	end,

	reload = function(self)
		self.tableview:reloadData();
	end,

	add_price = function(self, one_gold, ten_gold, one_crystal, ten_crystal)
		self.list = {};
		table.insert(self.list, { bg = "bg_choujiang1.png", tag = self.LTYPE_ONE_GOLD, tip = "产出3星或者以下卡牌,少几率出现4星卡牌", fee = one_gold, is_gold = true });
		table.insert(self.list, { bg = "bg_choujiang2.png", tag = self.LTYPE_ONE_CRYSTAL, tip = "产出2星或者以上卡牌,少几率出现5星卡牌", fee = one_crystal, is_gold = false });
		table.insert(self.list, { bg = "bg_choujiang3.png", tag = self.LTYPE_TEN_CRYSTAL, tip = "产出2星或者以上卡牌,至少出现1张5星卡牌", fee = ten_crystal, is_gold = false });
		self:reload();
	end,

	do_again = function(self)
		local ltype = self.last_ltype;
		local times = self.last_times;
		local fee = self.last_fee;
		if nil == ltype or nil == times or nil == fee then return; end
		if ltype == 1 and fee > g_euser.gold then
			show_msg(t_lang("TIP_NOT_ENOUGH_GOLD"));
			return;
		elseif ltype == 2 and fee > g_euser.crystal then
			show_crystal_tip();
			return;
		end
		local cmd = string.format("lottery %d %d", ltype, times);
		net_send(cmd);
	end,

	do_it = function(self, index)
		local info = self.list[index];
		if nil == info then return; end
		local tag = info.tag;
		local ltype = 0;
		local times = 0;
		local fee = 0;
		if tag == self.LTYPE_ONE_GOLD or tag == self.LTYPE_TEN_GOLD then
			ltype = 1;
			times = 1;
			fee = info.fee or 0;
			if fee > g_euser.gold then
				show_msg(t_lang("TIP_NOT_ENOUGH_GOLD"));
				return;
			end
			if tag == self.LTYPE_TEN_GOLD then
				times = 10;
			end
		elseif tag==self.LTYPE_ONE_CRYSTAL or tag==self.LTYPE_TEN_CRYSTAL then
			ltype = 2;
			times = 1;
			fee = info.fee or 0;
			if fee > g_euser.crystal then
				show_crystal_tip();
				return;
			end
			if tag == self.LTYPE_TEN_CRYSTAL then
				times = 10;
			end
		else
			return;
		end
		self.last_ltype = ltype;
		self.last_times = times;
		self.last_fee = fee;
		self:do_again();
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_lottery;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			play_tap_3();
			local cell = args[3];
			local idx = cell:getIdx();
			self:do_it(idx+1);
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			local info = self.list[idx + 1];
			data.fname1 = info.bg;
			gui_add_cell_bg(cell, data);

			local path, str, sprite, data2;
			str = info.tip or '';
			gui_add_label_on_cell(cell,data,str,25,'t_fee',GUI_LOTTERY,ANCHOR_DOWN);

			path = util.get_path(FNT_1);
			str = info.fee or 0;
			sprite, data2 = gui_add_labelbmf_on_cell(cell,data,str,path,'n_fee',GUI_LOTTERY,ANCHOR_DOWN);
			sprite:setAnchorPoint(ANCHOR_RIGHT_DOWN);
			sprite:setPositionX(data2.x+data2.width);
			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'icon_fee', GUI_LOTTERY, ANCHOR_DOWN);
			if true ~= info.is_gold then
				local path = util.get_path(data2.fname2);
				local tc = cc.Director:getInstance():getTextureCache();
				local texture = tc:addImage(path);
				if nil ~= texture then 
					sprite:setTexture(texture);
				end
			end
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_lottery;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,
} -- layer_lottery end

layer_tower = {
	name = 'layer_tower',
	layer = nil,
	rect = nil,
	kind = nil,
	KIND_TOWER = 1,
	KIND_RANK = 2,
	KIND_SHOP = 3,
	tap_tower = nil,
	tap_rank = nil,
	tap_shop = nil,

	cleanup = function(self)
		self.layer = nil;
		self.rect = nil;
		self.tap_tower = nil;
		self.tap_rank = nil;
		self.tap_shop = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_TOWER, self.handler, true);



		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		local sprite, data;
		local offsetheight, bg, rect = init_bg_for_view(self.layer, GUI_TOWER, '无限塔', self.back);
		self.rect = rect;

		-- add tabs
		local items = {};
		local item;

		item, data = gui_add_item(items, 'tab_tower', GUI_TOWER, self.callback_tower, ANCHOR_UP);
		gui_add_text_outline_on_sprite(item, "爬塔", 'lb_tab_tower', GUI_TOWER, ANCHOR_UP, 30);
		self.tap_tower = item;

		item, data = gui_add_item(items, 'tab_rank', GUI_TOWER, self.callback_rank, ANCHOR_UP);
		gui_add_text_outline_on_sprite(item, "排行榜", 'lb_tab_rank', GUI_TOWER, ANCHOR_UP, 30);
		self.tap_rank = item;

		item, data = gui_add_item(items, 'tab_shop', GUI_TOWER, self.callback_shop, ANCHOR_UP);
		gui_add_text_outline_on_sprite(item, "战功商店", 'lb_tab_shop', GUI_TOWER, ANCHOR_UP, 30);
		self.tap_shop = item;

		util.add_menu(self.layer, items, data.zorder);


		local d1 = gui_get_data('p_bg_card', GUI_TOWER, ANCHOR_UP);
		local d2 = gui_get_data('p_bg_card', GUI_TOWER, ANCHOR_DOWN);
		local offsety = d1.y - d2.y;
		gui_add_sprite(self.layer, 'p_bg_card', GUI_TOWER,ANCHOR_DOWN,nil,offsety);

--		self.callback_tower(0, self.tap_tower);


		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		local self = layer_tower;
		self:remove();
	end,

	show_tower_info = function()
		
	end,

	show_rank_info = function()
		
	end,

	show_shop_info = function()
		
	end,

	callback_tower = function()
		play_tap_3();
		local self = layer_tower;
		--local toggle = tolua.cast(sender, "CCMenuItemToggle");
		self.kind = self.KIND_TOWER;
		local index = self.tap_tower:getSelectedIndex();
		if 0 == index then
			self.tap_tower:setSelectedIndex(1);
			return;
		end
		self.tap_tower:setSelectedIndex(1);
		self.tap_rank:setSelectedIndex(0);
		self.tap_shop:setSelectedIndex(0);

		self:show_tower_info();
	end,

	callback_rank = function()
		play_tap_3();
		local self = layer_tower;
		--local toggle = tolua.cast(sender, "CCMenuItemToggle");
		self.kind = self.KIND_RANK;
		local index = self.tap_rank:getSelectedIndex();
		if 0 == index then
			self.tap_rank:setSelectedIndex(1);
			return;
		end
		self.tap_tower:setSelectedIndex(0);
		self.tap_rank:setSelectedIndex(1);
		self.tap_shop:setSelectedIndex(0);

		self:show_rank_info();
	end,

	callback_shop = function()
		play_tap_3();
		local self = layer_tower;
		--local toggle = tolua.cast(sender, "CCMenuItemToggle");
		self.kind = self.KIND_SHOP;
		local index = self.tap_shop:getSelectedIndex();
		if 0 == index then
			self.tap_shop:setSelectedIndex(1);
			return;
		end
		self.tap_tower:setSelectedIndex(0);
		self.tap_rank:setSelectedIndex(0);
		self.tap_shop:setSelectedIndex(1);

		self:show_shop_info();
	end,

	handler = function(event, x, y)
		local self = layer_tower;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,
} -- layer_tower end

layer_notice = {
	name = 'layer_notice',
	layer = nil,
	list = nil,
	tableview = nil,
	btn_top = nil,
	rect = nil,
	cwidth = nil,
	cheight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,
	do_cell_anim = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.btn_top = nil;
		self.rect = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
		self.do_cell_anim = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_NOTICE, self.handler, true);

		self.list = {};
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		local offsetheight, sprite, rect = init_bg_pop(self.layer, GUI_NOTICE, '今日公告', self.back, nil, true);
		self.rect = rect;

		sprite, data = gui_add_sprite(self.layer, 'bg_table', GUI_NOTICE, ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));

		data = gui_get_data('cell', GUI_NOTICE, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		data = gui_get_data('table', GUI_NOTICE, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		local self = layer_notice;
		self:remove();
	end,

	reload = function(self)
		self.do_cell_anim = true;
		self.tableview:reloadData();
	end,

	add_list = function(self, list)
		self.list = list or {};
		self:reload();
	end,

	set_detail = function(self, t, detail)
		if nil == self or nil == self.list then
			return;
		end
		local title = '';
		for i = 1, #self.list do
			local list = self.list[i];
			if list.t == t then
				list.height = nil;
				list.detail = detail;
				list.is_on = true;
				list.cheight = nil;
				title = list.title or '';
			end
		end
		g_scene:add_layer(ZORDER_LAYER_TEXT, layer_text:create(title, detail));
	end,

	return_top = function()
		local self = layer_notice;
		if nil == self.tableview then
			return;
		end
		local size = self.tableview:getContentSize();
		--self.tableview:setContentOffset(ccp(0, 0), false);
		self.tableview:setContentOffset(ccp(0, -#self.list*hfix(80)), false);
		self.btn_top:setVisible(false);
	end,

	change_notice = function()
		local self = layer_notice;
	end,

	cb_didbtn = function()
		local self = layer_notice;
		if nil == self.tableview then
			return;
		end
		local t, l = self.tableview:getContentOffset();
		size = self.tableview:getContentSize();
		--if - #self.list * hfix(80) < l then
		if - #self.list * hfix(80) + size.height/2 < l then
			self.btn_top:setVisible(true);
		end
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_notice;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			play_tap_3();
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.list[idx + 1];
			if nil == info.detail then
				local cmd = 'notice ' .. info.t;
				net_send(cmd);
				return;
			end
			local t = info.title or '';
			local d = info.detail or '';
			g_scene:add_layer(ZORDER_LAYER_TEXT, layer_text:create(t, d));
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local info = self.list[idx + 1];
			local str = info.title;
			gui_add_sprite_on_cell(cell,data,'icon',GUI_NOTICE, ANCHOR_DOWN);
			gui_add_label_on_cell(cell,data,str,24,'cell_title',GUI_NOTICE,ANCHOR_DOWN);
			if true == self.do_cell_anim then
				local delay = (idx%10)*0.1;
				keff_show_fromright(cell, delay);
			end
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_notice;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		self.do_cell_anim = nil;
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,
} -- layer_notice end

layer_option = { -- start
	name = 'layer_option',
	layer = nil,
	slider_music = nil,
	slider_effect = nil,

	cleanup = function(self)
		self.layer = nil;
		self.slider_music = nil;
		self.slider_effect = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_OPTION, self.handler, true);

		local offsetheight = init_bg_full(self.layer, GUI_OPTION, self.back);
		self.offsetheight = offsetheight;
		local sprite, data, str;
		sprite,data = gui_add_sprite(self.layer,'outframe',GUI_OPTION,ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));
		gui_add_sprite(self.layer, 'bg_music', GUI_OPTION, ANCHOR_UP);
		gui_add_sprite(self.layer, 't_music', GUI_OPTION, ANCHOR_UP);
		gui_add_sprite(self.layer, 'bg_eff', GUI_OPTION, ANCHOR_UP);
		gui_add_sprite(self.layer, 't_eff', GUI_OPTION, ANCHOR_UP);
		str = get_client_version();
		gui_add_label_ali(self.layer, str, 25, 'client_ver', GUI_OPTION, ANCHOR_UP, cc.TEXT_ALIGNMENT_CENTER);

		--[[
		-- btn back set in g_scene.option
		init_bg_for_full_view(self.layer, GUI_OPTION, '选项');
		gui_add_sprite(self.layer, 'p_music_left', GUI_OPTION, ANCHOR_UP);
		gui_add_sprite(self.layer, 'p_music_right', GUI_OPTION, ANCHOR_UP);
		gui_add_sprite(self.layer, 'p_eff_left', GUI_OPTION, ANCHOR_UP);
		gui_add_sprite(self.layer, 'p_eff_right', GUI_OPTION, ANCHOR_UP);
		gui_add_label_ali(self.layer, '音乐', 22, 't_music', GUI_OPTION, ANCHOR_UP, cc.TEXT_ALIGNMENT_CENTER);
		gui_add_label_ali(self.layer, '音效', 22, 't_eff', GUI_OPTION, ANCHOR_UP, cc.TEXT_ALIGNMENT_CENTER);
		local sprite, data, str;

		str = get_client_version();
		gui_add_label_ali(self.layer, str, 25, 't_game_ver', GUI_OPTION, ANCHOR_DOWN, cc.TEXT_ALIGNMENT_CENTER);
		]]--

		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn_exchange', GUI_OPTION, self.enter_code, ANCHOR_UP);
		util.add_text_to_sprite_by_data(item, data, "兑换", 26);

		item, data = gui_add_item(items, 'btn_logout', GUI_OPTION, self.logout, ANCHOR_UP);
		util.add_text_to_sprite_by_data(item, data, "登出", 26);

		item, data = gui_add_item(items, 'm_music', GUI_OPTION, self.change_value, ANCHOR_UP);
		item:setTag(1);

		item, data = gui_add_item(items, 'p_music', GUI_OPTION, self.change_value, ANCHOR_UP);
		item:setTag(2);

		item, data = gui_add_item(items, 'm_eff', GUI_OPTION, self.change_value, ANCHOR_UP);
		item:setTag(3);

		item, data = gui_add_item(items, 'p_eff', GUI_OPTION, self.change_value, ANCHOR_UP);
		item:setTag(4);

		util.add_menu(self.layer, items, data.zorder);

		local slider, value, pos;
		local d1, d2, dtap, p1, p2, ptap;
		d1 = gui_get_data("bar1_music", GUI_OPTION, ANCHOR_UP);
		p1 = util.get_path(d1.fname1);
		d2 = gui_get_data("bar2_music", GUI_OPTION, ANCHOR_UP);
		p2 = util.get_path(d2.fname1);
		dtap = gui_get_data("tap_music", GUI_OPTION, ANCHOR_UP);
		ptap = util.get_path(dtap.fname1);
		pos = cc.p(d1.x, d1.y);
		slider = util.add_slider_image(self.layer, p1, p2, ptap, 1, 0, pos, ANCHOR_LEFT_DOWN, self.music_change, data.zorder);
		slider:setScale(d1.width / slider:getContentSize().width);
		value = cc.SimpleAudioEngine:getInstance():getMusicVolume();
		slider:setValue(value);
		self.slider_music = slider;

		d1 = gui_get_data("bar1_eff", GUI_OPTION, ANCHOR_UP);
		p1 = util.get_path(d1.fname1);
		d2 = gui_get_data("bar2_eff", GUI_OPTION, ANCHOR_UP);
		p2 = util.get_path(d2.fname1);
		dtap = gui_get_data("tap_eff", GUI_OPTION, ANCHOR_UP);
		ptap = util.get_path(dtap.fname1);
		pos = cc.p(d1.x, d1.y);
		slider = util.add_slider_image(self.layer, p1, p2, ptap, 1, 0, pos, ANCHOR_LEFT_DOWN, self.effect_change, data.zorder);
		slider:setScale(d1.width / slider:getContentSize().width);
		value = cc.SimpleAudioEngine:getInstance():getEffectsVolume();
		slider:setValue(value);
		self.slider_effect = slider;

		return self.layer, self.name;
	end,

	enter_code = function()
		play_tap_1();
		g_scene:add_layer(ZORDER_LAYER_CODE, layer_code:create());
	end,

	logout = function()
		play_tap_1();
		logout();
	end,

	music_change = function(sender)
		local self = layer_option;
		local value = sender:getValue();
		util.set_music_volume(value);
	end,

	effect_change = function(sender)
		local self = layer_option;
		local value = sender:getValue();
		util.set_effect_volume(value);
	end,

	change_value = function(...)
		play_tap_3();
		local self = layer_option;
		local args = {...};
		local tag = args[2]:getTag();
		if 1 == tag then
			local value = self.slider_music:getValue();
			self.slider_music:setValue(value - 0.1);
		elseif 2 == tag then
			local value = self.slider_music:getValue();
			self.slider_music:setValue(value + 0.1);
		elseif 3 == tag then
			local value = self.slider_effect:getValue();
			self.slider_effect:setValue(value - 0.1);
		elseif 4 == tag then
			local value = self.slider_effect:getValue();
			self.slider_effect:setValue(value + 0.1);
		end
	end,

	back = function()
		play_tap_1();
		local self = layer_option;
		local value;
		value = self.slider_music:getValue();
		util.save_rms('music_volume', value, 'string');
		value = self.slider_effect:getValue();
		util.save_rms('effect_volume', value, 'string');
		g_scene:map();
	end,

	handler = function(event, x, y)
		local self = layer_option;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_option end

layer_lmatch = {
	name = 'layer_lmatch',
	layer = nil,
	list = nil,
	tableview = nil,
	cwidth = nil,
	cheight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,
	my_match_id = nil,
	s_match_id = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
		self.my_match_id = nil;
		self.s_match_id = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_LMATCH, self.handler, true);

		self.list = {};
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		local sprite, data;
		local offsetheight = init_bg_for_view(self.layer, GUI_LMATCH, '比赛', self.back);

		data = gui_get_data('cell', GUI_LMATCH, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		data = gui_get_data('table', GUI_LMATCH, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	refresh_my_status = function(self, my_match_id, max_player, current_player, is_add)
		if true == is_add then
			self.my_match_id = my_match_id or '0';
		else
			self.my_match_id = '0';
		end
		for i = 1, #self.list do
			local info = self.list[i];
			if info.match_id == my_match_id then
				info.max_player = max_player;
				info.current_player = current_player;
				break;
			end
		end
		local offset = self.tableview:getContentOffset();
		self:reload();
		self.tableview:setContentOffset(offset);
	end,

	reload = function(self)
		self.tableview:reloadData();
	end,

	add_list = function(self, list, my_match_id)
		self.my_match_id = my_match_id or '0';
		self.list = list or {};
		self:reload();
	end,

	create_match = function()
		play_tap_1();
		g_scene:add_layer(ZORDER_LAYER_CMATCH, layer_cmatch:create());
	end,

	cb_cancel = function()
		local self = layer_lmatch;
		if nil == self.s_match_id then return; end
		local cmd = 'match_cancel ' .. self.s_match_id;
		--local cmd = '@match_init ' .. self.s_match_id;
		net_send(cmd);
	end,

	m_cancel = function(...)
		play_tap_2();
		local self = layer_lmatch;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		self.s_match_id = info.match_id;
		local str = string.format("确定退出比赛(%s)吗?", info.title);
		g_scene:add_layer(ZORDER_LAYER_TIP, layer_tip:create(str,self.cb_cancel));
	end,

	cb_apply = function()
		local self = layer_lmatch;
		if nil == self.s_match_id then return; end
		local cmd = 'match_apply ' .. self.s_match_id;
		net_send(cmd);
	end,

	m_apply = function(...)
		play_tap_2();
		local self = layer_lmatch;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		self.s_match_id = info.match_id;
		local str = string.format("确定参加比赛(%s)吗?", info.title);
		g_scene:add_layer(ZORDER_LAYER_TIP, layer_tip:create(str, self.cb_apply));
	end,

	m_check = function(...)
		play_tap_2();
		local self = layer_lmatch;
		local cmd = 'player_data ' .. g_euser.eid;
		net_send(cmd);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_lmatch;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			--local cell = args[3];
			--local idx = cell:getIdx();
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new();
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local info = self.list[idx + 1];
			local match_id = info.match_id;
			local title = info.title;
			local round = info.round;
			local status = info.match_status;
			local max = info.max_player;
			local current = info.current_player;
			local start_time = info.start_time;
			local round_time = info.match_round_time;
			local daily_info = info.daily_info;
			local data2, sprite, path, pos, size, str;

			gui_add_sprite_on_cell(cell,data,'bg_alias',GUI_LMATCH,ANCHOR_DOWN);
			str = title;
			gui_add_label_on_cell(cell,data,str,28,'c_alias',GUI_LMATCH,ANCHOR_DOWN);

			if round > 0 then
				str = string.format("正进行第%d轮(总)", round);
				sprite = gui_add_stroke_on_cell(cell,data,str,28,'c_alias',GUI_LMATCH,ANCHOR_DOWN, cc.c4b(0, 200, 0, 255), cc.c4b(0, 0, 0, 255));
				sprite:setHorizontalAlignment(cc.TEXT_ALIGNMENT_RIGHT);
			end

			str = '开始时间:';
			gui_add_label_on_cell(cell,data,str,24,'t_start',GUI_LMATCH,ANCHOR_DOWN);
			local t = os.date("*t", start_time);
			str = string.format("%d年%02d月%02d日", t.year, t.month, t.day);
			gui_add_label_on_cell(cell,data,str,24,'start',GUI_LMATCH,ANCHOR_DOWN);

			str = '回合时间:';
			gui_add_label_on_cell(cell,data,str,24,'t_round',GUI_LMATCH,ANCHOR_DOWN);
			t = os.date("*t", round_time);
			str = string.format("%02d分%02d秒", t.min, t.sec);
			gui_add_label_on_cell(cell,data,str,24,'round',GUI_LMATCH,ANCHOR_DOWN);

			str = '状态:';
			gui_add_label_on_cell(cell,data,str,24,'t_status',GUI_LMATCH,ANCHOR_DOWN);
			str = get_match_status(status);
			gui_add_label_on_cell(cell,data,str,24,'status',GUI_LMATCH,ANCHOR_DOWN);

			str = '人数:';
			gui_add_label_on_cell(cell,data,str,24,'t_player',GUI_LMATCH,ANCHOR_DOWN);
			str = current .. ' / ' .. max;
			gui_add_label_on_cell(cell,data,str,24,'player',GUI_LMATCH,ANCHOR_DOWN);

			local len = #daily_info;
			if len > 4 then len = 4; end
			for i = 1, len do
				local d = daily_info[i];
				local k = 't_r' .. i;
				str = '第' .. i .. '轮:';
				gui_add_label_on_cell(cell,data,str,24,k,GUI_LMATCH,ANCHOR_DOWN);
				local hour = math.floor(d/60/60);
				local min = math.floor((d-hour*60*60)/60);
				str = string.format("%02d时%02d分", hour, min);
				k = 'r' .. i;
				gui_add_label_on_cell(cell,data,str,24,k,GUI_LMATCH,ANCHOR_DOWN);
			end

			if self.my_match_id == match_id then
				str = '已参赛';
				gui_add_label_on_cell(cell,data,str,24,'has_in',GUI_LMATCH,ANCHOR_DOWN);
			end

			local cb = nil;
			local t = nil;
			if self.my_match_id == match_id then
				if status > MATCH_STATUS_READY then
					cb = self.m_check;
					t = '查看';
				elseif status == MATCH_STATUS_READY then
					cb = self.m_cancel;
					t = '退出';
				end
			elseif MATCH_STATUS_READY == status and '0' == self.my_match_id then
				cb = self.m_apply;
				t = '申请';
			end

			if nil ~= cb then
				local items = {};
				local item;

				item, data2 = gui_add_item_on_cell(items, data, 'btn_act', GUI_LMATCH, cb, ANCHOR_DOWN);
				item:setTag(idx + 1);
				gui_add_text_on_sprite(item,t,'t_act',GUI_LMATCH,ANCHOR_DOWN,25);

				util.add_menu(cell, items, data2.zorder);
			end

			return cell;
		end
	end, -- tableview_handler end }

	back = function()
		local self = layer_lmatch;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_lmatch;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_lmatch end

layer_matchdata = {
	name = 'layer_matchdata',
	layer = nil,

	cleanup = function(self)
		self.layer = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, match_data, player_info, oppo_info, round_date)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_MATCHDATA, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 100));
		local bgsize = cc.size(FULL_WIDTH-80, FULL_HEIGHT-100);
		local title = string.format("%s 的比赛信息", player_info.alias);
		local bg, rect = init_bg_for_popview(self.layer,title,bgsize,self.back);

		local x = 25;
		local y = bgsize.height - 130;
		local height = 40;
		local fsize = 28;
		local bcolor = cc.c4b(0, 0, 0, 255);
		local color = cc.c4b(255, 255, 255, 255);
		local color2 = cc.c4b(0, 255, 0, 255);
		local label, pos, size, str;
		pos = cc.p(x, y);
		size = cc.size(bgsize.width-pos.x*2, height);
		str = '参与比赛:';
		label = util.add_labeloutline(bg, str, nil, fsize, pos, color, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		str = match_data.title or '';
		label = util.add_labeloutline(bg, str, nil, fsize, pos, color2, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_RIGHT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos.y = pos.y - height;
		str = '比赛状态:';
		label = util.add_labeloutline(bg, str, nil, fsize, pos, color, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		str = get_match_status(match_data.match_status);
		label = util.add_labeloutline(bg, str, nil, fsize, pos, color2, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_RIGHT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos.y = pos.y - height;
		str = '回合进度:';
		label = util.add_labeloutline(bg, str, nil, fsize, pos, color, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		str = string.format("第%d回合", (match_data.round or 0));
		label = util.add_labeloutline(bg, str, nil, fsize, pos, color2, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_RIGHT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos.y = pos.y - height;
		str = '战况';
		label = util.add_labeloutline(bg, str, nil, fsize, pos, color, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		self:init_player_view(player_info, bg, pos.x+size.width/4, pos.y);
		if nil ~= oppo_info then
			self:init_player_view(oppo_info, bg, pos.x+size.width/4*3, pos.y);
		end

		pos.y = pos.y - 120;
		str = 'VS';
		label = util.add_labeloutline(bg, str, nil, fsize, pos, color, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos.y = pos.y - 180;
		str = '胜利';
		label = util.add_labeloutline(bg, str, nil, fsize, pos, color, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		height = 50;

		pos.y = pos.y - height;
		str = '失败';
		label = util.add_labeloutline(bg, str, nil, fsize, pos, color, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos.y = pos.y - height;
		str = '平局';
		label = util.add_labeloutline(bg, str, nil, fsize, pos, color, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos.y = pos.y - height;
		str = '得分';
		label = util.add_labeloutline(bg, str, nil, fsize, pos, color, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos.y = pos.y - height;
		if 0 == round_date then
			str = '回合战斗结果:';
			label = util.add_labeloutline(bg, str, nil, fsize, pos, color, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

			str = '出局';
			label = util.add_labeloutline(bg, str, nil, fsize, pos, color2, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_RIGHT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);
		elseif nil ~= round_date then
			str = '下回合开始时间:';
			label = util.add_labeloutline(bg, str, nil, fsize, pos, color, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

			local t = os.date("*t", rond_date);
			str = string.format("%d年%02d月%02d日", t.year, t.month, t.day);
			label = util.add_labeloutline(bg, str, nil, fsize, pos, color2, bcolor, 2, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_RIGHT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);
		end

		return self.layer, self.name;
	end,

	init_player_view = function(self, player, bg, x, y)
		local path, sprite, pos, size, str;
		pos = cc.p(x, y-200);
		path = util.get_path('bg_53.png');
		sprite = util.add_sprite(bg, path, pos, ANCHOR_CENTER_DOWN, 10);
		local w = sprite:getContentSize().width;
		path = get_icon_path(player.icon);
		sprite = util.add_sprite(sprite, path, cc.p(0,0), ANCHOR_LEFT_DOWN, -1);
		sprite:setScale(w/sprite:getContentSize().width);

		local height = 50;
		local fsize = 28;
		local bcolor = cc.c4b(0, 0, 0, 255);
		local color = cc.c4b(255, 255, 255, 255);
		local color2 = cc.c4b(255, 0, 0, 255);
		local color3 = cc.c4b(255, 255, 0, 255);
		
		pos.y = pos.y-height;
		str = player.alias or '';
		util.add_labeloutline(bg, str, nil, fsize, pos, color, bcolor, 2, ANCHOR_CENTER_DOWN, 10, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos.y = pos.y-height;
		str = player.win or 0;
		util.add_labeloutline(bg, str, nil, fsize, pos, color2, bcolor, 2, ANCHOR_CENTER_DOWN, 10, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos.y = pos.y-height;
		str = player.lose or 0;
		util.add_labeloutline(bg, str, nil, fsize, pos, color2, bcolor, 2, ANCHOR_CENTER_DOWN, 10, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos.y = pos.y-height;
		str = player.draw or 0;
		util.add_labeloutline(bg, str, nil, fsize, pos, color2, bcolor, 2, ANCHOR_CENTER_DOWN, 10, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos.y = pos.y-height;
		str = player.point or 0;
		util.add_labeloutline(bg, str, nil, fsize, pos, color3, bcolor, 2, ANCHOR_CENTER_DOWN, 10, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);
	end,

	back = function()
		local self = layer_matchdata;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_matchdata;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function (self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)

	end,
} -- layer_matchdata end

layer_cmatch = {
	name = 'layer_cmatch',
	layer = nil,
	title = nil,
	year = nil,
	month = nil,
	day = nil,
	max = nil,
	r1h = nil,
	r2h = nil,
	r3h = nil,
	r4h = nil,
	r1m = nil,
	r2m = nil,
	r3m = nil,
	r4m = nil,

	cleanup = function(self)
		self.layer = nil;
		self.title = nil;
		self.year = nil;
		self.month = nil;
		self.day = nil;
		self.max = nil;
		self.r1h = nil;
		self.r2h = nil;
		self.r3h = nil;
		self.r4h = nil;
		self.r1m = nil;
		self.r2m = nil;
		self.r3m = nil;
		self.r4m = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_CMATCH, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 128));

		self.match_id = nil;
		local bgsize = cc.size(500, 650);
		local bg,rect=init_bg_for_popview(self.layer,'创建比赛',bgsize,self.back);

		local size = cc.size(wfix(300), hfix(71));
		local pos = cc.p((bgsize.width-size.width)/2, hfix(450));
		local tip = '请输入比赛标题';
		self.title = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		size = cc.size(wfix(150), hfix(71));
		pos = cc.p(bgsize.width/2-size.width-wfix(80), hfix(375));
		tip = '年';
		self.year = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		pos = cc.p(bgsize.width/2-size.width-wfix(80), hfix(300));
		tip = '月';
		self.month = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		pos = cc.p(bgsize.width/2-size.width-wfix(80), hfix(225));
		tip = '日';
		self.day = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		pos = cc.p(bgsize.width/2-size.width-wfix(80), hfix(150));
		tip = '最大人数';
		self.max = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		pos = cc.p((bgsize.width-size.width)/2, hfix(375));
		tip = 'r1时';
		self.r1h = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		pos = cc.p((bgsize.width-size.width)/2, hfix(300));
		tip = 'r2时';
		self.r2h = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		pos = cc.p((bgsize.width-size.width)/2, hfix(225));
		tip = 'r3时';
		self.r3h = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		pos = cc.p((bgsize.width-size.width)/2, hfix(150));
		tip = 'r4时';
		self.r4h = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		pos = cc.p(bgsize.width/2+wfix(80), hfix(375));
		tip = 'r1分';
		self.r1m = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		pos = cc.p(bgsize.width/2+wfix(80), hfix(300));
		tip = 'r2分';
		self.r2m = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		pos = cc.p(bgsize.width/2+wfix(80), hfix(225));
		tip = 'r3分';
		self.r3m = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		pos = cc.p(bgsize.width/2+wfix(80), hfix(150));
		tip = 'r4分';
		self.r4m = add_editbox_1(bg, pos, size, tip, 10,self.editbox_handler);

		local items = {};
		local item;

		add_item_1(items, '创建', nil, 30, self.action, ANCHOR_CENTER_DOWN, cc.p(bgsize.width/2, hfix(30)));
		
		util.add_menu(bg, items, 50);

		return self.layer, self.name;
	end,

	action = function()
		play_tap_1();
		local self = layer_cmatch;
		local title = self.title:getText() or '';
		if 0 == string.len(title) then
			show_msg('标题不能为空');
			return;
		end
		local year = tonumber(self.year:getText() or '');
		if nil == year then
			show_msg('年 要为数字');
			return;
		end
		local month = tonumber(self.month:getText() or '');
		if nil == month then
			show_msg('月 要为数字');
			return;
		end
		local day = tonumber(self.day:getText() or '');
		if nil == day then
			show_msg('日 要为数字');
			return;
		end
		local max = tonumber(self.max:getText() or '');
		if nil == year then
			show_msg('最大人数 要为数字');
			return;
		end
		local max = tonumber(self.max:getText() or '');
		if nil == year then
			show_msg('最大人数 要为数字');
			return;
		end
		local r1h = tonumber(self.r1h:getText() or '');
		if nil == r1h then
			show_msg('r1时 要为数字');
			return;
		end
		local r2h = tonumber(self.r2h:getText() or '');
		if nil == r2h then
			show_msg('r2时 要为数字');
			return;
		end
		local r3h = tonumber(self.r3h:getText() or '');
		if nil == r3h then
			show_msg('r3时 要为数字');
			return;
		end
		local r4h = tonumber(self.r4h:getText() or '');
		if nil == r4h then
			show_msg('r4时 要为数字');
			return;
		end
		local r1m = tonumber(self.r1m:getText() or '');
		if nil == r1m then
			show_msg('r1分 要为数字');
			return;
		end
		local r2m = tonumber(self.r2m:getText() or '');
		if nil == r2m then
			show_msg('r2分 要为数字');
			return;
		end
		local r3m = tonumber(self.r3m:getText() or '');
		if nil == r3m then
			show_msg('r3分 要为数字');
			return;
		end
		local r4m = tonumber(self.r4m:getText() or '');
		if nil == r4m then
			show_msg('r4分 要为数字');
			return;
		end
		local cmd = string.format("@match_add %d %04d%02d%02d", max, year, month, day);
		cmd = string.format("%s %02d%02d %02d%02d %02d%02d %02d%02d %s", cmd, r1h, r1m, r2h, r2m, r3h, r3m, r4h, r4m, title);
		net_send(cmd);
		--[[
		--print('DEBUG search friend: ', alias);
		local cmd = string.format("fsearch %s", alias);
		net_send(cmd);
		]]--
	end,

	back = function()
		local self = layer_cmatch;
		self:remove();
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_cmatch;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
		elseif eventname == "changed" then
		end

	end,

	handler = function(event, x, y)
		local self = layer_cmatch;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
	end,

} -- layer_cmatch end

layer_friend = {
	name = 'layer_friend',
	PAGE_SIZE = 15,
	layer = nil,
	list = nil,
	editbox = nil,
	tableview = nil,
	cwidth = nil,
	cheight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,
	eid_to_delete = nil,
	do_cell_anim = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.editbox = nil;
		self.tableview = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
		self.eid_to_delete = nil;
		self.do_cell_anim = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_FRIEND, self.handler, true);

		self.list = {};
		self.state = 1;
		util.add_layer_color(self.layer, cc.c4b(0, 0, 0, 150));
		local data;
		local offsetheight, sprite, rect = init_bg_pop(self.layer, GUI_FRIEND, '好友', self.back, nil, true);

		gui_add_sprite(self.layer, 'fade_bottom', GUI_FRIEND, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 'bg_search', GUI_FRIEND, ANCHOR_UP);

		self.editbox = gui_add_editbox(self.layer, 't_search', GUI_FRIEND, ANCHOR_UP, 22, self.editbox_handler, 20, "查找好友...");

		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn_add', GUI_FRIEND, self.add_friend, ANCHOR_UP);

		item, data = gui_add_item(items, 'btn_search', GUI_FRIEND, self.find_friend, ANCHOR_UP);

		util.add_menu(self.layer, items, data.zorder);

		data = gui_get_data('cell', GUI_FRIEND, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		data = gui_get_data('table', GUI_FRIEND, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	back = function()
		local self = layer_friend;
		self:remove();
	end,

	reload = function(self)
		self.do_cell_anim = true;
		self.tableview:reloadData();
	end,

	add_list = function(self, list, state, total, start_pos)
		if nil == total or nil == start_pos then
			self.label_total:setString("");
			self.state = state or 1;
			self.list = list or {};
			self:reload();
			return;
		end
		local offset = nil;
		if start_pos > 0 then
			offset = self.tableview:getContentOffset();
		end
		local tstr = string.format("(%d)", total);
		self.state = state or 1;
		list = list or {};
		local more_cell = { flag_more_cell = true };
		self.list = self.list or {};
		if 0 == start_pos then
			self.list = {};
		end
		if 0 < #self.list then
			local m = self.list[#self.list];
			if true == m.flag_more_cell then
				table.remove(self.list, #self.list);
			end
		end
		for i = 1, #list do
			table.insert(self.list, list[i]);
		end
		if self.PAGE_SIZE == #list then
			table.insert(self.list, more_cell);
		end
		self:reload();
		if nil ~= offset then
			offset.y = offset.y - #list * self.cheight;
			self.tableview:setContentOffset(offset);
		end
	end,

	get_more = function()
		play_tap_1();
		local self = layer_friend;
		local len = #(self.list or {});
		if self.list[len].flag_more_cell == true then
			len = len - 1;
		end
		if len < 0 then len = 0; end
		local opt_alias = self.editbox:getText() or "";
		local cmd = string.format("flist %d %d %s", len, self.PAGE_SIZE, opt_alias);
		net_send(cmd);
	end,

	add_friend = function()
		play_tap_1();
		g_scene:add_layer(ZORDER_LAYER_FINDFRD, layer_findfrd:create());
	end,

	find_friend = function()
		play_tap_1();
		local self = layer_friend;
		local opt_alias = self.editbox:getText() or "";
		local cmd = string.format("flist %d %d %s", 0, self.PAGE_SIZE, opt_alias);
		net_send(cmd);
		--g_scene:add_layer(ZORDER_LAYER_FINDFRD, layer_findfrd:create());
		--[[
		local self = layer_friend;
		local alias = self.editbox:getText() or '';
		if 0 == string.len(alias) then
			return;
		end
		--print('DEBUG search friend: ', alias);
		local cmd = string.format("fsearch %s", alias);
		net_send(cmd);
		]]--
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_friend;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
		elseif eventname == "changed" then
		end
	end,

	detail = function(...)
		play_tap_2();
		local self = layer_friend;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		local eid = info.eid;
		local cmd = 'fsta ' .. eid;
		net_send(cmd);
	end,

	delete = function(...)
		play_tap_2();
		local self = layer_friend;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		local eid = info.eid;
		self.eid_to_delete = eid;
		local tip = '确定删除 ' .. info.alias .. ' ?';
		g_scene:add_layer(ZORDER_LAYER_TIP,layer_tip:create(tip, self.cb_delete));
	end,

	cb_delete = function(tag)
		local self = layer_friend;
		tag = tag or 0;
		if 0 == tag then 
			self.eid_to_delete = nil;
			return;
		end
		if nil == self.eid_to_delete then return; end
		local cmd = 'fdel ' .. self.eid_to_delete;
		net_send(cmd);
	end,

	whisper = function(...)
		play_tap_2();
		local self = layer_friend;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		local eid = info.eid;
		local alias = info.alias;
		if nil == layer_chat.layer then
			return;
		end
		self.back();
		layer_chat.chat_target = { eid = eid, alias = alias };
		layer_chat:handle_channel_btn(C_PRIVATE);
	end,

	fight = function(...)
		play_tap_2();
		local self = layer_friend;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		local eid = info.eid;
		pop_invite_fight(eid);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_friend;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			--local cell = args[3];
			--local idx = cell:getIdx();
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new();
			local width = self.cwidth;
			local height = self.cheight;
			local info = self.list[idx + 1];
			if true == info.flag_more_cell then
				local items = {};
				local pos = cc.p(width/2, height/2);
				local size = cc.size(172, 52);
				local item = add_item_1(items, '更多', nil, 20, self.get_more, ANCHOR_CENTER_CENTER, pos, size);
				item:setTag(idx + 1);

				util.add_menu(cell, items, 1);
				return cell;
			end
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local icon = info.icon;
			local eid = info.eid;
			local alias = info.alias;
			local is_online = info.is_online;
			local data2, sprite, path, pos, size, str;

			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'icon', GUI_FRIEND, ANCHOR_DOWN);
			size = sprite:getContentSize();
			path = get_icon_path(icon);
			pos = cc.p(size.width/2, size.height/2);
			sprite = util.add_sprite(sprite, path,pos,ANCHOR_CENTER_CENTER,-1);
			sprite:setScale((size.width-8)/sprite:getContentSize().width);

			gui_add_sprite_on_cell(cell,data,'bg_alias',GUI_FRIEND,ANCHOR_DOWN);
			str = alias;
			gui_add_label_on_cell(cell,data,str,24,'alias',GUI_FRIEND,ANCHOR_DOWN);

			if 1 == is_online then
				str = '(在线)';
				gui_add_stroke_on_cell(cell,data,str,22,'online',GUI_FRIEND,ANCHOR_DOWN);
			else
				str = '(离线)';
				gui_add_stroke_on_cell(cell,data,str,22,'offline',GUI_FRIEND,ANCHOR_DOWN);
			end

			local items = {};
			local item;

			if self.state == 1 then
				item, data2 = gui_add_item_on_cell(items, data, 'btn_info', GUI_FRIEND, self.detail, ANCHOR_DOWN);
				item:setTag(idx + 1);
				util.add_stroke_to_sprite_by_data(item, data2, "资料", 25, 2);

				item, data2 = gui_add_item_on_cell(items, data, 'btn_delete', GUI_FRIEND, self.delete, ANCHOR_DOWN);
				item:setTag(idx + 1);
				util.add_stroke_to_sprite_by_data(item, data2, "删除", 25, 2);

				item, data2 = gui_add_item_on_cell(items, data, 'btn_chat', GUI_FRIEND, self.whisper, ANCHOR_DOWN);
				item:setTag(idx + 1);
				util.add_stroke_to_sprite_by_data(item, data2, "私聊", 25, 2);
				if 1 ~= is_online then
					enable_btn(item, false);
				end

				item, data2 = gui_add_item_on_cell(items, data, 'btn_fight', GUI_FRIEND, self.fight, ANCHOR_DOWN);
				item:setTag(idx + 1);
				util.add_stroke_to_sprite_by_data(item, data2, "挑战", 25, 2);
				if 1 ~= is_online then
					enable_btn(item, false);
				end
			end

			util.add_menu(cell, items, data2.zorder);

			if true == self.do_cell_anim then
				local delay = (idx%10)*0.1;
				keff_showup_1(cell, delay);
			end
			return cell;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_friend;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		self.do_cell_anim = false;

	end,
} -- layer_friend end

layer_sfriend = {
	name = 'layer_sfriend',
	layer = nil,
	list = nil,
	tableview = nil,
	cwidth = nil,
	cheight = nil,
	bar = nil,
	tap = nil,
	data_cell = nil,
	do_cell_anim = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell = nil;
		self.do_cell_anim = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, list)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_SFRIEND, self.handler, true);

		self.do_cell_anim = true;
		self.list = list or {};
		util.add_layer_color(self.layer, cc.c4b(0, 0, 0, 150));
		local data;
		local offsetheight, sprite, rect = init_bg_pop(self.layer, GUI_SFRIEND, '好友', self.back, nil, true);

		gui_add_sprite(self.layer, 'fade_bottom', GUI_SFRIEND, ANCHOR_DOWN);

		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn_return', GUI_SFRIEND, self.cb_return, ANCHOR_UP);

		util.add_menu(self.layer, items, data.zorder);

		data = gui_get_data('cell', GUI_SFRIEND, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		data = gui_get_data('table', GUI_SFRIEND, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	back = function()
		layer_sfriend:remove();
		if nil ~= layer_friend.layer then
			layer_friend:remove();
		end
	end,

	cb_return = function()
		local self = layer_sfriend;
		self:remove();
	end,

	add_frd = function(...)
		play_tap_2();
		local self = layer_sfriend;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		local eid = info.eid;
		local cmd = string.format("fadd %d", eid);
		net_send(cmd);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_sfriend;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			--local cell = args[3];
			--local idx = cell:getIdx();
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new();
			local width = self.cwidth;
			local height = self.cheight;
			local info = self.list[idx + 1];
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local icon = info.icon;
			local eid = info.eid;
			local alias = info.alias;
			local is_online = info.is_online;
			local level = info.level;
			local data2, sprite, path, pos, size, str;

			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'icon', GUI_SFRIEND, ANCHOR_DOWN);
			size = sprite:getContentSize();
			path = get_icon_path(icon);
			pos = cc.p(size.width/2, size.height/2);
			sprite = util.add_sprite(sprite, path,pos,ANCHOR_CENTER_CENTER,-1);
			sprite:setScale((size.width-8)/sprite:getContentSize().width);

			gui_add_sprite_on_cell(cell,data,'bg_alias',GUI_SFRIEND,ANCHOR_DOWN);
			str = alias;
			gui_add_label_on_cell(cell,data,str,24,'alias',GUI_SFRIEND,ANCHOR_DOWN);
			gui_add_sprite_on_cell(cell,data,'lv',GUI_SFRIEND,ANCHOR_DOWN);
			path = util.get_path(FT_6);
			str = level;
			gui_add_labelbmf_on_cell(cell,data,str,path,'n_lv',GUI_SFRIEND,ANCHOR_DOWN);

			if 1 == is_online then
				str = '(在线)';
				gui_add_stroke_on_cell(cell,data,str,22,'online',GUI_FRIEND,ANCHOR_DOWN);
			else
				str = '(离线)';
				gui_add_stroke_on_cell(cell,data,str,22,'offline',GUI_FRIEND,ANCHOR_DOWN);
			end

			gui_add_sprite_on_cell(cell,data,'bg_add',GUI_SFRIEND,ANCHOR_DOWN);
			local items = {};
			local item;

			item, data2 = gui_add_item_on_cell(items, data, 'btn_add', GUI_SFRIEND, self.add_frd, ANCHOR_DOWN);
			item:setTag(idx + 1);
			util.add_text_to_sprite_by_data(item, data2, "加好友", 25);

			util.add_menu(cell, items, data2.zorder);

			if true == self.do_cell_anim then
				local delay = (idx%10)*0.1;
				keff_showup_1(cell, delay);
			end
			return cell;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_sfriend;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		self.do_cell_anim = false;

	end,
} -- layer_sfriend end

layer_findfrd = {
	name = 'layer_findfrd',
	layer = nil,
	editbox = nil,
	rect = nil,

	cleanup = function(self)
		self.layer = nil;
		self.editbox = nil;
		self.rect = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_FINDFRD, self.handler, true);

		util.add_layer_color(self.layer, cc.c4b(0, 0, 0, 128));
		local title = '加好友';
		local bgsize = cc.size(540, 390);
		local bg, rect = init_bg_for_popview(self.layer,title,bgsize,self.back,true);

		local path = util.get_path('bg_156.png');
		local frect = cc.rect(0, 0, 64, 64); -- fullrect
		local irect = cc.rect(30, 30, 4, 4); -- insetrect
		local size = cc.size(467, 165); -- realsize
		local pos = cc.p(35, 132);
		util.add_scale9sprite(bg, path, pos, ANCHOR_LEFT_DOWN, frect, irect, size, 15); 

		size = cc.size(286, 62);
		pos = cc.p(122, 196);
		local tip = '输入对方名称或ID';
		self.editbox = add_editbox_2(bg, pos, size, tip, 20,self.editbox_handler);

		local items = {};

		add_item_4(items, '查找', nil, 30, self.action, ANCHOR_CENTER_DOWN, cc.p(bgsize.width/2, 44));

		util.add_menu(bg, items, 50);

		return self.layer, self.name;
	end,

	action = function()
		play_tap_1();
		local self = layer_findfrd;
		local alias = self.editbox:getText() or '';
		if 0 == string.len(alias) then
			return;
		end
		--print('DEBUG search friend: ', alias);
		local cmd = string.format("fsearch %s", alias);
		net_send(cmd);
	end,

	back = function()
		local self = layer_findfrd;
		self:remove();
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_findfrd;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
		elseif eventname == "changed" then
		end

	end,

	handler = function(event, x, y)
		local self = layer_findfrd;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil ~= r and (x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2) then
			self.back();
		end
	end,

} -- layer_findfrd end

layer_dialog = {
	name = 'layer_dialog',
	list = nil, -- drama
	callback = nil,
	drama_view = nil, -- story chat view
	bg = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.drama_view = nil;
		self.bg = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, list, callback)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_DIALOG, self.handler, true);

		self.list = list;
		self.callback = callback;
		util.add_layer_color(self.layer, cc.c4b(0, 0, 0, 30));
		self:init_drama_view();

		return self.layer, self.name;
	end,

	init_drama_view = function(self)
		if 0 == #(self.list or {}) then
			return;
		end
		local actor = self.list[1];
		local name = actor.name;
		local icon_id = actor.icon;
		local side = actor.side;
		local dialog = actor.dialog;
		table.remove(self.list, 1);
		local fullrect = cc.rect(0, 0, 64, 64);
		local insetrect = cc.rect(30, 30, 4, 4);
		local bgsize = cc.size(542, 132);
		local y = FULL_HEIGHT-hfix(373);
		if side == 0 then
			y = y - hfix(200);
		end
		local bgpos = cc.p(HALF_WIDTH, y);
		local path = util.get_path('bg_191.png');
		local bg = util.add_scale9sprite(self.layer, path, bgpos, ANCHOR_CENTER_CENTER, fullrect, insetrect, bgsize); 
		self.bg = bg;
		-- icon
		local pos = cc.p(10, 18);
		path = util.get_path('bg_192.png');
		local icon = util.add_sprite(bg, path, pos, ANCHOR_LEFT_DOWN, 100);
		icon:setPosition(cc.p(pos.x+icon:getContentSize().width/2, pos.y+icon:getContentSize().height/2));
		icon:setAnchorPoint(ANCHOR_CENTER_CENTER);
		local size = icon:getContentSize();
		path = get_icon_path(icon_id or 0);
		local s = util.add_sprite(icon, path, cc.p(size.width/2, size.height/2),ANCHOR_CENTER_CENTER,-1);
		s:setScale((icon:getContentSize().width-6)/s:getContentSize().width);
		-- name
		pos = cc.p(135, 98);
		local str = name or '';
		local name = util.add_labelttf(bg, str, nil, 25, pos, cc.c4b(250, 237, 149, 255), ANCHOR_LEFT_DOWN, 105);
		-- text
		pos = cc.p(117, 14);
		fullrect = cc.rect(0, 0, 74, 74);
		insetrect = cc.rect(35, 35, 4, 4);
		size = cc.size(416, 75);
		path = util.get_path('bg_193.png');
		util.add_scale9sprite(bg, path, pos, ANCHOR_LEFT_DOWN, fullrect, insetrect, size, 100); 
		pos = cc.p(155, 26);
		size = cc.size(357, 54);
		str = dialog or '';
		local label = util.add_labelttf(bg, str, nil, 20, pos, util.c4b_white, ANCHOR_LEFT_DOWN, 105, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_TOP);

		icon:setScale(1.3);
		icon:setPositionY(icon:getPositionY()+30);
		icon:setVisible(false);
		name:setVisible(false);
		label:setVisible(false);
		label:setPositionY(label:getPositionY()-30);
		bg:setPositionX(FULL_WIDTH);
		local array = {};
		table.insert(array, cc.EaseBackOut:create(cc.MoveTo:create(0.5, bgpos)));
		bg:runAction(cc.Sequence:create(array));

		local function cb_show(...)
			local args = { ... };
			local sprite = args[1];
			sprite:setVisible(true);
		end
		array = {};
		local sarray = {};
		table.insert(array, cc.DelayTime:create(0.5));
		table.insert(array, cc.CallFunc:create(cb_show));
		table.insert(sarray, cc.ScaleTo:create(0.2, 1));
		table.insert(sarray, cc.MoveBy:create(0.2, cc.p(0, -30)));
		table.insert(array, cc.Spawn:create(sarray));
		icon:runAction(cc.Sequence:create(array));

		array = {};
		table.insert(array, cc.DelayTime:create(0.6));
		table.insert(array, cc.CallFunc:create(cb_show));
		name:runAction(cc.Sequence:create(array));

		array = {};
		sarray = {};
		table.insert(array, cc.DelayTime:create(0.6));
		table.insert(array, cc.CallFunc:create(cb_show));
		--table.insert(sarray, cc.FadeIn:create(0.2));
		table.insert(sarray, cc.MoveBy:create(0.2, cc.p(0, 30)));
		table.insert(array, cc.Spawn:create(sarray));
		label:runAction(cc.Sequence:create(array));
	end,

	next_drama = function(self)
		if 0 == #(self.list or {}) then
			return false;
		end
		if nil ~= self.bg then
			self.bg:removeFromParent(true);
			self.bg = nil;
		end
		self:init_drama_view();
		--[[
		local str = self.list[1];
		table.remove(self.list, 1);
		if nil == str then
			return false;
		end
		local function cb_change()
			self.label:setString(str);
		end
		array = {};
		sarray = {};
		table.insert(sarray, cc.FadeOut:create(0.1));
		table.insert(sarray, cc.MoveBy:create(0.1, cc.p(0, -30)));
		table.insert(array, cc.Spawn:create(sarray));
		table.insert(array, cc.CallFunc:create(cb_change));
		sarray = {};
		table.insert(sarray, cc.FadeIn:create(0.1));
		table.insert(sarray, cc.MoveBy:create(0.1, cc.p(0, 30)));
		table.insert(array, cc.Spawn:create(sarray));
		self.label:runAction(cc.Sequence:create(array));
		]]--
		return true;
	end,

	handler = function(event, x, y)
		local self = layer_dialog;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
	end,

	onTouchEnded = function(self, x, y)
		if true == self:next_drama() then
			return;
		end
		local cb = self.callback;
		self:remove();
		if nil ~= cb then
			cb();
		end
	end,

} -- layer_dialog end

layer_story = {
	name = 'layer_story',
	list = nil, -- drama
	label = nil,
	callback = nil,
	drama_view = nil, -- story chat view

	cleanup = function(self)
		self.layer = nil;
		self.label = nil;
		self.list = nil;
		self.drama_view = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, actor, list, callback)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_STORY, self.handler, true);

		self.list = list;
		self.callback = callback;
		--util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		self:init_drama_view(actor);
		--self.layer:scheduleUpdateWithPriorityLua(self.update_drama, 1);

		return self.layer, self.name;
	end,

	show_finger_tip = function(self)
	end,

	init_drama_view = function(self, actor)
		local fullrect = cc.rect(0, 0, 64, 64);
		local insetrect = cc.rect(30, 30, 4, 4);
		local bgsize = cc.size(542, 132);
		--local bgpos = cc.p(HALF_WIDTH-bgsize.width/2, FULL_HEIGHT-hfix(373)-bgsize.height/2);
		local bgpos = cc.p(HALF_WIDTH, FULL_HEIGHT-hfix(373));
		local path = util.get_path('bg_191.png');
		local bg = util.add_scale9sprite(self.layer, path, bgpos, ANCHOR_CENTER_CENTER, fullrect, insetrect, bgsize); 
		-- icon
		local pos = cc.p(10, 18);
		path = util.get_path('bg_192.png');
		local icon = util.add_sprite(bg, path, pos, ANCHOR_LEFT_DOWN, 100);
		icon:setPosition(cc.p(pos.x+icon:getContentSize().width/2, pos.y+icon:getContentSize().height/2));
		icon:setAnchorPoint(ANCHOR_CENTER_CENTER);
		local size = icon:getContentSize();
		path = get_icon_path(actor.icon or 0);
		local s = util.add_sprite(icon, path, cc.p(size.width/2, size.height/2),ANCHOR_CENTER_CENTER,-1);
		s:setScale((icon:getContentSize().width-6)/s:getContentSize().width);
		-- name
		pos = cc.p(135, 98);
		local str = actor.name or '';
		local name = util.add_labelttf(bg, str, nil, 25, pos, cc.c4b(250, 237, 149, 255), ANCHOR_LEFT_DOWN, 105);
		-- text
		pos = cc.p(117, 14);
		fullrect = cc.rect(0, 0, 74, 74);
		insetrect = cc.rect(35, 35, 4, 4);
		size = cc.size(416, 75);
		path = util.get_path('bg_193.png');
		util.add_scale9sprite(bg, path, pos, ANCHOR_LEFT_DOWN, fullrect, insetrect, size, 100); 
		pos = cc.p(155, 26);
		size = cc.size(357, 54);
		str = self.list[1] or '';
		table.remove(self.list, 1);
		self.label = util.add_labelttf(bg, str, nil, 20, pos, util.c4b_white, ANCHOR_LEFT_DOWN, 105, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_TOP);

		--[[
		icon:setScale(1.3);
		icon:setPositionY(icon:getPositionY()+30);
		icon:setVisible(false);
		name:setVisible(false);
		self.label:setVisible(false);
		self.label:setPositionY(self.label:getPositionY()-30);
		bg:setPositionX(FULL_WIDTH);
		local array = {};
		table.insert(array, cc.EaseBackOut:create(cc.MoveTo:create(0.5, bgpos)));
		bg:runAction(cc.Sequence:create(array));

		local function cb_show(...)
			local args = { ... };
			local sprite = args[1];
			sprite:setVisible(true);
		end
		array = {};
		local sarray = {};
		table.insert(array, cc.DelayTime:create(0.5));
		table.insert(array, cc.CallFunc:create(cb_show));
		table.insert(sarray, cc.ScaleTo:create(0.2, 1));
		table.insert(sarray, cc.MoveBy:create(0.2, cc.p(0, -30)));
		table.insert(array, cc.Spawn:create(sarray));
		icon:runAction(cc.Sequence:create(array));

		array = {};
		table.insert(array, cc.DelayTime:create(0.6));
		table.insert(array, cc.CallFunc:create(cb_show));
		name:runAction(cc.Sequence:create(array));

		array = {};
		sarray = {};
		table.insert(array, cc.DelayTime:create(0.6));
		table.insert(array, cc.CallFunc:create(cb_show));
		--table.insert(sarray, cc.FadeIn:create(0.2));
		table.insert(sarray, cc.MoveBy:create(0.2, cc.p(0, 30)));
		table.insert(array, cc.Spawn:create(sarray));
		self.label:runAction(cc.Sequence:create(array));
		]]--
	end,

	update_drama = function(delta)
		self.layer:unscheduleUpdate();
	end,

	next_drama = function(self)
		local str = self.list[1];
		table.remove(self.list, 1);
		if nil == str then
			return false;
		end
		local function cb_change()
			self.label:setString(str);
		end
		array = {};
		sarray = {};
		table.insert(sarray, cc.FadeOut:create(0.1));
		table.insert(sarray, cc.MoveBy:create(0.1, cc.p(0, -30)));
		table.insert(array, cc.Spawn:create(sarray));
		table.insert(array, cc.CallFunc:create(cb_change));
		sarray = {};
		table.insert(sarray, cc.FadeIn:create(0.1));
		table.insert(sarray, cc.MoveBy:create(0.1, cc.p(0, 30)));
		table.insert(array, cc.Spawn:create(sarray));
		self.label:runAction(cc.Sequence:create(array));
		return true;
	end,

	handler = function(event, x, y)
		local self = layer_story;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
	end,

	onTouchEnded = function(self, x, y)
		if true == self:next_drama() then
			return;
		end
		local cb = self.callback;
		self:remove();
		if nil ~= cb then
			cb();
		end
	end,

} -- layer_story end

layer_gatepop = {
	name = 'layer_gatepop',
	list = nil, -- drama
	label = nil,
	callback = nil,
	drama_view = nil, -- story chat view

	cleanup = function(self)
		self.layer = nil;
		self.label = nil;
		self.list = nil;
		self.drama_view = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, card, msg, callback)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_GATEPOP, self.handler, true);

		self.callback = callback;
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		self:init_drama_view(card, msg);

		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		local self = layer_gatepop;
		local cb = self.callback;
		self:remove();
		if nil == cb then return; end
		cb();
	end,

	init_drama_view = function(self, card, msg)
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local fullrect = cc.rect(0, 0, 64, 64);
		local insetrect = cc.rect(30, 30, 4, 4);
		local bgsize = cc.size(FULL_WIDTH-wfix(100), FULL_HEIGHT-hfix(200));
		local path = util.get_path('pop_up.png');
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, fullrect, insetrect, bgsize); 

		local scale = get_card_scale(bgsize.width-80, bgsize.height/4*3-100, CARD_SIZE);
		pos = cc.p(bgsize.width/2, bgsize.height-30-CARD_SIZE.height*scale/2);
		local cinfo = object_card:new(bg, card, nil, nil, pos, 0, scale);
		local csprite = cinfo:get_show_sprite(bg, pos, 0, scale);

		pos = cc.p(bgsize.width/2, hfix(100));
		local size = cc.size(bgsize.width-40, 100);
		msg = msg or '';
		self.label = util.add_labelttf(bg, msg, nil, 30, pos, util.c4b_white, ANCHOR_CENTER_DOWN, 30, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_TOP);

		local items = {};
		local item;

		pos = ccp(bgsize.width/2, hfix(28));
		add_item_1(items, '关闭',nil,30,self.back,ANCHOR_CENTER_DOWN,pos);

		util.add_menu(bg, items, 35);

		csprite:setScale(1.3);
		csprite:setPositionY(csprite:getPositionY()+30);
		csprite:setVisible(false);
		self.label:setVisible(false);
		self.label:setPositionY(self.label:getPositionY()-30);
		bg:setPositionX(FULL_WIDTH);
		local array = {};
		table.insert(array, cc.EaseBackOut:create(cc.MoveTo:create(0.5, cc.p(HALF_WIDTH, HALF_HEIGHT))));
		bg:runAction(cc.Sequence:create(array));

		local function cb_show(...)
			local args = { ... };
			local sprite = args[1];
			sprite:setVisible(true);
		end
		array = {};
		local sarray = {};
		table.insert(array, cc.DelayTime:create(0.5));
		table.insert(array, cc.CallFunc:create(cb_show));
		table.insert(sarray, cc.ScaleTo:create(0.2, 1));
		table.insert(sarray, cc.MoveBy:create(0.2, cc.p(0, -30)));
		table.insert(array, cc.Spawn:create(sarray));
		csprite:runAction(cc.Sequence:create(array));

		array = {};
		sarray = {};
		table.insert(array, cc.DelayTime:create(0.6));
		table.insert(array, cc.CallFunc:create(cb_show));
		table.insert(sarray, cc.MoveBy:create(0.2, cc.p(0, 30)));
		table.insert(array, cc.Spawn:create(sarray));
		self.label:runAction(cc.Sequence:create(array));
	end,

	handler = function(event, x, y)
		local self = layer_gatepop;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
	end,

	onTouchEnded = function(self, x, y)
	end,

} -- layer_gatepop end

layer_dragstory = {
	name = 'layer_dragstory',
	layer = nil,
	callback = nil,
	fdata = nil,
	tdata = nil,
	tp = nil, -- touch point
	line = nil,
	finger = nil,
	can_touch = nil,

	cleanup = function(self)
		self.layer = nil;
		self.fdata = nil;
		self.tdata = nil;
		self.tp = nil;
		self.line = nil;
		self.finger = nil;
		self.can_touch = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, fdata, tdata, callback)
		self:remove();

		self.layer = cc.Layer:create();

		self.can_touch = true;
		self.callback = callback;
		local flag = true;
		if nil == self.callback then
			flag = false;
		end
		util.reg_handler(self.layer, -ZORDER_LAYER_DRAGSTORY, self.handler, flag);

		--self:init_clip_view(fdata, tdata);
		self:init_finger(fdata, tdata);
		self.fdata = fdata;
		self.tdata = tdata;

		return self.layer, self.name;
	end,

	get_sprite_data = function(sprite, use_circle)
		local x, y = sprite:getPosition();
		local size = sprite:getContentSize();
		local width = size.width;
		local height = size.height;
		local scale = sprite:getScale();
		local data = { x=x, y=y, width=width*scale, height=height*scale, use_circle=use_circle };
		return data;
	end,

	init_clip_view = function(self, fdata, tdata)
		local list = {};
		if nil ~= fdata then table.insert(list, fdata); end
		if nil ~= tdata then table.insert(list, tdata); end
		local layer_color = cc.LayerColor:create(ccc4(0, 0, 0, 180));
		local pclip = cc.ClippingNode:create();
		pclip:setInverted(true);
		pclip:addChild(layer_color);

		local pstencil = cc.DrawNode:create();
		local fill_color = cc.c4f(1, 0, 0, 1);
		local border_color = cc.c4f(1, 0, 0, 1);
		for i = 1, #list do
			local verts = {};
			local data = list[i];
			local x = data.x;
			local y = data.y;
			local width = data.width;
			local height = data.height;
			local use_circle = data.use_circle;
			if true == use_circle then
				local radius;
				if width > height then
					radius = width/2;
				else
					radius = height/2;
				end
				local count = 200;
				local m_pi = 3.1415926;
				local angel = 2.0 * m_pi / count;
				for i = 0, count - 1 do
					local radian = i * angel;
					local cx = radius * math.cos(radian);
					local cy = radius * math.sin(radian);
					table.insert(verts, cc.p(x+cx, y+cy));
				end
			else
				local hw = width/2;
				local hh = height/2;
				verts = {
					cc.p(x-hw, y-hh);
					cc.p(x+hw, y-hh);
					cc.p(x+hw, y+hh);
					cc.p(x-hw, y+hh);
				};
			end
			pstencil:drawPolygon(verts, #verts, fill_color, 0, border_color);
		end

		pstencil:setPosition(cc.p(0, 0));
		pclip:setStencil(pstencil);
		self.layer:addChild(pclip, 50);
	end,

	init_finger = function(self, fdata, tdata)
		if nil == fdata then return; end
		local fpos = cc.p(fdata.x, fdata.y);
		if nil == tdata then
			self.finger = util.play_frame(self.layer, 'tutor_finger', fpos, ANCHOR_LEFT_CENTER, 0.1, 70, true);
			return;
		end
		local tpos = cc.p(tdata.x, tdata.y);
		local finger = util.play_frame(self.layer, 'tutor_finger', fpos, ANCHOR_LEFT_CENTER, 0.1, 70, false);
		self.finger = finger;
		local dis = math.sqrt(math.pow((tpos.x-fpos.x), 2) + math.pow((tpos.y-fpos.y), 2));
		local speed = 200;
		local t = dis/speed;
		local array = {};
		table.insert(array, cc.MoveTo:create(t, tpos));
		table.insert(array, cc.MoveTo:create(0.1, fpos));
		finger:runAction(cc.RepeatForever:create(cc.Sequence:create(array)));
	end,

	handler = function(event, x, y)
		local self = layer_dragstory;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		self.tp = nil;
		if false == self.can_touch then return true; end
		if nil == self.callback then return; end
		if nil ~= self.line then
			self.line.batch:removeFromParentAndCleanup(true);
			self.line = nil;
		end
		if nil ~= self.fdata then
			local hw = self.fdata.width/2;
			local hh = self.fdata.height/2;
			if true == self.fdata.use_circle then
				local t = hw;
				if hh > hw then
					t = hh;
				end
				hw = t;
				hh = t;
			end
			local x1 = self.fdata.x - hw;
			local y1 = self.fdata.y - hh;
			local x2 = self.fdata.x + hw;
			local y2 = self.fdata.y + hh;
			if x > x1 and x < x2 and y > y1 and y < y2 then
				self.tp = cc.p(x, y);
			end
		end
		return true;
	end,

	onTouchMoved = function(self, x, y)
		if nil == self.tp then 
			return; 
		end
		if nil == self.tdata then 
			return; 
		end
		local ttt = self.tp;
		if nil == self.line then
			--[[
			local path = util.get_path('dragline.plist');	
			self.line = util.add_particle(self.layer, path, ttt, 60);
			]]--
			local verts = {
				cc.p(ttt.x, ttt.y),
				cc.p(x, y),
			};
			local ret_verts = nil;
			self.line, ret_verts = util.draw_line(self.layer, verts, cc.c4f(1, 1, 1, 1), 28, 12, 2, ZORDER_EFFECT, 4);
			self.line.ret_verts = ret_verts;
		end
		local ret_verts = self.line.ret_verts;
		if #(ret_verts or {}) > 1 then
			ret_verts[2].x = x;
			ret_verts[2].y = y;
		end
		--[[
		local pp = cc.p(x-ttt.x, y-ttt.y);
		local r = math.atan2(pp.y, pp.x);
		local r1 = r * 360 / ( 2 * 3.14 );
		local r2 = 90 - r1;
		local offset = math.sqrt(math.pow(pp.x, 2) + math.pow(pp.y, 2));
		local spos = self.line.emitter:getPosVar();
		spos.y = offset*0.5;
		self.line.emitter:setPosVar(spos);
		local pos = cc.p(pp.x/2+ttt.x, pp.y/2+ttt.y);
		self.line.batch:setPosition(pos);
		self.line.batch:setRotation(r2);
		]]--
	end,

	onTouchEnded = function(self, x, y)
		if nil == self.tp then 
			show_msg("请按提示进行操作");
			return; 
		end
		self.tp = nil;
		if nil == self.tdata then
			self:remove();
			self.callback();
			return;
		end
		if nil ~= self.line then
			--self.line.batch:removeFromParentAndCleanup(true);
			self.line:removeFromParent(true);
			self.line = nil;
		end
		if nil ~= self.tdata then
			local hw = self.tdata.width/2;
			local hh = self.tdata.height/2;
			if true == self.fdata.use_circle then
				local t = hw;
				if hh > hw then
					t = hh;
				end
				hw = t;
				hh = t;
			end
			local x1 = self.tdata.x - hw;
			local y1 = self.tdata.y - hh;
			local x2 = self.tdata.x + hw;
			local y2 = self.tdata.y + hh;
			if x > x1 and x < x2 and y > y1 and y < y2 then
				self:remove();
				self.callback();
				return;
			end
		end
	end,

} -- layer_dragstory end

layer_tutorial = {
	name = 'layer_tutorial',
	layer = nil,
	pclip = nil,
	rect = nil,
	finger = nil,
	tip = nil,
	board = nil,
	star = nil,
	tail = nil,
	callback = nil,

	cleanup = function(self)
		self.layer = nil;
		self.pclip = nil;
		self.rect = nil;
		self.finger = nil;
		self.tip = nil;
		self.board = nil;
		self.star = nil;
		self.tail = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, pos, size, tip, callback)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_TUTORIAL, self.handler, true);

		self:set_view(pos, size, tip, callback);

		return self.layer, self.name;
	end,

	set_view = function(self, pos, size, tip, callback)
		self.callback = callback;
		local r = nil;
		if nil ~= pos and nil ~= size then
			r = { 
				x1 = math.floor(pos.x), x2 = math.floor(pos.x + size.width),
				y1 = math.floor(pos.y), y2 = math.floor(pos.y + size.height) 
			};
			self:init_view(pos, size);
		end
		self.rect = r;

		local pos = cc.p(pos.x + size.width/2, pos.y + size.height/2+30);
		if nil ~= self.finger then
			self.finger:setPosition(pos);
			self.finger:setFlipX(false);
		else
			local finger = util.play_frame(self.layer, 'tutor_finger', pos, ANCHOR_LEFT_UP, 0.2, 70, true);
			self.finger = finger;
		end
		if pos.x > FULL_WIDTH/4*3 then
			self.finger:setFlipX(true);
			self.finger:setAnchorPoint(ANCHOR_RIGHT_UP);
		end

		if nil ~= self.tip then
			self.tip:removeFromParentAndCleanup(true);
		end
		if nil ~= tip and nil ~= r then
			local line = math.floor(FULL_HEIGHT/4*3);
			local gap = hfix(100);
			if pos.y > line then
				pos = cc.p(HALF_WIDTH, r.y1 - gap);
			else
				pos = cc.p(HALF_WIDTH, r.y2 + gap);
			end
			local size = cc.size(FULL_WIDTH/4*3, HALF_HEIGHT/4);
			--self.tip = util.add_labelsys(self.layer, tip, nil, 25, pos, util.c_white, ANCHOR_CENTER_CENTER, 60, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
			self.tip = util.add_labelttf(self.layer, tip, nil, 28, pos, util.c4b_white, ANCHOR_CENTER_CENTER, 60, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_CENTER); 
			local s = self.tip:getContentSize();
			size = cc.size(s.width + wfix(80), s.height + hfix(40));
			if nil ~= self.board then
				self.board:setPosition(pos);
				self.board:setContentSize(size);
			else
				local path = util.get_path('pop_up.png');
				local frect = cc.rect(0, 0, 64, 64); -- fullrect
				local irect = cc.rect(30, 30, 4, 4); -- insetrect
				self.board = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, size, 55); 
			end
		elseif nil ~= self.board then
			self.board:removeFromParentAndCleanup(true);
		end

		self:show_eff();
	end,

	show_eff = function(self)
		local r = self.rect;
		if nil == r or (r.x1 == r.x2 and r.y1 == r.y2) then
			if nil ~= self.star then
				self.star:removeFromParentAndCleanup(true);
				self.star = nil;
			end
			if nil ~= self.tail then
				self.tail.batch:removeFromParentAndCleanup(true);
				self.tail = nil;
			end
			return;
		end
		local speed = 250;
		local tx = (r.x2 - r.x1) / speed;
		local ty = (r.y2 - r.y1) / speed;
		local sprite, path, info, pos, size, action;
		pos = cc.p(r.x1, r.y2);
		if nil ~= self.star then
			self.star:setPosition(pos);
			self.star:stopAllActions();
		else
			path = util.get_path('tutor_star.png');
			self.star = util.add_sprite(self.layer,path,pos,ANCHOR_CENTER_CENTER,65);
		end
		size = self.star:getContentSize();
		local array = {};
		table.insert(array, cc.MoveTo:create(ty, cc.p(r.x1, r.y2)));
		table.insert(array, cc.MoveTo:create(tx, cc.p(r.x2, r.y2)));
		table.insert(array, cc.MoveTo:create(ty, cc.p(r.x2, r.y1)));
		table.insert(array, cc.MoveTo:create(tx, cc.p(r.x1, r.y1)));
		self.star:runAction(cc.RepeatForever:create(cc.Sequence:create(array)));
		self.star:runAction(cc.RepeatForever:create(cc.RotateBy:create(1, 360)));

		if nil ~= self.tail then
			self.tail.batch:setPosition(pos);
			self.tail.batch:stopAllActions();
		else
			path = util.get_path('tutor_tail.plist');
			self.tail = util.add_particle(self.layer, path, pos, 64);
		end
		array = {};
		table.insert(array, cc.MoveTo:create(ty, cc.p(r.x1, r.y2)));
		table.insert(array, cc.MoveTo:create(tx, cc.p(r.x2, r.y2)));
		table.insert(array, cc.MoveTo:create(ty, cc.p(r.x2, r.y1)));
		table.insert(array, cc.MoveTo:create(tx, cc.p(r.x1, r.y1)));
		self.tail.batch:runAction(cc.RepeatForever:create(cc.Sequence:create(array)));
	end,

	init_view = function(self, pos, size)
		if nil ~= self.pclip then
			self.pclip:removeFromParentAndCleanup(true);
			self.pclip = nil;
		end
		local layer_color = cc.LayerColor:create(ccc4(0, 0, 0, 180));
		local pclip = cc.ClippingNode:create();
		pclip:setInverted(true);
		pclip:addChild(layer_color);

		local fill_color = cc.c4f(1, 0, 0, 1);
		local border_color = cc.c4f(1, 0, 0, 1);
		local verts = {
			cc.p(0, 0);
			cc.p(size.width, 0);
			cc.p(size.width, size.height);
			cc.p(0, size.height);
		};
		--[[ 
		--circle
		--local radius = 55.0;
		local radius;
		if size.width > size.height then
			radius = size.width/2;
		else
			radius = size.height/2;
		end
		local count = 200;
		local m_pi = 3.1415926;
		local angel = 2.0 * m_pi / count;
		local verts = {};
		for i = 0, count - 1 do
			local radian = i * angel;
			local x = radius * math.cos(radian);
			local y = radius * math.sin(radian);
			table.insert(verts, cc.p(x, y));
		end
		]]--
		local pstencil = cc.DrawNode:create();
		pstencil:drawPolygon(verts, #verts, fill_color, 0, border_color);
		pstencil:setPosition(pos);
		pclip:setStencil(pstencil);
		self.layer:addChild(pclip, 50);
		self.pclip = pclip;
	end,

	get_finger = function(self)
		if nil == self.layer then
			return nil;
		end
		return self.finger;
	end,

	check_touch = function(self, x, y)
		local r = self.rect;
		if nil == r then
			kerror("layer_tutorial rect is nil");
			return false;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			return true;
		end
		return false;
	end,

	handler = function(event, x, y)
		local self = layer_tutorial;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	to_close = function(delta)
		local self = layer_tutorial;
		local cb = self.callback;
		if nil == cb then
			self:remove();
			return;
		end
		-- see in util.add_tutorial
		local flag, not_remove = cb();
		if true ~= flag or true ~= not_remove then
			self:remove();
			return;
		end
	end,

	onTouchBegan = function(self, x, y)
		-- flag==false means touching bright area, true==other area
		local flag = self:check_touch(x, y);
		-- if this is last touch of tutor(cb==nil)
		-- AND touching the bright area(flag==false)
		-- then close layer immediately to let the underlying layer
		-- get the touch signal
		if false == flag and nil == self.callback then -- tap the area
			self.to_close();
		end
		return true;
	end,

	onTouchMoved = function(self, x, y)
		return false;
	end,

	onTouchEnded = function(self, x, y)
		if true == g_is_in_tutor then
			local flag = self:check_touch(x, y);
			if false == flag and nil ~= self.callback then -- tap the area
				self.to_close();
			end
		else
			self.to_close();
		end
		return false;
	end,

} -- layer_tutorial end

layer_dragtutorial = {
	name = 'layer_dragtutorial',
	layer = nil,
	callback = nil,

	cliplist = nil,
	fdata = nil,
	tdata = nil,
	tp = nil, -- touch point
	line = nil,
	tip = nil,
	board = nil,

	cleanup = function(self)
		self.layer = nil;
		cliplist = nil;
		self.fdata = nil;
		self.tdata = nil;
		self.tp = nil;
		self.line = nil;
		self.tip = nil;
		self.board = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, cliplist, fdata, tdata, pos, tip, callback)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_DRAGTUTOR, self.handler, true);

		--self:init_clip_view(cliplist);
		self:init_finger(fdata, tdata);
		self:init_tip_view(cliplist, pos, tip)
		self.callback = callback;
		self.fdata = fdata;
		self.tdata = tdata;

		return self.layer, self.name;
	end,

	get_sprite_data = function(sprite, use_circle)
		local x, y = sprite:getPosition();
		local size = sprite:getContentSize();
		local width = size.width;
		local height = size.height;
		local scale = sprite:getScale();
		local data = { x=x, y=y, width=width*scale, height=height*scale, use_circle=use_circle };
		return data;
	end,

	init_clip_view = function(self, cliplist)
		cliplist = cliplist or {}
		local layer_color = cc.LayerColor:create(ccc4(0, 0, 0, 180));
		local pclip = cc.ClippingNode:create();
		pclip:setInverted(true);
		pclip:addChild(layer_color);

		local pstencil = cc.DrawNode:create();
		local fill_color = cc.c4f(1, 0, 0, 1);
		local border_color = cc.c4f(1, 0, 0, 1);
		for i = 1, #cliplist do
			local verts = {};
			local data = cliplist[i];
			local x = data.x;
			local y = data.y;
			local width = data.width;
			local height = data.height;
			local use_circle = data.use_circle;
			if true == use_circle then
				local radius;
				if width > height then
					radius = width/2;
				else
					radius = height/2;
				end
				local count = 200;
				local m_pi = 3.1415926;
				local angel = 2.0 * m_pi / count;
				for i = 0, count - 1 do
					local radian = i * angel;
					local cx = radius * math.cos(radian);
					local cy = radius * math.sin(radian);
					table.insert(verts, cc.p(x+cx, y+cy));
				end
			else
				local hw = width/2;
				local hh = height/2;
				verts = {
					cc.p(x-hw, y-hh);
					cc.p(x+hw, y-hh);
					cc.p(x+hw, y+hh);
					cc.p(x-hw, y+hh);
				};
			end
			pstencil:drawPolygon(verts, #verts, fill_color, 0, border_color);
		end

		pstencil:setPosition(cc.p(0, 0));
		pclip:setStencil(pstencil);
		self.layer:addChild(pclip, 50);
	end,

	init_finger = function(self, fdata, tdata)
		if nil == fdata then
			return;
		end

		local fpos = cc.p(fdata.x, fdata.y);
		if nil == tdata then
			util.play_frame(self.layer, 'tutor_finger', fpos, ANCHOR_LEFT_CENTER, 0.2, 70, true);
			return;
		end
		local tpos = cc.p(tdata.x, tdata.y);
		local finger = util.play_frame(self.layer, 'tutor_finger', fpos, ANCHOR_LEFT_CENTER, 0.1, 70, false);
		local dis = math.sqrt(math.pow((tpos.x-fpos.x), 2) + math.pow((tpos.y-fpos.y), 2));
		local speed = 200;
		local t = dis/speed;
		local array = {};
		table.insert(array, cc.MoveTo:create(t, tpos));
		table.insert(array, cc.MoveTo:create(0.1, fpos));
		finger:runAction(cc.RepeatForever:create(cc.Sequence:create(array)));
	end,

	init_tip_view = function(self, cliplist, pos, tip)

		if nil ~= self.tip then
			self.tip:removeFromParentAndCleanup(true);
		end
		if nil ~= tip then
			local size = cc.size(FULL_WIDTH/4*3, HALF_HEIGHT/4);
			if nil == pos then
				pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
				size = cc.size(FULL_WIDTH/2, HALF_HEIGHT/4);
				--[[
				for i=1, #(cliplist or {}) do
					local area = cliplist[i];
					if ((pos.x >= area.x and pos.x < area.x + area.width)
					or (area.x >= pos.x and area.x < pos.x + size.width))
					and ((pos.y >= area.y and pos.y < area.y + area.height)
					or (area.y >= pos.y and area.y < pos.y + size.height))
					then
						
						size = cc.size(FULL_WIDTH/8*5, HALF_HEIGHT/4*3);
						break
					end
				end
				]]--
			end

			--self.tip = util.add_labelsys(self.layer, tip, nil, 25, pos, util.c_white, ANCHOR_CENTER_CENTER, 60, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
			self.tip = util.add_labelttf(self.layer, tip, nil, 28, pos, util.c4b_white, ANCHOR_CENTER_CENTER, 60, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_CENTER); 
			local s = self.tip:getContentSize();
			size = cc.size(s.width + wfix(80), s.height + hfix(40));
			if nil ~= self.board then
				self.board:removeFromParentAndCleanup(true);
			end

			local path = util.get_path('bg_191.png');
			local frect = cc.rect(0, 0, 64, 64); -- fullrect
			local irect = cc.rect(30, 30, 4, 4); -- insetrect
			self.board = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, size, 55); 
		elseif nil ~= self.board then
			self.board:removeFromParentAndCleanup(true);
		end

	end,

	handler = function(event, x, y)
		local self = layer_dragtutorial;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
			util.free_ram();
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		self.tp = nil;
		self.line = nil;
		--[[
		if nil ~= self.line then
			self.line.batch:removeFromParentAndCleanup(true);
			self.line = nil;
		end
		]]--
		if nil ~= self.fdata then
			local hw = self.fdata.width/2;
			local hh = self.fdata.height/2;
			if true == self.fdata.use_circle then
				local t = hw;
				if hh > hw then
					t = hh;
				end
				hw = t;
				hh = t;
			end
			local x1 = self.fdata.x - hw;
			local y1 = self.fdata.y - hh;
			local x2 = self.fdata.x + hw;
			local y2 = self.fdata.y + hh;
			if x > x1 and x < x2 and y > y1 and y < y2 then
				self.tp = cc.p(x, y);
			end
		end
		return true;
	end,

	onTouchMoved = function(self, x, y)
		if nil == self.tp then return; end
		if nil == self.tdata then return; end
		local ttt = self.tp;
		if nil == self.line then
			--[[
			local path = util.get_path('dragline.plist');	
			self.line = util.add_particle(self.layer, path, ttt, 60);
			]]--
			local verts = {
				cc.p(ttt.x, ttt.y),
				cc.p(x, y),
			};
			local ret_verts = nil;
			self.line, ret_verts = util.draw_line(self.layer, verts, cc.c4f(1, 1, 1, 1), 28, 12, 2, ZORDER_EFFECT, 4);
			self.line.ret_verts = ret_verts;
		end
		local ret_verts = self.line.ret_verts;
		if #(ret_verts or {}) > 1 then
			ret_verts[2].x = x;
			ret_verts[2].y = y;
		end
		--[[
		local pp = cc.p(x-ttt.x, y-ttt.y);
		local r = math.atan2(pp.y, pp.x);
		local r1 = r * 360 / ( 2 * 3.14 );
		local r2 = 90 - r1;
		local offset = math.sqrt(math.pow(pp.x, 2) + math.pow(pp.y, 2));
		local spos = self.line.emitter:getPosVar();
		spos.y = offset*0.5;
		self.line.emitter:setPosVar(spos);
		local pos = cc.p(pp.x/2+ttt.x, pp.y/2+ttt.y);
		self.line.batch:setPosition(pos);
		self.line.batch:setRotation(r2);
		]]--
	end,

	onTouchEnded = function(self, x, y)
		if nil == self.fdata and nil == self.tdata then
			self:remove();
			if nil ~= self.callback then self.callback(); end
			return;
		end
		if nil == self.tp then 
			show_msg("请按提示进行操作");
			return; 
		end
		self.tp = nil;
		if nil == self.tdata then
			self:remove();
			if nil ~= self.callback then self.callback(); end
			return;
		end
		if nil ~= self.line then
			--self.line.batch:removeFromParentAndCleanup(true);
			self.line:removeFromParent(true);
			self.line = nil;
		end
		if nil ~= self.tdata then
			local hw = self.tdata.width/2;
			local hh = self.tdata.height/2;
			if true == self.fdata.use_circle then
				local t = hw;
				if hh > hw then
					t = hh;
				end
				hw = t;
				hh = t;
			end
			local x1 = self.tdata.x - hw;
			local y1 = self.tdata.y - hh;
			local x2 = self.tdata.x + hw;
			local y2 = self.tdata.y + hh;
			if x > x1 and x < x2 and y > y1 and y < y2 then
				self:remove();
				self.callback();
				return;
			end
		end
	end,

} -- layer_dragtutorial end

layer_horselamp = {
	name = 'layer_horselamp',
	list = {},
	layer = nil,
	count = nil,
	label = nil,
	bg_width = nil,
	label_width = nil,
	label_x = nil,

	cleanup = function(self)
		self.layer = nil;
		self.count = nil;
		self.label = nil;
		self.bg_width = nil;
		self.label_width = nil;
		self.label_x = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_HORSELAMP, self.handler,false);

		local info = self.list[1];
		local msg, count;
		if nil == info then
			msg = '???';
			count = 1;
		else
			msg = info.msg;
			count = info.count;
		end
		self.count = count;
		local bgpos = cc.p(HALF_WIDTH, FULL_HEIGHT-wfix(192)-92);
		local path = util.get_path('bg_222.png');
		local bg = util.add_sprite(self.layer, path, bgpos, ANCHOR_CENTER_DOWN);
		local bx = bgpos.x;
		local by = bgpos.y + 10;
		local pclip = cc.ClippingNode:create();
		self.layer:addChild(pclip);
		local size = bg:getContentSize();
		local bwidth = size.width - 30;
		local bheight = size.height - 20;
		self.bg_width = bwidth;
		self.offsetx = bwidth;
		pos = cc.p(bx+bwidth/2, by);
		self.label_x = pos.x;
		self.label = util.add_labelttf(pclip, msg, nil, 34, pos, util.c4b_white, ANCHOR_LEFT_DOWN, 10);
		self.label_width = self.label:getContentSize().width;
		local fill_color = cc.c4f(1, 0, 0, 1);
		local border_color = cc.c4f(1, 0, 0, 1);
		local hwidth = bwidth/2;
		local verts = {
			cc.p(bx-hwidth, by);
			cc.p(bx+hwidth, by);
			cc.p(bx+hwidth, by+bheight);
			cc.p(bx-hwidth, by+bheight);
		};
		local pstencil = cc.DrawNode:create();
		pstencil:drawPolygon(verts, #verts, fill_color, 0, border_color);
		pstencil:setPosition(cc.p(0, 0));
		pclip:setStencil(pstencil);
		self.layer:scheduleUpdateWithPriorityLua(self.update, 1);

		return self.layer, self.name;
	end,

	update = function(delta)
		local self = layer_horselamp;

		local gap = wfix(3);
		self.offsetx = self.offsetx - gap;
		local x, y = self.label:getPosition();
		--self.label:setPosition(cc.p(x+self.offsetx, y+0));
		self.label:setPosition(cc.p(x-gap, y));
		if self.offsetx < -self.label_width then
			self.label:setPositionX(self.label_x);
			self.offsetx = self.bg_width;
			self.count = self.count - 1;
			if 1 > self.count then
				table.remove(self.list, 1);
				self:check_next();
			end
		end
	end,

	check_next = function(self)
		if 0 == #self.list then
			self.layer:unscheduleUpdate();
			self:remove()
			return;
		end
		local info = self.list[1];
		local msg, count;
		if nil == info then
			msg = '???';
			count = 1;
		else
			msg = info.msg;
			count = info.count;
		end
		self.label:setString(msg);
		self.count = count;
	end,

	handler = function(event, x, y)
		local self = layer_horselamp;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
	end,
} -- layer_horselamp end

layer_grave = { -- layer_grave start
	name = 'layer_grave',
	layer = nil,
	table_view = nil,
	list = nil,
	slist = nil,
	tlist = nil,
	target_list = nil,
	cwidth = nil, -- cell width
	cheight = nil, -- cell height
	scale = nil, -- card scale

	cleanup = function(self)
		self.layer = nil;
		self.table_view = nil;
		self.list = {};
		self.slist = {};
		self.tlist = {};
		self.target_list = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.scale = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, list)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_GRAVE, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 128));
		self.target_list = {};
		self.list = {};
		for i = #list, 1, -1 do
			--table.insert(self.list, list[i]);
			local info = list[i];
			local cid = info.card.id;
			local index = cindex(info.card);
			table.insert(self.list, { cid = cid, index = index });
		end
		self:set_selectable_list();

		-- table view: FULL_WIDTH, hfix(700)
		-- cell: hfix(400), hfix(700)  -- both use hfix to keep scale same
		local size, pos;
		size = cc.size(FULL_WIDTH, hfix(700));
		--self.cwidth = size.width/1.5;
		self.cwidth = hfix(400);
		self.cheight = size.height;
		pos = cc.p(wfix(0), hfix(160));
		-- card scale
		self.scale = (self.cwidth - hfix(70)) / CARD_SIZE.width;
		---
		self.table_view = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_HORIZONTAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN, 1);

		local items = {};
		local item;
		local size = cc.size(172, 52);

		pos = ccp(HALF_WIDTH, hfix(40));
		item = add_item_1(items, '关闭', nil, 20, self.callback_close, ANCHOR_CENTER_DOWN, pos, size);

		util.add_menu(self.layer, items);

		return self.layer, self.name;
	end, 

	set_selectable_list = function(self)
		self.slist = {};
		if nil == g_src_index then
			return self.slist;
		end
		self.target_list = {};
		local num;
		local err;
		num, err = total_target(g_src_index, g_logic_table, g_current_side)
		local ability_target_indexs = list_ability_target(g_src_index, g_logic_table, g_current_side, self.target_list, #self.target_list + 1);
		self.slist = ability_target_indexs;
		return self.slist;
	end,

	handler = function(event, x, y)
		self = layer_grave;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,

	callback_close = function()
		play_tap_1();
		local self = layer_grave;
		local need_clean = false;
		if 0 < #(self.target_list or {}) then
			need_clean = true;
		end
		self:remove();
		if true == need_clean then
			g_src_index = 0;
			g_action_type = TYPE_NONE;
			refresh_layer_card();
		end
	end,

	callback_target = function(...)
		play_tap_1();
		local self = layer_grave;
		local args = {...};
		local index = args[2]:getTag();
		print('DEBUG g_layer_grave callback_target: ', tag);

		table.insert(self.target_list, index);
		local ability_target_indexs = list_ability_target(g_src_index, g_logic_table, g_current_side, self.target_list, #self.target_list + 1);
		if 0 == #(ability_target_indexs or {}) then
			layer_card:clean_menu();

			local cmd = 'b ' .. g_src_index ;
			for i=1, #self.target_list do
				cmd = cmd .. ' ' .. self.target_list[i];
			end
			self.callback_close();
			play_game_cmd(cmd);

			return;
		end
		self:set_selectable_list();
		self.table_view:reloadData();
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_grave;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			--local cell = args[3];
			--local idx = cell:getIdx();
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight ,self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local info = self.list[idx + 1];
			local cid = info.cid;
			local index = info.index;
			--print('------- cid, index: ', cid, index);
			local card = clone(g_card_list[cid]);
			local size = cc.size(self.cwidth, self.cheight);
			local pos = ccp(size.width/2, size.height/2 + hfix(60));
			--local sprite = info:get_grave_sprite(cell, pos, 0, self.scale);
			--local new_info = info:copy(cell, STYPE_VER_1, nil, self.scale, nil);
			local cobj = object_card:new(cell, card, nil, nil, pos, 0, 1, STYPE_VER_1);
			local sprite = cobj:get_front();
			g_sprite_cache[cobj.card] = nil; -- don't put sprite in g_sprite_cache

			local is_target = false;
			for i = 1, #self.slist do
				--local index = cindex(card);
				local sindex = self.slist[i];
				if index == sindex then
					local items = {};
					local item;
					local size = cc.size(172, 52);

					pos = ccp(self.cwidth/2, 0);
					item = add_item_1(items, '目标', nil, 20, self.callback_target, ANCHOR_CENTER_DOWN, pos, size);
					local offsetx = item:getContentSize().width/2;
					item:setTag(index);

					util.add_menu(cell, items);
					break;
				end
			end
			return cell;
		end
	end, -- tableview_handler end }

} -- layer_grave end

layer_pay = { -- start
	name = 'layer_pay',
	layer = nil,
	pay_type = nil,
	time = nil,
	list = nil,
	tableview = nil,
	cwidth = nil,
	cheight = nil,
	theight = nil,
	rect = nil,
	data_cell = nil,
	do_cell_anim = nil,
	bar = nil,
	tap = nil,
	icon_up = nil,
	icon_down = nil,

	cleanup = function(self)
		self.layer = nil;
		self.time = nil;
		self.pay_type = nil;
		self.list = nil;
		self.tableview = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.theight = nil;
		self.rect = nil;
		self.data_cell = nil;
		self.do_cell_anim = nil;
		self.bar = nil;
		self.tap = nil;
		self.icon_up = nil;
		self.icon_down = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_PAY, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		self.pay_type = 0;
		self.list = {};
		local data;
		local offsetheight, bg, rect = init_bg_pop(self.layer, GUI_PAY, '充值', self.back);
		self.rect = rect;

		gui_add_sprite(self.layer, 'bottom_line', GUI_PAY, ANCHOR_DOWN);

		data = gui_get_data('c1', GUI_PAY, ANCHOR_DOWN);
		table.insert(self.list, { data = data });
		data = gui_get_data('c2', GUI_PAY, ANCHOR_DOWN);
		table.insert(self.list, { data = data });

		data = gui_get_data('c3', GUI_PAY, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		data = gui_get_data('table', GUI_PAY, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		self.theight = size.height;
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);
		pos = cc.p(data.x+size.width, data.y+size.height);
		self.icon_up = add_scroll_icons(self.layer, pos, true);
		self.icon_up:setVisible(false);
		pos = cc.p(data.x+size.width, data.y);
		self.icon_down = add_scroll_icons(self.layer, pos, false);
		self.icon_down:setVisible(false);

		return self.layer, self.name;
	end, 

	check = function(...)
		local args = {...};
		local self = layer_pay;
		local cid = args[1];
		local card = clone(g_card_list[cid]);
		if nil == card then card = clone(hero_list[cid]); end
		if nil == card then return; end
		g_scene:add_layer(ZORDER_LAYER_MISPOP, layer_mispop:create(card));
	end,

	reload = function(self)
		self.tableview:reloadData();
	end,

	add_list = function(self, pay_type, list)
		self.pay_type = pay_type;
		for i = 1, #(list or {}) do
			table.insert(self.list, list[i]);
		end
		self.do_cell_anim = true;
		self:reload();
	end,

	handler = function(event, x, y)
		local self = layer_pay;
		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		self.do_cell_anim = false;
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,

	back = function()
		play_tap_1();
		local self = layer_pay;
		self:remove();
		if is_ver(VER_ANYSDK) or is_ver(VER_ANYSDK_NO_LOGIN) then
			ProtocolIAP:resetPayState();
		end
		if nil ~= layer_lottery.layer then
			layer_lottery:remove();
		end
		if nil ~= layer_stage.layer then
			if true == util.trigger_tutor(TUTOR_STAGE_1_9) then
				return;
			end
		end
		--util.trigger_tutor(TUTOR_DECK);
	end,

	request_ucsdk = function(self, index)
		local info = self.list[index];
		if nil == info then
			return;
		end
		local payCode = info.pay_code .. '';
		local serverId = util.get_server_id(util.load_server(), IP_ADDR) .. '';
		print('ip, payCode, serverId: ', IP_ADDR, payCode, serverId);
		local payPrice = math.floor(tonumber(info.pay_price or '0') / 100) .. '';
		local eid = g_euser.eid .. '';
		local alias = g_euser.alias .. '';
		local crystal = g_euser.crystal .. '';
		local level = g_euser.level .. '';
		--local money = info.money or 0;

		serverId = 1;
		show_netloading();
		local xhr = cc.XMLHttpRequest:new();
		xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_STRING;
		local r = string.format("http://%s:8899/pay_server/order?playerId=%d&serverId=%s&payCode=%s", IP_ADDR, tonumber(g_euser.eid), serverId, payCode);
		print('iap get order_no address=', r);
		xhr:open("GET", r);
		local function callback_xhr()
			hide_netloading();
			local status = "Http Status Code:" .. xhr.statusText;
			local order_no = xhr.response;
			order_no = string.gsub(order_no, "\n", "");
			if (tonumber(order_no) or -1) < 0 then
				local tip = string.format("获取订单失败 %s", order_no);
				g_scene:add_layer(ZORDER_LAYER_MSG, layer_msg:create(tip));
				return;
			end
			print('iap ----- status: ', status);
			print('iap ----- order_no: ', order_no);
			local allowContinuousPay = true;
			local amount = payPrice;
			local serverId = 0;
			local pszRoleId = eid;
			local pszRoleName = alias;
			local pszGrade = level;
			local pszCustomInfo = order_no;
			local pszNotifyUrl = string.format("http://%s:8899/pay_server/ucpay?", IP_ADDR);
			local pszTransactionNum = "0";
			
			UCSdkHandler:pay(allowContinuousPay, amount, serverId, pszRoleId, pszRoleName, pszGrade, pszCustomInfo, pszNotifyUrl, pszTransactionNum);
			return;
		end
		xhr:registerScriptHandler(callback_xhr);
		xhr:send();
	end,

	request_9you = function(self, index)
		local info = self.list[index];
		if nil == info then
			return;
		end
		local payCode = info.pay_code .. '';
		local serverId = util.get_server_id(util.load_server(), IP_ADDR) .. '';
		local payPrice = tonumber(info.pay_price or '0');
		print('ip, payCode, serverId: ', IP_ADDR, payCode, serverId);

		serverId = 1;
		show_netloading();
		local xhr = cc.XMLHttpRequest:new();
		xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_STRING;
		local r = string.format("http://%s:8899/pay_server/order?playerId=%d&serverId=%s&payCode=%s", IP_ADDR, tonumber(g_euser.eid), serverId, payCode);
		print('iap get order_no address=', r);
		xhr:open("GET", r);
		local function callback_xhr()
			hide_netloading();
			local status = "Http Status Code:" .. xhr.statusText;
			local order_no = xhr.response;
			order_no = string.gsub(order_no, "\n", "");
			if (tonumber(order_no) or -1) < 0 then
				local tip = string.format("获取订单失败 %s", order_no);
				g_scene:add_layer(ZORDER_LAYER_MSG, layer_msg:create(tip));
				return;
			end
			print('iap ----- status: ', status);
			print('iap ----- order_no: ', order_no);
			local pszUserId = g_euser.user_id;
			local pszProductName = info.title;
			local money = payPrice;
			local count = 1;
			local pszOrderId = order_no;
			local pszProductId = payCode;
			local pszExtInfo = g_euser.eid;
			
--			show_msg("pay order no: " .. (pszOrderId or -1));
			Sdk9youHandler:pay(pszUserId, pszProductName, money, count, pszOrderId, pszProductId, pszExtInfo);
			return;
		end
		xhr:registerScriptHandler(callback_xhr);
		xhr:send();
	end,

	request_anysdk = function(self, index)
		local info = self.list[index];
		if nil == info or nil == g_anysdk_plugin then
			return;
		end
		local payCode = info.pay_code .. '';
		local serverId = util.get_server_id(util.load_server(), IP_ADDR) .. '';
		print('ip, payCode, serverId: ', IP_ADDR, payCode, serverId);
		local payPrice = math.floor(tonumber(info.pay_price or '0') / 100) .. '';
		local eid = g_euser.eid .. '';
		local crystal = g_euser.crystal .. '';
		local level = g_euser.level .. '';
		--local money = info.money or 0;

		serverId = 1; -- hardcode serverId to 1;
		show_netloading();
		local xhr = cc.XMLHttpRequest:new();
		xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_STRING;
		local r = string.format("http://%s:8899/pay_server/order?playerId=%d&serverId=%s&payCode=%s", IP_ADDR, tonumber(g_euser.eid), serverId, payCode);
		print('iap get order_no address=', r);
		xhr:open("GET", r);
		local function callback_xhr()
			hide_netloading();
			local status = "Http Status Code:" .. xhr.statusText;
			local order_no = xhr.response;
			order_no = string.gsub(order_no, "\n", "");
			if (tonumber(order_no) or -1) < 0 then
				local tip = string.format("获取订单失败 %s", order_no);
				g_scene:add_layer(ZORDER_LAYER_MSG, layer_msg:create(tip));
				return;
			end
			print('iap ----- status: ', status);
			print('iap ----- order_no: ', order_no);
			local agent = AgentManager:getInstance();
			local iap_plugin_maps = agent:getIAPPlugin();
			local info = {
				Product_Price = payPrice,
				Product_Id = payCode,
				Product_Name = info.title,
				Server_Id = serverId,
				Product_Count = "1",  
				Role_Id = eid,
				Role_Grade = level,
				Role_Balance = crystal,
				Role_Name = g_euser.alias,
				EXT = order_no
			};
			local cid = tonumber(agent:getChannelId() or "0");
			if cid == 20 then
				info.Product_Name = "个(" .. info.Product_Name .. ")";
			end
			g_anysdk_plugin:payForProduct(info);
			return;
		end
		xhr:registerScriptHandler(callback_xhr);
		xhr:send();
	end,

	request_ljsdk = function(self, index)
		local info = self.list[index];
		if nil == info then
			return;
		end
		local payCode = info.pay_code or '';
		local serverId = util.get_server_id(util.load_server(), IP_ADDR) .. '';
		print('ip, payCode, serverId: ', IP_ADDR, payCode, serverId);
		local payPrice = math.floor(tonumber(info.pay_price or '0')) .. '';
		local unitName = info.title or '';
		local count = info.money;
		local eid = g_euser.eid .. '';
		local crystal = g_euser.crystal .. '';
		local level = g_euser.level .. '';

		serverId = 1; -- hardcode serverId to 1;
		show_netloading();
		local xhr = cc.XMLHttpRequest:new();
		xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_STRING;
		local r = string.format("http://%s:8899/pay_server/order?playerId=%d&serverId=%s&payCode=%s", IP_ADDR, tonumber(g_euser.eid), serverId, payCode);
		print('iap get order_no address=', r);
		xhr:open("GET", r);
		local function callback_xhr()
			hide_netloading();
			local status = "Http Status Code:" .. xhr.statusText;
			local order_no = xhr.response;
			order_no = string.gsub(order_no, "\n", "");
			if (tonumber(order_no) or -1) < 0 then
				local tip = string.format("获取订单失败 %s", order_no);
				g_scene:add_layer(ZORDER_LAYER_MSG, layer_msg:create(tip));
				return;
			end
			print('iap ----- status: ', status);
			print('iap ----- order_no: ', order_no);
			local callbackUrl = string.format("http://%s:8899/pay_server/ljsdkpay", IP_ADDR);
			-- TODO: pay
			LJSdkImpl:pay(payPrice, '水晶', count, order_no, callbackUrl, layer_net.layer);
			return;
		end
		xhr:registerScriptHandler(callback_xhr);
		xhr:send();
	end,

	request_appstore = function(self, index)
		local info = self.list[index];
		if nil == info then
			return;
		end
		local payCode = info.pay_code;
		local serverId = util.get_server_id(util.load_server(), IP_ADDR);
		print('ip, payCode, serverId: ', IP_ADDR, payCode, serverId);
		-- exmaple: "http://211.149.186.201:8899/pay_server/order?playerId=1074&serverId=1&payCode=41"
		serverId = 1; -- hardcode serverId to 1;
		show_netloading();
		local xhr = cc.XMLHttpRequest:new();
		xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_STRING;
		local r = string.format("http://%s:8899/pay_server/order?playerId=%d&serverId=%s&payCode=%s", IP_ADDR, tonumber(g_euser.eid), serverId, payCode);
		print('iap get order_no address=', r);
		xhr:open("GET", r);
		local function callback_xhr()
			hide_netloading();
			local status = "Http Status Code:" .. xhr.statusText;
			local order_no = xhr.response;
			order_no = string.gsub(order_no, "\n", "");
			if (tonumber(order_no) or -1) < 0 then
				local tip = string.format("获取订单失败 %s", order_no);
				g_scene:add_layer(ZORDER_LAYER_MSG, layer_msg:create(tip));
				return;
			end
			print('iap ----- status: ', status);
			print('iap ----- order_no: ', order_no);
			local platform = cc.Application:getInstance():getTargetPlatform();
			if platform ~= cc.PLATFORM_OS_IPHONE and platform ~= cc.PLATFORM_OS_IPAD then
				return;
			end
			local url = string.format("http://%s:8899/pay_server/apple?", IP_ADDR);
			--local url = string.format("http://192.168.1.33:8899/pay_server/apple?", IP_ADDR);
			--local url = string.format("http://%s:8080/pay_server/apple?", "192.168.1.22");
			local mode = '1'; -- mode 0->test 1->official
			if true == DEBUG_MODE then
				mode = '0';
			end
			local product_id = string.format("%d", payCode);
			g_scene:add_layer(ZORDER_LAYER_APPSTOREPAY, layer_appstorepay:create());
			local args = { 
				product_id = product_id, handler = layer_appstorepay.callback,
				url = url, mode = mode, order_no = order_no,
			};
			local luaoc = require "luaoc";
			local class_name = "IAPView";
			local ok, ret = luaoc.callStaticMethod(class_name, "requestAppStorePay",args);
			return;
		end
		xhr:registerScriptHandler(callback_xhr);
		xhr:send();
	end,

	request_apay = function(self, index)
		local info = self.list[index];
		if nil == info then
			return;
		end
		local payCode = info.pay_code;
		local serverId = util.get_server_id(util.load_server(), IP_ADDR);
		print('ip, payCode, serverId: ', IP_ADDR, payCode, serverId);
		-- exmaple: "http://211.149.186.201:8899/pay_server/order?playerId=1074&serverId=1&payCode=41"
		serverId = 1; -- hardcode serverId to 1;
		show_netloading();
		local xhr = cc.XMLHttpRequest:new();
		xhr.responseType = cc.XMLHTTPREQUEST_RESPONSE_STRING;
		local r = string.format("http://%s:8899/pay_server/order?playerId=%d&serverId=%s&payCode=%s", IP_ADDR, tonumber(g_euser.eid), serverId, payCode);
		xhr:open("GET", r);
		local function callback_xhr()
			hide_netloading();
			local status = "Http Status Code:" .. xhr.statusText;
			local order_no = xhr.response;
			order_no = string.gsub(order_no, "\n", "");
			if (tonumber(order_no) or -1) < 0 then
				local tip = string.format("获取订单失败 %s", order_no);
				g_scene:add_layer(ZORDER_LAYER_MSG, layer_msg:create(tip));
				return;
			end
			print('----- status: ', status);
			print('----- order_no: ', order_no);
			local mflag = 2; -- 1 test, 2 product
			if true == DEBUG_MODE then
				mflag = 1;
			end
			mflag = 1; -- always test mode
			local mode = nil; -- "01" is testing, "00" is product
			local servlet = nil;
			local merchantId = "109020201409007";
			local key = "124567890";
			if 1 == mflag then
				mode = "01";
				servlet = "allinpaydebug";
				merchantId = "100020091218001";
				key = "1234567890";
			else
				mode = "00";
				servlet = "allinpay";
			end
			local platform = cc.Application:getInstance():getTargetPlatform();
			if platform == cc.PLATFORM_OS_IPHONE or platform == cc.PLATFORM_OS_IPAD then
				g_scene:add_layer(ZORDER_LAYER_APPSTOREPAY, layer_appstorepay:create());
				local args = { 
					merchantId = merchantId,
					orderNo = order_no, 
					receiveUrl = string.format("http://%s:8899/pay_server/%s", IP_ADDR, servlet),
					productName = info.description,
					price = info.pay_price,
					handler = layer_appstorepay.callback,
					mode = mode,
					key = key,
				};
				local luaoc = require "luaoc";
				local class_name = "APayView";
				local ok, ret;
				ok, ret = luaoc.callStaticMethod(class_name,"requestAPay",args);
			elseif platform == cc.PLATFORM_OS_ANDROID then
				g_scene:add_layer(ZORDER_LAYER_APPSTOREPAY, layer_appstorepay:create());
				local args = { 
					merchantId, order_no, string.format("http://%s:8899/pay_server/%s", IP_ADDR, servlet), info.description, info.pay_price, mode, key, layer_appstorepay.callback,
				};
				local sigs = "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;I)V";
				local luaj = require "luaj";
				local class_name = "org/cocos2dx/lua/AppActivity";
				local ok, ret = luaj.callStaticMethod(class_name, "requestAPay", args, sigs);
			end
			return;
		end
		xhr:registerScriptHandler(callback_xhr);
		xhr:send();
	end,

	request_pay = function(self, index)
		local info = self.list[index];
		if nil == info then
			return;
		end
		local time = os.date("%y%m%d%H%M%S", os.time());
		if time == self.time then
			-- prevent create same order cos tap too fast
			return;
		end
		self.time = time;
		local pay_type = self.pay_type;
		local pay_code = info.pay_code;
		local pay_price = info.pay_price;
		local money_type = info.money_type;
		local money = info.money;
		local server_id = 1; -- hard code
		local player_id = g_euser.eid;
		local trade_no = time .. '_' .. pay_type .. '_' .. pay_code .. '_';
		trade_no = trade_no .. pay_price .. '_' .. money_type .. '_' .. money;
		trade_no = trade_no .. '_' .. server_id .. '_' .. player_id;
		--print('trade_no: ', trade_no);

		local desc = info.description or '';
		local platform = cc.Application:getInstance():getTargetPlatform();
		if platform == cc.PLATFORM_OS_IPHONE or platform==cc.PLATFORM_OS_IPAD then
			local args = { 
				trade_no = trade_no, title = "玛莎还没弄", desc = desc, 
				price = pay_price,
			};
			local luaoc = require "luaoc";
			local class_name = "SysTool";
			local ok, ret = luaoc.callStaticMethod(class_name, "requestPay",args);
		elseif platform == cc.PLATFORM_OS_ANDROID then
			--[[
			local args = { 
				trade_no, "玛莎还没弄", desc, pay_price,
			};
			local sigs = "(Ljava/lang/String;I)V";
			local luaj = require "luaj";
			local class_name = "org/cocos2dx/lua/AppActivity";
			local ok, ret = luaj.callStaticMethod(class_name, "openURL", args, sigs);
			]]--
		end
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_pay;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			if nil == self.icon_up or nil == self.icon_down then return; end
			update_scroll_icon(self.icon_up, self.icon_down, view, self.theight);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			if 0 == idx or 1 == idx then return; end
			--self:request_pay(idx + 1);
			if is_ver(VER_ANYSDK) or is_ver(VER_ANYSDK_NO_LOGIN) then
				self:request_anysdk(idx + 1);
			elseif is_ver(VER_APPSTORE) then
				self:request_appstore(idx + 1);
			elseif is_ver(VER_APAY) then
				self:request_apay(idx + 1);
			elseif is_ver(VER_UCSDK) then
				self:request_ucsdk(idx + 1);
			elseif is_ver(VER_NINEYOU) then
				self:request_9you(idx + 1);
			elseif is_ver(VER_LJSDK) then
				self:request_ljsdk(idx + 1);
			else
				show_msg("充值尚未开放");
			end
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			if idx == 1 or idx == 0 then
				local data = self.list[idx+1].data;
				return data.height, data.width;
			end
			return self.cheight ,self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local index = idx+1;
			if 1 == index then
				local info = self.list[index];
				local data = info.data;
				gui_add_cell_bg(cell, data);
				gui_add_sprite_on_cell(cell, data, 'c1_bg_title', GUI_PAY,ANCHOR_DOWN);
				local str = "首充大礼三重奖";
				gui_add_label_on_cell(cell,data,str,28,'c1_title',GUI_PAY,ANCHOR_DOWN);
				gui_add_sprite_on_cell(cell, data, 'c1_crystal', GUI_PAY,ANCHOR_DOWN);
				local path = util.get_path(FT_4);
				gui_add_labelbmf_on_cell(cell,data,"+",path,'c1_p1',GUI_PAY,ANCHOR_DOWN);
				gui_add_labelbmf_on_cell(cell,data,"+",path,'c1_p2',GUI_PAY,ANCHOR_DOWN);
				local items = {};
				local item, data2;
				item, data2 = gui_add_item_on_cell(items, data, 'c1_card1', GUI_PAY, self.check, ANCHOR_DOWN);
				item:setTag(69);
				item, data2 = gui_add_item_on_cell(items, data, 'c1_card2', GUI_PAY, self.check, ANCHOR_DOWN);
				item:setTag(29);
				util.add_menu(cell, items, data2.zorder);
				return cell;
			elseif 2 == index then
				local info = self.list[index];
				local data = info.data;
				gui_add_cell_bg(cell, data);
				gui_add_sprite_on_cell(cell, data, 'c2_bg_title', GUI_PAY,ANCHOR_DOWN);
				local str = "首购VIP三重奖励";
				gui_add_label_on_cell(cell,data,str,28,'c2_title',GUI_PAY,ANCHOR_DOWN);
				local path = util.get_path(FT_4);
				gui_add_labelbmf_on_cell(cell,data,"+",path,'c2_p1',GUI_PAY,ANCHOR_DOWN);
				gui_add_labelbmf_on_cell(cell,data,"+",path,'c2_p2',GUI_PAY,ANCHOR_DOWN);
				local items = {};
				local item, data2;
				item, data2 = gui_add_item_on_cell(items, data, 'c2_card1', GUI_PAY, self.check, ANCHOR_DOWN);
				item:setTag(74);
				item, data2 = gui_add_item_on_cell(items, data, 'c2_card2', GUI_PAY, self.check, ANCHOR_DOWN);
				item:setTag(71);
				item, data2 = gui_add_item_on_cell(items, data, 'c2_card3', GUI_PAY, self.check, ANCHOR_DOWN);
				item:setTag(78);
				util.add_menu(cell, items, data2.zorder);
				return cell;
			end
			local width = self.cwidth;
			local height = self.cheight;
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local info = self.list[idx + 1];
			local money_type = info.money_type;
			local sprite, data2, str, path;
			gui_add_sprite_on_cell(cell, data, 'c3_bg_title',GUI_PAY,ANCHOR_DOWN);
			str = info.title .. '';
			gui_add_label_on_cell(cell,data,str,28,'c3_title',GUI_PAY,ANCHOR_DOWN);
			str = info.description or '';
			sprite = gui_add_label_on_cell(cell,data,str,21,'c3_desc',GUI_PAY,ANCHOR_DOWN);
			sprite:setAlignment(cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_TOP);
			path = util.get_path(FT_4);
			str = math.floor(tonumber(info.pay_price or '0') / 100);
			sprite = gui_add_labelbmf_on_cell(cell,data,str,path,'c3_price',GUI_PAY,ANCHOR_DOWN, cc.TEXT_ALIGNMENT_RIGHT);
			gui_add_sprite_on_cell(cell, data, 'c3_yuan',GUI_PAY,ANCHOR_DOWN);
			if 1 == money_type then
				if nil ~= string.find(info.title, '月卡') then
					gui_add_sprite_on_cell(cell,data,'c3_vip',GUI_PAY,ANCHOR_DOWN);
				else
					gui_add_sprite_on_cell(cell,data,'c3_crystal',GUI_PAY,ANCHOR_DOWN);
				end
			end
			if true == self.do_cell_anim then
				local delay = (idx%10)*0.1;
				keff_showup_1(cell, delay);
			end
			
			return cell;
		end
	end, -- tableview_handler end }

} -- layer_pay end


layer_pay_ad = { -- start
	name = 'layer_pay_ad',
	layer = nil,

	cleanup = function(self)
		self.layer = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_PAY_AD, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		local data;
		local sprite;
		sprite, data = gui_add_sprite(self.layer, 'bg', GUI_PAY_AD,ANCHOR_UP);
		
		local offsety = HALF_HEIGHT - (data.y + data.height / 2);
		sprite:setPositionY(data.y + offsety);

		local item;
		local items = {};
		item,data =gui_add_item(items,'btn_charge',GUI_PAY_AD,self.charge,ANCHOR_UP);
		item:setPositionY(data.y + offsety);
		item,data =gui_add_item(items,'btn_back',GUI_PAY_AD,self.back,ANCHOR_UP);
		item:setPositionY(data.y + offsety);

		util.add_menu(self.layer, items, data.zorder);

		return self.layer, self.name;
	end, 

	back = function()
		play_tap_1();
		local self = layer_pay_ad;
		self:remove();
		if nil ~= layer_lottery.layer then
			layer_lottery:remove();
		end
		util.set_tutor(TUTOR_PAY_AD, true, true);
		util.trigger_tutor(TUTOR_DECK);
	end,

	charge = function()
		play_tap_1();
		local self = layer_pay_ad;
		self:remove();
		go_pay();
		util.set_tutor(TUTOR_PAY_AD, true, true);
	end,

	handler = function(event, x, y)
		self = layer_pay_ad;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
	end,

} -- layer_pay_ad end

layer_lguild = {
	name = 'layer_lguild',
	PAGE_SIZE = 15,
	layer = nil,
	list = nil,
	editbox = nil,
	tableview = nil,
	bar = nil,
	tap = nil,
	cwidth = nil,
	cheight = nil,
	data_cell = nil,
	do_cell_anim = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.editbox = nil;
		self.tableview = nil;
		self.bar = nil;
		self.tap = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.data_cell = nil;
		self.do_cell_anim = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();
		
		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_LGUILD, self.handler, true);

		self.list = {};
		local offsetheight = init_bg_full(self.layer, GUI_LGUILD, self.back);
		local sprite, data, pos, size, path;
		sprite,data=gui_add_sprite(self.layer,'outframe',GUI_LGUILD,ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));
		sprite, data = gui_add_sprite(self.layer,'fade_bottom',GUI_LGUILD,ANCHOR_DOWN);
		sprite:setScaleX(data.width/sprite:getContentSize().width);

		gui_add_sprite(self.layer, 'bg_search', GUI_LGUILD, ANCHOR_UP);
		self.editbox, data = gui_add_editbox(self.layer, 't_search', GUI_LGUILD, ANCHOR_UP, 22, self.editbox_handler, 10, '请输入公会名称...');

		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn_search', GUI_LGUILD, self.search, ANCHOR_UP);

		if false == g_euser:has_guild() then
			item, data = gui_add_item(items, 'btn_create', GUI_LGUILD, self.create_guild, ANCHOR_UP);
		end

		util.add_menu(self.layer, items, data.zorder);

		data = gui_get_data('cell', GUI_LGUILD, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height+10;
		data = gui_get_data('table', GUI_LGUILD, ANCHOR_DOWN);
		size = cc.size(data.width, data.height+offsetheight);
		pos = cc.p(data.x, data.y);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);


		--[[
		local has_guild = g_euser:has_guild();

		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn_search', GUI_LGUILD, self.search, ANCHOR_UP);
		gui_add_text_on_sprite(item, "查找", 't_search', GUI_LGUILD,ANCHOR_UP,30);

		if true ~= has_guild then
			item, data = gui_add_item(items, 'btn_create', GUI_LGUILD, self.create_guild, ANCHOR_DOWN);
			gui_add_text_on_sprite(item, "创建公会", 't_create', GUI_LGUILD, ANCHOR_DOWN, 30);
		end

		util.add_menu(self.layer, items, data.zorder);

		local d1 = gui_get_data('table', GUI_LGUILD, ANCHOR_UP);
		local d2 = gui_get_data('table', GUI_LGUILD, ANCHOR_DOWN);
		local offsety = d1.y - d2.y;
		data = gui_get_data('cell', GUI_LGUILD, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height+10;
		data = gui_get_data('table', GUI_LGUILD, ANCHOR_DOWN);
		size = cc.size(data.width, data.height+offsety);
		pos = cc.p(data.x, data.y);
		if true == has_guild then
			local d = gui_get_data('btn_create', GUI_LGUILD, ANCHOR_DOWN);
			size.height = size.height + (pos.y - d.y);
			pos.y = d.y;
		end
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, ccp(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+10);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);
		]]--

		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		if true == g_euser:has_guild() and nil ~= g_euser.guild_data then
			g_scene:guild();
		else
			g_scene:map();
		end
	end,

	search = function()
		play_tap_1();
		local self = layer_lguild;
		local key = self.editbox:getText();
		local cmd = string.format("lguild %d %d %s", 0, self.PAGE_SIZE, key);
		net_send(cmd);
	end,

	get_more = function()
		play_tap_1();
		local self = layer_lguild;
		local key = self.editbox:getText();
		local len = #(self.list or {});
		if self.list[len].flag_more_cell == true then
			len = len - 1;
		end
		if len < 0 then len = 0; end
		local cmd = string.format("lguild %d %d %s", len, self.PAGE_SIZE, key);
		net_send(cmd);
	end,

	create_guild = function()
		play_tap_1();
		local mygpos = g_euser.gpos or GUILD_POS_NONE;
		if mygpos == GUILD_POS_APPLY then
			show_msg("申请公会中，如需创建公会，请先取消申请");
			return;
		end
		local gold = tonumber(g_constant.create_guild_gold);
		local crystal = tonumber(g_constant.create_guild_crystal);
		if nil == gold or nil == crystal then
			local cmd = 'cguild';
			net_send(cmd);
			return;
		end
		g_scene:add_layer(ZORDER_LAYER_CGUILD, layer_cguild:create(gold,crystal));
	end,

	apply = function(...)
		play_tap_1();
		local self = layer_lguild;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		local gid = info.gid;
		local cmd = 'gapply ' .. gid;
		net_send(cmd);
	end,

	cancel_apply = function()
		play_tap_1();
		local self = layer_lguild;
		local cmd = 'gquit';
		net_send(cmd);
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_lguild;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
			local str = edit:getText();
			str = util.space_(str);
			edit:setText(str);
		elseif eventname == "changed" then
		end
	end,
	
	reload_data = function(self)
		self.tableview:reloadData();
	end,

	add_list = function(self, list, start_pos)
		list = list or {};
		local more_cell = { flag_more_cell = true };
		self.list = self.list or {};
		if 0 == start_pos then
			self.list = {};
		end
		if 0 == self.list then
			self.do_cell_anim = true;
		end
		if 0 < #self.list then
			local m = self.list[#self.list];
			if true == m.flag_more_cell then
				table.remove(self.list, #self.list);
			end
		end
		for i = 1, #list do
			table.insert(self.list, list[i]);
		end
		if self.PAGE_SIZE == #list then
			table.insert(self.list, more_cell);
		end

		self:reload_data();
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_lguild;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			play_tap_3();
			local cell = args[3];
			local idx = cell:getIdx();
			local info = self.list[idx + 1];
			if true == info.flag_more_cell then
				return;
			end
			local cmd = 'guild ' .. info.gid;
			net_send(cmd);
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local info = self.list[idx + 1];
			if true == info.flag_more_cell then
				local items = {};
				local pos = cc.p(width/2, height/2);
				local size = cc.size(172, 52);
				local item = add_item_1(items, '更多', nil, 20, self.get_more, ANCHOR_CENTER_CENTER, pos, size);
				item:setTag(idx + 1);

				util.add_menu(cell, items, 1);
				return cell;
			end
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local level = info.glevel or 0;
			local gid = info.gid;
			local gname = info.gname or '';
			local sprite, path, pos, size, str, data2;

			gui_add_sprite_on_cell(cell, data, 't_lv', GUI_LGUILD, ANCHOR_DOWN);
			path = util.get_path(FT_3);
			str = '' .. level;
			gui_add_labelbmf_on_cell(cell,data,str,path,'lv',GUI_LGUILD,ANCHOR_DOWN);

			str = gname;
			gui_add_label_on_cell(cell,data,str,24,'name',GUI_LGUILD,ANCHOR_DOWN);

			gui_add_sprite_on_cell(cell, data, 't_bg', GUI_LGUILD, ANCHOR_DOWN);
			gui_add_sprite_on_cell(cell, data, 't_master', GUI_LGUILD, ANCHOR_DOWN);
			str = info.master_name;
			gui_add_label_on_cell(cell,data,str,24,'master',GUI_LGUILD,ANCHOR_DOWN);
			gui_add_sprite_on_cell(cell, data, 't_num', GUI_LGUILD, ANCHOR_DOWN);
			path = util.get_path(FT_1);
			str = tonumber(info.total_member) or 0;
			gui_add_labelbmf_on_cell(cell,data,str,path,'num',GUI_LGUILD,ANCHOR_DOWN);

			local mygid = g_euser.gid or 0;
			local mygpos = g_euser.gpos or GUILD_POS_NONE;
			local key, cb;
			if mygid == 0 then
				cb = self.apply;
				key = "btn_apply";
			elseif gid == mygid and mygpos == GUILD_POS_APPLY then
				cb = self.cancel_apply;
				key = "btn_cancel";
			else
				return cell;
			end
			if nil ~= key then
				local items = {};
				local item;

				item, data2 = gui_add_item_on_cell(items, data, key, GUI_LGUILD, cb, ANCHOR_DOWN);
				item:setTag(idx + 1);

				util.add_menu(cell, items, data2.zorder);
			end
			if true == self.do_cell_anim then
				local delay = (idx%10)*0.1;
				keff_showup_1(cell, delay);
			end
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_lguild;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		self.do_cell_anim = false;

	end,
} -- layer_lguild end

layer_cguild = {
	name = 'layer_cguild',
	layer = nil,
	rect = nil,
	editbox = nil,
	gold = 0,
	crystal = 0,

	cleanup = function(self)
		self.layer = nil;
		self.rect = nil;
		self.editbox = nil;
		self.gold = 0;
		self.crystal = 0;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, gold, crystal)
		self:remove();

		self.gold = gold;
		self.crystal = crystal;
		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_CGUILD, self.handler, true);

		util.add_layer_color(self.layer, cc.c4b(0, 0, 0, 200));
		local bgsize = cc.size(540, 476);
		local bg,rect=init_bg_for_popview(self.layer,'创建公会',bgsize,self.back,true);
		self.rect = rect;

		local path = util.get_path('bg_156.png');
		local frect = cc.rect(0, 0, 64, 64); -- fullrect
		local irect = cc.rect(30, 30, 4, 4); -- insetrect
		local size = cc.size(467, 260); -- realsize
		local pos = cc.p(35, 132);
		util.add_scale9sprite(bg, path, pos, ANCHOR_LEFT_DOWN, frect, irect, size, 15); 

		size = cc.size(300, 71);
		pos = cc.p(122, 282);
		local tip = '请输入公会名称';
		self.editbox = add_editbox_1(bg, pos, size, tip, 20,self.editbox_handler);

		pos = cc.p(122, 215);
		size = cc.size(137, 40);
		tip = '所需费用:';
		util.add_labelttf(bg, tip, nil, 25, pos, cc.c4b(240, 240, 203, 255), ANCHOR_LEFT_DOWN, 20, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos = cc.p(279, 215);
		add_icon_gold(bg, pos, ANCHOR_LEFT_DOWN, 20);

		pos = cc.p(314, 215);
		gold = gold or 0;
		add_font_1(bg, gold, pos, ANCHOR_LEFT_DOWN, 20);

		local items = {};

		add_item_4(items, '创建', nil, 30, self.confirm_create, ANCHOR_CENTER_DOWN, cc.p(bgsize.width/2, 44));
		
		util.add_menu(bg, items, 50);

		return self.layer, self.name;
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_cguild;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
		elseif eventname == "changed" then
		end

	end,

	confirm_create = function()
		local self = layer_cguild;
		local str = self.editbox:getText();
		str = util.space_(str);
		if 0 == string.len(str) then
			show_msg('起个名字先吧');
			return;
		end
		self:back();
		local cmd = 'cguild ' .. str;
		net_send(cmd);
	end,

	back = function()
		local self = layer_cguild;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_cguild;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,

} -- layer_cguild end

layer_guild = {
	name = 'layer_guild',
	layer = nil,
	guild = nil,
	edit_rect = nil,
	editbox = nil,
	label_notice = nil,
	levelup_guild_gold = nil,
	guild_gold = nil,

	cleanup = function(self)
		self.layer = nil;
		self.guild = nil;
		self.edit_rect = nil;
		self.editbox = nil;
		self.label_notice = nil;
		self.levelup_guild_gold = nil;
		self.guild_gold = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, info)
		self:remove();
		
		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_GUILD, self.handler, true);

		local note = info.notice;
		self.guild = info;

		local offsetheight = init_bg_full(self.layer, GUI_GUILD, self.back);
		local sprite, data, pos, size, str, path;
		sprite,data = gui_add_sprite(self.layer,'outframe',GUI_PLAYERINFO,ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));
		sprite,data = gui_add_sprite(self.layer,'bg_stone',GUI_PLAYERINFO,ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));
		sprite, data = gui_add_sprite(self.layer, 'bg_note', GUI_GUILD, ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));
		gui_add_sprite(self.layer, 't_lv', GUI_GUILD, ANCHOR_UP);
		path = util.get_path(FT_3);
		str = info.glevel .. '';
		gui_add_labelbmf(self.layer, str, path, 'lv', GUI_GUILD, ANCHOR_UP);
		str = info.gname;
		gui_add_label_ali(self.layer, str, 25, 'gname', GUI_GUILD, ANCHOR_UP, cc.TEXT_ALIGNMENT_CENTER);

		self.label_notice, data = gui_add_label_ali(self.layer, note, 30, 'note', GUI_GUILD, ANCHOR_DOWN, cc.TEXT_ALIGNMENT_CENTER, nil, 0, offsetheight);
		self.label_notice:setVerticalAlignment(cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
		if info.gid == g_euser.gid then
			if info.gid == g_euser.eid then
				local color = cc.c3b(data.r, data.g, data.b);
				self.edit_rect = { x1 = data.x, x2 = data.x + data.width,
								   y1 = data.y,  y2 = data.y + data.height }; 
				self.editbox = util.add_editbox_blank(self.layer, 
					cc.size(data.width, data.height), ANCHOR_LEFT_DOWN, 
					cc.p(data.x, data.y), util.f_default, 22, color, 
					cc.EDITBOX_INPUT_MODE_SINGLELINE, cc.KEYBOARD_RETURNTYPE_DONE,
					nil,self.editbox_handler, 100, '', color, data.zorder);
				self.editbox:setText(note);
				self.editbox:setVisible(false);
			end
		end

		gui_add_sprite(self.layer, 'bg_master', GUI_GUILD, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 'bg_num', GUI_GUILD, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 'bg_fund', GUI_GUILD, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 't_master', GUI_GUILD, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 't_num', GUI_GUILD, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 't_fund', GUI_GUILD, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 'gold', GUI_GUILD, ANCHOR_DOWN);
		gui_add_sprite(self.layer, 'crystal', GUI_GUILD, ANCHOR_DOWN);
		str = info.master_alias or '';
		gui_add_label(self.layer, str, 22, 'master', GUI_GUILD, ANCHOR_DOWN);
		path = util.get_path(FT_1);
		str = info.total_member or 0;
		str = str .. '/' .. (info.max_member or 0);
		gui_add_labelbmf(self.layer, str, path, 'num', GUI_GUILD, ANCHOR_DOWN);
		self.guild_gold = info.gold or 0;
		str = self.guild_gold;
		gui_add_labelbmf(self.layer, str, path, 'n_gold', GUI_GUILD, ANCHOR_DOWN);

		str = info.crystal or 0;
		gui_add_labelbmf(self.layer, str, path,'n_crystal',GUI_GUILD,ANCHOR_DOWN);


		if info.gid == g_euser.gid and g_euser.gpos ~= GUILD_POS_APPLY then
			local items = {};
			local item;

			item, data = gui_add_item(items, 'btn_list', GUI_GUILD, self.to_lguild, ANCHOR_DOWN);
			gui_add_stroke_ali_on_cell(item,data,"公会列表",25,'btn_list',GUI_GUILD, ANCHOR_DOWN, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);

			item, data = gui_add_item(items, 'btn_member', GUI_GUILD, self.action_guild, ANCHOR_DOWN);
			gui_add_stroke_ali_on_cell(item,data,"成员",25,'btn_member',GUI_GUILD, ANCHOR_DOWN, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
			item:setTag(1);

			item, data = gui_add_item(items, 'btn_stock', GUI_GUILD, self.action_guild, ANCHOR_DOWN);
			gui_add_stroke_ali_on_cell(item,data,"股份",25,'btn_stock',GUI_GUILD, ANCHOR_DOWN, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
			item:setTag(3);

			item, data = gui_add_item(items, 'btn_invest', GUI_GUILD, self.action_guild, ANCHOR_DOWN);
			gui_add_stroke_ali_on_cell(item,data,"投资",25,'btn_invest',GUI_GUILD, ANCHOR_DOWN, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
			item:setTag(4);

			--item, data = gui_add_item(items, 'btn_welfare', GUI_GUILD, self.action_guild, ANCHOR_DOWN);
			--gui_add_text_on_sprite(item, "福利", 't_welfare', GUI_GUILD, ANCHOR_DOWN, 30);
			--item:setTag(5);

			if info.gid == g_euser.eid then
				item, data = gui_add_item(items, 'btn_dismiss', GUI_GUILD, self.action_guild, ANCHOR_DOWN);
				gui_add_stroke_ali_on_cell(item,data,"解散",25,'btn_dismiss',GUI_GUILD, ANCHOR_DOWN, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
				item:setTag(6);

				item, data = gui_add_item(items, 'btn_apply', GUI_GUILD, self.action_guild, ANCHOR_DOWN);
				gui_add_stroke_ali_on_cell(item,data,"审批",25,'btn_apply',GUI_GUILD, ANCHOR_DOWN, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
				item:setTag(2);

				item, data = gui_add_item(items, 'btn_upgrade', GUI_GUILD, self.action_guild, ANCHOR_DOWN);
				gui_add_stroke_ali_on_cell(item,data,"工会升级",25,'btn_upgrade',GUI_GUILD, ANCHOR_DOWN, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
				item:setTag(7);
			
			elseif g_euser.gpos == GUILD_POS_SENIOR then
				item, data = gui_add_item(items, 'btn_apply', GUI_GUILD, self.action_guild, ANCHOR_DOWN);
				gui_add_stroke_ali_on_cell(item,data,"审批",25,'btn_apply',GUI_GUILD, ANCHOR_DOWN, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
				item:setTag(2);

			else
				item, data = gui_add_item(items, 'btn_dismiss', GUI_GUILD, self.action_guild, ANCHOR_DOWN);
				gui_add_stroke_ali_on_cell(item,data,"退出",25,'btn_dismiss',GUI_GUILD, ANCHOR_DOWN, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
				item:setTag(6);
			end

			util.add_menu(self.layer, items, data.zorder);
		end


		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		local self = layer_guild;
		if self.guild.gid ~= g_euser.gid or g_euser.gpos == GUILD_POS_APPLY then
			g_scene:lguild();
			return;
		end
		g_scene:map();
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_guild;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
			local str = edit:getText();
			str = util.space_(str);
			edit:setText(str);
			edit:setVisible(false);
			self.label_notice:setString(str);
			self.label_notice:setVisible(true);
			local cmd = 'guild ' .. g_euser.eid .. ' ' .. str;
			net_send(cmd);
		elseif eventname == "changed" then
		end
	end,

	action_guild = function(...)
		play_tap_1();
		local self = layer_guild;
		local args = {...};
		local index = args[2]:getTag();
		if 1 == index then -- member
			g_scene:lmember();
			return;
		elseif 2 == index then -- approve
			g_scene:lapply();
			return;
		elseif 3 == index then -- stock
			g_scene:lstock();
			return;
		elseif 4 == index then -- invest
			g_scene:invest();
			return;
		elseif 5 == index then -- welfare
			--g_scene:welfare();
			return;
		elseif 6 == index then -- quit/dismiss
			local gid = tonumber(self.guild.gid);
			local eid = tonumber(g_euser.eid);
			local tip, cb;
			if gid == eid then
				tip = "是否解散公会？";
				cb = self.dismiss;
			else
				tip = "是否退出公会？";
				cb = self.leave_guild;
			end
			g_scene:add_layer(ZORDER_LAYER_TIP,layer_tip:create(tip, cb));
			return;
		elseif 7 == index then
			self.levelup_guild_gold = 0;
			local gid = tonumber(self.guild.gid);
			local cmd = 'glv ' .. gid;
			net_send(cmd);
		--local tip = string.format("确定要用%s购买第%d个卡槽吗？", money, sid);
		--g_scene:add_layer(ZORDER_LAYER_TIP,layer_tip:create(tip, cb));
			return;
		end
	end,

	ask_levelup_guild = function(self, info)
		self.levelup_guild_gold = info.levelup_gold;
		g_scene:add_layer(ZORDER_LAYER_TIP,layer_guildup:create(info, self.cb_levelup_guild));
	end,

	cb_levelup_guild = function()
		local self = layer_guild;
		if nil == self.guild_gold or nil == self.levelup_guild_gold then
			return;
		end
		if self.guild_gold < self.levelup_guild_gold then
			show_err("公会资金不足");
			return;
		end
		net_send('glevelup');
	end,

	to_lguild = function()
		play_tap_1();
		g_scene:lguild();
	end,

	-- tag 1->confirm 0->cancel
	dismiss = function(tag)
		if 0 == tag then
			return;
		end
		local self = layer_guild;
		local gid = self.guild.gid;
		if nil == gid then
			return;
		end
		local cmd = 'dguild ' .. gid;
		net_send(cmd);
	end,

	leave_guild = function(tag)
		if 0 == tag then
			return;
		end
		local cmd = 'gquit';
		net_send(cmd);
	end,

	handler = function(event, x, y)
		local self = layer_guild;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			g_scene:map();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local t = self.edit_rect;
		if nil ~= t and x > t.x1 and x < t.x2 and y > t.y1 and y < t.y2 then
			self.label_notice:setVisible(false);
			self.editbox:setVisible(true);
			local str = self.editbox:getText();
			self.editbox:sendActionsForControlEvents(cc.CONTROL_EVENTTYPE_TOUCH_UP_INSIDE);
			return;
		end
	end,

} -- layer_guild end

layer_welfare = {
	name = 'layer_welfare',
	layer = nil,
	l_fund = nil,
	l_point = nil,
	l_gold = nil,
	btn_get = nil,

	cleanup = function(self)
		self.layer = nil;
		self.label_guild = nil;
		self.label_my = nil;
		self.label_bonus = nil;
		self.btn_get = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();
		
		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_WELFARE, self.handler, true);

		local sprite, fullpath, pos, size, data;
		local tvh = suit_scale_big_frame(self.layer, GUI_WELFARE, self.back);
		add_big_frame_title(self.layer, '福利', GUI_WELFARE, ANCHOR_CENTER);

		gui_add_sprite_tip(self.layer,'title_reward',GUI_WELFARE,ANCHOR_CENTER);
		sprite = gui_add_sprite(self.layer,'bg_reward',GUI_WELFARE,ANCHOR_CENTER);
		sprite=gui_add_sprite_tip(self.layer,'t_fund',GUI_WELFARE,ANCHOR_CENTER);
		sprite=gui_add_sprite_tip(self.layer,'t_point',GUI_WELFARE,ANCHOR_CENTER);
		sprite=gui_add_sprite_tip(self.layer,'t_gold',GUI_WELFARE,ANCHOR_CENTER);
		sprite = gui_add_sprite(self.layer,'bg_btn',GUI_WELFARE,ANCHOR_CENTER);
		sprite = gui_add_sprite(self.layer,'tip',GUI_WELFARE,ANCHOR_CENTER);

		fullpath = util.get_fullpath(F_FONT, FNT_1);
		data = gui_get_data('num_fund', GUI_WELFARE, ANCHOR_CENTER);
		pos = cc.p(data.x + data.width/2, data.y);
		self.l_fund = util.add_labelbmf(self.layer, str, fullpath, pos, ANCHOR_CENTER_DOWN, data.zorder);

		data = gui_get_data('num_point', GUI_WELFARE, ANCHOR_CENTER);
		pos = cc.p(data.x + data.width/2, data.y);
		self.l_point = util.add_labelbmf(self.layer, str, fullpath, pos, ANCHOR_CENTER_DOWN, data.zorder);

		data = gui_get_data('num_gold', GUI_WELFARE, ANCHOR_CENTER);
		pos = cc.p(data.x + data.width/2, data.y);
		self.l_gold = util.add_labelbmf(self.layer, str, fullpath, pos, ANCHOR_CENTER_DOWN, data.zorder);

		data = gui_get_data('tip_area', GUI_WELFARE, ANCHOR_CENTER);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height);
		util.add_labelttf(self.layer, t_lang("TIP_WELFARE"), nil, 20, pos, util.c_black, ANCHOR_LEFT_DOWN, data.zorder, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_TOP);

		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn', GUI_WELFARE, self.get_bonus, ANCHOR_CENTER);
		item:setVisible(false);
		self.btn_get = item;

		util.add_menu(self.layer, items, data.zorder);

		return self.layer, self.name;
	end,

	set_data = function(self, info)
		local guild_gold = info.guild_gold or 0;
		local gshare = (info.gshare or 0) * 100;
		local bonus_gold = info.bonus_gold or 0;
		local ltime = info.last_bonus_time or os.time();
		local t_offset = get_hour_offset(os.time(), ltime);

		self.l_fund:setString(guild_gold);
		self.l_point:setString(string.format("%d%%", gshare));
		self.l_gold:setString(bonus_gold);
		if 24 < t_offset then
			self.btn_get:setVisible(true);
		else
			self.btn_get:setVisible(false);
		end
	end,

	get_bonus = function()
		play_tap_1();
		local self = layer_welfare;
		local cmd = 'gbonus 1';
		net_send(cmd);
	end,

	back = function()
		play_tap_1();
		g_scene:guild();
	end,

	handler = function(event, x, y)
		local self = layer_welfare;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			g_scene:guild();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_welfare end

layer_lmember = {
	name = 'layer_lmember',
	PAGE_SIZE = 15,
	layer = nil,
	list = nil,
	editbox = nil,
	tableview = nil,
	bar = nil,
	tap = nil,
	cwidth = nil,
	cheight = nil,
	data_cell = nil,
	editbox = nil,
	is_in_search = nil,
	do_cell_anim = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.editbox = nil;
		self.tableview = nil;
		self.bar = nil;
		self.tap = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.data_cell = nil;
		self.editbox = nil;
		self.is_in_search = nil;
		self.do_cell_anim = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();
		
		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_LMEMBER, self.handler, true);

		self.list = {};
		local offsetheight = init_bg_full(self.layer, GUI_MEMBER, self.back);
		local sprite, data, pos, size, path;
		sprite,data = gui_add_sprite(self.layer,'outframe',GUI_MEMBER,ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));
		sprite, data = gui_add_sprite(self.layer,'fade_bottom',GUI_MEMBER,ANCHOR_DOWN);
		sprite:setScaleX(data.width/sprite:getContentSize().width);

		gui_add_sprite(self.layer, 'bg_search', GUI_MEMBER, ANCHOR_UP);
		self.editbox, data = gui_add_editbox(self.layer, 't_search', GUI_MEMBER, ANCHOR_UP, 22, self.editbox_handler, 10, '请输入成员名称或ID...');

		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn_search', GUI_MEMBER, self.search, ANCHOR_UP);

		util.add_menu(self.layer, items, data.zorder);

		data = gui_get_data('cell', GUI_MEMBER, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height+10;
		data = gui_get_data('table', GUI_MEMBER, ANCHOR_DOWN);
		size = cc.size(data.width, data.height+offsetheight);
		pos = cc.p(data.x, data.y);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	set_list = function(self, list, start_pos)
		list = list or {};
		local more_cell = { flag_more_cell = true };
		self.list = self.list or {};
		if 0 == #self.list then
			self.do_cell_anim = true;
		end
		if 0 < #self.list then
			local m = self.list[#self.list];
			if true == m.flag_more_cell then
				table.remove(self.list, #self.list);
			end
		end
		for i = 1, #list do
			table.insert(self.list, list[i]);
		end
		if self.PAGE_SIZE == #list then
			table.insert(self.list, more_cell);
		end

		self:reload_data();
	end,

	add_list = function(self, list, start_pos)
		if true == self.is_in_search then
			self.list = {};
		end
		self.is_in_search = nil;
		self:set_list(list, start_pos);
	end,

	add_search_list = function(self, list, start_pos)
		if true ~= self.is_in_search then
			self.list = {};
		end
		self.is_in_search = true;
		self:set_list(list, start_pos);
	end,

	reload_data = function(self)
		self.tableview:reloadData();
	end,

	get_more = function()
		local self = layer_lmember;
		local len = #(self.list or {});
		if self.list[len].flag_more_cell == true then
			len = len - 1;
		end
		if len < 0 then len = 0; end
		local key = "glist";
		if self.is_in_search then
			key = "gsearch";
		end
		local cmd = string.format("%s 1 %d %d", key, len, self.PAGE_SIZE);
		net_send(cmd);
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_lmember;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
			local str = edit:getText();
			str = util.space_(str);
			edit:setText(str);
		elseif eventname == "changed" then
		end
	end,

	search = function()
		play_tap_1();
		local self = layer_lmember;
		local key = self.editbox:getText();
		if string.len(key) == 0 then
			if true ~= self.is_in_search then
				return;
			end
			local cmd = 'glist 1 0 ' .. layer_lmember.PAGE_SIZE .. ' ' .. key;
			net_send(cmd);
			return;
		end
		self.list = {};
		local cmd = 'gsearch 1 0 ' .. layer_lmember.PAGE_SIZE .. ' ' .. key;
		net_send(cmd);
	end,

	back = function()
		play_tap_1();
		g_scene:guild();
	end,

	remove_member = function(self, eid)
		self.list = self.list or {};
		local index = 0;
		for i = 1, #self.list do
			local info = self.list[i];
			local id = info.eid;
			if id == eid then
				index = i;
				break;
			end
		end
		if 0 < index then
			table.remove(self.list, index);
		end
		self:reload_data();
	end,

	update_pos = function(self, eid, npos)
		local index = 0;
		local tindex = 1;
		if 1 < #self.list then
			tindex = 2;
		end
		local data = nil;
		for i = 1, #self.list do
			local info = self.list[i];
			if info.eid == eid then
				index = i;
				data = info;
				data.gpos = npos;
				break;
			end
		end
		if 0 ~= index then
			table.remove(self.list, index);
			tindex = index;
		end
		if nil ~= data then
			table.insert(self.list, tindex, data);
		end
		self:reload_data();
	end,

	action = function(...)
		play_tap_1();
		local self = layer_lmember;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		if nil == info then
			return;
		end
		g_scene:add_layer(ZORDER_LAYER_AGUILD, layer_aguild:create(info));
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_lmember;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			play_tap_1();
			local info = self.list[idx+1];
			if nil == info then
				return;
			end
			if true == info.flag_more_cell then
				return;
			end
			local eid = info.eid;
			if eid == g_euser.eid then return; end
			local cmd = 'fsta ' .. eid;
			net_send(cmd);
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local info = self.list[idx + 1];
			if true == info.flag_more_cell then
				local items = {};
				local pos = cc.p(width/2, height/2);
				local size = cc.size(172, 52);
				local item = add_item_1(items, '更多', nil, 20, self.get_more, ANCHOR_CENTER_CENTER, pos, size);
				item:setTag(idx + 1);

				util.add_menu(cell, items, 1);
				return cell;
			end
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local icon = info.icon;
			local alias = info.alias;
			local gpos = info.gpos;
			local last_login = info.last_login or 0;
			local level = info.level;
			local data2, sprite, path, pos, size, str;

			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'icon', GUI_MEMBER, ANCHOR_DOWN);
			size = sprite:getContentSize();
			path = get_icon_path(icon);
			pos = cc.p(size.width/2, size.height/2);
			sprite = util.add_sprite(sprite, path,pos,ANCHOR_CENTER_CENTER,-1);
			sprite:setScale((size.width-6)/sprite:getContentSize().width);

			gui_add_label_on_cell(cell,data,alias,24,'alias',GUI_MEMBER,ANCHOR_DOWN);

			if last_login > 0 then
				local t = os.date("*t", last_login);
				path = util.get_path(FT_1);
				str = string.format("%d/%02d/%02d", t.year, t.month, t.day);
				gui_add_labelbmf_on_cell(cell,data,str,path,'lastlogin',GUI_MEMBER,ANCHOR_DOWN);
				str = "最后登录时间:";
			else
				str = "在线";
			end
			gui_add_label_on_cell(cell,data,str,24,'t_lastlogin',GUI_MEMBER,ANCHOR_DOWN);
			gui_add_sprite_on_cell(cell, data, 't_lv', GUI_MEMBER, ANCHOR_DOWN);
			path = util.get_path(FT_3);
			str = '' .. level;
			gui_add_labelbmf_on_cell(cell,data,str,path,'lv',GUI_MEMBER,ANCHOR_DOWN);

			--str = get_guild_title(gpos);
			--gui_add_stroke_on_cell(cell,data,str,24,'t_pos',GUI_MEMBER,ANCHOR_DOWN);
			gui_add_sprite_on_cell(cell,data,'bg_pos',GUI_MEMBER,ANCHOR_DOWN);
			if gpos == GUILD_POS_MASTER then
				-- '会长';
				gui_add_sprite_on_cell(cell,data,'master',GUI_MEMBER,ANCHOR_DOWN);
			elseif gpos == GUILD_POS_SENIOR then
				-- '副会长';
				gui_add_sprite_on_cell(cell,data,'senior',GUI_MEMBER,ANCHOR_DOWN);
			elseif gpos == GUILD_POS_MEMBER then
				-- '会员';
				gui_add_sprite_on_cell(cell,data,'member',GUI_MEMBER,ANCHOR_DOWN);
			--elseif gpos == GUILD_POS_APPLY then
				-- '申请者';
			end

			if info.eid ~= g_euser.eid then
				local items = {};
				local item;

				item, data2 = gui_add_item_on_cell(items, data, 'btn_action', GUI_MEMBER, self.action, ANCHOR_DOWN);
				item:setTag(idx + 1);

				util.add_menu(cell, items, data2.zorder);
			end
			if true == self.do_cell_anim then
				local delay = (idx%10)*0.1;
				keff_showup_1(cell, delay);
			end
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_lmember;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			g_scene:guild();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		self.do_cell_anim = false;

	end,
} -- layer_lmember end

layer_aguild = { 
	name = 'layer_aguild',
	layer = nil,
	info = nil,
	rect = nil,
	kick_eid = nil,

	cleanup = function(self)
		self.layer = nil;
		self.info = nil;
		self.rect = nil;
		self.kick_eid = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, info)
		self:remove();

		self.info = info;
		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_AGUILD, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 200));
		local path = util.get_path('bg_121.png');
		local frect = cc.rect(0, 0, 404, 260); -- fullrect
		local irect = cc.rect(200, 128, 4, 4); -- insetrect
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local bgsize = cc.size(wfix(540), wfix(288));
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, bgsize, 10); 
		self.rect = {
			x1 = pos.x-bgsize.width/2,  x2 = pos.x+bgsize.width/2,
			y1 = pos.y-bgsize.height/2, y2 = pos.y+bgsize.height/2,
		};

		path = util.get_path('bg_156.png');
		frect = cc.rect(0, 0, 64, 64); -- fullrect
		irect = cc.rect(30, 30, 4, 4); -- insetrect
		local barsize = cc.size(491, 96); -- realsize
		pos = cc.p(26, 158);
		local bar = util.add_scale9sprite(bg, path, pos, ANCHOR_LEFT_DOWN, frect, irect, barsize, 50); 

		path = util.get_path('bg_131.png');
		pos = cc.p(100, 178);
		local icon = util.add_sprite(bg, path, pos, ANCHOR_LEFT_DOWN, 60);
		local size = icon:getContentSize();
		path = get_icon_path(info.icon);
		pos = cc.p(size.width/2, size.height/2);
		local pic = util.add_sprite(icon, path, pos, ANCHOR_CENTER_CENTER, -1);
		pic:setScale((size.width-6)/pic:getContentSize().width);

		local str = info.alias or '';
		pos = cc.p(182, 180);
		local label = util.add_labelttf(bg, str, nil, 30, pos, cc.c4b(240, 240, 203, 255), ANCHOR_LEFT_DOWN, 60);

		local items = {};

		if g_euser.gpos == GUILD_POS_MASTER then
			--table.insert(item_list, { title = '职位变更', cb = self.cpos });
			--table.insert(item_list, { title = '开除', cb = self.kick });
			local p = cc.p(66, 49);
			str = "职位变更";
			add_item_3(items, str, nil, 30, self.cpos, ANCHOR_LEFT_DOWN, p);
			--p = cc.p(181, 49);
			--str = "副会长";
			--add_item_2(items, str, nil, 30, self.kick, ANCHOR_LEFT_DOWN, p);
			p = cc.p(299, 49);
			str = "开除";
			add_item_3(items, str, nil, 30, self.kick, ANCHOR_LEFT_DOWN, p);
		end

		pos = cc.p(474, 213);
		add_item_close(items, pos, ANCHOR_LEFT_DOWN, self.back);

		util.add_menu(bg, items, 70);

		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		local self = layer_aguild;
		self:remove();
	end,

	detail = function()
		play_tap_1();
		local self = layer_aguild;
		local info = self.info;
		if nil == info then
			return;
		end
		local eid = info.eid;
		local cmd = 'fsta ' .. eid;
		net_send(cmd);
		self:remove();
	end,

	cpos = function()
		play_tap_1();
		local self = layer_aguild;
		local info = self.info;
		g_scene:add_layer(ZORDER_LAYER_CPOS, layer_cpos:create(info, self.cb_change_pos));
	end,

	cb_change_pos = function(info, index)
		local self = layer_aguild;
		local eid = info.eid;
		local pos = index;
		local cmd = string.format("gpos %d %d", eid, pos);
		net_send(cmd);
		self:remove();
	end,

	kick = function()
		play_tap_1();
		local self = layer_aguild;
		local info = self.info;
		if nil == info then
			return;
		end
		self.kick_eid = info.eid;
		local s = '是否要开除' .. info.alias .. '?';
		g_scene:add_layer(ZORDER_LAYER_TIP,layer_tip:create(s,self.cb_kick));
	end,

	-- tag 1->confirm 0->cancel
	cb_kick = function(tag)
		if 1 ~= tag then return; end
		local self = layer_aguild;
		local cmd = 'gquit ' .. self.kick_eid;
		net_send(cmd);
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_aguild;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,
} -- layer_aguild end

layer_cpos = { 
	name = 'layer_cpos',
	layer = nil,
	info = nil,
	cb = nil,
	t_member = nil,
	t_senior = nil,

	cleanup = function(self)
		self.layer = nil;
		self.info = nil;
		self.cb = nil;
		self.t_member = nil;
		self.t_senior = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, info, cb)
		self:remove();

		self.info = info;
		self.cb = cb;
		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_CPOS, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 10));
		local path = util.get_path('bg_121.png');
		local frect = cc.rect(0, 0, 404, 260); -- fullrect
		local irect = cc.rect(200, 128, 4, 4); -- insetrect
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local bgsize = cc.size(wfix(540), wfix(288));
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, bgsize, 10); 
		self.rect = {
			x1 = pos.x-bgsize.width/2,  x2 = pos.x+bgsize.width/2,
			y1 = pos.y-bgsize.height/2, y2 = pos.y+bgsize.height/2,
		};

		path = util.get_path('bg_156.png');
		frect = cc.rect(0, 0, 64, 64); -- fullrect
		irect = cc.rect(30, 30, 4, 4); -- insetrect
		local barsize = cc.size(491, 96); -- realsize
		pos = cc.p(26, 158);
		local bar = util.add_scale9sprite(bg, path, pos, ANCHOR_LEFT_DOWN, frect, irect, barsize, 50); 

		path = util.get_path('bg_131.png');
		pos = cc.p(100, 178);
		local icon = util.add_sprite(bg, path, pos, ANCHOR_LEFT_DOWN, 60);
		local size = icon:getContentSize();
		path = get_icon_path(info.icon);
		pos = cc.p(size.width/2, size.height/2);
		local pic = util.add_sprite(icon, path, pos, ANCHOR_CENTER_CENTER, -1);
		pic:setScale((size.width-6)/pic:getContentSize().width);

		local str = info.alias or '';
		pos = cc.p(182, 180);
		local label = util.add_labelttf(bg, str, nil, 30, pos, cc.c4b(240, 240, 203, 255), ANCHOR_LEFT_DOWN, 60);

		local items = {};

		if info.gpos == GUILD_POS_MEMBER then
			local p = cc.p(181, 49);
			str = "副会长";
			local item=add_item_3(items, str, nil, 30, self.do_change, ANCHOR_LEFT_DOWN, p);
			item:setTag(GUILD_POS_SENIOR);
		elseif info.gpos == GUILD_POS_SENIOR then
			local p = cc.p(181, 49);
			str = "成员";
			local item=add_item_3(items, str, nil, 30, self.do_change, ANCHOR_LEFT_DOWN, p);
			item:setTag(GUILD_POS_MEMBER);
		end

		pos = cc.p(474, 213);
		add_item_close(items, pos, ANCHOR_LEFT_DOWN, self.back);

		util.add_menu(bg, items, 70);

		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		local self = layer_cpos;
		self:remove();
	end,

	change_pos = function(...)
		play_tap_3();
		local self = layer_cpos;
		local args = {...};
		local item = args[2];
		-- toggle:getSelectedIndex()  0 : off     1 : on
		local t1, t2;
		if item == self.t_member then
			t1 = self.t_member;
			t2 = self.t_senior;
		else
			t1 = self.t_senior;
			t2 = self.t_member;
		end
		local index = t1:getSelectedIndex();
		if 1 == index then
			t2:setSelectedIndex(0);
		else
			t1:setSelectedIndex(1);
			t2:setSelectedIndex(0);
		end
	end,

	confirm = function()
		play_tap_1();
		local self = layer_cpos;
		local item = nil;
		local list = { self.t_member, self.t_senior };
		for i = 1, #list do
			local t = list[i];
			local index = t:getSelectedIndex();
			if 1 == index then
				item = t;
				break;
			end
		end
		if nil == item then
			return;
		end
		local opos = self.info.gpos;
		local pos = item:getTag();
		local info = self.info;
		local cb = self.cb;
		self.back();
		if opos == pos or nil == cb then
			return;
		end
		cb(info, pos);
	end,

	do_change = function(...)
		play_tap_1();
		local self = layer_cpos;
		local args = {...};
		local pos = args[2]:getTag();
		local opos = self.info.gpos;
		local info = self.info;
		local cb = self.cb;
		self.back();
		if opos == pos or nil == cb then
			return;
		end
		cb(info, pos);
	end,

	handler = function(event, x, y)
		local self = layer_cpos;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,
} -- layer_cpos end

layer_lapply = {
	name = 'layer_lapply',
	PAGE_SIZE = 15,
	layer = nil,
	list = nil,
	editbox = nil,
	tableview = nil,
	bar = nil,
	tap = nil,
	cwidth = nil,
	cheight = nil,
	data_cell = nil,
	is_in_search = nil,
	do_cell_anim = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.editbox = nil;
		self.tableview = nil;
		self.bar = nil;
		self.tap = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.data_cell = nil;
		self.is_in_search = nil;
		self.do_cell_anim = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();
		
		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_LAPPLY, self.handler, true);

		self.list = {};
		local offsetheight = init_bg_full(self.layer, GUI_APPROVE, self.back);
		local sprite, data, pos, size, path;
		sprite,data = gui_add_sprite(self.layer,'outframe',GUI_APPROVE,ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));
		sprite, data = gui_add_sprite(self.layer,'fade_bottom',GUI_APPROVE,ANCHOR_DOWN);
		sprite:setScaleX(data.width/sprite:getContentSize().width);

		gui_add_sprite(self.layer, 'bg_search', GUI_APPROVE, ANCHOR_UP);
		self.editbox, data = gui_add_editbox(self.layer, 't_search', GUI_APPROVE, ANCHOR_UP, 22, self.editbox_handler, 10, '请输入申请者名称或ID...');

		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn_search', GUI_APPROVE, self.search, ANCHOR_UP);

		util.add_menu(self.layer, items, data.zorder);

		data = gui_get_data('cell', GUI_APPROVE, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height+10;
		data = gui_get_data('table', GUI_APPROVE, ANCHOR_DOWN);
		size = cc.size(data.width, data.height+offsetheight);
		pos = cc.p(data.x, data.y);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	set_list = function(self, list, start_pos)
		list = list or {};
		local more_cell = { flag_more_cell = true };
		self.list = self.list or {};
		if 0 == #self.list then
			self.do_cell_anim = true;
		end
		if 0 < #self.list then
			local m = self.list[#self.list];
			if true == m.flag_more_cell then
				table.remove(self.list, #self.list);
			end
		end
		for i = 1, #list do
			table.insert(self.list, list[i]);
		end
		if self.PAGE_SIZE == #list then
			table.insert(self.list, more_cell);
		end

		self:reload_data();
	end,

	add_list = function(self, list, start_pos)
		if true == self.is_in_search then
			self.list = {};
		end
		self.is_in_search = nil;
		self:set_list(list, start_pos);
	end,

	add_search_list = function(self, list, start_pos)
		if true ~= self.is_in_search then
			self.list = {};
		end
		self.is_in_search = true;
		self:set_list(list, start_pos);
	end,

	reload_data = function(self)
		self.tableview:reloadData();
	end,

	get_more = function()
		local self = layer_lapply;
		local len = #(self.list or {});
		if self.list[len].flag_more_cell == true then
			len = len - 1;
		end
		if len < 0 then len = 0; end
		local key = "glist";
		if self.is_in_search then
			key = "gsearch";
		end
		local cmd = string.format("%s 9 %d %d", key, len, self.PAGE_SIZE);
		net_send(cmd);
	end,

	back = function()
		play_tap_1();
		g_scene:guild();
	end,

	search = function()
		play_tap_1();
		local self = layer_lapply;
		local key = self.editbox:getText();
		if string.len(key) == 0 then
			if true ~= self.is_in_search then
				return;
			end
			local cmd = 'glist 9 0 ' .. layer_lmember.PAGE_SIZE .. ' ' .. key;
			net_send(cmd);
			return;
		end
		self.list = {};
		local cmd = 'gsearch 9 0 ' .. layer_lmember.PAGE_SIZE .. ' ' .. key;
		net_send(cmd);
	end,
	
	editbox_handler = function(eventname, psender)
		local self = layer_lapply;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
		elseif eventname == "changed" then
		end
	end,

	-- deprecated
	--[[
	action = function(...)
		play_tap_1();
		local self = layer_lapply;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		if nil == info then
			return;
		end
		g_scene:add_layer(ZORDER_LAYER_APPROVE, layer_approve:create(info));
	end,
	]]--

	remove_apply = function(self, eid)
		self.list = self.list or {};
		local index = 0;
		for i = 1, #self.list do
			local info = self.list[i];
			local id = info.eid;
			if id == eid then
				index = i;
				break;
			end
		end
		if 0 < index then
			table.remove(self.list, index);
		end
		self:reload_data();
	end,

	approve = function(...)
		play_tap_1();
		local args = {...};
		local index = args[2]:getTag();
		local self = layer_lapply;
		local info = self.list[index];
		if nil == info then
			return;
		end
		local eid = info.eid;
		local cmd = 'gpos ' .. eid .. ' ' .. GUILD_POS_MEMBER;
		net_send(cmd);
	end,

	reject = function(...)
		play_tap_1();
		local args = {...};
		local index = args[2]:getTag();
		local self = layer_lapply;
		local info = self.list[index];
		if nil == info then
			return;
		end
		local eid = info.eid;
		local cmd = 'gquit ' .. eid;
		net_send(cmd);
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_lapply;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			play_tap_1();
			local info = self.list[idx+1];
			if nil == info then
				return;
			end
			if true == info.flag_more_cell then
				return;
			end
			local eid = info.eid;
			if eid == g_euser.eid then return; end
			local cmd = 'fsta ' .. eid;
			net_send(cmd);
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local info = self.list[idx + 1];
			if true == info.flag_more_cell then
				local items = {};
				local pos = cc.p(width/2, height/2);
				local size = cc.size(172, 52);
				local item = add_item_1(items, '更多', nil, 20, self.get_more, ANCHOR_CENTER_CENTER, pos, size);
				item:setTag(idx + 1);

				util.add_menu(cell, items, 1);
				return cell;
			end
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local icon = info.icon;
			local alias = info.alias;
			local gpos = info.gpos;
			local last_login = info.last_login or 0;
			local level = info.level;
			local data2, sprite, path, pos, size, str;

			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'icon', GUI_APPROVE, ANCHOR_DOWN);
			size = sprite:getContentSize();
			path = get_icon_path(icon);
			pos = cc.p(size.width/2, size.height/2);
			sprite = util.add_sprite(sprite, path,pos,ANCHOR_CENTER_CENTER,-1);
			sprite:setScale((size.width-6)/sprite:getContentSize().width);

			gui_add_sprite_on_cell(cell, data, 'bg_alias', GUI_APPROVE, ANCHOR_DOWN);
			gui_add_label_on_cell(cell,data,alias,28,'alias',GUI_APPROVE,ANCHOR_DOWN);

			gui_add_sprite_on_cell(cell, data, 't_lv', GUI_APPROVE, ANCHOR_DOWN);
			path = util.get_path(FT_3);
			str = '' .. level;
			gui_add_labelbmf_on_cell(cell,data,str,path,'lv',GUI_APPROVE,ANCHOR_DOWN);

			if info.eid ~= g_euser.eid then
				local items = {};
				local item;

				item, data2 = gui_add_item_on_cell(items, data, 'btn_approve', GUI_APPROVE, self.approve, ANCHOR_DOWN);
				util.add_stroke_to_sprite_by_data(item, data2, "同意", 26, 2);
				item:setTag(idx + 1);
				item, data2 = gui_add_item_on_cell(items, data, 'btn_reject', GUI_APPROVE, self.reject, ANCHOR_DOWN);
				util.add_stroke_to_sprite_by_data(item, data2, "拒绝", 26, 2);
				item:setTag(idx + 1);

				util.add_menu(cell, items, data2.zorder);
			end
			if true == self.do_cell_anim then
				local delay = (idx%10)*0.1;
				keff_showup_1(cell, delay);
			end
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_lapply;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			g_scene:guild();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		self.do_cell_anim = false;

	end,
} -- layer_lapply end

layer_approve = { 
	name = 'layer_approve',
	layer = nil,
	info = nil,

	cleanup = function(self)
		self.layer = nil;
		self.info = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, info)
		self:remove();

		self.info = info;
		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_APPROVE, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 200));
		local btn_height = 70;
		local item_list = {};
		if g_euser.eid ~= info.eid then
			table.insert(item_list, { title = '资料', cb = self.detail });
		end
		if (g_euser.gpos == GUILD_POS_MASTER or g_euser.gpos == GUILD_POS_SENIOR) and info.gpos == GUILD_POS_APPLY then
			table.insert(item_list, { title = '同意', cb = self.agree });
			table.insert(item_list, { title = '拒绝', cb = self.reject });
		end
		local path = util.get_path('pop_up.png');
		local frect = cc.rect(0, 0, 64, 64); -- fullrect
		local irect = cc.rect(30, 30, 4, 4); -- insetrect
		local height = 110 + (#item_list * (btn_height + 10));
		local bgsize = cc.size(wfix(400), height);--realsize
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, bgsize, 10); 
		self.rect = {
			x1 = pos.x-bgsize.width/2,  x2 = pos.x+bgsize.width/2,
			y1 = pos.y-bgsize.height/2, y2 = pos.y+bgsize.height/2,
		};

		path = util.get_path('popup_title.png');
		frect = cc.rect(0, 0, 64, 55); -- fullrect
		irect = cc.rect(30, 25, 4, 5); -- insetrect
		local barsize = cc.size(bgsize.width-50, 60); -- realsize
		pos = cc.p(bgsize.width/2, bgsize.height - 50);
		local bar = util.add_scale9sprite(bg, path, pos, ANCHOR_CENTER_CENTER, frect, irect, barsize, 10); 

		path = get_icon_path(info.icon);
		pos = cc.p(10, barsize.height/2);
		local icon = util.add_sprite(bar, path, pos, ANCHOR_LEFT_CENTER, 10);
		icon:setScale((barsize.height-10)/icon:getContentSize().height);

		local str = info.alias or '';
		local iwidth = icon:getContentSize().width * icon:getScaleX();
		pos = cc.p(pos.x + iwidth + 20, barsize.height/2);
		local label = util.add_labeloutline(bar, str, nil, 30, pos, util.c4b_black, util.c4b_white, 2, ANCHOR_LEFT_CENTER, 10);

		local items = {};

		local gap = btn_height + 5;
		for i = 1, #item_list do
			local l = item_list[i];
			local p = cc.p(bgsize.width/2, bgsize.height-150-gap*(i-1));
			local s = cc.size(bgsize.width - 70, btn_height);
			add_item_1(items, l.title, nil, 30, l.cb, ANCHOR_CENTER_CENTER, p, s);
		end

		pos = cc.p(bgsize.width-20, bgsize.height-20);
		add_item_close(items, pos, ANCHOR_CENTER_CENTER, self.back);

		util.add_menu(bg, items, 20);

		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		local self = layer_approve;
		self:remove();
	end,

	detail = function()
		play_tap_1();
		local self = layer_approve;
		local info = self.info;
		if nil == info then
			return;
		end
		local eid = info.eid;
		local cmd = 'fsta ' .. eid;
		net_send(cmd);
		self:remove();
	end,

	agree = function()
		play_tap_1();
		local self = layer_approve;
		local info = self.info;
		if nil == info then
			return;
		end
		local eid = info.eid;
		self.back();
		local cmd = 'gpos ' .. eid .. ' ' .. GUILD_POS_MEMBER;
		net_send(cmd);
	end,

	reject = function()
		play_tap_1();
		local self = layer_approve;
		local info = self.info;
		if nil == info then
			return;
		end
		local eid = info.eid;
		self.back();
		local cmd = 'gquit ' .. eid;
		net_send(cmd);
	end,

	handler = function(event, x, y)
		local self = layer_approve;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,
} -- layer_approve end

layer_lstock = {
	name = 'layer_lstock',
	PAGE_SIZE = 15,
	layer = nil,
	list = nil,
	editbox = nil,
	tableview = nil,
	bar = nil,
	tap = nil,
	cwidth = nil,
	cheight = nil,
	data_cell = nil,
	is_in_search = nil,
	do_cell_anim = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.editbox = nil;
		self.tableview = nil;
		self.bar = nil;
		self.tap = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.data_cell = nil;
		self.is_in_search = nil;
		self.do_cell_anim = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();
		
		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_LSTOCK, self.handler, true);

		self.list = {};
		local offsetheight = init_bg_full(self.layer, GUI_STOCK, self.back);
		local sprite, data, pos, size, path;
		sprite,data = gui_add_sprite(self.layer,'outframe',GUI_STOCK,ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));
		sprite, data = gui_add_sprite(self.layer,'fade_bottom',GUI_STOCK,ANCHOR_DOWN);
		sprite:setScaleX(data.width/sprite:getContentSize().width);

		gui_add_sprite(self.layer, 'bg_search', GUI_STOCK, ANCHOR_UP);
		self.editbox, data = gui_add_editbox(self.layer, 't_search', GUI_STOCK, ANCHOR_UP, 22, self.editbox_handler, 10, '请输入成员名称或ID...');

		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn_search', GUI_STOCK, self.search, ANCHOR_UP);

		util.add_menu(self.layer, items, data.zorder);

		data = gui_get_data('cell', GUI_STOCK, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height+10;
		data = gui_get_data('table', GUI_STOCK, ANCHOR_DOWN);
		size = cc.size(data.width, data.height+offsetheight);
		pos = cc.p(data.x, data.y);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		return self.layer, self.name;
	end,

	set_list = function(self, list, start_pos)
		list = list or {};
		local more_cell = { flag_more_cell = true };
		self.list = self.list or {};
		if 0 == #self.list then
			self.do_cell_anim = true;
		end
		if 0 < #self.list then
			local m = self.list[#self.list];
			if true == m.flag_more_cell then
				table.remove(self.list, #self.list);
			end
		end
		for i = 1, #list do
			table.insert(self.list, list[i]);
		end
		if self.PAGE_SIZE == #list then
			table.insert(self.list, more_cell);
		end

		self:reload_data();
	end,

	add_list = function(self, list, start_pos)
		if true == self.is_in_search then
			self.list = {};
		end
		self.is_in_search = nil;
		self:set_list(list, start_pos);
	end,

	add_search_list = function(self, list, start_pos)
		if true ~= self.is_in_search then
			self.list = {};
		end
		self.is_in_search = true;
		self:set_list(list, start_pos);
	end,

	reload_data = function(self)
		self.tableview:reloadData();
	end,

	get_more = function()
		local self = layer_lstock;
		local len = #(self.list or {});
		if self.list[len].flag_more_cell == true then
			len = len - 1;
		end
		if len < 0 then len = 0; end
		local cmd = string.format("glist 1 %d %d", len, self.PAGE_SIZE);
		net_send(cmd);
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_lstock;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
			local str = edit:getText();
			str = util.space_(str);
			edit:setText(str);
		elseif eventname == "changed" then
		end
	end,

	search = function()
		play_tap_1();
		local self = layer_lstock;
		local key = self.editbox:getText();
		if string.len(key) == 0 then
			if true ~= self.is_in_search then
				return;
			end
			local cmd = 'glist 1 0 ' .. layer_lstock.PAGE_SIZE .. ' ' .. key;
			net_send(cmd);
			return;
		end
		self.list = {};
		local cmd = 'gsearch 1 0 ' .. layer_lstock.PAGE_SIZE .. ' ' .. key;
		net_send(cmd);
	end,

	back = function()
		play_tap_1();
		g_scene:guild();
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_lstock;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			local cell = args[3];
			local idx = cell:getIdx();
			play_tap_1();
			local info = self.list[idx+1];
			if nil == info then
				return;
			end
			if true == info.flag_more_cell then
				return;
			end
			local eid = info.eid;
			if eid == g_euser.eid then return; end
			local cmd = 'fsta ' .. eid;
			net_send(cmd);
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local info = self.list[idx + 1];
			if true == info.flag_more_cell then
				local items = {};
				local pos = cc.p(width/2, height/2);
				local size = cc.size(172, 52);
				local item = add_item_1(items, '更多', nil, 20, self.get_more, ANCHOR_CENTER_CENTER, pos, size);
				item:setTag(idx + 1);

				util.add_menu(cell, items, 1);
				return cell;
			end
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local icon = info.icon;
			local alias = info.alias;
			local gshare = info.gshare or 0;
			local level = info.level;
			--gshare = string.format("%.2f%%", gshare*100);
			gshare = string.format("%.0f%%", gshare*100);
			local gpos = info.gpos;
			local last_login = info.last_login or 0;
			local level = info.level;
			local data2, sprite, path, pos, size, str;
			sprite, data2 = gui_add_sprite_on_cell(cell, data, 'icon', GUI_STOCK, ANCHOR_DOWN);
			size = sprite:getContentSize();
			path = get_icon_path(icon);
			pos = cc.p(size.width/2, size.height/2);
			sprite = util.add_sprite(sprite, path,pos,ANCHOR_CENTER_CENTER,-1);
			sprite:setScale((size.width-6)/sprite:getContentSize().width);

			gui_add_label_on_cell(cell,data,alias,24,'alias',GUI_STOCK,ANCHOR_DOWN);

			gui_add_sprite_on_cell(cell, data, 't_lv', GUI_STOCK, ANCHOR_DOWN);
			path = util.get_path(FT_3);
			str = '' .. level;
			gui_add_labelbmf_on_cell(cell,data,str,path,'lv',GUI_STOCK,ANCHOR_DOWN);

			gui_add_sprite_on_cell(cell,data,'bg_pos',GUI_STOCK,ANCHOR_DOWN);
			if gpos == GUILD_POS_MASTER then
				-- '会长';
				gui_add_sprite_on_cell(cell,data,'master',GUI_STOCK,ANCHOR_DOWN);
			elseif gpos == GUILD_POS_SENIOR then
				-- '副会长';
				gui_add_sprite_on_cell(cell,data,'senior',GUI_STOCK,ANCHOR_DOWN);
			elseif gpos == GUILD_POS_MEMBER then
				-- '会员';
				gui_add_sprite_on_cell(cell,data,'member',GUI_STOCK,ANCHOR_DOWN);
			--elseif gpos == GUILD_POS_APPLY then
				-- '申请者';
			end

			str = "股份:"
			gui_add_label_on_cell(cell,data,str,24,'t_stock', GUI_STOCK,ANCHOR_DOWN);
			path = util.get_path(FT_5);
			str = gshare;
			sprite = gui_add_labelbmf_on_cell(cell,data,str,path,'n_stock',GUI_STOCK,ANCHOR_DOWN);
			sprite:setScale(0.9);

			if true == self.do_cell_anim then
				local delay = (idx%10)*0.1;
				keff_showup_1(cell, delay);
			end
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_lstock;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			g_scene:guild();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		self.do_cell_anim = false;

	end,
} -- layer_lstock end

layer_invest = {
	name = 'layer_invest',
	layer = nil,
	info = nil,
	l_fund = nil,
	l_my = nil,
	l_stock = nil,

	cleanup = function(self)
		self.layer = nil;
		self.info = nil;
		self.l_fund = nil;
		self.l_my = nil;
		self.l_stock = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();
		
		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_INVEST, self.handler, true);

		local offsetheight = init_bg_full(self.layer, GUI_INVEST, self.back);
		self.offsetheight = offsetheight;
		local sprite, data, path;
		sprite,data = gui_add_sprite(self.layer,'outframe',GUI_INVEST,ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));

		gui_add_label_ali(self.layer, '公会投资', 26, 't_title',GUI_INVEST,ANCHOR_UP,cc.TEXT_ALIGNMENT_CENTER);
		gui_add_sprite(self.layer,'box',GUI_INVEST,ANCHOR_UP);
		gui_add_sprite(self.layer,'bg_fund',GUI_INVEST,ANCHOR_UP);
		gui_add_sprite(self.layer,'t_fund',GUI_INVEST,ANCHOR_UP);
		gui_add_sprite(self.layer,'gold_fund',GUI_INVEST,ANCHOR_UP);
		gui_add_sprite(self.layer,'bg_myfund',GUI_INVEST,ANCHOR_UP);
		gui_add_sprite(self.layer,'t_myfund',GUI_INVEST,ANCHOR_UP);
		gui_add_sprite(self.layer,'gold_myfund',GUI_INVEST,ANCHOR_UP);
		gui_add_sprite(self.layer,'bg_my',GUI_INVEST,ANCHOR_UP);
		gui_add_sprite(self.layer,'t_my',GUI_INVEST,ANCHOR_UP);
		path = util.get_path(FT_5);
		self.l_fund = gui_add_labelbmf(self.layer, '', path, 'n_fund', GUI_INVEST, ANCHOR_UP);
		self.l_my = gui_add_labelbmf(self.layer, '', path, 'n_myfund', GUI_INVEST, ANCHOR_UP);
		self.l_stock = gui_add_labelbmf(self.layer, '', path, 'n_my', GUI_INVEST, ANCHOR_UP);
		local items = {};
		local item;

		item, data = gui_add_item(items, 'btn_invest', GUI_INVEST, self.go_invest, ANCHOR_UP);

		item, data = gui_add_item(items, 'btn_record', GUI_INVEST, self.go_record, ANCHOR_UP);

		util.add_menu(self.layer, items, data.zorder);

		return self.layer, self.name;
	end,

	set_data = function(self, info)
		self.info = info;
		local guild_gold = info.guild_gold or 0;
		--local guild_crystal = info.guild_crystal or 0;
		local my_gold = info.my_gold or 0;
		local gshare = (info.gshare or 0) * 100;
		self.l_fund:setString(guild_gold);
		self.l_my:setString(my_gold);
		self.l_stock:setString(string.format("%d%%", gshare));
	end,

	go_invest = function()
		play_tap_1();
		local self = layer_invest;
		local m = self.info.guild_gold or 0;
		local s = (self.info.gshare or 0) * 100;
		s = string.format("%d%%", s);
		g_scene:add_layer(ZORDER_LAYER_AINVEST, layer_ainvest:create(1, m, s));
	end,

	go_record = function()
		play_tap_1();
		local function callback()
			local cmd = 'ldeposit 0 ' .. layer_ldeposit.PAGE_SIZE;
			net_send(cmd, true);
		end
		local layer, name = layer_ldeposit:create();
		g_scene:add_layer(ZORDER_LAYER_LDEPOSIT, layer, name, true, callback);
	end,

	back = function()
		play_tap_1();
		g_scene:guild();
	end,

	handler = function(event, x, y)
		local self = layer_invest;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			g_scene:guild();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)

	end,
} -- layer_invest end

layer_ainvest = {
	name = 'layer_ainvest',
	layer = nil,
	rect = nil,
	editbox = nil,

	cleanup = function(self)
		self.layer = nil;
		self.rect = nil;
		self.editbox = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, mtype, gfund, gshare)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_AINVEST, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 200));
		local bgsize = cc.size(540, 476);
		local bg,rect=init_bg_for_popview(self.layer,'金币投资',bgsize,self.back,true);
		self.rect = rect;

		local path = util.get_path('bg_156.png');
		local frect = cc.rect(0, 0, 64, 64); -- fullrect
		local irect = cc.rect(30, 30, 4, 4); -- insetrect
		local size = cc.size(467, 260); -- realsize
		local pos = cc.p(35, 132);
		util.add_scale9sprite(bg, path, pos, ANCHOR_LEFT_DOWN, frect, irect, size, 15); 

		local pos, size, str;

		pos = cc.p(80, 321);
		size = cc.size(130, 36);
		str = '公会资金:';
		util.add_labelttf(bg, str, nil, 25, pos, cc.c4b(240, 240, 203, 255), ANCHOR_LEFT_DOWN, 20, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos = cc.p(237, 320);
		add_icon_gold(bg, pos, ANCHOR_LEFT_DOWN, 20);
		pos = cc.p(279, 320);
		str = gfund or 0;
		add_font_1(bg, str, pos, ANCHOR_LEFT_DOWN, 20);

		pos = cc.p(80, 250);
		size = cc.size(130, 36);
		str = '我的股份:';
		util.add_labelttf(bg, str, nil, 25, pos, cc.c4b(240, 240, 203, 255), ANCHOR_LEFT_DOWN, 20, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos = cc.p(237, 250);
		str = gshare or '0%';
		add_font_5(bg, str, pos, ANCHOR_LEFT_DOWN, 20);

		pos = cc.p(80, 181);
		size = cc.size(130, 36);
		str = '本次投资:';
		util.add_labelttf(bg, str, nil, 25, pos, cc.c4b(240, 240, 203, 255), ANCHOR_LEFT_DOWN, 20, size, cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

		pos = cc.p(237, 180);
		add_icon_gold(bg, pos, ANCHOR_LEFT_DOWN, 20, wfix(1));
		pos = cc.p(279, 165);
		size = cc.size(205, 62);
		str = '请输入投资金额';
		self.editbox = add_editbox_1(bg, pos, size, str, 20,self.editbox_handler);

		local items = {};

		add_item_4(items, '确定', nil, 30, self.do_invest, ANCHOR_CENTER_DOWN, cc.p(bgsize.width/2, 44));
		
		util.add_menu(bg, items, 50);

		return self.layer, self.name;
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_ainvest;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
		elseif eventname == "changed" then
		end

	end,

	do_invest = function()
		play_tap_1();
		local self = layer_ainvest;
		local str = self.editbox:getText();
		--local mtype = self.mtype;
		local num = tonumber(self.editbox:getText());
		if nil == num then
			show_msg('请输入有效数字');
			return;
		end
		if 1 > num then
			show_msg('请输入数量');
			return;
		end
		local cmd = 'gdeposit ' .. num;
		net_send(cmd);
	end,

	back = function()
		play_tap_1();
		local self = layer_ainvest;
		self:remove();
	end,

	handler = function(event, x, y)
		local self = layer_ainvest;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,

} -- layer_ainvest end

layer_ldeposit = {
	name = 'layer_ldeposit',
	PAGE_SIZE = 15,
	layer = nil,
	rect = nil,
	list = nil,
	tableview = nil,
	bar = nil,
	tap = nil,
	cwidth = nil,
	cheight = nil,
	data_cell = nil,
	do_cell_anim = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.rect = nil;
		self.tableview = nil;
		self.bar = nil;
		self.tap = nil;
		self.cwidth = nil;
		self.cheight = nil;
		self.data_cell = nil;
		self.do_cell_anim = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();
		
		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_LDEPOSIT, self.handler, true);

		self.list = {};
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		local offsetheight, sprite, rect = init_bg_pop(self.layer, GUI_RECORD, '投资记录', self.back, nil, true);
		self.rect = rect;

		sprite, data = gui_add_sprite(self.layer, 'frame',GUI_RECORD,ANCHOR_DOWN);
		sprite:setContentSize(cc.size(data.width, data.height+offsetheight));

		data = gui_get_data('cell', GUI_RECORD, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height + 10;
		data = gui_get_data('table', GUI_RECORD, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		self.theight = size.height;
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		--[[
		-- btn back set in g_scene.lguild
		init_bg_for_full_view(self.layer, GUI_RECORD, '投资记录');

		local d1 = gui_get_data('table', GUI_RECORD, ANCHOR_UP);
		local d2 = gui_get_data('table', GUI_RECORD, ANCHOR_DOWN);
		local offsety = d1.y - d2.y;
		data = gui_get_data('cell', GUI_RECORD, ANCHOR_DOWN);
		self.data_cell = data;
		self.cwidth = data.width;
		self.cheight = data.height+10;
		data = gui_get_data('table', GUI_RECORD, ANCHOR_DOWN);
		size = cc.size(data.width, data.height+offsety);
		pos = cc.p(data.x, data.y);
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, ccp(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+10);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos, cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);
		]]--

		return self.layer, self.name;
	end,

	add_list = function(self, list, start_pos)
		list = list or {};
		local more_cell = { flag_more_cell = true };
		self.list = self.list or {};
		if 0 == start_pos then
			self.list = {};
			self.do_cell_anim = true;
		end
		if 0 < #self.list then
			local m = self.list[#self.list];
			if true == m.flag_more_cell then
				table.remove(self.list, #self.list);
			end
		end
		for i = 1, #list do
			table.insert(self.list, list[i]);
		end
		if self.PAGE_SIZE == #list then
			table.insert(self.list, more_cell);
		end

		self:reload_data();
	end,

	reload_data = function(self)
		self.tableview:reloadData();
	end,

	get_more = function()
		local self = layer_ldeposit;
		local len = #(self.list or {});
		if self.list[len].flag_more_cell == true then
			len = len - 1;
		end
		if len < 0 then len = 0; end
		local cmd = string.format("ldeposit %d %d", len, self.PAGE_SIZE);
		net_send(cmd);
	end,

	back = function()
		play_tap_1();
		layer_ldeposit:remove();
	end,

	editbox_handler = function(eventname, psender)
		local self = layer_ldeposit;
		local edit = tolua.cast(psender, "cc.EditBox");
		if eventname == "began" then
		elseif eventname == "ended" then
		elseif eventname == "return" then
		elseif eventname == "changed" then
		end
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_ldeposit;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			--local cell = args[3];
			--local idx = cell:getIdx();
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			return self.cheight, self.cwidth;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local width = self.cwidth;
			local height = self.cheight;
			local info = self.list[idx + 1];
			if true == info.flag_more_cell then
				local items = {};
				local pos = cc.p(width/2, height/2);
				local size = cc.size(172, 52);
				local item = add_item_1(items, '更多', nil, 20, self.get_more, ANCHOR_CENTER_CENTER, pos, size);
				item:setTag(idx + 1);

				util.add_menu(cell, items, 1);
				return cell;
			end
			local data = self.data_cell;
			gui_add_cell_bg(cell, data);
			local alias = info.alias;
			local deposit_date = info.deposit_date;
			local gold = info.gold;
			local crystal = info.crystal;
			local sprite, path, pos, size, str;

			str = alias;
			gui_add_label_on_cell(cell,data,str,25,'name',GUI_RECORD,ANCHOR_DOWN);

			path = util.get_path(FT_8);
			local t = os.date("*t", deposit_date);
			str = string.format("%d/%d", t.month, t.day);
			sprite = gui_add_labelbmf_on_cell(cell,data,str,path,'date',GUI_RECORD,ANCHOR_DOWN);
			--sprite:setAlignment(cc.TEXT_ALIGNMENT_RIGHT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);
			sprite:setScale(0.7);

			gui_add_sprite_on_cell(cell, data, 'gold', GUI_RECORD, ANCHOR_DOWN);
			path = util.get_path(FT_1);
			str = gold;
			gui_add_labelbmf_on_cell(cell,data,str,path,'n_gold',GUI_RECORD,ANCHOR_DOWN);
			if true == self.do_cell_anim then
				local delay = (idx%10)*0.1;
				keff_show_fromright(cell, delay);
			end
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_ldeposit;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			g_scene:guild();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		self.do_cell_anim = false;
	end,
} -- layer_ldeposit end

layer_chatpop = { 
	name = 'layer_chatpop',
	layer = nil,
	info = nil,
	rect = nil,

	cleanup = function(self)
		self.layer = nil;
		self.info = nil;
		self.rect = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, info)
		self:remove();

		self.info = info;
		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_CHATPOP, self.handler, true);

		util.add_layer_color(self.layer, cc.c4b(0, 0, 0, 200));

		--local btn_height = 70;
		local item_list = {};
		if g_euser.eid ~= info.eid then
			-- 加好友
			table.insert(item_list, { fname1 = 'btn_123.png', fname2 = 'btn_123_s.png', cb = self.addfrd });

			if not g_scene:is_battle() and not g_scene:is_stage(STAGE_REPLAY) then
				table.insert(item_list, { fname1 = 'btn_124.png', fname2 = 'btn_124_s.png', cb = self.detail });

				if g_scene:is_stage(STAGE_MAP) then
					--table.insert(item_list, { title = '挑战', cb = self.fight });
				end
			end

			if nil ~= layer_chat.layer then
				--table.insert(item_list, { title = '私聊', cb=self.private_chat });
			end
		end

		local path = util.get_path('bg_121.png');
		local frect = cc.rect(0, 0, 404, 260); -- fullrect
		local irect = cc.rect(200, 128, 4, 4); -- insetrect
		--local height = 110 + (#item_list * (btn_height + 10));
		--local bgsize = cc.size(wfix(400), height);--realsize
		local bgsize = cc.size(wfix(540), wfix(288));
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, bgsize, 10); 
		self.rect = {
			x1 = pos.x-bgsize.width/2,  x2 = pos.x+bgsize.width/2,
			y1 = pos.y-bgsize.height/2, y2 = pos.y+bgsize.height/2,
		};

		path = util.get_path('bg_115.png');
		pos = cc.p(64, 98);
		local sprite = util.add_sprite(bg, path, pos, ANCHOR_LEFT_DOWN, 10);
		path = get_icon_path(info.icon);
		local size = sprite:getContentSize();
		pos = cc.p(size.width/2, size.height/2);
		local icon = util.add_sprite(sprite, path, pos, ANCHOR_CENTER_CENTER, -1);
		icon:setScale((size.height-8)/icon:getContentSize().height);

		path = util.get_path('bg_116.png');
		pos = cc.p(64+size.width/2, 60);
		sprite = util.add_sprite(bg, path, pos, ANCHOR_CENTER_DOWN, 10);
		size = sprite:getContentSize();
		pos = cc.p(0, 0);
		local str = info.alias or '';
		local label = util.add_labelttf(sprite, str, nil, 24, pos, util.c4b_black, ANCHOR_LEFT_DOWN, 10, size, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);

		local items = {};

		local x = 212;
		local y = 74;
		local gap = 84;
		if #item_list > 2 then
			y = 10;
			gap = 70;
		end
		for i = 1, #item_list do
			local l = item_list[i];
			pos = cc.p(x, y);
			add_item_2(items, l.fname1, l.fname2, l.cb, ANCHOR_LEFT_DOWN, pos);
			y = y + gap;
		end

		pos = cc.p(474, 213);
		add_item_close(items, pos, ANCHOR_LEFT_DOWN, self.back);

		util.add_menu(bg, items, 20);

		return self.layer, self.name;
	end,

	back = function()
		local self = layer_chatpop;
		self:remove();
	end,

	detail = function()
		local self = layer_chatpop;
		local info = self.info;
		if nil == info then
			return;
		end
		local eid = info.eid;
		local cmd = 'fsta ' .. eid;
		net_send(cmd);
		self:remove();
	end,

	addfrd = function()
		local self = layer_chatpop;
		local info = self.info;
		if nil == info then
			return;
		end
		local eid = info.eid;
		local cmd = string.format("fadd %d", eid);
		net_send(cmd);
	end,

	fight = function()
		local self = layer_chatpop;
		local info = self.info;
		if nil == info then
			return;
		end
		local eid = info.eid;
		pop_invite_fight(eid);
	end,

	private_chat = function()
		local self = layer_chatpop;
		local info = self.info;
		if nil == info then
			return;
		end
		local eid = info.eid;
		local alias = info.alias;
		if nil == layer_chat.layer then
			if g_scene:is_stage(STAGE_PVP) then
				g_scene:add_layer(ZORDER_LAYER_CHAT, layer_chat:create(true));
			else
				return;
			end
		end
		self.back();
		layer_chat.chat_target = { eid = eid, alias = alias };
		layer_chat:handle_channel_btn(C_PRIVATE);
	end,

	handler = function(event, x, y)
		local self = layer_chatpop;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,
} -- layer_chatpop end

layer_fight = {
	name = 'layer_fight',
	layer = nil,
	data = nil,
	TIP_TYPE_INVITE_FIGHT = 1,
	TIP_TYPE_ANSWER_FIGHT = 2,

	cleanup = function(self)
		self.layer = nil;
		self.callback = nil;
		self.data = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, msg, tip_type, data)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_FIGHT, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));

		local path = util.get_path('pop_up.png');
		local frect = cc.rect(0, 0, 64, 64); -- fullrect
		local irect = cc.rect(30, 30, 4, 4); -- insetrect
		local size = cc.size(wfix(505), hfix(302));--realsize
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
		local bg = util.add_scale9sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, frect, irect, size, 10); 

    	if nil ~= msg then
			pos = cc.p(size.width/2, size.height-50);
			local lsize = cc.size(size.width-40, 70);
			util.add_labeloutline(bg, msg, nil, 25, pos, util.c4b_white, util.c4b_black, 1, ANCHOR_CENTER_UP, 1, lsize, cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_TOP);
    	end

		if tip_type == self.TIP_TYPE_INVITE_FIGHT then
			self:init_btn_for_invite_fight(bg, size, data);
			return self.layer, self.name;
		end
		if tip_type == self.TIP_TYPE_ANSWER_FIGHT then
			self:init_btn_for_answer_fight(bg, size, data);
			return self.layer, self.name;
		end

		local items = {};

		pos = cc.p(size.width/2, 28);
		add_item_1(items, '取消',nil,30,self.remove,ANCHOR_CENTER_DOWN,pos);
		
		util.add_menu(bg, items, 1);

		return self.layer, self.name;
	end,

	cancel_invite_fight = function()
		local self = layer_fight;
		local data = self.data;
		self:remove();
		local cmd = string.format("challenge 1 %d", data.eid);
		net_send(cmd);
	end,

	init_btn_for_invite_fight = function(self, bg, size, data)
		self.data = data;
		local items = {};
		local item, p1, p2, pos;

		pos = cc.p(size.width/2, 28);
		add_item_1(items, '取消',nil,30,self.cancel_invite_fight,ANCHOR_CENTER_DOWN,pos);
		
		util.add_menu(bg, items, 1);
	end,

	accept_fight = function()
		local self = layer_fight;
		local data = self.data;
		self:remove();
		local cmd = string.format("challenge 2 %d", data.eid);
		net_send(cmd);
	end,

	refuse_fight = function()
		local self = layer_fight;
		local data = self.data;
		self:remove();
		local cmd = string.format("challenge 3 %d", data.eid);
		net_send(cmd);
	end,

	init_btn_for_answer_fight = function(self, bg, size, data)
		self.data = data;
		local items = {};

		pos = cc.p(size.width/4*3, 28);
		add_item_1(items, '接受',nil,30,self.accept_fight,ANCHOR_CENTER_DOWN,pos);

		pos = cc.p(size.width/4, 28);
		add_item_1(items, '拒绝',nil,30,self.refuse_fight,ANCHOR_CENTER_DOWN,pos);
		
		util.add_menu(bg, items, 1);
	end,

	handler = function(event, x, y)
		local self = layer_fight;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
	end,

} -- layer_fight end

layer_pick = { -- start
	name = 'layer_pick',
	layer = nil,

	save_to_slot = function(...)
		local self = layer_pick;
		local args = {...};
		local index = args[2]:getTag();
		local info = self.list[index];
		if nil ~= layer_deck.layer and nil ~= info then
			layer_deck:save_to_slot(info.tag, info.title);
		end
		self:close();
	end,


} -- layer_pick end

layer_daily = {
	name = 'layer_daily',
	layer = nil,
	list = nil,
	tableview = nil,
	rect = nil,
	theight = nil,
	bar = nil,
	tap = nil,
	data_cell1 = nil,
	data_cell2 = nil,
	icon_up = nil,
	icon_down = nil,
	log_day = nil,
	has_get_reward = nil,
	do_cell_anim = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.rect = nil;
		self.theight = nil;
		self.bar = nil;
		self.tap = nil;
		self.data_cell1 = nil;
		self.data_cell2 = nil;
		self.icon_up = nil;
		self.icon_down = nil;
		self.log_day = nil;
		self.has_get_reward = nil;
		self.do_cell_anim = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_DAILY, self.handler, true);

		self.list = {};
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		local sprite, data;
		local offsetheight, bg, rect = init_bg_pop(self.layer, GUI_DAILY, '登陆奖励', self.back);
		self.rect = rect;

		gui_add_sprite(self.layer, 'bottom_line', GUI_DAILY, ANCHOR_DOWN);

		data = gui_get_data('cell1', GUI_DAILY, ANCHOR_DOWN);
		self.data_cell1 = data;
		data = gui_get_data('cell2', GUI_DAILY, ANCHOR_DOWN);
		self.data_cell2 = data;
		data = gui_get_data('table', GUI_DAILY, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		self.theight = size.height;
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		pos = cc.p(data.x+size.width, data.y+size.height);
		self.icon_up = add_scroll_icons(self.layer, pos, true);
		self.icon_up:setVisible(false);
		pos = cc.p(data.x+size.width, data.y);
		self.icon_down = add_scroll_icons(self.layer, pos, false);
		self.icon_down:setVisible(false);

		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		local self = layer_daily;
		self:remove();
	end,

	reload = function(self, offset)
		self.do_cell_anim = true;
		self.tableview:reloadData();
		if nil ~= offset then
			self.tableview:setContentOffset(offset, false);
		end
	end,

	set_data = function(self, data)
		self.log_day = data.log_day;
		self.has_get_reward = data.has_get_reward;
		local list = data.day_info or {};
		self.list = {};
		for i = 1, #list do
			local info = list[i];
			local m = 0;
			if info.gold > 0 or info.crystal > 0 then
				m = m + 1;
			end
			local len = #info.clist;
			if len > 0 then m = m + 1; end
			if len > 4 then m = m + 1; end
			if 1 == m then
				info.data_cell = self.data_cell1;
				info.cell_type = 1;
			else
				info.data_cell = self.data_cell2;
				info.cell_type = 2;
			end
			table.insert(self.list, info);
		end
		self:reload();
	end,

	cb_get_reward = function(self, data)
		self.log_day = self.log_day + 1;
		self.has_get_reward = 1;
		self:reload();
	end,

	get_reward = function(...)
		local args = {...};
		local tag = args[2]:getTag();
		local self = layer_daily;
		local info = self.list[tag];
		local day = info.day;
		net_send('daily_reward ' .. day);
	end,

	show_card = function(...)
		local args = {...};
		local cid = args[2]:getTag();
		local self = layer_daily;
		local card = clone_card_by_id(cid);
		if nil == card then return; end
		g_scene:add_layer(ZORDER_LAYER_MISPOP, layer_mispop:create(card));
	end,

	show_piece = function(...)
		local args = {...};
		local cid = args[2]:getTag();
		local self = layer_daily;
		local card = clone_card_by_id(cid);
		if nil == card then return; end
		g_scene:add_layer(ZORDER_LAYER_MISPOP, layer_mispop:create(card, true));
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_daily;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			update_scroll_icon(self.icon_up, self.icon_down, view, self.theight);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			--play_tap_3();
			--local cell = args[3];
			--local idx = cell:getIdx();
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			local info = self.list[idx + 1];
			local data = info.data_cell or self.data_cell1;
			return data.height, data.width;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local info = self.list[idx + 1];
			local data = info.data_cell or self.data_cell1;
			gui_add_cell_bg(cell, data);
			local width = data.width;
			local height = data.height;
			local ctype = info.cell_type;
			local day = info.day;
			local gold = info.gold;
			local crystal = info.crystal;
			local card_list = info.card_list;
			local piece_list = info.piece_list;
			local data2, sprite, path, pos, size, str, key;
			local d1 = self.data_cell1;
			local d2 = self.data_cell2;
			local offsety = d2.height - d1.height;
			key = 'cell' .. ctype .. '_bgtitle';
			sprite=gui_add_sprite_on_cell(cell, data, key, GUI_DAILY,ANCHOR_DOWN);
			if day < self.log_day + 1 then
				data2 = gui_get_data('cell1_bgtitle', GUI_DAILY, ANCHOR_DOWN);
				gui_add_sprite_on_cell(sprite,data2,'check',GUI_DAILY,ANCHOR_DOWN);
			end
			key = 'cell' .. ctype .. '_title';
			str = string.format("第%d天", day);
			gui_add_label_on_cell(cell,data,str,25,key,GUI_DAILY,ANCHOR_DOWN);

			key = 'gold1';
			local ldata = gui_get_data(key, GUI_DAILY, ANCHOR_DOWN);
			local x = ldata.x-d1.x;
			path = util.get_path(FT_4);
			if gold > 0 then
				key = 'gold1';
				sprite, data2 = gui_add_sprite_on_cell(cell, d1, key, GUI_DAILY, ANCHOR_DOWN);
				if ctype == 2 then
					sprite:setPositionY(data2.y+offsety);
				end
				key = 'n_gold1';
				str = info.gold;
				sprite, data2 = gui_add_labelbmf_on_cell(cell,d1,str,path,key,GUI_DAILY,ANCHOR_DOWN);
				if ctype == 2 then
					sprite:setPositionY(data2.y+offsety);
				end
			end
			if crystal > 0 then
				key = 'crystal1';
				sprite, data2 = gui_add_sprite_on_cell(cell, d1, key, GUI_DAILY, ANCHOR_DOWN);
				local gapx = 0;
				if gold == 0 then
					gapx = data2.x - x;
					sprite:setPositionX(x);
				end
				if ctype == 2 then
					sprite:setPositionY(data2.y+offsety);
				end
				key = 'n_crystal1';
				str = info.crystal;
				sprite, data2 = gui_add_labelbmf_on_cell(cell,d1,str,path,key,GUI_DAILY,ANCHOR_DOWN);
				if gapx > 0 then
					sprite:setPositionX(data2.x-gapx);
				end
				if ctype == 2 then
					sprite:setPositionY(data2.y+offsety);
				end
			end
			key = 'pframe2';
			ldata = gui_get_data(key, GUI_DAILY, ANCHOR_DOWN);
			key = 'cframe2_2';
			local ldata2 = gui_get_data(key, GUI_DAILY, ANCHOR_DOWN);
			x = ldata.x-d2.x;
			local gapx = ldata2.x-ldata.x;
			for i = 1, #info.clist do
				local cinfo = info.clist[i];
				local cid = cinfo.cid;
				local is_piece = cinfo.is_piece;
				local piece_count = cinfo.piece_count or 0;
				local cb = nil;
				if true == is_piece then
					key = 'pframe2';
					cb = self.show_piece;
				else
					key = 'cframe2_1';
					cb = self.show_card;
				end
				--sprite, data2 = gui_add_sprite_on_cell(cell, d2, key, GUI_DAILY, ANCHOR_DOWN);
				local items = {};
				sprite, data2 = gui_add_item_on_cell(items, d2, key, GUI_DAILY, cb, ANCHOR_DOWN);
				sprite:setTag(cid);
				util.add_menu(cell, items, data2.zorder);
				if ctype == 2 and #info.clist > 3 and i <= 3 then
					sprite:setPositionY(ldata1.y - d2.y);
				else
					sprite:setPositionY(ldata2.y - d2.y);
				end
				sprite:setPositionX(x+gapx*((i-1)%3));
				local size = sprite:getContentSize();
				local pic, mask_path;
				if true == is_piece then
					mask_path = util.get_path('bg_173.png');
				else
					mask_path = util.get_path('bg_172.png');
				end
				local fname = 'card' .. cinfo.cid .. '.png';
				path = util.get_path(fname, 'card0.png');
				pic = util.add_mask_sprite(sprite, path, mask_path, cc.p(size.width/2, size.height/2), ANCHOR_CENTER_CENTER, -1);
				pic:setScaleX(size.width/pic:getContentSize().width);
				pic:setScaleY(size.height/pic:getContentSize().height);
				if piece_count > 0 then
					path = util.get_path(FT_4);
					str = piece_count .. '';
					util.add_labelbmf(sprite, str, path, cc.p(size.width, 0), ANCHOR_RIGHT_DOWN, 1);
				end
			end
			key = 'bg_btn_get' .. ctype;
			gui_add_sprite_on_cell(cell, data, key, GUI_DAILY, ANCHOR_DOWN);
			--if day <= self.log_day and 1 == self.has_get_reward then
			if day < self.log_day + 1 then
				key = 'gray_get' .. ctype;
				sprite, data2 = gui_add_sprite_on_cell(cell, data, key, GUI_DAILY, ANCHOR_DOWN);
			else
				local items = {};
				local item;

				key = 'btn_get' .. ctype;
				item, data2 = gui_add_item_on_cell(items, data, key, GUI_DAILY, self.get_reward, ANCHOR_DOWN);
				item:setTag(idx + 1);
				if (1 == self.has_get_reward and day > self.log_day) or
				   (0 == self.has_get_reward and day > self.log_day+1) then
					enable_btn(item, false);
				end

				util.add_menu(cell, items, data2.zorder);
			end
			if true == self.do_cell_anim then
				local delay = (idx%10)*0.1;
				keff_show_fromright(cell, delay);
			end
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_daily;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		self.do_cell_anim = false;
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,
} -- layer_daily end

layer_mission = {
	name = 'layer_mission',
	layer = nil,
	list = nil,
	tableview = nil,
	rect = nil,
	theight = nil,
	bar = nil,
	tap = nil,
	mission_count = nil,
	data_cell1 = nil,
	data_cell2 = nil,
	icon_up = nil,
	icon_down = nil,
	do_cell_anim= nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.tableview = nil;
		self.rect = nil;
		self.theight = nil;
		self.bar = nil;
		self.tap = nil;
		self.mission_count = nil;
		self.data_cell1 = nil;
		self.data_cell2 = nil;
		self.icon_up = nil;
		self.icon_down = nil;
		self.do_cell_anim = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();
		util.reg_handler(self.layer, -ZORDER_LAYER_MISSION, self.handler, true);

		self.mission_count = 0;
		g_mission_tip = nil;
		if nil ~= layer_map.layer then
			layer_map:tip_btn_mission();
		end
		self.list = {};
		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));
		local sprite, data;
		local offsetheight, bg, rect = init_bg_pop(self.layer, GUI_MISSION, '任务', self.back);
		self.rect = rect;

		gui_add_sprite(self.layer, 'bottom_line', GUI_MISSION, ANCHOR_DOWN);

		data = gui_get_data('cell1', GUI_MISSION, ANCHOR_DOWN);
		self.data_cell1 = data;
		data = gui_get_data('cell2', GUI_MISSION, ANCHOR_DOWN);
		self.data_cell2 = data;
		data = gui_get_data('table', GUI_MISSION, ANCHOR_DOWN);
		pos = cc.p(data.x, data.y);
		size = cc.size(data.width, data.height + offsetheight);
		self.theight = size.height;
		-----
		self.bar, self.tap = util.add_tableview_scrollbar(self.layer, cc.p(pos.x+size.width, pos.y), size, ANCHOR_LEFT_DOWN, data.zorder+4);
		-----
		self.tableview = util.add_tableview(self.layer, size, cc.SCROLLVIEW_DIRECTION_VERTICAL, self.tableview_handler, pos,cc.TABLEVIEW_FILL_TOPDOWN,data.zorder);

		pos = cc.p(data.x+data.width, data.y+size.height);
		self.icon_up = add_scroll_icons(self.layer, pos, true);
		self.icon_up:setVisible(false);
		pos = cc.p(data.x+data.width, data.y);
		self.icon_down = add_scroll_icons(self.layer, pos, false);
		self.icon_down:setVisible(false);

		return self.layer, self.name;
	end,

	back = function()
		play_tap_1();
		local self = layer_mission;
		self:remove();
	end,

	reload = function(self, offset)
		self.do_cell_anim = true;
		self.tableview:reloadData();
		if nil ~= offset then
			self.tableview:setContentOffset(offset, false);
		end
	end,

	add_list = function(self, list, has_more)
		list = list or {};
		self.list = self.list or {};
		if 0 == #self.list then
			self.mission_count = 0;
		end
		if 0 < #self.list then
			local info = self.list[#self.list];
			if true == info.flag_more_cell then
				table.remove(self.list, #self.list);
			end
		end
		for i = 1, #list do
			local info = list[i];
			local m = 0;
			if info.gold > 0 or info.crystal > 0 or info.exp > 0 then
				m = m + 1;
			end
			if #info.clist > 0 then
				m = m + 1;
			end
			if 1 == m then
				info.data_cell = self.data_cell2;
				info.cell_type = 2;
			else
				info.data_cell = self.data_cell1;
				info.cell_type = 1;
			end
			table.insert(self.list, list[i]);
			self.mission_count = self.mission_count + 1;
		end
		if true == has_more then
			local more_cell = { flag_more_cell = true };
			table.insert(self.list, more_cell);
		end
		self:reload();
	end,

	get_more = function()
		local self = layer_mission;
		local index = self.mission_count or 0;
		local cmd = string.format("mlist %d %d", MLIST_WITHOUT_CHAPTER, index);
		--local cmd = 'mlist ' .. index;
		net_send(cmd);
	end,

	get_reward = function(...)
		local args = {...};
		local tag = args[2]:getTag();
		local self = layer_mission;
		local info = self.list[tag];
		local mid = info.mid;
		net_send('mreward ' .. mid);
	end,

	go_action = function(...)
		local args = {...};
		local tag = args[2]:getTag();
		local self = layer_mission;
		local info = self.list[tag];
		self:do_gate(info.p2);
	end,

	go_chapter = function(...)
		local args = {...};
		local tag = args[2]:getTag();
		local self = layer_mission;
		local info = self.list[tag];
		local chapter_id = info.p2;
		local stage_id = info.p3;
		layer_chapter.set_stage_id_for_mission = stage_id;
		layer_chapter.last_chapter_id = chapter_id;
		g_scene:chapter();
	end,

	do_gate = function(self, gate_id)
		local gate_id = tonumber(gate_id) or 0;
		if 0 == gate_id then
			show_gate();
			return;
		end
		net_send('gate ' .. gate_id);
	end,

	show_card = function(...)
		local args = {...};
		local tag = args[2]:getTag();
		local self = layer_mission;
		local card = clone_card_by_id(tag);
		if nil == card then return; end
		g_scene:add_layer(ZORDER_LAYER_MISPOP, layer_mispop:create(card));
	end,

	show_piece = function(...)
		local args = {...};
		local tag = args[2]:getTag();
		local self = layer_mission;
		local card = clone_card_by_id(tag);
		if nil == card then return; end
		g_scene:add_layer(ZORDER_LAYER_MISPOP, layer_mispop:create(card, true));
	end,

	tableview_handler = function(...)  -- { start
		local self = layer_mission;
		local args = {...};
		local event = args[1];
		local view = args[2];
		--kdebug("%s", event);
		if "numberOfCellsInTableView" == event then
			return #(self.list or {});
		elseif "scrollViewDidScroll" == event then
			util.handle_tableview_scrollbar(view, self.bar, self.tap);
			update_scroll_icon(self.icon_up, self.icon_down, view, self.theight);
			return;
		elseif "scrollViewDidZoom" == event then
			return;
		elseif "tableCellTouched" == event then
			return;
		elseif "cellSizeForTable" == event then
			local idx = args[3];
			local info = self.list[idx + 1];
			local data = info.data_cell or self.data_cell2;
			return data.height, data.width;
		elseif "tableCellAtIndex" == event then
			local idx = args[3];
			local cell = view:dequeueCell()
			if nil ~= cell then
				cell:removeFromParentAndCleanup(true);
			end
			cell = cc.TableViewCell:new()
			local info = self.list[idx + 1];
			local data = info.data_cell or self.data_cell2;
			local width = data.width;
			local height = data.height;
			if true == info.flag_more_cell then
				local items = {};

				pos = cc.p(width/2, height/2);
				size = cc.size(172, 52);
				local item = add_item_1(items, '更多任务', nil, 20, self.get_more, ANCHOR_CENTER_CENTER, pos, size);
				item:setTag(idx + 1);

				util.add_menu(cell, items, 1);
				return cell;
			end
			gui_add_cell_bg(cell, data);
			local ctype = info.cell_type;
			local gold = info.gold;
			local crystal = info.crystal;
			local exp = info.exp;
			local d1 = self.data_cell1;
			local d2 = self.data_cell2;
			local offsety = d2.height - d1.height;
			local data2, sprite, path, pos, size, str;
			key = 'cell' .. ctype .. '_bgtitle';
			gui_add_sprite_on_cell(cell, data, key, GUI_MISSION, ANCHOR_DOWN);
			key = 'cell' .. ctype .. '_icon';
			gui_add_sprite_on_cell(cell, data, key, GUI_MISSION, ANCHOR_DOWN);
			key = 'cell' .. ctype .. '_title';
			str = info.title;
			gui_add_label_on_cell(cell,data,str,25,key,GUI_MISSION,ANCHOR_DOWN);
			key = 'cell' .. ctype .. '_desc';
			str = info.detail;
			gui_add_label_on_cell(cell,data,str,22,key,GUI_MISSION,ANCHOR_DOWN);
			path = util.get_path(FT_4);
			if gold > 0 then
				key = 'gold' .. ctype;
				gui_add_sprite_on_cell(cell, data, key, GUI_MISSION, ANCHOR_DOWN);
				key = 'n_gold' .. ctype;
				str = gold;
				sprite, data2 = gui_add_labelbmf_on_cell(cell,data,str,path,key,GUI_MISSION,ANCHOR_DOWN);
			end
			if crystal > 0 then
				local newy = 0;
				if 2 == ctype and gold == 0 then
					key = 'gold' .. ctype;
					data2 = gui_get_data(key, GUI_MISSION, ANCHOR_DOWN);
					newy = data2.y - data.y;
				end
				key = 'crystal' .. ctype;
				sprite = gui_add_sprite_on_cell(cell, data, key, GUI_MISSION, ANCHOR_DOWN);
				if newy > 0 then
					sprite:setPositionY(newy);
				end
				key = 'n_crystal' .. ctype;
				str = crystal;
				sprite, data2 = gui_add_labelbmf_on_cell(cell,data,str,path,key,GUI_MISSION,ANCHOR_DOWN);
				if newy > 0 then
					sprite:setPositionY(newy);
				end
			end
			if exp > 0 then
				key = 'exp' .. ctype;
				gui_add_sprite_on_cell(cell, data, key, GUI_MISSION, ANCHOR_DOWN);
				key = 'n_exp' .. ctype;
				str = exp;
				sprite, data2 = gui_add_labelbmf_on_cell(cell,data,str,path,key,GUI_MISSION,ANCHOR_DOWN);
			end
			key = 'pframe1';
			local ldata = gui_get_data(key, GUI_MISSION, ANCHOR_DOWN);
			key = 'cframe1_1';
			local ldata2 = gui_get_data(key, GUI_MISSION, ANCHOR_DOWN);
			key = 'cframe1_2';
			local ldata3 = gui_get_data(key, GUI_MISSION, ANCHOR_DOWN);
			x = ldata.x-d1.x;
			local gapx = ldata3.x-ldata2.x;
			for i = 1, #info.clist do
				local cinfo = info.clist[i];
				local cid = cinfo.cid;
				local is_piece = cinfo.is_piece;
				local piece_count = cinfo.piece_count or 0;
				local cb = nil;
				if true == is_piece then
					key = 'pframe1';
					cb = self.show_piece;
				else
					key = 'cframe1_1';
					cb = self.show_card;
				end
				local items = {};
				sprite, data2 = gui_add_item_on_cell(items, d1, key, GUI_MISSION, cb, ANCHOR_DOWN);
				sprite:setTag(cid);
				util.add_menu(cell, items, data2.zorder);
				if ctype == 1 and #info.clist > 3 and i <= 3 then
					sprite:setPositionY(ldata1.y - d1.y);
				else
					sprite:setPositionY(ldata2.y - d1.y);
				end
				sprite:setPositionX(x+gapx*((i-1)%3));
				local size = sprite:getContentSize();
				local pic, mask_path;
				if true == is_piece then
					mask_path = util.get_path('bg_173.png');
				else
					mask_path = util.get_path('bg_172.png');
				end
				local fname = 'card' .. cinfo.cid .. '.png';
				path = util.get_path(fname, 'card0.png');
				pic = util.add_mask_sprite(sprite, path, mask_path, cc.p(size.width/2, size.height/2), ANCHOR_CENTER_CENTER, -1);
				pic:setScaleX(size.width/pic:getContentSize().width);
				pic:setScaleY(size.height/pic:getContentSize().height);
				if piece_count > 0 then
					path = util.get_path(FT_4);
					str = piece_count .. '';
					util.add_labelbmf(sprite, str, path, cc.p(size.width, 0), ANCHOR_RIGHT_DOWN, 1);
				end
			end
			local cb = nil;
			str = nil;
			local mtype = info.mtype;
			if 2 == info.status then
				cb = self.get_reward;
				str = '领取';
			elseif MISSION_CHAPTER_STAGE == mtype or MISSION_CHAPTER == mtype then
				cb = self.go_chapter;
				str = '快捷入口';
			elseif MISSION_LEVEL == mtype or MISSION_GATE == mtype then
				cb = self.go_action;
				str = MISSION_LEVEL == mtype and '闯关' or '挑战';
			elseif MISSION_FIGHT_AI == mtype or MISSION_FIGHT_VS == mtype or MISSION_FIGHT == mtype then
				cb = show_service;
				str = '对战';
			elseif MISSION_MONTHLY == mtype then
				cb = go_pay;
				str = '充值';
			elseif MISSION_RANK_GAME_TIMES == mtype then
				cb = show_pclg;
				str = '竞技';
			end
			if nil ~= cb then
				key = 'bg_btn_get' .. ctype;
				gui_add_sprite_on_cell(cell, data, key, GUI_MISSION, ANCHOR_DOWN);

				local items = {};
				local item;

				key = 'btn_get' .. ctype;
				item, data2 = gui_add_item_on_cell(items, data, key, GUI_MISSION, cb, ANCHOR_DOWN);
				item:setTag(idx + 1);
				util.add_text_to_sprite(item, str, 23, cc.c4b(13, 52, 24, 255));

				util.add_menu(cell, items, data2.zorder);
			end
			if true == self.do_cell_anim then
				local delay = (idx%10)*0.1;
				keff_show_fromright(cell, delay);
			end
			return cell;
		elseif "tableCellHighlight" == event then
			local cell = args[3];
			return;
		elseif "tableCellUnhighlight" == event then
			local cell = args[3];
			return;
		end
	end, -- tableview_handler end }

	handler = function(event, x, y)
		local self = layer_mission;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
			self.back();
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
		
	end,

	onTouchEnded = function(self, x, y)
		self.do_cell_anim = false;
		local r = self.rect;
		if nil == r then
			return;
		end
		if x < r.x1 or x > r.x2 or y < r.y1 or y > r.y2 then
			self.back();
		end
	end,
} -- layer_mission end

layer_mispop = { -- start
	name = 'layer_mispop',
	layer = nil, 
	sprite = nil,

	cleanup = function(self)
		self.layer = nil;
		self.sprite = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, _card, is_piece)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_MISPOP, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));

		local card = clone(_card);
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT - hfix(50));
		local cwidth = FULL_WIDTH - wfix(70);
		local cheight = FULL_HEIGHT - hfix(340);
		local scale = get_card_scale(cwidth, cheight, CARD_SIZE);
		local cinfo = object_card:new(self.layer, card, nil, nil, pos, 0, scale, STYPE_VER_1);
		local sprite = cinfo:get_front();
		self.sprite = sprite;
		if true == is_piece then
			local path = util.get_path('pic_88.png');
			util.add_sprite(sprite, path, cc.p(50, 380), ANCHOR_LEFT_DOWN, 10);
		end

		pos.y = HALF_HEIGHT;
		local farray = {};
		local action;
		table.insert(farray, cc.CallFunc:create(disable_touch));
		action = cc.EaseIn:create(cc.MoveTo:create(0.2, pos), 0.2);
		table.insert(farray, action);
		table.insert(farray, cc.CallFunc:create(enable_touch));

		sprite:runAction( cc.Sequence:create(farray));
		
		return self.layer, self.name;
	end, 

	show_eff1 = function(self)
		local sprite = self.sprite;
		if nil == sprite then
			return;
		end
		local scale = sprite:getScale();
		sprite:setScale(0.1);
		local farray = {};
		local action;
		action = cc.ScaleTo:create(0.5, scale);
		table.insert(farray, action);
		action = cc.RotateBy:create(0.5, 720);
		table.insert(farray, action);

		action = cc.Spawn:create(farray);
		sprite:runAction(action);
	end,

	handler = function(event, x, y)
		local self = layer_mispop;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
		self:remove();
	end,

} -- layer_mispop end

layer_cardshow = { -- start
	name = 'layer_cardshow',
	layer = nil, 

	cleanup = function(self)
		self.layer = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, list)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_CARDSHOW, self.handler, true);

		util.add_layer_color(self.layer, cc.c4b(0, 0, 0, 150));

		-- ------------------------
		-- --x1,y2---------x2,y2---
		-- ------------------------
		-- ------------------------
		-- ------------------------
		-- --x1,y1---------x2,y1---
		-- ------------------------
		local x1 = HALF_WIDTH/2;
		local x2 = FULL_WIDTH/4*3;
		local y1 = HALF_HEIGHT-hfix(50);
		local y2 = FULL_HEIGHT/4*3;
		local t = 6;
		local function roll(...)
			local args = {...};
			local sprite = args[1];
			local scale = sprite:getScale();
			local c1, c2, ep, bezier, action;
			local array = {};
			local ll = {};
			c1 = cc.p(x1, y1);
			c2 = cc.p(x1, y2);
			ep = cc.p(x1+(x2-x1)/2, y2);
			bezier = { c1, c2, ep };
			action = cc.BezierTo:create(t, bezier);
			table.insert(ll, action);
			action = cc.ScaleTo:create(t, scale*0.7);
			table.insert(ll, action);
			--table.insert(array, cc.EaseIn:create(cc.Spawn:create(ll), t));
			table.insert(array, cc.Spawn:create(ll));
			local function mvfront()
				sprite:setLocalZOrder(10);
			end
			table.insert(array, cc.CallFunc:create(mvfront));
			ll = {};
			c1 = cc.p(x2, y2);
			c2 = cc.p(x2, y1);
			ep = cc.p(x1+(x2-x1)/2, y1);
			bezier = { c1, c2, ep };
			action = cc.BezierTo:create(t, bezier);
			table.insert(ll, action);
			action = cc.ScaleTo:create(t, scale);
			table.insert(ll, action);
			--table.insert(array, cc.EaseOut:create(cc.Spawn:create(ll), t));
			table.insert(array, cc.Spawn:create(ll));
			local function mvback()
				sprite:setLocalZOrder(9);
			end
			table.insert(array, cc.CallFunc:create(mvback));
			sprite:runAction(cc.RepeatForever:create(cc.Sequence:create(array)));
		end
		for i = 1, #list do
			local info = list[i];
			local card = info.card;
			local is_piece = info.is_piece;
			local pos = cc.p(x1+(x2-x1)/2, y1);
			local cwidth = FULL_WIDTH - wfix(70);
			local cheight = FULL_HEIGHT - hfix(340);
			local scale = get_card_scale(cwidth, cheight, CARD_SIZE);
			local cinfo = object_card:new(self.layer, card, nil, nil, pos, 0, scale, STYPE_VER_1);
			local sprite = cinfo:get_front();
			sprite:setLocalZOrder(9);
			if true == is_piece then
				local path = util.get_path('pic_88.png');
				pos = cc.p(50, 300);
				util.add_sprite(sprite, path, pos, ANCHOR_LEFT_DOWN, 10);
			end
			if #list == 1 then
				pos.y = HALF_HEIGHT;
				local farray = {};
				local action;
				table.insert(farray, cc.CallFunc:create(disable_touch));
				action = cc.EaseIn:create(cc.MoveTo:create(0.2, pos), 0.2);
				table.insert(farray, action);
				table.insert(farray, cc.CallFunc:create(enable_touch));

				sprite:runAction( cc.Sequence:create(farray));
				break;
			end
			local fa = {};
			table.insert(fa, cc.DelayTime:create((i-1)*t/#list*2));
			table.insert(fa, cc.CallFunc:create(roll));
			sprite:runAction(cc.Sequence:create(fa));
		end
		
		return self.layer, self.name;
	end, 

	handler = function(event, x, y)
		local self = layer_cardshow;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
		self:remove();
	end,

} -- layer_cardshow end

layer_popclist = { -- start
	name = 'layer_popclist',
	layer = nil, 
	list = nil,
	last_data = nil,
	can_touch = nil,
	btn_again = nil,
	btn_back = nil,

	cleanup = function(self)
		self.layer = nil;
		self.list = nil;
		self.last_data = nil;
		self.can_touch = nil;
		self.btn_again = nil;
		self.btn_back = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self, clist, is_lottery)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_POPCLIST, self.handler, true);

		util.add_layer_color(self.layer, ccc4(0, 0, 0, 150));

		self.can_touch = false;
		self.btn_again = nil;
		self.list = {};

		local t_again = nil;
		if #clist > 1 then
			self:init_for_more(clist);
			t_again = '再抽10次';
		else
			self:init_for_one(clist);
			t_again = '再抽1次';
		end

		local items = {};
		local label, item, pos;

		if true == is_lottery then
			pos = cc.p(HALF_WIDTH/2, hfix(30));
			item = add_item_1(items, t_again, nil, 20, self.do_again, ANCHOR_CENTER_DOWN, pos);
			self.btn_again = item;

			pos = cc.p(HALF_WIDTH/2*3, hfix(30));
		else
			pos = cc.p(HALF_WIDTH, hfix(30));
		end

		item = add_item_1(items, '返回', nil, 20, self.back, ANCHOR_CENTER_DOWN, pos);
		self.btn_back = item;

		util.add_menu(self.layer, items, 80);
		enable_btn(self.btn_again, false);
		enable_btn(self.btn_back, false);
		
		return self.layer, self.name;
	end, 

	back = function()
		layer_popclist:remove();
	end,

	init_for_more = function(self, clist)
		--[[
		local path = util.get_path('l_eff_2.plist');
		local p = util.add_particle(self.layer, path, cc.p(HALF_WIDTH, HALF_HEIGHT), 1);
		]]--
		local speed = 1000;
		local delay = 0;
		local function flip(...)
			local args = {...};
			local tag = args[1]:getTag();
			local info = self.list[tag].info;
			if nil == info then return; end
			local sprite = info.sprite;
			info:flip_to_front();
			--[[
			local x, y = sprite:getPosition();
			local zorder = sprite:getLocalZOrder()-10;
			local scale = sprite:getScale();
			local path = util.get_path('l_eff_1.plist');
			local p = util.add_particle(self.layer, path, cc.p(x, y), zorder);
			p.batch:setScale(scale);
			]]--
		end
		local move_h = hfix(100);
		for i = 1, #clist do
			local card = clist[i];
			local pos = cc.p(HALF_WIDTH, HALF_HEIGHT+move_h/2);
			local cwidth = HALF_WIDTH;
			local cheight = HALF_HEIGHT;
			local scale = get_card_scale(cwidth, cheight, CARD_SIZE);
			local cinfo = object_card:new(self.layer, card, nil, nil, pos, 0, scale, STYPE_VER_1);
			local sprite = cinfo:get_cover();
			self.layer:reorderChild(sprite, 50-i);
			sprite:setTag(i);

			local index = i;
			if i > 5 then
				index = index + 2;
			end

			local offsetx = FULL_WIDTH / 4;
			local x = offsetx/2 + (index-1) % 4 * offsetx;
			local y = FULL_HEIGHT/4*3 - math.floor((index-1)/4) * FULL_HEIGHT/4;
			if i < 5 then
				y = FULL_HEIGHT - cheight/3*2*0.3;
			elseif i > 6 then
				y = cheight/3*2*0.3+move_h;
			else
				y = HALF_HEIGHT+move_h;
			end
			local tpos = cc.p(x, y);
			local tscale = 0.3;
			local offset = math.sqrt(math.pow((x-pos.x),2)+math.pow((y-pos.y),2));
			local array = {};
			local sa = {};
			local t = offset / speed;
			table.insert(array, cc.DelayTime:create(delay));
			table.insert(sa, cc.MoveTo:create(t, tpos));
			table.insert(sa, cc.ScaleTo:create(t, tscale));
			table.insert(array, cc.Spawn:create(sa));
			local orbit_time = 0.3;
			local orbit1 = cc.OrbitCamera:create(orbit_time, 1, 0, 0, -90, 0, 0);
			local orbit2 = cc.OrbitCamera:create(orbit_time, 1, 0, 90, -90, 0, 0);
			table.insert(array, orbit1);
			table.insert(array, cc.CallFunc:create(flip));
			table.insert(array, orbit2);
			table.insert(array, cc.CallFunc:create(self.show_eff));
			if i == #clist then
				table.insert(array, cc.CallFunc:create(self.after_eff));
			end

			local data = { info = cinfo, scale = scale, pos = pos, tpos = tpos, tscale = tscale };
			table.insert(self.list, data);
			sprite:runAction(cc.Sequence:create(array));
			delay = delay + t/2;
		end
	end,

	init_for_one = function(self, clist)
		local card = clist[1];
		if nil == card then 
			self.after_eff(); 
			return;
		end
		local pos = cc.p(HALF_WIDTH, HALF_HEIGHT - hfix(50));
		local cwidth = FULL_WIDTH - wfix(70);
		local cheight = FULL_HEIGHT - hfix(340);
		local scale = get_card_scale(cwidth, cheight, CARD_SIZE);
		local cinfo = object_card:new(self.layer, card, nil, nil, pos, 0, scale, STYPE_VER_1);
		local sprite = cinfo:get_front();
		sprite:setTag(1);
		sprite:setScale(scale*0.5);

		pos.y = HALF_HEIGHT;
		local array = {};
		local sa = {};
		local action;
		table.insert(sa, cc.ScaleTo:create(0.5, scale));
		table.insert(sa, cc.RotateBy:create(0.5, 720));
		table.insert(array, cc.Spawn:create(sa));
		table.insert(array, cc.CallFunc:create(self.show_eff));
		table.insert(array, cc.CallFunc:create(self.after_eff));

		local data = { info = cinfo, scale = scale, pos = pos };
		table.insert(self.list, data);

		sprite:runAction(cc.Sequence:create(array));
	end,

	show_eff = function(...)
		local self = layer_popclist;
		local args = {...};
		local tag = args[1]:getTag();
		local info = self.list[tag].info;
		if nil == info then return; end
		local sprite = info.sprite;
		local num_star = info.card.star or 0;
		if num_star < 4 then return; end
		if nil == sprite then return; end
		local x, y = sprite:getPosition();
		local scale = sprite:getScale();
		local size = sprite:getContentSize();
		local width = size.width*scale;
		local height = size.height*scale;
		local hw = width/2;
		local hh = height/2;
		local x1 = x - hw;
		local x2 = x + hw;
		local y1 = y - hh;
		local y2 = y + hh;
		local path = util.get_path('tutor_star.png');
		local pos = cc.p(x1, y1);
		sprite = util.add_sprite(self.layer, path, pos, ANCHOR_CENTER_CENTER, 60);

		local speed = 250;
		local tx = (x2 - x1) / speed;
		local ty = (y2 - y1) / speed;

		local array = {};
		table.insert(array, cc.MoveTo:create(ty, cc.p(x1, y2)));
		table.insert(array, cc.MoveTo:create(tx, cc.p(x2, y2)));
		table.insert(array, cc.MoveTo:create(ty, cc.p(x2, y1)));
		table.insert(array, cc.MoveTo:create(tx, cc.p(x1, y1)));
		sprite:runAction(cc.RepeatForever:create(cc.Sequence:create(array)));
		sprite:runAction(cc.RepeatForever:create(cc.RotateBy:create(1, 360)));

		path = util.get_path('tutor_tail.plist');
		pos = cc.p(x1, y1);
		local p = util.add_particle(self.layer, path, pos, 55);
		sprite = p.batch;
		sprite:setTag(320);

		array = {};
		table.insert(array, cc.MoveTo:create(ty, cc.p(x1, y2)));
		table.insert(array, cc.MoveTo:create(tx, cc.p(x2, y2)));
		table.insert(array, cc.MoveTo:create(ty, cc.p(x2, y1)));
		table.insert(array, cc.MoveTo:create(tx, cc.p(x1, y1)));

		sprite:runAction(cc.RepeatForever:create(cc.Sequence:create(array)));
	end,

	do_again = function()
		local self = layer_popclist;
		if nil ~= layer_lottery.layer then
			layer_lottery:do_again();
		end
	end,

	after_eff = function()
		local self = layer_popclist;
		self.can_touch = true;
		if #self.list > 1 then
			self:show_card(self.list[1]);
		end
		enable_btn(self.btn_again, true);
		enable_btn(self.btn_back, true);
		if g_tutor_wait_net == tutor_pay_ad_3 then
			g_tutor_wait_net();
		end
	end,

	check_touch = function(self, x, y)
		if 1 == #self.list then return nil; end
		for i = 1, #self.list do
			local data = self.list[i];
			local info = data.info;
			local sprite = info.sprite;
			local ox, oy = sprite:getPosition();
			local size = sprite:getContentSize();
			local scale = sprite:getScale();
			local hw = size.width*scale/2;
			local hh = size.height*scale/2;
			if data ~= self.last_data and x > ox-hw and x < ox+hw and y > oy-hh and y < oy+hh then
				return data;
			end
		end
		return nil;
	end,

	show_card = function(self, data)
		local speed = 1500;
		local move_tag = 333;
		if nil ~= self.last_data then
			local ld = self.last_data;
			local sprite = ld.info.sprite;
			sprite:stopActionByTag(move_tag);
			local p1 = ld.pos;
			local p2 = ld.tpos;
			local offset = math.sqrt(math.pow((p1.x-p2.x),2)+math.pow((p1.y-p2.y),2));
			local array = {};
			local t = offset / (speed*1.5);
			table.insert(array, cc.MoveTo:create(t, p2));
			table.insert(array, cc.ScaleTo:create(t, ld.tscale));
			local action = cc.Spawn:create(array);
			action:setTag(move_tag);
			sprite:runAction(action);
		end
		self.last_data = data;
		local ld = data;
		local p1 = ld.pos;
		local p2 = ld.tpos;
		local sprite = ld.info.sprite;
		local offset = math.sqrt(math.pow((p1.x-p2.x),2)+math.pow((p1.y-p2.y),2));
		local array = {};
		local t = offset / speed;
		table.insert(array, cc.MoveTo:create(t, p1));
		table.insert(array, cc.ScaleTo:create(t, ld.scale));
		local action = cc.Spawn:create(array);
		action:setTag(move_tag);
		sprite:runAction(action);
	end,

	handler = function(event, x, y)
		local self = layer_popclist;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,
	
	onTouchMoved = function(self, x, y)
		
	end,
	
	onTouchEnded = function(self, x, y)
		if true ~= self.can_touch then return; end
		local data = self:check_touch(x, y);
		if nil == data then return; end
		self:show_card(data);
	end,

} -- layer_popclist end

layer_control = { -- start
	name = 'layer_control',
	layer = nil,
	is_stop = nil,
	speed = nil,

	cleanup = function(self)
		self.layer = nil;
		self.is_stop = nil;
		self.speed = nil;
	end,

	remove = function(self)
		g_scene:remove_layer(self.layer, self.name);
	end,

	create = function(self)
		self:remove();

		self.layer = cc.Layer:create();

		util.reg_handler(self.layer, -ZORDER_LAYER_CONTROL, self.handler, false);

		self.is_stop = false;
		self.speed = 1;
		
		local items = {};
		local label, item, pos;
		local size = cc.size(160, 52);

		pos = cc.p(HALF_WIDTH-wfix(30), HALF_HEIGHT);
		item = add_item_1(items, '暂停', nil, 20, self.cb_stop, ANCHOR_RIGHT_CENTER, pos, size);

		pos = cc.p(HALF_WIDTH+wfix(30), HALF_HEIGHT);
		item = add_item_1(items, '速度x1', nil, 20, self.cb_speed, ANCHOR_LEFT_CENTER, pos, size);

		util.add_menu(self.layer, items, 10);

		return self.layer, self.name;
	end,

	cb_stop = function(...)
		local args = {...};
		local item = args[2];
		local label = item:getChildByTag(TAG_SPRITE_LABEL);
		local str = nil;
		local self = layer_control;
		self.is_stop = not self.is_stop;
		local director = cc.Director:getInstance();
		if true == self.is_stop then
			director:pause();
			str = '继续';
		else
			director:resume();
			str = '暂停';
		end
		if nil ~= label then
			label:setString(str);
		end
	end,

	cb_speed = function(...)
		local args = {...};
		local item = args[2];
		local label = item:getChildByTag(TAG_SPRITE_LABEL);
		local str = nil;
		local self = layer_control;
		self.speed = self.speed + 1;
		if self.speed > 2 then
			self.speed = 1;
		end
		local director = cc.Director:getInstance();
		local scheduler = director:getScheduler();
		if 2 == self.speed then
			scheduler:setTimeScale(2);
			str = '速度x2';
		else -- 1 == self.speed
			scheduler:setTimeScale(1);
			str = '速度x1';
		end
		if nil ~= label then
			label:setString(str);
		end
	end,

	handler = function(event, x, y)
		local self = layer_control;

		if "began" == event then   
			return self.onTouchBegan(self, x, y)
		elseif "moved" == event then
			return self.onTouchMoved(self, x, y)
		elseif "ended" == event or "cancelled" == event then
			return self.onTouchEnded(self, x, y)
		elseif "enter" == event then
		elseif "exit" == event then
			self:cleanup();
		elseif "backClicked" == event then
		end
	end,

	onTouchBegan = function(self, x, y)
		return true;
	end,

	onTouchMoved = function(self, x, y)
	end,

	onTouchEnded = function(self, x, y)
	end,
} -- layer_control end
-- /////////////////////// LAYER END   ///////////////////////////

-- /////////////////////// TESTLUA START ///////////////////////////
function show_test1(layer) -- show_test1 start {
	local label = nil;
	local text = "1234567890'labelttf'abcdefghijklmnopgrstuvwxyz不是吧!!";
	local path = util.get_path("zpixel2_ex.ttf");
	local pos = ccp(0, FULL_HEIGHT-80);
	label = util.add_labeloutline(layer, text, path, 40, pos, util.c4b_white, util.c4b_black, 1, ANCHOR_LEFT_UP, 10, cc.size(FULL_WIDTH, 200), cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_TOP);

	pos.y = pos.y - 200;
	label = util.add_labelglow(layer, text, path, 40, pos, util.c4b_white, util.c4b_red, ANCHOR_LEFT_UP, 10, cc.size(FULL_WIDTH, 200), cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

	pos.y = pos.y - 200;
	label = util.add_labelshadow(layer, text, path, 40, pos, util.c4b_white, util.c4b_red, ANCHOR_LEFT_UP, 10, cc.size(FULL_WIDTH, 200), cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

	pos.y = pos.y - 200;
	util.add_labelttf(layer, '字体zpixel2_ex.ttf', path, 22, pos, util.c4b_black, ANCHOR_LEFT_UP, 10, cc.size(FULL_WIDTH, 100), cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);

	--[[
	path = util.get_path("JDJZONGYI_0.ttf");
	pos.y = pos.y - 100;
	util.add_labelttf(layer, 'JDJZONGYI_0.ttf', path, 22, pos, util.c4b_black, ANCHOR_LEFT_UP, 10, cc.size(FULL_WIDTH, 100), cc.TEXT_ALIGNMENT_LEFT, cc.VERTICAL_TEXT_ALIGNMENT_BOTTOM);
	]]--

	--show_loading('加载中');

	local function onTouch(event, x, y)
		if event == "began" then   
			return true;
		elseif event == "moved" then
			return 
		else
			return 
		end
	end
	util.layer_register(layer, -(ZORDER_LAYER_TESTLUA+20), onTouch, false, true);
end -- show_test1 end }

function show_test2(layer) -- show_test2 start {

	local card = clone(g_card_list[22]);	
	local pos = cc.p(CARD_SIZE.width/2+50, FULL_HEIGHT-100-CARD_SIZE.height/2);
	local rotation = 0;
	local scale = 1;
	--local info = object_card:sample(layer, pos, rotation, scale);
	local info = object_card:new(layer, card, nil, nil, pos, rotation, scale);
	local sprite = info:get_front();

	card = clone(g_card_list[22]);	
	pos.x = pos.x + CARD_SIZE.width/2 + CARD_SIZE_2.width/2 + 50;
	info = object_card:new(layer, card, nil, nil, pos,rotation,scale,STYPE_VER_2);
	sprite = info:get_front();

	local function onTouch(event, x, y)
		if event == "began" then   
			return true;
		elseif event == "moved" then
			return 
		else
			return 
		end
	end
	util.layer_register(layer, -(ZORDER_LAYER_TESTLUA+20), onTouch, false, true);
end -- show_test2 end }

function show_test3(layer) -- show_test3 start {

	g_euser.exp_next = 200;
	g_euser.exp_this = 100;
	g_euser.exp = 150;
	g_euser.level = 2;

	local function win_normal()
		g_euser.side = 1;
		local cmd = "win 1 1 0.000000 0 0 27 3360 127 0 0 0 7";
		local input_list = split_string(cmd);
		local check = tonumber(input_list[2]);
		net_win(input_list, cmd, check);
	end

	local function win()
		g_euser.side = 1;
		--local cmd = "win 1 0 0.000000 0 100 27 3360 127 0 0 0 15 1 1 3 3 0 0 1 1 1 0 5 10 1 2 10 0 7 1 4 100 10 2 10 3 22 4 26 0";
		local cmd = "win 1 0 0.000000 0 100 27 3360 1327 0 0 0 15 1 2 3 3 0 0 1 1 1 99 8 10 1 2 12 99 9 1 4 1 10 2 10 3 22 4 26 3"
		local input_list = split_string(cmd);
		local check = tonumber(input_list[2]);
		net_win(input_list, cmd, check);
	end

	local function lose()
		local cmd = "win 2 1 0.000000 0 0 27 3360 27 0 0 0 15 1 1 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 100 10 2 10 3 22 4 26 -1";
		local input_list = split_string(cmd);
		local check = tonumber(input_list[2]);
		net_win(input_list, cmd, check);
	end

	local function draw()
		local cmd = "win 9 1 0.000000 0 0 27 3360 27 0 0 0 15 1 1 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 100 10 2 10 3 22 4 26 -1";
		local input_list = split_string(cmd);
		local check = tonumber(input_list[2]);
		net_win(input_list, cmd, check);
	end

	local function guest()
		local data = {};
		data.winnername = 'kelton';
		local tag = layer_result.TAG_GUEST;
		g_scene:add_layer(ZORDER_LAYER_RESULT, layer_result:create(tag, data));
	end

	local items = {};
	local item;
	local size = cc.size(172, 52);

	pos = cc.p(HALF_WIDTH/2, HALF_HEIGHT/2+hfix(50));
	item = add_item_1(items, 'win_normal', nil, 20, win_normal, ANCHOR_CENTER_CENTER, pos,size);

	pos = cc.p(HALF_WIDTH/2, HALF_HEIGHT/2-hfix(50));
	item = add_item_1(items, 'win', nil, 20, win, ANCHOR_CENTER_CENTER, pos,size);

	pos = cc.p(FULL_WIDTH/3*2, HALF_HEIGHT/2-hfix(50));
	item = add_item_1(items, 'lose', nil, 20, lose,ANCHOR_CENTER_CENTER,pos,size);

	pos = cc.p(FULL_WIDTH/3*2, HALF_HEIGHT);
	item = add_item_1(items, 'draw', nil, 20, draw,ANCHOR_CENTER_CENTER,pos,size);

	pos = cc.p(HALF_WIDTH/2, HALF_HEIGHT);
	item = add_item_1(items, 'guest', nil,20,guest,ANCHOR_CENTER_CENTER,pos,size);

	util.add_menu(layer, items);
	local function onTouch(event, x, y)
		if event == "began" then   
			return true;
		elseif event == "moved" then
			return 
		else
			return 
		end
	end
	util.layer_register(layer, -(ZORDER_LAYER_TESTLUA+20), onTouch, false, true);
end -- show_test3 end }

function show_test4(layer) -- show_test4 start {

	local card = clone(g_card_list[22]);	
	local pos = cc.p(HALF_WIDTH, FULL_HEIGHT / 4 * 3);
	local rotation = 0;
	local scale = 1;
	local info = object_card:new(layer, card, nil, nil, pos, rotation, scale,STYPE_VER_2);
	local s_up = info:get_front();

	card = clone(g_card_list[22]);	
	pos.y = HALF_HEIGHT / 2;
	info = object_card:new(layer, card, nil, nil, pos,rotation,scale,STYPE_VER_2);
	local s_down = info:get_front();

	local function eff_frames()
		play_eff(layer, 2, s_down, s_up, 0, false);
	end

	local function eff_cocostudio()
		play_animation(layer, 2, s_down, s_up, 0, false);
	end

	local function eff_flash()
		local function cbb()
			print('cbb is call');
		end
		--play_flash(layer, 2, s_down, s_up, 0, false, cbb);
		play_flash(layer, 502, s_down, s_up, 0, false, cbb);
	end

	local items = {};
	local item;

	add_item_1(items, 'flash', nil, 25, eff_flash, ANCHOR_LEFT_DOWN, cc.p(0,200));

	add_item_1(items, 'cocostudio', nil, 25, eff_cocostudio, ANCHOR_LEFT_DOWN, cc.p(0, 100));

	add_item_1(items, 'frames', nil, 25, eff_frames, ANCHOR_LEFT_DOWN, cc.p(0,0));

	util.add_menu(layer, items);
	local function onTouch(event, x, y)
		if event == "began" then   
			return true;
		elseif event == "moved" then
			return 
		else
			return 
		end
	end
	util.layer_register(layer, -(ZORDER_LAYER_TESTLUA+20), onTouch, false, true);
end -- show_test4 end }

function show_test5(layer) -- {

	local fullpath = util.get_fullpath(F_IMAGE, 'bg_8.png');
	local pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	local sprite = util.add_sprite(layer, fullpath, pos, ANCHOR_CENTER_CENTER);

	local function cb1()
		show_msg('press btn1');
	end

	local function cb2()
		show_msg('press btn2');
	end

	local items = {};
	local item;
	local size = cc.size(172, 52);

	pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	item = add_item_1(items, 'btn1', nil, 20, cb1, ANCHOR_CENTER_CENTER, pos, size);
	local tsize = item:getContentSize();
	local tpos = cc.p(pos.x-tsize.width/2, pos.y-tsize.height/2);

	pos = cc.p(HALF_WIDTH, HALF_HEIGHT/2*3);
	item = add_item_1(items, 'btn2', nil, 20, cb2, ANCHOR_CENTER_CENTER, pos, size);

	util.add_menu(layer, items, 1);

	util.add_tutorial(tpos, tsize, TUTOR_TEST);

	local t_mark = 0;
	print('t_mark, TUTOR_RES: ', t_mark, TUTOR_RES);
	local a = util.bit_lshift(1, TUTOR_RES);
	t_mark = util.bit_and(t_mark, a);
	print('and1 t_mark: ', t_mark);
	a = util.bit_lshift(1, TUTOR_RES);
	print('lshift: ', a);
	t_mark = util.bit_or(t_mark, a);
	print('or t_mark: ', t_mark);
	a = util.bit_lshift(1, TUTOR_RES);
	t_mark = util.bit_and(t_mark, a);
	print('and t_mark: ', t_mark);

	local function onTouch(event, x, y)
		if event == "began" then   
			return true;
		elseif event == "moved" then
			return 
		else
			return 
		end
	end
	util.layer_register(layer, -(ZORDER_LAYER_TESTLUA+20), onTouch, false, true);
end -- show_test5 end }

function show_test6(layer) -- {
	
	local function cb1()
		local c = #(layer_horselamp.list or {});
		util.show_horselamp(string.format("test #list[%d]", c), 2);
	end

	local items = {};
	local item;
	local size = cc.size(172, 52);

	pos = cc.p(HALF_WIDTH, HALF_HEIGHT);
	item = add_item_1(items, '走马灯', nil, 20, cb1, ANCHOR_CENTER_CENTER, pos, size);

	util.add_menu(layer, items, 1);

	local function handler(event, x, y)
		print('event: ', event);
		if "began" == event then   
			return true;
		elseif "moved" == event then
		elseif "ended" == event or "cancelled" == event then
		elseif "enter" == event then
		elseif "exit" == event then
			layer_horselamp:remove();
		elseif "backClicked" == event then
		end
	end
	util.reg_handler(layer, -(ZORDER_LAYER_HORSELAMP+20), handler, true);
end -- show_test6 end }

function show_test7(layer) -- {
	local seed = 2613; 
	math.randomseed(seed);
	local a = math.random(1, 50);
	local b = math.random(1, 33);
	local c = math.random(1, 74);
	local d = math.random(1, 101); 
	local e; --  = mathf.random(1, 244);
	e = 0;
	for i=1,9999 do
		math.randomseed(i);
		for j=1,1000 do
			e = (e + math.random(1, 200)) % 1000; 
		end   
	end   

	local jitversion = 'jit is nil';
	if nil ~= jit then
		jitversion = jit.version;
	end

	local str = string.format("luajit version = [%s](LuaJIT 2.0.2)\nrandom seed is %d\na = random(1, 50) => [%d](14)\nb = random(1, 33) => [%d](28)\nc = random(1, 74) => [%d](62)\nd = random(1, 101) => [%d](88)\ne = 9999 * 1000 random => [%d](585)\n", jitversion, seed, a, b, c, d, e);
	util.add_labelttf(layer, str, nil, 35, cc.p(0, HALF_HEIGHT), util.c4b_black, ANCHOR_LEFT_CENTER, 1);

	local function handler(event, x, y)
		print('event: ', event);
		if "began" == event then   
			return true;
		elseif "moved" == event then
		elseif "ended" == event or "cancelled" == event then
		elseif "enter" == event then
		elseif "exit" == event then
			layer_horselamp:remove();
		elseif "backClicked" == event then
		end
	end
	util.reg_handler(layer, -(ZORDER_LAYER_HORSELAMP+20), handler, true);
end -- show_test7 end }

function show_test8(layer) -- {
	--local text = "[color=0FFFFF number=998]这是一条测试数据[/color][color=F0FF00]效果还ok吧[/color][image=wsk1.png]口[/image][color=FF0F00]+物攻[/color][color=F0FF00]*[0.4][/color][image=wsk1.png]口[/image][color=F0FF00]*[0.4][/color][color=0FFFFF]清除自身所有负面状态，并向敌军上/下半场吞吐雷电,造成[/color][color=F0FF00][360][/color][image=wsk1.png]口[/image][color=FF0F00]+物攻[/color][color=F0FF00]*[0.4][/color][image=wsk1.png]口[/image][color=F0FF00]*[0.4][/color]";
	local text = "[color=0FFFFF]这是一条测试数据[/color][color=F0FF00]效果还ok吧[/color][image=star.png][/image]";
	local pos = cc.p(50, HALF_HEIGHT);
	local color = cc.c3b(0, 0, 0);
	local label = rich_label.new(layer, pos, text, "Arial", 30, 540, 2, color,10);

	local function handler(event, x, y)
		print('event: ', event);
		if "began" == event then   
			return true;
		elseif "moved" == event then
		elseif "ended" == event or "cancelled" == event then
		elseif "enter" == event then
		elseif "exit" == event then
			layer_horselamp:remove();
		elseif "backClicked" == event then
		end
	end
	util.reg_handler(layer, -(ZORDER_LAYER_HORSELAMP+20), handler, true);
end -- show_test8 end }

function show_test9(layer) -- {
	local a = 1;
	if a == 1 then
		local url = string.format("http://%s:8899/pay_server/apple?", IP_ADDR);
		local args = {
			handler = layer_appstorepay.callback, url = url
		};        
		local luaoc = require "luaoc";
		local class_name = "IAPView";
		local ok, ret = luaoc.callStaticMethod(class_name, "testSend",args);
		return;
	end  

	local function handler(event, x, y)
		print('event: ', event);
		if "began" == event then   
			return true;
		elseif "moved" == event then
		elseif "ended" == event or "cancelled" == event then
		elseif "enter" == event then
		elseif "exit" == event then
			layer_horselamp:remove();
		elseif "backClicked" == event then
		end
	end
	util.reg_handler(layer, -(ZORDER_LAYER_HORSELAMP+20), handler, true);
end -- show_test9 end }

function show_test10(layer) -- {
	--[[
	local pstencil = cc.DrawNode:create();
	layer:addChild(pstencil, ZORDER_CARD-10);

	local fill_color = cc.c4f(0.5, 0.2, 0.2, 0.2);
	local border_color = cc.c4f(0.8, 0, 0, 1);
	local verts = {};
	verts = {
		cc.p(100, 100);
		cc.p(100, 200);
		cc.p(400, 200);
		cc.p(400, 100);
	};
	pstencil:drawPolygon(verts, #verts, fill_color, 3, border_color);
	]]--
	
	local verts = {
		cc.p(100, 200),
		cc.p(500, 300),
		cc.p(250, 400),
		cc.p(100, 200),
	};
	util.draw_line(layer, verts, cc.c4f(1, 0, 0, 1), 20, 10, 1);

	verts = {
		cc.p(100, 700),
		cc.p(500, 700),
		cc.p(500, 800),
		cc.p(100, 800),
		cc.p(100, 700),
	};
	util.draw_line(layer, verts, cc.c4f(1, 0, 0, 1), 20, 10, 1);

	local function handler(event, x, y)
		print('event: ', event);
		if "began" == event then   
			--pstencil:removeFromParent(true);
			return true;
		elseif "moved" == event then
		elseif "ended" == event or "cancelled" == event then
		elseif "enter" == event then
		elseif "exit" == event then
		elseif "backClicked" == event then
		end
	end
	util.reg_handler(layer, -(ZORDER_LAYER_HORSELAMP+20), handler, true);
end -- show_test10 end }
-- /////////////////////// TESTLUA END   ///////////////////////////

-- /////////////////////// GAME START ///////////////////////////
data_handler = {
	has_init_tables = false,
	show_all_card = false,
	is_check_for_teach = false,
	is_auto = 0,

	cleanup = function(self)
		-- TODO need cleanup each layer_xxx ??
		--layer_loading:cleanup();

		g_ui_table = {};
		g_all_card_list = {};
		g_sprite_cache = {};
		g_pic_cache = {};
		g_cache_cmd_list = {};
		g_last_phase = 0;
		g_net_win_data = nil;
		g_is_in_tutor = nil;
		self.has_init_tables = false;
		self.show_all_card = false;
		self.is_check_for_teach = false;
		reset_touchable();
		self.is_auto = 0;
		-- TODO
		--reset_touchable();
	end,

	-- clean card info in table list, is for net_game cmd refresh
	clean_ui_table = function(self)
		if nil == g_ui_table or 0 == #g_ui_table then
			return;
		end
		local sss = { SIDE_UP, SIDE_DOWN };
		local ttt = { T_HERO, T_HAND, T_ALLY, T_SUPPORT, T_GRAVE, T_DECK };
		for i = 1, #sss do
			local ss = g_ui_table[sss[i]];
			for j = 1, #ttt do
				local tt = ss[ttt[j]];
				local len = #tt;
				for i = 1, len do
					table.remove(tt, 1);
				end
			end
		end
		for k, v in pairs(g_sprite_cache) do
			v:removeFromParentAndCleanup(true);
			g_sprite_cache[k] = nil;
		end
		for k, v in pairs(g_pic_cache) do
			v:removeFromParentAndCleanup(true);
			g_pic_cache[k] = nil;
		end
	end,

	init_tables = function(self)
		self:cleanup();

		g_ui_table = {
			[SIDE_UP] = {
				[T_HERO]    = object_uitable:new(UP_HERO),
				[T_HAND]    = object_uitable:new(UP_HAND),
				[T_ALLY]    = object_uitable:new(UP_ALLY),
				[T_SUPPORT] = object_uitable:new(UP_SUPPORT),
				[T_GRAVE]   = object_uitable:new(UP_GRAVE),
				[T_DECK]    = object_uitable:new(UP_DECK),
				[T_RES]     = object_uitable:new(UP_RES),
			},
			[SIDE_DOWN] = {
				[T_HERO]    = object_uitable:new(DOWN_HERO),
				[T_HAND]    = object_uitable:new(DOWN_HAND),
				[T_ALLY]    = object_uitable:new(DOWN_ALLY),
				[T_SUPPORT] = object_uitable:new(DOWN_SUPPORT),
				[T_GRAVE]   = object_uitable:new(DOWN_GRAVE),
				[T_DECK]    = object_uitable:new(DOWN_DECK),
				[T_RES]     = object_uitable:new(DOWN_RES),
			},
			label_res = {
				[SIDE_DOWN] = nil,
				[SIDE_UP] = nil,
			},
			label_res_max = {
				[SIDE_DOWN] = nil,
				[SIDE_UP] = nil,
			},
		};

		g_all_card_list = {
			g_ui_table[SIDE_DOWN][T_HERO],
			g_ui_table[SIDE_DOWN][T_HAND],
			g_ui_table[SIDE_DOWN][T_ALLY],
			g_ui_table[SIDE_DOWN][T_SUPPORT],
			g_ui_table[SIDE_UP][T_HERO],
			g_ui_table[SIDE_UP][T_HAND],
			g_ui_table[SIDE_UP][T_ALLY],
			g_ui_table[SIDE_UP][T_SUPPORT],
		};

		self.has_init_tables = true;
		self.show_all_card = false;
		if true == SHOW_ALL then
			self.show_all_card = true;
		elseif g_scene:is_stage(STAGE_REPLAY) then
			self.show_all_card = true;
		elseif true == SHOW_ALL and nil ~= g_euser.room_data then
			local list = g_euser.room_data.guest_list or {};
			if #list >= 2 then
				for i = 1, 2 do
					local info = list[i];
					if info.eid < 500 then
						self.show_all_card = true;
					end
				end
			end
		end

	end,

	init_game = function(self, seed, deck1_array, deck2_array, side, timeout, solo_data, robot_data, hero_info)
		anim.reset_data();
		reset_win_data();
		timeout = timeout or 0;
		if false == self.has_init_tables then
			self:init_tables();
		end

		--[[
		local deck1, deck2;
		local hero1, hero2;
		deck1, hero1 = card_array_list(deck1_array);
		deck2, hero2 = card_array_list(deck2_array);
		--local ddata = side .. ' ' .. hero1 .. ' ' .. hero2;
		--ddata = ddata .. ' ' .. deck1_array .. ' ' .. deck2_array;
		--ddata = ddata .. ' ' .. seed .. ' ' .. timeout;
		--push_playcmd_list(ddata);
		logic_init(hero1, hero2, deck1, deck2, seed, timeout);
		]]--
		if nil == deck1_array then
			local tt = deck2_array;
			local ret, cmd = game_init(tt);
			if ret < 0 then
				g_scene:map();
				local err = ret .. ' msg: ' .. cmd;
				show_msg(err);
				return;
			end
			return cmd;
		elseif nil ~= deck2_array then
			local hp1, hp2, energy1, energy2 = 0, 0, 0, 0;
			if nil ~= hero_info then
				hp1 = hero_info.hp1;
				hp2 = hero_info.hp2;
				energy1 = hero_info.energy1;
				energy2 = hero_info.energy2;
			end
			logic_init_array(deck1_array, deck2_array, seed, side, hp1, hp2, energy1, engergy2);
		elseif nil ~= solo_data then
			if solo_data.check_teach == 1 then
				data_handler.is_check_for_teach = true;
			end
			solo_init_array(deck1_array, solo_data.deck2_list, 
			                solo_data.type_flag, solo_data.max_ally, 
							solo_data.max_hp, solo_data.myhero_hp, 
							solo_data.myhero_energy, solo_data.type_list, seed);
		else
			robot_init_array(deck1_array, robot_data.deck2_list, seed);
		end
		return;
	end,

	init_gate = function(self, seed, deck1_array, gate_list, side)
		anim.reset_data();
		reset_win_data();
		timeout = timeout or 0;
		if false == self.has_init_tables then
			self:init_tables();
		end

		gate_init_array(deck1_array, gate_list, seed);
	end,

	init_side = function(self, my_side)
		g_euser.side = my_side;
		-- In logic, side_up is 1, side_down is 2
		-- so in PVP, if my_side is 1, in order to turn my_side to be down side
		-- will exchange up and side marks values
		if 1 == my_side then
			SIDE_UP       = 2;
			SIDE_DOWN     = 1;

			DOWN_HERO     = 1001; 
			DOWN_HAND     = 1002;
			DOWN_ALLY     = 1003;
			DOWN_SUPPORT  = 1004;
			DOWN_GRAVE    = 1005;
			DOWN_DECK     = 1006;
			DOWN_RES      = 1007;
			UP_HERO       = 2001;
			UP_HAND       = 2002;
			UP_ALLY       = 2003;
			UP_SUPPORT    = 2004;
			UP_GRAVE      = 2005;
			UP_DECK       = 2006;
			UP_RES        = 2007;

		else -- 2 == my_side
			SIDE_UP       = 1;
			SIDE_DOWN     = 2;

			DOWN_HERO     = 2001;
			DOWN_HAND     = 2002;
			DOWN_ALLY     = 2003;
			DOWN_SUPPORT  = 2004;
			DOWN_GRAVE    = 2005;
			DOWN_DECK     = 2006;
			DOWN_RES      = 2007;
			UP_HERO       = 1001;
			UP_HAND       = 1002;
			UP_ALLY       = 1003;
			UP_SUPPORT    = 1004;
			UP_GRAVE      = 1005;
			UP_DECK       = 1006;
			UP_RES        = 1007;
		end
	end,

}

object_card = { -- start
	-- stype: size type
	new = function(self, layer, card, sprite, alist, pos, rotation, scale, stype)
		if nil == card then
			kerror("object_card card is nil");
			return nil;
		end
		scale = scale or 1;
		stype = stype or STYPE_VER_1;
		local data = self:get_data(card, sprite);
		local proxy = {
			layer = layer,
			stype = stype,
			card = card,
			card_sprite = sprite,
			attach_list = alist or {},
			frame = {
				x = pos.x,
				y = pos.y,
				width = 0,
				height = 0,
				scale = scale or data.scale,
				rotation = rotation or data.rotation,
				zorder = data.zorder,
			},
			data = {
				left_top = data.left_top,
				left_bottom = data.left_bottom,
				right_bottom = data.right_bottom,
			},
			status = CARD_FRONT,
		};
			
		setmetatable(proxy, self);
		return proxy;
	end,

	sample = function(self, layer, pos, rotation, scale, stype)
		local card = {
			id = 1,
			ctype = HERO,
			name = 'Kel测试ton',
			cost = 10,
			power = 12,
			energy = 31,
			hp = 29,
			skill_desc = 'this is abcd\n这是中文啊',
			is_test = true;
		};
		return self:new(layer, card, nil, nil, pos, rotation, scale, stype);
	end,

	copy = function(self, layer, stype, pos, scale, rotation)
		local card = clone(self.card);
		local frame = self.frame;
		local pos = pos or ccp(frame.x, frame.y);
		local rotation = rotation or frame.rotation;
		local scale = scale or frame.scale;
		local copy = object_card:new(layer,card,nil,nil,pos,rotation,scale,stype);
		return copy;
	end,

	set_data = function(self, lt, lb, rb)
		if nil ~= lt then
			self.data.left_top = lt;
		end
		if nil ~= lb then
			self.data.left_bottom = lb;
		end
		if nil ~= rb then
			self.data.right_bottom = rb;
		end
	end,

	get_data = function(self, card, sprite)
		local data = {};
		local label_lt = nil; -- left_top
		local label_lb = nil; -- left_down
		local label_rb = nil; -- right_down
		if nil ~= sprite then
			local label = sprite:getChildByTag(TAG_COST);
			tolua.cast(label, "cc.Label");
			label_lt = label;
			label = sprite:getChildByTag(TAG_POWER);
			tolua.cast(label, "cc.Label");
			label_lb = label;
			label = sprite:getChildByTag(TAG_HP);
			tolua.cast(label, "cc.Label");
			label_rb = label;

			data.zorder = sprite:getLocalZOrder();
			data.scale = sprite:getScale();
			data.rotation = sprite:getRotation();
		else
			data.zorder = 0;
			data.scale = 1;
			data.rotation = 0;
		end
		if nil ~= label_lt then
			data.left_top = tonumber(label_lt:getString());
		else
			if card.ctype ~= HERO then
				data.left_top = card.cost;
			end
		end
		if ABILITY == card.ctype or ATTACH == card.ctype 
				or SUPPORT == card.ctype or ARTIFACT == card.ctype
				or TRAP == card.ctype then
			return data;
		end
		if nil ~= label_lb then
			data.left_bottom = tonumber(label_lb:getString());
		else
			if card.ctype == HERO then
				data.left_bottom = card.energy;
			else
				data.left_bottom = card.power;
			end
		end
		if nil ~= label_rb then
			data.right_bottom = tonumber(label_rb:getString());
		else
			data.right_bottom = card.hp;
		end
		return data;
	end,

	-- deprecated , use local function instead, see in create_sprite
	cb_clean = function(event)
		if "enter" == event then
		elseif "exit" == event then
			--print('DEBUG cb_clean');
		end
	end,

	clean_sprite = function(self)
		local sprite = g_sprite_cache[self.card];
		if nil == sprite then
			return;
		end
		sprite:removeAllChildrenWithCleanup(true);
	end,

	remove_sprite = function(self)
		local sprite = self.card_sprite;
		self.card_sprite = nil;
		g_sprite_cache[self.card] = nil;
		if nil == sprite then
			return;
		end
		sprite:removeFromParentAndCleanup(true);
	end,

	get_ver_str = function(self, stype)
		if STYPE_VER_2 == stype then
			return '_2';
		else
			return '';
		end
	end,

	get_bg = function(self, status, stype)
		stype = stype or self.stype;
		local card = self.card;
		local str = self:get_ver_str(stype);
		local filename = nil;
		if stype == STYPE_VER_2 then
			if CARD_COVER == status then
				filename = 'bg_24.png';--'bg_card_cover.png';
			elseif CARD_GRAVE == status then
				filename = 'bg_88.png';--'frame_pic.png';
			elseif CARD_HERO == status then
				filename = 'bg_93.png';--'bg_25.png';
			elseif CARD_HERO_ATTACH == status then
				filename = 'bg_102.png';
			--elseif CARD_ALLY == status then
			--	filename = 'bg_19';--'bg_card_ally.png';
			--elseif CARD_ATTACH == status then
			--	filename = 'bg_card_magic.png';
			else -- CARD_FRONT == status
				if ARMOR == card.ctype then
					filename = 'bg_20.png';--'bg_card_armor.png';
				elseif HERO == card.ctype then
					filename = 'bg_21.png';--'bg_card_hero.png';
				elseif ALLY == card.ctype then
					filename = 'bg_19.png';--'bg_card_ally.png';
				elseif WEAPON == card.ctype then
					filename = 'bg_23.png';--'bg_card_weapon.png';
				else --if ABILITY == card.ctype or ATTACH == card.ctype or SUPPORT == card.ctype or ARTIFACT == card.ctype then
					filename = 'bg_22.png';--'bg_card_magic.png';
				end
			end
		else
			if CARD_FRONT == status then
				--filename = 'c_bg' .. str .. '.png';
				filename = 'bg_151.png';
			elseif CARD_COVER == status then
				filename = 'cover' .. str .. '.png';
			elseif CARD_GRAVE == status then
				filename = 'frame_pic.png';
			elseif CARD_ALLY == status then
				filename = 'c_bg' .. str .. '.png';
			elseif CARD_SUPPORT == status then
				filename = 'c_bg' .. str .. '.png';
			elseif CARD_HERO == status then
				filename = 'bg_25.png';
			elseif CARD_ATTACH == status then
				filename = 'c_bg' .. str .. '.png';
			end
		end
		return filename;
	end,

	create_sprite = function(self)
		local status = self.status;
		local filename = self:get_bg(status);
		if nil == filename then
			return nil;
		end
		local path = util.get_path(filename);
		--local sprite = self.card_sprite;
		local sprite = g_sprite_cache[self.card];
		if nil == sprite then
			sprite = EvilSprite:create(path);
			local function cb_clean(event)
				local card = self.card;
				if "enter" == event then
					--print('DEBUG cb_enter: ', card.name, cindex(card), card.id);
					--self.card_sprite = sprite;
					--g_sprite_cache[card] = self.card_sprite;
				elseif "exit" == event then
					--[[
					if true ~= card.is_test then
					print('DEBUG cb_clean: ', card.name, cindex(card), card.id);
					end
					]]--
					--self.card_sprite = nil;
					-- don't set g_sprite_cache here, card is no use
					--g_sprite_cache[card] = nil;
				end
			end
			--util.node_register(sprite, self.cb_clean);
			util.node_register(sprite, cb_clean);
			self.layer:addChild(sprite, ZORDER_CARD);

			--
			local frame = self.frame;
			sprite:setPosition(cc.p(frame.x, frame.y));
			sprite:setAnchorPoint(ANCHOR_CENTER_CENTER);
			sprite:setRotation(frame.rotation);
			sprite:setScale(frame.scale);
			self.frame.width = sprite:getContentSize().width * frame.scale;
			self.frame.height = sprite:getContentSize().height * frame.scale;
			--

			-- TODO maybe cache the object will be better
			g_sprite_cache[self.card] = sprite;
		else
			self:clean_sprite();
			local tc = CCTextureCache:sharedTextureCache();
			local texture = tc:addImage(path);
			local size = texture:getContentSize();
			sprite:setTexture(texture);
			--sprite:setContentSize(size);
			sprite:setTextureRect(cc.rect(0, 0, size.width, size.height));
		end

		self.card_sprite = sprite;
		return sprite;
	end,

	init_front_info_ver_1 = function(self, sprite)
		local card = self.card;
		local pos, size;
		local width = sprite:getContentSize().width;
		local height = sprite:getContentSize().height;
		local hwidth = math.floor(width / 2);
		local hheight = math.floor(height / 2);
		local label, str;

		local filename = 'card' .. card.id .. '.png';
		local path, is_exist = util.get_path(filename, 'card0.png');
		if true ~= is_exist then
			--net_send_dres(filename);
		end
		local zorder = ZORDER_CARD_IMAGE;
		pos = ccp(hwidth, height-40);
		local pic = util.add_sprite(sprite, path,pos,ANCHOR_CENTER_UP,zorder);

		-- description
		str = card.skill_desc;
		pos = cc.p(hwidth, height/2-106);
		size = cc.size(230, 120);
		label = util.add_labelttf(sprite, str, nil, 19, pos, util.c4b_white, ANCHOR_CENTER_UP, nil, size, cc.TEXT_ALIGNMENT_LEFT,cc.VERTICAL_TEXT_ALIGNMENT_TOP);
		label:setTag(TAG_DESC);

		-- card name
		if true == DEBUG_MODE then
			str = card.name .. '(' .. card.id .. ')';
		else
			str = card.name;
		end
		pos = ccp(hwidth, height/2-56);
		label = util.add_labelttf(sprite, str, nil, 23, pos, util.c4b_white, ANCHOR_CENTER_CENTER, nil, cc.size(width, 26), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
		label:setTag(TAG_NAME); -- use for detect is front or back

		str = '[' .. ctype_to_str(card.ctype, card.is_bow) .. ']' .. job_name(card.job);
		if true == card.unique then
			str = str .. '[唯一]';
		end
		pos = ccp(width/2, 20);
		label = util.add_labelttf(sprite, str, nil, 20, pos, util.c4b_white, ANCHOR_CENTER_DOWN, nil, cc.size(width, 26), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);

		local num_star = card.star or 0;
		path = util.get_path('star.png');
		pos = ccp(width - 25, height - 50);
		for i = 1, num_star do
			local star = util.add_sprite(sprite, path,pos,ANCHOR_RIGHT_UP, 1);
			pos.y = pos.y - star:getContentSize().height;
		end

		local data = self.data;
		local fontpath = util.get_path(FNT_CARD);
		
		str = data.left_top;
		local fname;
		if nil ~= str then
			path = util.get_path('icon_54.png');
			pos = ccp(-18, height);
			util.add_sprite(sprite, path, pos, ANCHOR_LEFT_UP);
			
			pos = ccp(18, height-38);
			label=util.add_labelbmf(sprite,str,fontpath,pos,ANCHOR_CENTER_CENTER);
			label:setTag(TAG_COST);
		end

		str = data.left_bottom;
		if nil ~= str then
			if ARMOR == card.ctype then
				fname = 'icon_59.png';
				pos = ccp(-19, -12);
			elseif HERO == card.ctype then
				fname = 'icon_57.png';
				pos = ccp(-19, -12);
			else
				fname = 'icon_55.png';
				pos = ccp(-50, -16);
			end
			path = util.get_path(fname);
			util.add_sprite(sprite, path, pos, ANCHOR_LEFT_DOWN);

			if ARMOR == card.ctype then
				pos = ccp(18, 32);
			elseif HERO == card.ctype then
				pos = ccp(18, 32);
			else
				pos = ccp(18, 32);
			end
			label=util.add_labelbmf(sprite,str,fontpath,pos,ANCHOR_CENTER_CENTER);
			label:setTag(TAG_POWER);
		end

		str = data.right_bottom;
		if nil ~= str then
			if ARMOR == card.ctype or WEAPON == card.ctype then
				fname = 'icon_58.png';
			else
				fname = 'icon_56.png';
			end
			path = util.get_path(fname);
			pos = ccp(width+18, -12);
			util.add_sprite(sprite, path, pos, ANCHOR_RIGHT_DOWN);

			if ARMOR == card.ctype or WEAPON == card.ctype then
				pos = ccp(width-20, 32);
			else
				pos = ccp(width-20, 32);
			end
			label=util.add_labelbmf(sprite,str,fontpath,pos,ANCHOR_CENTER_CENTER);
			label:setTag(TAG_HP);
		end
	end,

	init_front_info_ver_2 = function(self, sprite)
		local card = self.card;
		local pos, size;
		local width = sprite:getContentSize().width;
		local height = sprite:getContentSize().height;
		local hwidth = math.floor(width / 2);
		local hheight = math.floor(height / 2);
		local label, str, fsize;

		local filename = 'card' .. card.id .. '.png';
		local path, is_exist = util.get_path(filename, 'card0.png');
		local mask_path = util.get_path('bg_94.png');
		if true ~= is_exist then
			--net_send_dres(filename);
		end
		local zorder = ZORDER_CARD_IMAGE;
		pos = cc.p(hwidth+6, hheight);
		local pic = util.add_mask_sprite(sprite, path, mask_path, pos, ANCHOR_CENTER_CENTER, zorder);
		pic:setScale((height-10)/PIC_SIZE.height);

		--[[
		-- card name
		str = card.name;
		pos = ccp(hwidth, hheight-30);
		--label = util.add_labelttf(sprite, str, nil, 20, pos, util.c_white, ANCHOR_CENTER_CENTER, nil, cc.size(width, 20), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
		label = util.add_labelsys(sprite, str, nil, 11, pos, util.c_white, ANCHOR_CENTER_CENTER, nil, cc.size(width, 20), cc.TEXT_ALIGNMENT_CENTER, cc.VERTICAL_TEXT_ALIGNMENT_CENTER);
		label:setTag(TAG_NAME); -- use for detect is front or back

		local num_star = card.star or 0;
		path = util.get_path('star_2.png');
		pos = ccp(width - 10, height - 20);
		for i = 1, num_star do
			local star = util.add_sprite(sprite, path,pos,ANCHOR_RIGHT_UP, 1);
			pos.y = pos.y - star:getContentSize().height;
		end
		]]--

		local data = self.data;
		local fontpath = util.get_path(FNT_CARD_2);
		
		str = data.left_top;
		local fname;
		if nil ~= str then
			pos = ccp(27, height-23);
			label=util.add_labelbmf(sprite,str,fontpath,pos,ANCHOR_CENTER_CENTER);
			label:setTag(TAG_COST);
		end

		str = data.left_bottom;
		if nil ~= str then
			if ARMOR == card.ctype then
				pos = ccp(27, 12);
			elseif HERO == card.ctype then
				pos = ccp(12, 12);
			else
				pos = ccp(27, 12);
			end
			label=util.add_labelbmf(sprite,str,fontpath,pos,ANCHOR_CENTER_CENTER);
			label:setTag(TAG_POWER);
		end

		str = data.right_bottom;
		if nil ~= str then
			if ARMOR == card.ctype or WEAPON == card.ctype then
				pos = ccp(width-14, 12);
			else
				pos = ccp(width-14, 12);
			end
			label=util.add_labelbmf(sprite,str,fontpath,pos,ANCHOR_CENTER_CENTER);
			label:setTag(TAG_HP);
		end
	end,

	init_front_info = function(self, sprite, stype)
		stype = stype or self.stype;
		if STYPE_VER_2 == stype then
			self:init_front_info_ver_2(sprite);
		else
			self:init_front_info_ver_1(sprite);
		end
	end,

	init_hero_info = function(self, sprite)
		local card = self.card;
		local path, filename, pos;
		--[[
		filename = 'card' .. card.id .. '.png';
		local is_exist, pic;
		fullpath, is_exist = util.get_fullpath(F_PIC, filename, 'card0.png');
		if true ~= is_exist then
			--net_send_dres(filename);
		end
		]]--
		--filename = 'hero_' .. card.id .. '.png';
		--path, is_exist = util.get_path(filename, 'hero_0.png');
		--[[ -- TODO download image bug
		if true ~= is_exist then
			net_send_dres(filename);
		end
		]]--
		filename = 'card' .. card.id .. '.png';
		path, is_exist = util.get_path(filename, 'card0.png');
		local zorder = ZORDER_CARD_IMAGE;
		--local scale = sprite:getScale();
		local size = sprite:getContentSize();
		--[[
		pos = ccp(size.width/2, 0);
		print('fullpath: ', fullpath);
		pic = util.add_sprite(sprite,fullpath,pos,ANCHOR_CENTER_DOWN,zorder);
		]]--
		pos = ccp(size.width/2, size.height/2);
		local mask_path = util.get_path('bg_96.png');
		pic = util.add_mask_sprite(sprite, path, mask_path, pos, ANCHOR_CENTER_CENTER, zorder);
		--pic:setScale((size.height-4)/PIC_SIZE.height);
		--pic:setScale(scale);

		local data = self.data;
		local str = data.left_bottom;
		local label;
		if nil ~= str then
			local path = util.get_path(FT_5);
			pos = cc.p(31, 33);
			label=util.add_labelbmf(sprite,str,path,pos,ANCHOR_CENTER_CENTER);
			label:setTag(TAG_POWER);
			--label:setScale(0.5);
		end

		str = data.right_bottom;
		if nil ~= str then
			local path = util.get_path(FT_6);
			pos = ccp(size.width-33, 33);
			label=util.add_labelbmf(sprite,str,path,pos,ANCHOR_CENTER_CENTER);
			label:setTag(TAG_HP);
			--label:setScale(0.5);
		end
	end,

	get_front = function(self)
		self.status = CARD_FRONT;
		local sprite = self:create_sprite();
		if nil == sprite then
			return;
		end
		self:init_front_info(sprite);

		-- create attach card
		local attach_list = { cscale = 1 };
		local alist = self.card.attach_list;
		if alist ~= nil and #alist > 0 then
			local a_index = 1;
			local v_index = 1;
			local psize = sprite:getContentSize();
			local size = CARD_SIZE_2;
			for i = 1, #alist do
				-- attach card
				local ac = alist[i]; 
				local pos = ccp(psize.width/2, psize.height/2);
				if ac.id > 1000 then -- virtual card
					local ainfo = add_ui_card(sprite, attach_list, pos, 0, ac);
					ainfo:reset_zorder(v_index);
					v_index = v_index + 1;
				else -- not virtual card
					pos.y = pos.y + a_index * math.floor(size.height / 7);
					local ainfo = add_ui_card(sprite, attach_list, pos, 0, ac);
					ainfo:reset_zorder(ZORDER_CARD_ATTACH-a_index);
					a_index = a_index + 1;
				end
			end
		end
		self.attach_list = attach_list;

		return sprite;
	end,

	get_cover = function(self)
		self.status = CARD_COVER;
		local sprite = self:create_sprite();
		if nil == sprite then
			return;
		end
		return sprite;
	end,

	get_grave = function(self)
		self.status = CARD_GRAVE;
		local sprite = self:create_sprite();
		if nil == sprite then
			return;
		end
		local width = sprite:getContentSize().width;
		local height = sprite:getContentSize().height;
		local hwidth = math.floor(width / 2);
		local hheight = math.floor(height / 2);
		local card = self.card;
		local path, pos;
		local filename = 'card' .. card.id .. '.png';
		local is_exist;
		path, is_exist = util.get_path(filename, 'card0.png');
		if true ~= is_exist then
			--net_send_dres(filename);
		end
		local zorder = ZORDER_CARD_IMAGE;
		pos = ccp(0, 0);
		--local pic = util.add_sprite(sprite, path,pos,ANCHOR_LEFT_DOWN,zorder);
		local mask_path = util.get_path('bg_95.png');
		pos = cc.p(hwidth, hheight);
		local pic = util.add_mask_sprite(sprite, path, mask_path, pos, ANCHOR_CENTER_CENTER, zorder);
		pic:setScale(height/PIC_SIZE.height);
		return sprite;
	end,

	get_hero_attach = function(self)
		self.status = CARD_HERO_ATTACH;
		local sprite = self:create_sprite();
		if nil == sprite then
			return;
		end
		local width = sprite:getContentSize().width;
		local height = sprite:getContentSize().height;
		local card = self.card;
		local path, pos;
		local filename = 'card' .. card.id .. '.png';
		local is_exist;
		path, is_exist = util.get_path(filename, 'card0.png');
		if true ~= is_exist then
			--net_send_dres(filename);
		end
		local zorder = ZORDER_CARD_IMAGE;
		pos = ccp(width/2, height/2);
		local pic = util.add_sprite(sprite, path,pos,ANCHOR_CENTER_CENTER,zorder);
		pic:setScaleX((width-5)/pic:getContentSize().width);
		pic:setScaleY((height-5)/pic:getContentSize().height);
		return sprite;
	end,

	get_ally = function(self)
		self.status = CARD_ALLY;
		local sprite = self:create_sprite();
		if nil == sprite then
			return;
		end
		self:init_front_info(sprite);
		return sprite;
	end,

	get_support = function(self)
		self.status = CARD_SUPPORT;
		local sprite = self:create_sprite();
		if nil == sprite then
			return;
		end
		self:init_front_info(sprite);
		return sprite;
	end,

	get_hero = function(self)
		self.status = CARD_HERO;
		local sprite = self:create_sprite();
		if nil == sprite then
			return;
		end
		self:init_hero_info(sprite);

		-- create attach card
		local attach_list = { cscale = 1 };
		local alist = self.card.attach_list;
		if alist ~= nil and #alist > 0 then
			local a_index = 1;
			local v_index = 1;
			local total_v = 0;
			for i=1, #alist do
				local ac = alist[i];
				if ac.id > 1000 then
					total_v = total_v + 1;
				end
			end
			local hcw = nil;
			local hch = nil;
			local size = sprite:getContentSize();
			for i = 1, #alist do
				-- attach card
				local ac = alist[i]; 
				local pos = ccp(size.width/2, size.height/2);
				local csize = CARD_SIZE_2;
				local size = { width = csize.width, height = csize.height };
				if ac.id > 1000 then -- virtual card
					local ainfo = add_ui_card(sprite, attach_list, pos, 0, ac);
					ainfo:reset_zorder(v_index);
					v_index = v_index + 1;
				else -- not virtual card
					if nil == ch then
						hcw = 45 / 2; -- bg_102.png; 
						hch = 42 / 2; -- bg_102.png;
					end
					pos.x = hcw + 10;
					pos.y = size.height - hch - 5 - (a_index-1) * hch;
					local ainfo = add_ui_card(sprite,attach_list,pos,0,ac);
					ainfo:reset_zorder(total_v+a_index);
					a_index = a_index + 1;
				end
			end
		end
		self.attach_list = attach_list;
		return sprite;
	end,

	get_attach = function(self)
		self.status = CARD_ATTACH;
		local sprite = self:create_sprite();
		if nil == sprite then
			return;
		end
		self:init_front_info(sprite);
		return sprite;
	end,

	get_virtual = function(self)
		self.status = CARD_VIRTUAL;

		local sprite = nil;
		local card = self.card;
		local layer = self.layer;
		if nil == card or nil == layer then
			return sprite;
		end
		------
		local vtype = card.vtype or 0;
		local pos = cc.p(self.frame.x, self.frame.y);
		local eff_pos = cc.p(0, 0);
		local eff_scale = 1;
		local size = (self.stype==STYPE_VER_2) and CARD_SIZE_2 or CARD_SIZE;
		local eff_id = 0;
		if 1 == vtype then -- ablaze
			eff_id = 1;
			eff_pos.x = eff_pos.x + size.width/2-10;
			eff_pos.y = eff_pos.y + size.height/2-10;
			eff_scale = 0.4;
		elseif 2 == vtype or 6 == vtype then -- cobweb
			eff_id = 4;
			eff_pos.x = eff_pos.x + size.width/2-10;
			eff_pos.y = eff_pos.y + size.height/2-10;
			eff_scale = 0.4;
		elseif 3 == vtype then -- frozen
			eff_id = 3;
		elseif 4 == vtype then -- poison
			eff_id = 2;
			eff_pos.x = eff_pos.x + size.width/2-10;
			eff_pos.y = eff_pos.y + size.height/2-10;
			eff_scale = 0.4;
		end
		local sprite;
		sprite = cc.Node:create();
		sprite:setPosition(pos);
		sprite:setRotation(self.frame.rotation);
		layer:addChild(sprite, ZORDER_CARD);
		if 0 ~= eff_id then
			local s = add_status_eff_sprite(sprite,eff_id,eff_pos,ANCHOR_CENTER_CENTER, eff_scale, 1);
			s:setTag(TAG_STATUS_SPRITE);
		end
		self.card_sprite = sprite;
		g_sprite_cache[self.card] = self.card_sprite;
		--create_virtual_particle(sprite, vtype);
		update_attachment_timer(sprite, self.card);
		------------------------
		--[[
		local eff_name = nil;
		if 1 == vtype then
			eff_name = 'ablaze';
		elseif 2 == vtype then
			eff_name = 'cobweb';
		elseif 3 == vtype then
			eff_name = 'frozen';
		elseif 4 == vtype then
			eff_name = 'poison';
		elseif 5 == vtype then
			eff_name = 'stealth';
		end
		local pos = ccp(self.frame.x, self.frame.y);
		local sprite = nil;
		if nil ~= eff_name then
			local filename = 'v_' .. eff_name .. '_1.png';
			local path = util.get_path(filename);
			local cid = cindex(self.card);
			local mask_path;
			local tt = index_table_num(cindex(self.card));
			if tt == T_HERO then
				mask_path = util.get_path('v_mask_hero.png');
			else
				mask_path = util.get_path('v_mask_card.png');
			end
			sprite = util.add_mask_sprite(layer, path, mask_path, pos, ANCHOR_CENTER_CENTER, 1);
		else
			--print('------ cid: ', self.card.id);
			if 6 == vtype then
			--if 1021 == self.card.id then
				local path = util.get_path('status_no_attack.png');
				sprite = util.add_sprite(layer, path, cc.p(pos.x, pos.y), ANCHOR_CENTER_CENTER, 1);
			else
				sprite = cc.Node:create();
				sprite:setPosition(pos);
				layer:addChild(sprite, 1);
			end
		end
		--sprite:setBlendFunc(gl.DST_COLOR, gl.SRC_COLOR);
		--local sprite = util.add_sprite(layer, path, pos, ANCHOR_CENTER_CENTER, 1);
		sprite:setRotation(self.frame.rotation);
		--sprite:setScale(self.frame.scale);

		self.card_sprite = sprite;
		g_sprite_cache[self.card] = self.card_sprite;
		
		create_virtual_particle(sprite, vtype);

		update_attachment_timer(sprite, self.card);
		]]--
		return sprite;
	end,

	get_grave_sprite = function(self, layer, pos, rotation, scale)
		local sprite = nil;
		local stype = STYPE_VER_1;
		local filename = self:get_bg(CARD_FRONT, stype);
		if nil == filename then
			return sprite;
		end
		--local fullpath = util.get_fullpath(F_IMAGE, filename);
		--sprite = EvilSprite:create(fullpath);
		local path = util.get_path(filename);
		sprite = EvilSprite:create(path);
		local function cb_clean(event)
			local card = self.card;
			if "enter" == event then
				--self.card_sprite = sprite;
				--g_sprite_cache[card] = self.card_sprite;
			elseif "exit" == event then
				--[[
				if true ~= card.is_test then
				--print('DEBUG cb_clean: ', card.name, cindex(card), card.id);
				end
				]]--
				--self.card_sprite = nil;
				-- don't set g_sprite_cache here, card is no use
				--g_sprite_cache[card] = nil;
			end
		end
		--util.node_register(sprite, self.cb_clean);
		util.node_register(sprite, cb_clean);
		layer:addChild(sprite, ZORDER_CARD);

		sprite:setPosition(pos);
		sprite:setAnchorPoint(ANCHOR_CENTER_CENTER);
		sprite:setRotation(rotation);
		sprite:setScale(scale);
		self:init_front_info(sprite, stype);

		return sprite;
	end,

	get_show_sprite = function(self, layer, pos, rotation, scale)
		local sprite = nil;
		local stype = STYPE_VER_1;
		local filename = self:get_bg(CARD_FRONT, stype);
		if nil == filename then
			return sprite;
		end
		local fullpath = util.get_fullpath(F_IMAGE, filename);
		sprite = EvilSprite:create(fullpath);
		util.node_register(sprite, self.cb_clean);
		layer:addChild(sprite, ZORDER_CARD);

		sprite:setPosition(pos);
		sprite:setAnchorPoint(ANCHOR_CENTER_CENTER);
		sprite:setRotation(rotation);
		sprite:setScale(scale);
		self:init_front_info(sprite, stype);

		return sprite;
	end,

	get_show_sprite_hero = function(self, layer, pos, rotation, scale)
		local sprite = nil;
		local stype = STYPE_VER_1;
		local filename = self:get_bg(CARD_HERO, stype);
		if nil == filename then
			return sprite;
		end
		local fullpath = util.get_fullpath(F_IMAGE, filename);
		sprite = EvilSprite:create(fullpath);
		local function cb_clean(event)
			local card = self.card;
			if "enter" == event then
			elseif "exit" == event then
			end
		end
		util.node_register(sprite, cb_clean);
		layer:addChild(sprite, ZORDER_CARD);

		sprite:setPosition(pos);
		sprite:setAnchorPoint(ANCHOR_CENTER_CENTER);
		sprite:setRotation(rotation);
		sprite:setScale(scale);
		self:init_hero_info(sprite, stype);

		return sprite;
	end,

	get_action_sprite = function(self, layer, pos, rotation, scale)
		local sprite = nil;
		local stype = STYPE_VER_1;
		local filename = self:get_bg(CARD_FRONT, stype);
		if nil == filename then
			return sprite;
		end
		local fullpath = util.get_fullpath(F_IMAGE, filename);
		sprite = EvilSprite:create(fullpath);
		util.node_register(sprite, self.cb_clean);
		layer:addChild(sprite, ZORDER_CARD);

		sprite:setPosition(pos);
		sprite:setAnchorPoint(ANCHOR_CENTER_CENTER);
		sprite:setRotation(rotation);
		sprite:setScale(scale);
		self:init_front_info(sprite, stype);

		return sprite;
	end,

	change_status = function(self, nstatus)
		local sprite = g_sprite_cache[self.card];
		if nstatus == self.status and nil ~= sprite then
			return self.card_sprite;
		elseif nstatus == CARD_FRONT then
			sprite = self:get_front();
		elseif nstatus == CARD_COVER then
			sprite = self:get_cover();
		elseif nstatus == CARD_GRAVE then
			sprite = self:get_grave();
		elseif nstatus == CARD_HERO_ATTACH then
			sprite = self:get_hero_attach();
		elseif nstatus == CARD_ALLY then
			sprite = self:get_ally();
		elseif nstatus == CARD_SUPPORT then
			sprite = self:get_support();
		elseif nstatus == CARD_HERO then
			sprite = self:get_hero();
		elseif nstatus == CARD_ATTACH then
			sprite = self:get_attach();
		elseif nstatus == CARD_VIRTUAL then
			sprite = self:get_virtual();
		end
		return sprite;
	end,

	flip_to_front = function(self)
		--local sprite = self.card_sprite;
		local sprite = self:get_sprite();
		if nil == sprite then
			return;
		end
		--play_turn_card();
		self.status = CARD_FRONT;
		local filename = self:get_bg(self.status);
		local fullpath = util.get_fullpath(F_IMAGE, filename);
		self:clean_sprite();
		local tc = cc.Director:getInstance():getTextureCache();
		local texture = tc:addImage(fullpath);
		local size = texture:getContentSize();
		sprite:setTexture(texture);
		sprite:setTextureRect(cc.rect(0, 0, size.width, size.height));
		self:init_front_info(sprite);
	end,

	flip_to_cover = function(self)
		--local sprite = self.card_sprite;
		local sprite = self:get_sprite();
		if nil == sprite then
			print('DEBUG flip_to_cover sprite is nil');
			return;
		end
		--play_turn_card();
		self.status = CARD_COVER;
		local filename = self:get_bg(self.status);
		local fullpath = util.get_fullpath(F_IMAGE, filename);
		self:clean_sprite();
		local tc = cc.Director:getInstance():getTextureCache();
		local texture = tc:addImage(fullpath);
		local size = texture:getContentSize();
		sprite:setTexture(texture);
		sprite:setTextureRect(cc.rect(0, 0, size.width, size.height));
	end,

	reset_zorder = function(self, nzorder)
		local layer = self.layer;
		local sprite = self.card_sprite;
		if nil == layer or nil == nzorder or nil == sprite then
			return;
		end
		layer:reorderChild(sprite, nzorder);
		self.frame.zorder = nzorder;
	end,

	set_sprite = function(self, status)
		local sprite = self:change_status(status);
		return sprite;
	end,

	get_sprite = function(self, get_sprite_directly)
		if true == get_sprite_directly then
			return self.card_sprite;
		end
		local sprite = self:change_status(self.status);
		--local sprite = self.card_sprite;
		return sprite;
	end,

	get_card_attach_list = function(self)
		local list = {};
		local alist = self.attach_list or {};
		for i = 1, #alist do
			local obj = alist[i];
			if obj.card.id < 1000 then
				table.insert(list, obj);
			end
		end
		return list;
	end,

	get_virtual_attach_list = function(self)
		local list = {};
		local alist = self.attach_list or {};
		for i = 1, #alist do
			local obj = alist[i];
			if obj.card.id >= 1000 then
				table.insert(list, obj);
			end
		end
		return list;
	end,

	change_grave = function(self, pos, scale)
		local sprite = self:change_status(CARD_GRAVE);
		if nil == sprite then
			return sprite;
		end
		sprite:setPosition(pos);
		sprite:setScale(scale);
		return sprite;
	end,

	-- gframe --> grave_frame
	get_grave_pos = function(self, gframe, pindex)
		return cc.p(gframe.pic_x, gframe.pic_y);
		--[[
		local height = gframe.pic_height;
		if nil == height then
			kerror("get_grave_pos pic_height is nil");
			return nil;
		end
		local gapy = height + hfix(15);
		local pos = ccp(gframe.x, gframe.y-gapy*(pindex-1));
		return pos;
		]]--
	end,

	reset = function(self)
		if nil == self then
			return;
		end
		local card = self.card;
		local sprite = self.card_sprite;
		if nil == sprite then
			kdebug("object_card reset sprite[%s][%d] is nil", card.name, cindex(card));
			return;
		end
		local frame = self.frame;
		local pos = ccp(frame.x, frame.y);
		local scale = frame.scale;
		local rotation = frame.rotation;
		sprite:setPosition(pos);
		sprite:setScale(scale);
		sprite:setRotation(rotation);
	end,

	__index = function(t, k)
		if k == 'sprite' then
			return object_card.get_sprite(t);
		end
		if k == 'front' then
			return object_card.get_front(t);
		end
		if k == 'cover' then
			return object_card.get_cover(t);
		end
		if k == 'grave' then
			return object_card.get_grave(t);
		end
		if k == 'hero_attach' then
			return object_card.get_hero_attach(t);
		end
		if k == 'ally' then
			return object_card.get_ally(t);
		end
		if k == 'support' then
			return object_card.get_support(t);
		end
		if k == 'hero' then
			return object_card.get_hero(t);
		end
		if k == 'attach' then
			return object_card.get_attach(t);
		end
		if k == 'virutal' then
			return object_card.get_virtual(t);
		end
		if k == 'card_attach_list' then
			return object_card.get_card_attach_list(t);
		end
		if k == 'virtual_attach_list' then
			return object_card.get_virtual_attach_list(t);
		end

		local v = rawget(object_card, k);
		return v;
	end,

	__newindex = function(t, k, v)
		rawset(t, k, v);
	end,
} -- object_card end

object_uitable = {
	new = function(self, ltype)
		local proxy = {
			x = 0, y = 0, 
			width = 0, height = 0, 
			ltype = ltype, cscale = 1
		};
		setmetatable(proxy, self);
		return proxy;
	end,

	__index = function(t, k)
		--[[
		if k == 'xxx' then
			-- do something
		end
		]]--

		local v = rawget(object_uitable, k);
		return v;
	end,
}

g_scene = { -- g_scene start
	layer_list = {},
	is_connected = false,
	this_stage = nil,
	last_stage = nil,
	-- in some case, use getRunningScene will get the old one while changing scene
	-- so set thie_scene
	this_scene = nil,





	is_battle = function(self)
		if g_scene:is_stage(STAGE_PVP) or g_scene:is_stage(STAGE_PVE) then
			return true;
		end
		return false;
	end,
	go = function(self, gui_key, func, args)
		--[[
		local is_use_scene = true;
		if true == is_use_scene then
			self:loadres(gui_key, func, args);
			return;
		end
		]]--
		show_loading('加载中...');
		if nil ~= layer_loading.layer then
			local function finish()
				self[func](self, args);
				if nil ~= args and nil ~= args.callback then
					args.callback();
				end
			print('time2 : ', os.time());
				return;
			end
			local list = {};
			-- step 1
			local res_list = gui_get_list(gui_key);
			for k, v in pairs(res_list) do
				if nil ~= v then
					if nil ~= v.filename1 and "0" ~= v.filename1 then
						local path = util.get_path(v.filename1);
						table.insert(list, path);
					end
					if nil ~= v.filename2 and "0" ~= v.filename2 then
						local path = util.get_path(v.filename2);
						table.insert(list, path);
					end
					break;
				end
			end
			-----
			-- step 2
			local count = 0;
			local total = #list;
			kdebug("load_res total[%d]", total);
			if 0 == total then
				finish();
				return;
			end
			local function cb_load(texture)
				count = count + 1;
			print('time count : ', os.time(), count);
				if count >= total then
					finish();
				end
				return;
			end
			local cache = cc.Director:getInstance():getTextureCache();
			print('time1 : ', os.time());
			for i = 1, #list do
				local path = list[i];
				print('i, path: ', i, path);
				cache:addImageAsync(path, cb_load);
			end
			-----
		else
			self[func](self, args);
		end
	end,

	login = function(self)
	end,

	role = function(self)
		local stage = STAGE_ROLE;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {}

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_role:create();
		scene:addChild(layer, ZORDER_LAYER_ROLE);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

		local cmd = 'ljob';
		net_send(cmd);
	end,

	testlua = function(self)
		local stage = STAGE_TESTLUA;
		local scene = cc.Scene:create();
		local layer_list = {};
		local layer, name;

		layer, name = layer_testlua:create();
		scene:addChild(layer, ZORDER_LAYER_TESTLUA);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);
	end,

	pve_do_scene = function(self, side)
		local stage = STAGE_PVE;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_table:create();
		scene:addChild(layer, ZORDER_LAYER_TABLE);
		table.insert(layer_list, name);

		layer, name = layer_card:create();
		scene:addChild(layer, ZORDER_LAYER_CARD);
		table.insert(layer_list, name);

		layer, name = layer_menu:create(stage);
		scene:addChild(layer, ZORDER_LAYER_MENU);
		table.insert(layer_list, name);
		
		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

	end,

	pve = function(self, side, seed, deck1_array, deck2_array, is_replay)
		--[[
		if true == USE_FRAME then
			add_frame_cache(GUI_MATCH);
		end
		]]--
		SHOW_ALL = false;
		data_handler:cleanup();
		data_handler:init_side(side); 
		if LOCAL_TEST == true then
			if false == data_handler.has_init_tables then
				data_handler:init_tables();
			end
			local info = {
				side_up = {
					hero = { 5 },
					deck = { 79, 188, 27, 30, 36, 63 },
					hand = { 79, 90, 87, 95, 51 },
					ally = { 21, 22, 22, 22 },
					support = { },
					grave = { 27, 30, 63 },
				},
				side_down = {
					hero = { 15 },
					deck = { }, --155, 30, 27, 23, 155 },
					hand = { 80, 79, 102, 95, 22, 23 },
					ally = { 21, 23, 23, 23 },
					support = { 161, 90 },
					--grave = { 189,43, 23, 155, 43, 23, 30, 37, 31, 32, },
					grave = { 25, 25, 43, 30, 42, 22, 93, 93, 93, 181, 93, 37 },
				},
			};
			anim.reset_data();
			logic_init_test(info);
			-- card in deck
			local deck1 = {23, 24, 51};
			card_init_table(g_logic_table[1][T_DECK], deck1, g_logic_table);

			card_init_table(g_logic_table[2][T_DECK], { 40,22,101 }, g_logic_table);
			--[[
			local hp_up = g_logic_table[1][T_HERO][1].hp;
			local hp_down = g_logic_table[2][T_HERO][1].hp;
			g_logic_table[1][T_HERO][1]:change_hp(-(hp_up-9));
			g_logic_table[2][T_HERO][1]:change_hp(-(hp_down-10));
			]]--
			g_logic_table[1].resource = 99;
			g_logic_table[1].resource_max = 99;
			g_logic_table[2].resource = 50;
			g_logic_table[2].resource_max = 50;
		else
			--print('seed, d1, d2, side', seed, deck1_array, deck2_array, side);
			data_handler:init_game(seed,deck1_array, deck2_array, side);
		end

		self:pve_do_scene(side);

		--[[
		if true == is_replay then
			return;
		end
		]]--

		if true == LOCAL_TEST or side == g_current_side then
			layer_card:init_wait_action(g_phase);
			--layer_refresh:grave();
		else
			do_ai();
		end
	end,

	pvp = function(self, side, seed, deck1_array, deck2_array, timeout, solo_data, robot_data, hero_info)
		--[[
		if true == USE_FRAME then
			add_frame_cache(GUI_MATCH);
		end
		]]--
		data_handler:init_side(side); 
		data_handler:init_game(seed, deck1_array, deck2_array, side, timeout, solo_data, robot_data, hero_info);

		local stage = STAGE_PVP;
		local scene = cc.Scene:create();
		local layer, name;
		layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_table:create();
		scene:addChild(layer, ZORDER_LAYER_TABLE);
		table.insert(layer_list, name);

		layer, name = layer_card:create();
		scene:addChild(layer, ZORDER_LAYER_CARD);
		table.insert(layer_list, name);

		layer, name = layer_menu:create(stage);
		scene:addChild(layer, ZORDER_LAYER_MENU);
		table.insert(layer_list, name);
		
		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

		--net_send('room'); -- get player info

		if g_euser.side == g_current_side then
			layer_card:init_wait_action(g_phase);
		end
	end,

	pvg = function(self, side, seed, deck1_array, gate_list, gr, gate_id)
		data_handler:init_side(side); 
		data_handler:init_gate(seed, deck1_array, gate_list, side);

		local stage = STAGE_PVG;
		local scene = cc.Scene:create();
		local layer, name;
		layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_table:create();
		scene:addChild(layer, ZORDER_LAYER_TABLE);
		table.insert(layer_list, name);

		layer, name = layer_card:create();
		scene:addChild(layer, ZORDER_LAYER_CARD);
		table.insert(layer_list, name);

		layer, name = layer_menu:create(stage);
		scene:addChild(layer, ZORDER_LAYER_MENU);
		table.insert(layer_list, name);
		
		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

		local cmd = string.format("gate_msg %d", gate_id);
		net_send(cmd);
		--net_send('room'); -- get player info

		local label = g_ui_table[SIDE_DOWN][T_HERO][1].sprite:getChildByTag(TAG_HP);
		tolua.cast(label, "cc.Label");
		if nil ~= label then
			label:setVisible(false);
		end

		g_ui_table.label_res[SIDE_UP]:setString("-");
		g_ui_table.label_res_max[SIDE_UP]:setString("-");
		layer_card.label_count_deck[SIDE_UP]:setVisible(false);
		if g_euser.side == SIDE_UP then
			layer_table:hide_name_btn(SIDE_DOWN);
		else
			layer_table:hide_name_btn(SIDE_UP);
		end
		layer_table:add_gate_tip(gr);

		if g_euser.side == g_current_side then
			layer_card:init_wait_action(g_phase);
		end
	end,

	loadres = function(self, gui_key, callback, args)
		local stage = STAGE_LOADRES;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_loadres:create(gui_key, callback, args);
		scene:addChild(layer, ZORDER_LAYER_LOADRES);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);
	end,


	deck = function(self)
		local stage = STAGE_DECK;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_deck:create();
		scene:addChild(layer, ZORDER_LAYER_DECK);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

		--[[
		local item = add_item_back_1(layer_infobar.layer, GUI_DECK, layer_deck.callback_ask_return);
		layer_deck.btn_back = item;

		local cmd = 'ldeck ' .. CARD_ARRAY_LIST;
		net_send(cmd);
		]]--
	end,

	mystery = function(self)
		local stage = STAGE_MYSTERY;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_mystery:create();
		scene:addChild(layer, ZORDER_LAYER_MYSTERY);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

		-- should not show loading,
		-- when scene change, the pointer to loading will still here and cause bug
		net_send("pshop", true); 
	end,

	hero = function(self, args)
		special_type = layer_hero.TYPE_NORMAL;
		if nil ~= args then
			special_type = args.special_type or special_type;
		end
		local stage = STAGE_HERO;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_hero:create(special_type);
		scene:addChild(layer, ZORDER_LAYER_HERO);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

		-- should not show loading,
		-- when scene change, the pointer to loading will still here and cause bug
		net_send("lhero", true); 
	end,

	mydeck = function(self)
		local stage = STAGE_MYDECK;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_mydeck:create();
		scene:addChild(layer, ZORDER_LAYER_MYDECK);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

		-- should not show loading,
		-- when scene change, the pointer to loading will still here and cause bug
		net_send("load_hero_deck", true); 
	end,

	--pickdeck = function(self, hero_id, slot_id)
	pickdeck = function(self)
		local hero_id = g_euser.hero_id;
		local slot_id = g_euser.slot_id;
		local stage = STAGE_PICKDECK;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_pickdeck:create();
		scene:addChild(layer, ZORDER_LAYER_PICKDECK);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

		-- should not show loading,
		-- when scene change, the pointer to loading will still here and cause bug
		if nil == hero_id then return; end
		local cmd = 'list_hero_slot ' .. hero_id;
		net_send(cmd, true); 
	end,

	sgdeck = function(self)
		local stage = STAGE_SGDECK;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_sgdeck:create();
		scene:addChild(layer, ZORDER_LAYER_SGDECK);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

		-- should not show loading,
		-- when scene change, the pointer to loading will still here and cause bug
	end,

	--replay = function(self, side, seed, deck1_array, deck2_array)
	replay = function(self, side, seed, tt)
		data_handler:cleanup();
		data_handler:init_side(side); 
		--data_handler:init_game(seed,deck1_array, deck2_array, side);
		local cmd = data_handler:init_game(seed, nil, tt);

		local stage = STAGE_REPLAY;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_table:create();
		scene:addChild(layer, ZORDER_LAYER_TABLE);
		table.insert(layer_list, name);

		layer, name = layer_card:create();
		scene:addChild(layer, ZORDER_LAYER_CARD);
		table.insert(layer_list, name);

		layer, name = layer_menu:create(stage);
		scene:addChild(layer, ZORDER_LAYER_MENU);
		table.insert(layer_list, name);

		layer, name = layer_control:create();
		scene:addChild(layer, ZORDER_LAYER_CONTROL);
		table.insert(layer_list, name);
		
		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

		local str = cmd;
		local list_cmd = csplit(str, ';');
		for i = 1, #(list_cmd or {}) do
			local cmd = list_cmd[i];
			local ilist = csplit(cmd, ' ');
			if 'fold' ~= ilist[2] and '@win' ~= ilist[2] then
				local len = string.len(ilist[1]);
				len = len + 2; -- one space and start from next one character
				cmd = string.sub(cmd, len);
				local eff_list = nil;
				local err = nil;
				push_cmd_list(cmd, { refresh_layer_card }, nil);
			end
		end
		check_cmd_finish();
	end,

	shop = function(self)
		local stage = STAGE_SHOP;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_shop:create();
		scene:addChild(layer, ZORDER_LAYER_SHOP);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

		net_send("lcard", true);
	end,

	book = function(self)
		local stage = STAGE_BOOK;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_book:create();
		scene:addChild(layer, ZORDER_LAYER_BOOK);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

		net_send("lcard", true);
	end,

	piece = function(self)
		local stage = STAGE_PIECE;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_piece:create();
		scene:addChild(layer, ZORDER_LAYER_PIECE);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

		g_list_piece = g_list_piece or {};
		if 0 == #g_list_piece then
		    layer_piece:callback_reloadlist();
		else
			layer_piece:add_to_list(g_list_piece);
			net_send("lpiece", true);
		end
	end,

	rank = function(self, args)
		local stab = nil;
		if nil ~= args then
			stab = args.stab;
		end
		local stage = STAGE_RANK;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_rank:create(stab);
		scene:addChild(layer, ZORDER_LAYER_RANK);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);
	end,

	pclg = function(self)
		local stage = STAGE_PCLG;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_pclg:create();
		scene:addChild(layer, ZORDER_LAYER_PCLG);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

		--net_send('rtarlist', true);
		net_send('arenatarget', true);
	end,

	--[[
	mail = function(self)
		local stage = STAGE_MAIL;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_mail:create();
		scene:addChild(layer, ZORDER_LAYER_MAIL);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		add_item_back_1(layer_infobar.layer, GUI_MAIL, layer_mail.back);

		self:change_scene(scene, stage, layer_list);
	end,
	]]--

	gm = function(self)
		local stage = STAGE_GM;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_gm:create();
		scene:addChild(layer, ZORDER_LAYER_GM);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		add_item_back_1(layer_infobar.layer, GUI_GM, layer_gm.back);

		self:change_scene(scene, stage, layer_list);
	end,

	option = function(self)
		local stage = STAGE_OPTION;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_option:create();
		scene:addChild(layer, ZORDER_LAYER_OPTION);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);
	end,

	lguild = function(self)
		local stage = STAGE_LGUILD;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_lguild:create();
		scene:addChild(layer, ZORDER_LAYER_LGUILD);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

		local cmd = 'lguild 0 ' .. layer_lguild.PAGE_SIZE;
		net_send(cmd, true);
	end,

	guild = function(self, info)
		if nil == info then
			info = g_euser.guild_data;
		elseif info.gid == g_euser.gid then
			g_euser.guild_data = info;
		end
		if nil == info then
			return;
		end
		local stage = STAGE_GUILD;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_guild:create(info);
		scene:addChild(layer, ZORDER_LAYER_GUILD);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);
	end,

	welfare = function(self)
		local stage = STAGE_WELFARE;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_welfare:create();
		scene:addChild(layer, ZORDER_LAYER_WELFARE);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

		local cmd = 'gbonus 0';
		net_send(cmd);
	end,

	lmember = function(self)
		local stage = STAGE_LMEMBER;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_lmember:create();
		scene:addChild(layer, ZORDER_LAYER_LMEMBER);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

		local cmd = 'glist 1 0 ' .. layer_lmember.PAGE_SIZE;
		net_send(cmd, true);
	end,

	lapply = function(self)
		local stage = STAGE_LAPPLY;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_lapply:create();
		scene:addChild(layer, ZORDER_LAYER_LAPPLY);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

		local cmd = 'glist 9 0 ' .. layer_lapply.PAGE_SIZE;
		net_send(cmd, true);
	end,

	lstock = function(self)
		local stage = STAGE_LSTOCK;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_lstock:create();
		scene:addChild(layer, ZORDER_LAYER_LSTOCK);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);

		self:change_scene(scene, stage, layer_list);

		local cmd = 'glist 1 0 ' .. layer_lstock.PAGE_SIZE;
		net_send(cmd, true);
	end,

	invest = function(self)
		local stage = STAGE_INVEST;
		local scene = cc.Scene:create();
		local layer, name;
		local layer_list = {};

		layer, name = layer_net:create();
		scene:addChild(layer, ZORDER_LAYER_NET);
		table.insert(layer_list, name);

		layer, name = layer_invest:create();
		scene:addChild(layer, ZORDER_LAYER_INVEST);
		table.insert(layer_list, name);

		layer, name = layer_infobar:create();
		scene:addChild(layer, ZORDER_LAYER_INFOBAR);
		table.insert(layer_list, name);

		layer, name = layer_touch:create();
		scene:addChild(layer, ZORDER_LAYER_TOUCH);
		table.insert(layer_list, name);


		self:change_scene(scene, stage, layer_list);

		local cmd = 'deposit';
		net_send(cmd, true);
	end,

} -- g_scene end
-- /////////////////////// GAME END   ///////////////////////////


kdebug(' require game ');
